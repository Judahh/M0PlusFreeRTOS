   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	pxCurrentTCB
  18              		.section	.bss.pxCurrentTCB,"aw",%nobits
  19              		.align	2
  22              	pxCurrentTCB:
  23 0000 00000000 		.space	4
  24              		.section	.bss._ZL17pxReadyTasksLists,"aw",%nobits
  25              		.align	2
  28              	_ZL17pxReadyTasksLists:
  29 0000 00000000 		.space	120
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.section	.bss._ZL17xDelayedTaskList1,"aw",%nobits
  31              		.align	2
  34              	_ZL17xDelayedTaskList1:
  35 0000 00000000 		.space	20
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              		.section	.bss._ZL17xDelayedTaskList2,"aw",%nobits
  37              		.align	2
  40              	_ZL17xDelayedTaskList2:
  41 0000 00000000 		.space	20
  41      00000000 
  41      00000000 
  41      00000000 
  41      00000000 
  42              		.section	.bss._ZL17pxDelayedTaskList,"aw",%nobits
  43              		.align	2
  46              	_ZL17pxDelayedTaskList:
  47 0000 00000000 		.space	4
  48              		.section	.bss._ZL25pxOverflowDelayedTaskList,"aw",%nobits
  49              		.align	2
  52              	_ZL25pxOverflowDelayedTaskList:
  53 0000 00000000 		.space	4
  54              		.section	.bss._ZL17xPendingReadyList,"aw",%nobits
  55              		.align	2
  58              	_ZL17xPendingReadyList:
  59 0000 00000000 		.space	20
  59      00000000 
  59      00000000 
  59      00000000 
  59      00000000 
  60              		.section	.bss._ZL24xTasksWaitingTermination,"aw",%nobits
  61              		.align	2
  64              	_ZL24xTasksWaitingTermination:
  65 0000 00000000 		.space	20
  65      00000000 
  65      00000000 
  65      00000000 
  65      00000000 
  66              		.section	.bss._ZL14uxTasksDeleted,"aw",%nobits
  67              		.align	2
  70              	_ZL14uxTasksDeleted:
  71 0000 00000000 		.space	4
  72              		.section	.bss._ZL18xSuspendedTaskList,"aw",%nobits
  73              		.align	2
  76              	_ZL18xSuspendedTaskList:
  77 0000 00000000 		.space	20
  77      00000000 
  77      00000000 
  77      00000000 
  77      00000000 
  78              		.section	.bss._ZL22uxCurrentNumberOfTasks,"aw",%nobits
  79              		.align	2
  82              	_ZL22uxCurrentNumberOfTasks:
  83 0000 00000000 		.space	4
  84              		.section	.bss._ZL10xTickCount,"aw",%nobits
  85              		.align	2
  88              	_ZL10xTickCount:
  89 0000 00000000 		.space	4
  90              		.section	.bss._ZL18uxTopReadyPriority,"aw",%nobits
  91              		.align	2
  94              	_ZL18uxTopReadyPriority:
  95 0000 00000000 		.space	4
  96              		.section	.bss._ZL17xSchedulerRunning,"aw",%nobits
  97              		.align	2
 100              	_ZL17xSchedulerRunning:
 101 0000 00000000 		.space	4
 102              		.section	.bss._ZL13uxPendedTicks,"aw",%nobits
 103              		.align	2
 106              	_ZL13uxPendedTicks:
 107 0000 00000000 		.space	4
 108              		.section	.bss._ZL13xYieldPending,"aw",%nobits
 109              		.align	2
 112              	_ZL13xYieldPending:
 113 0000 00000000 		.space	4
 114              		.section	.bss._ZL15xNumOfOverflows,"aw",%nobits
 115              		.align	2
 118              	_ZL15xNumOfOverflows:
 119 0000 00000000 		.space	4
 120              		.section	.bss._ZL12uxTaskNumber,"aw",%nobits
 121              		.align	2
 124              	_ZL12uxTaskNumber:
 125 0000 00000000 		.space	4
 126              		.section	.data._ZL20xNextTaskUnblockTime,"aw",%progbits
 127              		.align	2
 130              	_ZL20xNextTaskUnblockTime:
 131 0000 FFFFFFFF 		.word	-1
 132              		.section	.bss._ZL20uxSchedulerSuspended,"aw",%nobits
 133              		.align	2
 136              	_ZL20uxSchedulerSuspended:
 137 0000 00000000 		.space	4
 138              		.section	.text.xTaskGenericCreate,"ax",%progbits
 139              		.align	2
 140              		.global	xTaskGenericCreate
 141              		.code	16
 142              		.thumb_func
 144              	xTaskGenericCreate:
 145              	.LFB9:
 146              		.file 1 "../Generated_Code/tasks.c"
   1:../Generated_Code/tasks.c **** /*
   2:../Generated_Code/tasks.c ****     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:../Generated_Code/tasks.c ****     All rights reserved
   4:../Generated_Code/tasks.c **** 
   5:../Generated_Code/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Generated_Code/tasks.c **** 
   7:../Generated_Code/tasks.c ****     ***************************************************************************
   8:../Generated_Code/tasks.c ****      *                                                                       *
   9:../Generated_Code/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Generated_Code/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Generated_Code/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:../Generated_Code/tasks.c ****      *                                                                       *
  13:../Generated_Code/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Generated_Code/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Generated_Code/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Generated_Code/tasks.c ****      *                                                                       *
  17:../Generated_Code/tasks.c ****      *    Thank you!                                                         *
  18:../Generated_Code/tasks.c ****      *                                                                       *
  19:../Generated_Code/tasks.c ****     ***************************************************************************
  20:../Generated_Code/tasks.c **** 
  21:../Generated_Code/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:../Generated_Code/tasks.c **** 
  23:../Generated_Code/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Generated_Code/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Generated_Code/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Generated_Code/tasks.c **** 
  27:../Generated_Code/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Generated_Code/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Generated_Code/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Generated_Code/tasks.c ****     >>! kernel.
  31:../Generated_Code/tasks.c **** 
  32:../Generated_Code/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Generated_Code/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Generated_Code/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Generated_Code/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:../Generated_Code/tasks.c **** 
  37:../Generated_Code/tasks.c ****     1 tab == 4 spaces!
  38:../Generated_Code/tasks.c **** 
  39:../Generated_Code/tasks.c ****     ***************************************************************************
  40:../Generated_Code/tasks.c ****      *                                                                       *
  41:../Generated_Code/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Generated_Code/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:../Generated_Code/tasks.c ****      *                                                                       *
  44:../Generated_Code/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Generated_Code/tasks.c ****      *                                                                       *
  46:../Generated_Code/tasks.c ****     ***************************************************************************
  47:../Generated_Code/tasks.c **** 
  48:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Generated_Code/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Generated_Code/tasks.c **** 
  51:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Generated_Code/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Generated_Code/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Generated_Code/tasks.c **** 
  55:../Generated_Code/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Generated_Code/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Generated_Code/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Generated_Code/tasks.c **** 
  59:../Generated_Code/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Generated_Code/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Generated_Code/tasks.c ****     mission critical applications that require provable dependability.
  62:../Generated_Code/tasks.c **** 
  63:../Generated_Code/tasks.c ****     1 tab == 4 spaces!
  64:../Generated_Code/tasks.c **** */
  65:../Generated_Code/tasks.c **** 
  66:../Generated_Code/tasks.c **** /* Standard includes. */
  67:../Generated_Code/tasks.c **** #include <stdlib.h>
  68:../Generated_Code/tasks.c **** #include <string.h>
  69:../Generated_Code/tasks.c **** 
  70:../Generated_Code/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:../Generated_Code/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:../Generated_Code/tasks.c **** task.h is included from an application file. */
  73:../Generated_Code/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:../Generated_Code/tasks.c **** 
  75:../Generated_Code/tasks.c **** /* FreeRTOS includes. */
  76:../Generated_Code/tasks.c **** #include "FreeRTOS.h"
  77:../Generated_Code/tasks.c **** #include "task.h"
  78:../Generated_Code/tasks.c **** #include "timers.h"
  79:../Generated_Code/tasks.c **** #include "StackMacros.h"
  80:../Generated_Code/tasks.c **** 
  81:../Generated_Code/tasks.c **** #include "Events.h"
  82:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
  83:../Generated_Code/tasks.c **** #include "UTIL0.h" /* interface to utility because used for safe string routines */ /* << EST */
  84:../Generated_Code/tasks.c **** #endif
  85:../Generated_Code/tasks.c **** 
  86:../Generated_Code/tasks.c **** #if (configCOMPILER == configCOMPILER_ARM_IAR) /* << EST: suppress warnings for IAR */
  87:../Generated_Code/tasks.c **** #pragma diag_suppress=pa082 /* Warning[Pa082]: undefined behavior: the order of volatile accesses i
  88:../Generated_Code/tasks.c **** #endif
  89:../Generated_Code/tasks.c **** 
  90:../Generated_Code/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  91:../Generated_Code/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  92:../Generated_Code/tasks.c **** header files above, but not in this file, in order to generate the correct
  93:../Generated_Code/tasks.c **** privileged Vs unprivileged linkage and placement. */
  94:../Generated_Code/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  95:../Generated_Code/tasks.c **** 
  96:../Generated_Code/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  97:../Generated_Code/tasks.c ****         /* At the bottom of this file are two optional functions that can be used
  98:../Generated_Code/tasks.c ****         to generate human readable text from the raw data generated by the
  99:../Generated_Code/tasks.c ****         uxTaskGetSystemState() function.  Note the formatting functions are provided
 100:../Generated_Code/tasks.c ****         for convenience only, and are NOT considered part of the kernel. */
 101:../Generated_Code/tasks.c ****         #include <stdio.h>
 102:../Generated_Code/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 103:../Generated_Code/tasks.c **** 
 104:../Generated_Code/tasks.c **** /* Sanity check the configuration. */
 105:../Generated_Code/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
 106:../Generated_Code/tasks.c ****         #if INCLUDE_vTaskSuspend != 1
 107:../Generated_Code/tasks.c ****                 #error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set 
 108:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
 109:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 110:../Generated_Code/tasks.c **** 
 111:../Generated_Code/tasks.c **** /*
 112:../Generated_Code/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 113:../Generated_Code/tasks.c ****  */
 114:../Generated_Code/tasks.c **** #define tskIDLE_STACK_SIZE      configMINIMAL_STACK_SIZE
 115:../Generated_Code/tasks.c **** 
 116:../Generated_Code/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 117:../Generated_Code/tasks.c ****         /* If the cooperative scheduler is being used then a yield should not be
 118:../Generated_Code/tasks.c ****         performed just because a higher priority task has been woken. */
 119:../Generated_Code/tasks.c ****         #define taskYIELD_IF_USING_PREEMPTION()
 120:../Generated_Code/tasks.c **** #else
 121:../Generated_Code/tasks.c ****         #define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 122:../Generated_Code/tasks.c **** #endif
 123:../Generated_Code/tasks.c **** 
 124:../Generated_Code/tasks.c **** /*
 125:../Generated_Code/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 126:../Generated_Code/tasks.c ****  * and stores task state information, including a pointer to the task's context
 127:../Generated_Code/tasks.c ****  * (the task's run time environment, including register values)
 128:../Generated_Code/tasks.c ****  */
 129:../Generated_Code/tasks.c **** typedef struct tskTaskControlBlock
 130:../Generated_Code/tasks.c **** {
 131:../Generated_Code/tasks.c ****         volatile StackType_t    *pxTopOfStack;  /*< Points to the location of the last item placed 
 132:../Generated_Code/tasks.c **** 
 133:../Generated_Code/tasks.c ****         #if ( portUSING_MPU_WRAPPERS == 1 )
 134:../Generated_Code/tasks.c ****                 xMPU_SETTINGS   xMPUSettings;           /*< The MPU settings are defined as part of
 135:../Generated_Code/tasks.c ****         #endif
 136:../Generated_Code/tasks.c **** 
 137:../Generated_Code/tasks.c ****         ListItem_t                      xGenericListItem;       /*< The list that the state list it
 138:../Generated_Code/tasks.c ****         ListItem_t                      xEventListItem;         /*< Used to reference a task from a
 139:../Generated_Code/tasks.c ****         UBaseType_t                     uxPriority;                     /*< The priority of the tas
 140:../Generated_Code/tasks.c ****         StackType_t                     *pxStack;                       /*< Points to the start of 
 141:../Generated_Code/tasks.c ****         char                            pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name 
 142:../Generated_Code/tasks.c **** 
 143:../Generated_Code/tasks.c ****         #if ( portSTACK_GROWTH > 0 )
 144:../Generated_Code/tasks.c ****                 StackType_t             *pxEndOfStack;          /*< Points to the end of the stack 
 145:../Generated_Code/tasks.c ****         #endif
 146:../Generated_Code/tasks.c **** 
 147:../Generated_Code/tasks.c ****         #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 148:../Generated_Code/tasks.c ****                 UBaseType_t     uxCriticalNesting;      /*< Holds the critical section nesting dept
 149:../Generated_Code/tasks.c ****         #endif
 150:../Generated_Code/tasks.c **** 
 151:../Generated_Code/tasks.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
 152:../Generated_Code/tasks.c ****                 UBaseType_t             uxTCBNumber;            /*< Stores a number that increments
 153:../Generated_Code/tasks.c ****                 UBaseType_t     uxTaskNumber;           /*< Stores a number specifically for use by
 154:../Generated_Code/tasks.c ****         #endif
 155:../Generated_Code/tasks.c **** 
 156:../Generated_Code/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
 157:../Generated_Code/tasks.c ****                 UBaseType_t     uxBasePriority;         /*< The priority last assigned to the task 
 158:../Generated_Code/tasks.c ****         #endif
 159:../Generated_Code/tasks.c **** 
 160:../Generated_Code/tasks.c ****         #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 161:../Generated_Code/tasks.c ****                 TaskHookFunction_t pxTaskTag;
 162:../Generated_Code/tasks.c ****         #endif
 163:../Generated_Code/tasks.c **** 
 164:../Generated_Code/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
 165:../Generated_Code/tasks.c ****                 uint32_t                ulRunTimeCounter;       /*< Stores the amount of time the t
 166:../Generated_Code/tasks.c ****         #endif
 167:../Generated_Code/tasks.c **** 
 168:../Generated_Code/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
 169:../Generated_Code/tasks.c ****                 /* Allocate a Newlib reent structure that is specific to this task.
 170:../Generated_Code/tasks.c ****                 Note Newlib support has been included by popular demand, but is not
 171:../Generated_Code/tasks.c ****                 used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 172:../Generated_Code/tasks.c ****                 responsible for resulting newlib operation.  User must be familiar with
 173:../Generated_Code/tasks.c ****                 newlib and must provide system-wide implementations of the necessary
 174:../Generated_Code/tasks.c ****                 stubs. Be warned that (at the time of writing) the current newlib design
 175:../Generated_Code/tasks.c ****                 implements a system-wide malloc() that must be provided with locks. */
 176:../Generated_Code/tasks.c ****                 struct  _reent xNewLib_reent;
 177:../Generated_Code/tasks.c ****         #endif
 178:../Generated_Code/tasks.c **** 
 179:../Generated_Code/tasks.c **** } tskTCB;
 180:../Generated_Code/tasks.c **** 
 181:../Generated_Code/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 182:../Generated_Code/tasks.c **** below to enable the use of older kernel aware debuggers. */
 183:../Generated_Code/tasks.c **** typedef tskTCB TCB_t;
 184:../Generated_Code/tasks.c **** 
 185:../Generated_Code/tasks.c **** /*
 186:../Generated_Code/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 187:../Generated_Code/tasks.c ****  * be global, rather than file scope.
 188:../Generated_Code/tasks.c ****  */
 189:../Generated_Code/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 190:../Generated_Code/tasks.c ****         #define static
 191:../Generated_Code/tasks.c **** #endif
 192:../Generated_Code/tasks.c **** 
 193:../Generated_Code/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 194:../Generated_Code/tasks.c **** static variables must be declared volatile. */
 195:../Generated_Code/tasks.c **** 
 196:../Generated_Code/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 197:../Generated_Code/tasks.c **** 
 198:../Generated_Code/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 199:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 200:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;                                                /*<
 201:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;                                                /*<
 202:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;                             /*< Points 
 203:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;             /*< Points to the d
 204:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;                                                /*<
 205:../Generated_Code/tasks.c **** 
 206:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 207:../Generated_Code/tasks.c **** 
 208:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static List_t xTasksWaitingTermination;                         /*< Tasks t
 209:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 210:../Generated_Code/tasks.c **** 
 211:../Generated_Code/tasks.c **** #endif
 212:../Generated_Code/tasks.c **** 
 213:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 214:../Generated_Code/tasks.c **** 
 215:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static List_t xSuspendedTaskList;                                       /*<
 216:../Generated_Code/tasks.c **** 
 217:../Generated_Code/tasks.c **** #endif
 218:../Generated_Code/tasks.c **** 
 219:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 220:../Generated_Code/tasks.c **** 
 221:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                     /*< Holds t
 222:../Generated_Code/tasks.c **** 
 223:../Generated_Code/tasks.c **** #endif
 224:../Generated_Code/tasks.c **** 
 225:../Generated_Code/tasks.c **** /* Other file private variables. --------------------------------*/
 226:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks      = ( UBaseType_t ) 0U;
 227:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount                           = ( TickType_t ) 0U
 228:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority          = tskIDLE_PRIORITY;
 229:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning            = pdFALSE;
 230:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks                       = ( UBaseType_t ) 0
 231:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending                        = pdFALSE;
 232:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows                      = ( BaseType_t ) 0;
 233:../Generated_Code/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber                                         = ( UBaseTy
 234:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime         = portMAX_DELAY;
 235:../Generated_Code/tasks.c **** 
 236:../Generated_Code/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 237:../Generated_Code/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 238:../Generated_Code/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 239:../Generated_Code/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 240:../Generated_Code/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 241:../Generated_Code/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 242:../Generated_Code/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 243:../Generated_Code/tasks.c **** accessed from a critical section. */
 244:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended        = ( UBaseType_t ) pdFALSE;
 245:../Generated_Code/tasks.c **** 
 246:../Generated_Code/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 247:../Generated_Code/tasks.c **** 
 248:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;     /*< Holds the value of a ti
 249:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;           /*< Holds the total amount 
 250:../Generated_Code/tasks.c **** 
 251:../Generated_Code/tasks.c **** #endif
 252:../Generated_Code/tasks.c **** 
 253:../Generated_Code/tasks.c **** /*lint +e956 */
 254:../Generated_Code/tasks.c **** 
 255:../Generated_Code/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 256:../Generated_Code/tasks.c **** 
 257:../Generated_Code/tasks.c **** /*
 258:../Generated_Code/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 259:../Generated_Code/tasks.c ****  * is used purely for checking the high water mark for tasks.
 260:../Generated_Code/tasks.c ****  */
 261:../Generated_Code/tasks.c **** #define tskSTACK_FILL_BYTE      ( 0xa5U )
 262:../Generated_Code/tasks.c **** 
 263:../Generated_Code/tasks.c **** /*
 264:../Generated_Code/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 265:../Generated_Code/tasks.c ****  */
 266:../Generated_Code/tasks.c **** #define tskBLOCKED_CHAR         ( 'B' )
 267:../Generated_Code/tasks.c **** #define tskREADY_CHAR           ( 'R' )
 268:../Generated_Code/tasks.c **** #define tskDELETED_CHAR         ( 'D' )
 269:../Generated_Code/tasks.c **** #define tskSUSPENDED_CHAR       ( 'S' )
 270:../Generated_Code/tasks.c **** 
 271:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 272:../Generated_Code/tasks.c **** 
 273:../Generated_Code/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 274:../Generated_Code/tasks.c **** 
 275:../Generated_Code/tasks.c ****         /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 276:../Generated_Code/tasks.c ****         performed in a generic way that is not optimised to any particular
 277:../Generated_Code/tasks.c ****         microcontroller architecture. */
 278:../Generated_Code/tasks.c **** 
 279:../Generated_Code/tasks.c ****         /* uxTopReadyPriority holds the priority of the highest priority ready
 280:../Generated_Code/tasks.c ****         state task. */
 281:../Generated_Code/tasks.c ****         #define taskRECORD_READY_PRIORITY( uxPriority )                                            
 282:../Generated_Code/tasks.c ****         {                                                                                          
 283:../Generated_Code/tasks.c ****                 if( ( uxPriority ) > uxTopReadyPriority )                                          
 284:../Generated_Code/tasks.c ****                 {                                                                                  
 285:../Generated_Code/tasks.c ****                         uxTopReadyPriority = ( uxPriority );                                       
 286:../Generated_Code/tasks.c ****                 }                                                                                  
 287:../Generated_Code/tasks.c ****         } /* taskRECORD_READY_PRIORITY */
 288:../Generated_Code/tasks.c **** 
 289:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 290:../Generated_Code/tasks.c **** 
 291:../Generated_Code/tasks.c ****         #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                 
 292:../Generated_Code/tasks.c ****         {                                                                                          
 293:../Generated_Code/tasks.c ****                 /* Find the highest priority queue that contains ready tasks. */                   
 294:../Generated_Code/tasks.c ****                 while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )         
 295:../Generated_Code/tasks.c ****                 {                                                                                  
 296:../Generated_Code/tasks.c ****                         configASSERT( uxTopReadyPriority );                                        
 297:../Generated_Code/tasks.c ****                         --uxTopReadyPriority;                                                      
 298:../Generated_Code/tasks.c ****                 }                                                                                  
 299:../Generated_Code/tasks.c ****                                                                                                    
 300:../Generated_Code/tasks.c ****                 /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of           
 301:../Generated_Code/tasks.c ****                 the     same priority get an equal share of the processor time. */                 
 302:../Generated_Code/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority
 303:../Generated_Code/tasks.c ****         } /* taskSELECT_HIGHEST_PRIORITY_TASK */
 304:../Generated_Code/tasks.c **** 
 305:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 306:../Generated_Code/tasks.c **** 
 307:../Generated_Code/tasks.c ****         /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 308:../Generated_Code/tasks.c ****         they are only required when a port optimised method of task selection is
 309:../Generated_Code/tasks.c ****         being used. */
 310:../Generated_Code/tasks.c ****         #define taskRESET_READY_PRIORITY( uxPriority )
 311:../Generated_Code/tasks.c ****         #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 312:../Generated_Code/tasks.c **** 
 313:../Generated_Code/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 314:../Generated_Code/tasks.c **** 
 315:../Generated_Code/tasks.c ****         /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 316:../Generated_Code/tasks.c ****         performed in a way that is tailored to the particular microcontroller
 317:../Generated_Code/tasks.c ****         architecture being used. */
 318:../Generated_Code/tasks.c **** 
 319:../Generated_Code/tasks.c ****         /* A port optimised version is provided.  Call the port defined macros. */
 320:../Generated_Code/tasks.c ****         #define taskRECORD_READY_PRIORITY( uxPriority ) portRECORD_READY_PRIORITY( uxPriority, uxTo
 321:../Generated_Code/tasks.c **** 
 322:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 323:../Generated_Code/tasks.c **** 
 324:../Generated_Code/tasks.c ****         #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                 
 325:../Generated_Code/tasks.c ****         {                                                                                          
 326:../Generated_Code/tasks.c ****         UBaseType_t uxTopPriority;                                                                 
 327:../Generated_Code/tasks.c ****                                                                                                    
 328:../Generated_Code/tasks.c ****                 /* Find the highest priority queue that contains ready tasks. */                   
 329:../Generated_Code/tasks.c ****                 portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                     
 330:../Generated_Code/tasks.c ****                 configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 
 331:../Generated_Code/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) 
 332:../Generated_Code/tasks.c ****         } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 333:../Generated_Code/tasks.c **** 
 334:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 335:../Generated_Code/tasks.c **** 
 336:../Generated_Code/tasks.c ****         /* A port optimised version is provided, call it only if the TCB being reset
 337:../Generated_Code/tasks.c ****         is being referenced from a ready list.  If it is referenced from a delayed
 338:../Generated_Code/tasks.c ****         or suspended list then it won't be in a ready list. */
 339:../Generated_Code/tasks.c ****         #define taskRESET_READY_PRIORITY( uxPriority )                                             
 340:../Generated_Code/tasks.c ****         {                                                                                          
 341:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )     
 342:../Generated_Code/tasks.c ****                 {                                                                                  
 343:../Generated_Code/tasks.c ****                         portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );        
 344:../Generated_Code/tasks.c ****                 }                                                                                  
 345:../Generated_Code/tasks.c ****         }
 346:../Generated_Code/tasks.c **** 
 347:../Generated_Code/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 348:../Generated_Code/tasks.c **** 
 349:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 350:../Generated_Code/tasks.c **** 
 351:../Generated_Code/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 352:../Generated_Code/tasks.c **** count overflows. */
 353:../Generated_Code/tasks.c **** #define taskSWITCH_DELAYED_LISTS()                                                                 
 354:../Generated_Code/tasks.c **** {                                                                                                  
 355:../Generated_Code/tasks.c ****         List_t *pxTemp;                                                                            
 356:../Generated_Code/tasks.c ****                                                                                                    
 357:../Generated_Code/tasks.c ****         /* The delayed tasks list should be empty when the lists are switched. */                  
 358:../Generated_Code/tasks.c ****         configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );                                
 359:../Generated_Code/tasks.c ****                                                                                                    
 360:../Generated_Code/tasks.c ****         pxTemp = pxDelayedTaskList;                                                                
 361:../Generated_Code/tasks.c ****         pxDelayedTaskList = pxOverflowDelayedTaskList;                                             
 362:../Generated_Code/tasks.c ****         pxOverflowDelayedTaskList = pxTemp;                                                        
 363:../Generated_Code/tasks.c ****         xNumOfOverflows++;                                                                         
 364:../Generated_Code/tasks.c ****         prvResetNextTaskUnblockTime();                                                             
 365:../Generated_Code/tasks.c **** }
 366:../Generated_Code/tasks.c **** 
 367:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 368:../Generated_Code/tasks.c **** 
 369:../Generated_Code/tasks.c **** /*
 370:../Generated_Code/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 371:../Generated_Code/tasks.c ****  * the task.  It is inserted at the end of the list.
 372:../Generated_Code/tasks.c ****  */
 373:../Generated_Code/tasks.c **** #define prvAddTaskToReadyList( pxTCB )                                                             
 374:../Generated_Code/tasks.c ****         traceMOVED_TASK_TO_READY_STATE( pxTCB )                                                    
 375:../Generated_Code/tasks.c ****         taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                        
 376:../Generated_Code/tasks.c ****         vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericList
 377:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 378:../Generated_Code/tasks.c **** 
 379:../Generated_Code/tasks.c **** /*
 380:../Generated_Code/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 381:../Generated_Code/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 382:../Generated_Code/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 383:../Generated_Code/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 384:../Generated_Code/tasks.c ****  */
 385:../Generated_Code/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 386:../Generated_Code/tasks.c **** 
 387:../Generated_Code/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 388:../Generated_Code/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 389:../Generated_Code/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 390:../Generated_Code/tasks.c **** is important its value is not updated due to a task priority change while it is
 391:../Generated_Code/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 392:../Generated_Code/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 393:../Generated_Code/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 394:../Generated_Code/tasks.c **** to its original value when it is released. */
 395:../Generated_Code/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 396:../Generated_Code/tasks.c ****         #define taskEVENT_LIST_ITEM_VALUE_IN_USE        0x8000U
 397:../Generated_Code/tasks.c **** #else
 398:../Generated_Code/tasks.c ****         #define taskEVENT_LIST_ITEM_VALUE_IN_USE        0x80000000UL
 399:../Generated_Code/tasks.c **** #endif
 400:../Generated_Code/tasks.c **** 
 401:../Generated_Code/tasks.c **** /* Callback function prototypes. --------------------------*/
 402:../Generated_Code/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 403:../Generated_Code/tasks.c ****         extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 404:../Generated_Code/tasks.c **** #endif
 405:../Generated_Code/tasks.c **** 
 406:../Generated_Code/tasks.c **** #if configUSE_TICK_HOOK > 0
 407:../Generated_Code/tasks.c ****         extern void vApplicationTickHook( void );
 408:../Generated_Code/tasks.c **** #endif
 409:../Generated_Code/tasks.c **** 
 410:../Generated_Code/tasks.c **** /* File private functions. --------------------------------*/
 411:../Generated_Code/tasks.c **** 
 412:../Generated_Code/tasks.c **** /*
 413:../Generated_Code/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 414:../Generated_Code/tasks.c ****  * into the TCB structure.
 415:../Generated_Code/tasks.c ****  */
 416:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 417:../Generated_Code/tasks.c **** 
 418:../Generated_Code/tasks.c **** /**
 419:../Generated_Code/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 420:../Generated_Code/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 421:../Generated_Code/tasks.c ****  * is in any other state.
 422:../Generated_Code/tasks.c ****  */
 423:../Generated_Code/tasks.c **** static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 424:../Generated_Code/tasks.c **** 
 425:../Generated_Code/tasks.c **** /*
 426:../Generated_Code/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 427:../Generated_Code/tasks.c ****  * automatically upon the creation of the first task.
 428:../Generated_Code/tasks.c ****  */
 429:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 430:../Generated_Code/tasks.c **** 
 431:../Generated_Code/tasks.c **** /*
 432:../Generated_Code/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 433:../Generated_Code/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 434:../Generated_Code/tasks.c ****  * creation of the first user task.
 435:../Generated_Code/tasks.c ****  *
 436:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 437:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 438:../Generated_Code/tasks.c ****  *
 439:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
 440:../Generated_Code/tasks.c ****  *
 441:../Generated_Code/tasks.c ****  */
 442:../Generated_Code/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 443:../Generated_Code/tasks.c **** 
 444:../Generated_Code/tasks.c **** /*
 445:../Generated_Code/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 446:../Generated_Code/tasks.c ****  * including the stack pointed to by the TCB.
 447:../Generated_Code/tasks.c ****  *
 448:../Generated_Code/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 449:../Generated_Code/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 450:../Generated_Code/tasks.c ****  */
 451:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 452:../Generated_Code/tasks.c **** 
 453:../Generated_Code/tasks.c ****         static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 454:../Generated_Code/tasks.c **** 
 455:../Generated_Code/tasks.c **** #endif
 456:../Generated_Code/tasks.c **** 
 457:../Generated_Code/tasks.c **** /*
 458:../Generated_Code/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 459:../Generated_Code/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 460:../Generated_Code/tasks.c ****  * and its TCB deleted.
 461:../Generated_Code/tasks.c ****  */
 462:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 463:../Generated_Code/tasks.c **** 
 464:../Generated_Code/tasks.c **** /*
 465:../Generated_Code/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 466:../Generated_Code/tasks.c ****  * either the current or the overflow delayed task list.
 467:../Generated_Code/tasks.c ****  */
 468:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 469:../Generated_Code/tasks.c **** 
 470:../Generated_Code/tasks.c **** /*
 471:../Generated_Code/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 472:../Generated_Code/tasks.c ****  * allocation was successful.
 473:../Generated_Code/tasks.c ****  */
 474:../Generated_Code/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 475:../Generated_Code/tasks.c **** 
 476:../Generated_Code/tasks.c **** /*
 477:../Generated_Code/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 478:../Generated_Code/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 479:../Generated_Code/tasks.c ****  * a suspended list, etc.).
 480:../Generated_Code/tasks.c ****  *
 481:../Generated_Code/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 482:../Generated_Code/tasks.c ****  * NORMAL APPLICATION CODE.
 483:../Generated_Code/tasks.c ****  */
 484:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 485:../Generated_Code/tasks.c **** 
 486:../Generated_Code/tasks.c ****         static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *px
 487:../Generated_Code/tasks.c **** 
 488:../Generated_Code/tasks.c **** #endif
 489:../Generated_Code/tasks.c **** 
 490:../Generated_Code/tasks.c **** /*
 491:../Generated_Code/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 492:../Generated_Code/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 493:../Generated_Code/tasks.c ****  * determining how much of the stack remains at the original preset value.
 494:../Generated_Code/tasks.c ****  */
 495:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 496:../Generated_Code/tasks.c **** 
 497:../Generated_Code/tasks.c ****         static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCT
 498:../Generated_Code/tasks.c **** 
 499:../Generated_Code/tasks.c **** #endif
 500:../Generated_Code/tasks.c **** 
 501:../Generated_Code/tasks.c **** /*
 502:../Generated_Code/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 503:../Generated_Code/tasks.c ****  * next move a task from the Blocked state to the Running state.
 504:../Generated_Code/tasks.c ****  *
 505:../Generated_Code/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 506:../Generated_Code/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 507:../Generated_Code/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 508:../Generated_Code/tasks.c ****  * set to a value other than 1.
 509:../Generated_Code/tasks.c ****  */
 510:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 511:../Generated_Code/tasks.c **** 
 512:../Generated_Code/tasks.c ****         static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 513:../Generated_Code/tasks.c **** 
 514:../Generated_Code/tasks.c **** #endif
 515:../Generated_Code/tasks.c **** 
 516:../Generated_Code/tasks.c **** /*
 517:../Generated_Code/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 518:../Generated_Code/tasks.c ****  * will exit the Blocked state.
 519:../Generated_Code/tasks.c ****  */
 520:../Generated_Code/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 521:../Generated_Code/tasks.c **** 
 522:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 523:../Generated_Code/tasks.c **** 
 524:../Generated_Code/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 525:../Generated_Code/tasks.c **** {
 147              		.loc 1 525 0
 148              		.cfi_startproc
 149 0000 90B5     		push	{r4, r7, lr}
 150              	.LCFI0:
 151              		.cfi_def_cfa_offset 12
 152              		.cfi_offset 4, -12
 153              		.cfi_offset 7, -8
 154              		.cfi_offset 14, -4
 155 0002 8BB0     		sub	sp, sp, #44
 156              	.LCFI1:
 157              		.cfi_def_cfa_offset 56
 158 0004 02AF     		add	r7, sp, #8
 159              	.LCFI2:
 160              		.cfi_def_cfa 7, 48
 161 0006 F860     		str	r0, [r7, #12]
 162 0008 B960     		str	r1, [r7, #8]
 163 000a 3B60     		str	r3, [r7]
 164 000c BB1D     		add	r3, r7, #6
 165 000e 1A80     		strh	r2, [r3]
 166              	.LBB2:
 526:../Generated_Code/tasks.c **** BaseType_t xReturn;
 527:../Generated_Code/tasks.c **** TCB_t * pxNewTCB;
 528:../Generated_Code/tasks.c **** 
 529:../Generated_Code/tasks.c ****         configASSERT( pxTaskCode );
 167              		.loc 1 529 0
 168 0010 FB68     		ldr	r3, [r7, #12]
 169 0012 002B     		cmp	r3, #0
 170 0014 01D1     		bne	.L2
 171              		.loc 1 529 0 is_stmt 0
 172              	@ 529 "../Generated_Code/tasks.c" 1
 173 0016 72B6     		cpsid i
 174              	@ 0 "" 2
 175              		.code	16
 176              	.L3:
 177              		.loc 1 529 0
 178 0018 FEE7     		b	.L3
 179              	.L2:
 530:../Generated_Code/tasks.c ****         configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 180              		.loc 1 530 0 is_stmt 1
 181 001a 3B6B     		ldr	r3, [r7, #48]
 182 001c 052B     		cmp	r3, #5
 183 001e 01D9     		bls	.L4
 184              		.loc 1 530 0 is_stmt 0
 185              	@ 530 "../Generated_Code/tasks.c" 1
 186 0020 72B6     		cpsid i
 187              	@ 0 "" 2
 188              		.code	16
 189              	.L5:
 190              		.loc 1 530 0
 191 0022 FEE7     		b	.L5
 192              	.L4:
 531:../Generated_Code/tasks.c **** 
 532:../Generated_Code/tasks.c ****         /* Allocate the memory required by the TCB and stack for the new task,
 533:../Generated_Code/tasks.c ****         checking that the allocation was successful. */
 534:../Generated_Code/tasks.c ****         pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 193              		.loc 1 534 0 is_stmt 1
 194 0024 BB1D     		add	r3, r7, #6
 195 0026 1A88     		ldrh	r2, [r3]
 196 0028 BB6B     		ldr	r3, [r7, #56]
 197 002a 101C     		mov	r0, r2
 198 002c 191C     		mov	r1, r3
 199 002e FFF7FEFF 		bl	_ZL22prvAllocateTCBAndStacktPm
 200 0032 031C     		mov	r3, r0
 201 0034 BB61     		str	r3, [r7, #24]
 202              	.LBB3:
 535:../Generated_Code/tasks.c **** 
 536:../Generated_Code/tasks.c ****         if( pxNewTCB != NULL )
 203              		.loc 1 536 0
 204 0036 BB69     		ldr	r3, [r7, #24]
 205 0038 002B     		cmp	r3, #0
 206 003a 00D1     		bne	.LCB53
 207 003c 81E0     		b	.L6	@long jump
 208              	.LCB53:
 209              	.LBB4:
 537:../Generated_Code/tasks.c ****         {
 538:../Generated_Code/tasks.c ****                 StackType_t *pxTopOfStack;
 539:../Generated_Code/tasks.c **** 
 540:../Generated_Code/tasks.c ****                 #if( portUSING_MPU_WRAPPERS == 1 )
 541:../Generated_Code/tasks.c ****                         /* Should the task be created in privileged mode? */
 542:../Generated_Code/tasks.c ****                         BaseType_t xRunPrivileged;
 543:../Generated_Code/tasks.c ****                         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 544:../Generated_Code/tasks.c ****                         {
 545:../Generated_Code/tasks.c ****                                 xRunPrivileged = pdTRUE;
 546:../Generated_Code/tasks.c ****                         }
 547:../Generated_Code/tasks.c ****                         else
 548:../Generated_Code/tasks.c ****                         {
 549:../Generated_Code/tasks.c ****                                 xRunPrivileged = pdFALSE;
 550:../Generated_Code/tasks.c ****                         }
 551:../Generated_Code/tasks.c ****                         uxPriority &= ~portPRIVILEGE_BIT;
 552:../Generated_Code/tasks.c ****                 #endif /* portUSING_MPU_WRAPPERS == 1 */
 553:../Generated_Code/tasks.c **** 
 554:../Generated_Code/tasks.c ****                 /* Calculate the top of stack address.  This depends on whether the
 555:../Generated_Code/tasks.c ****                 stack grows from high memory to low (as per the 80x86) or vice versa.
 556:../Generated_Code/tasks.c ****                 portSTACK_GROWTH is used to make the result positive or negative as
 557:../Generated_Code/tasks.c ****                 required by the port. */
 558:../Generated_Code/tasks.c ****                 #if( portSTACK_GROWTH < 0 )
 559:../Generated_Code/tasks.c ****                 {
 560:../Generated_Code/tasks.c ****                         pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 210              		.loc 1 560 0
 211 003e BB69     		ldr	r3, [r7, #24]
 212 0040 1A6B     		ldr	r2, [r3, #48]
 213 0042 BB1D     		add	r3, r7, #6
 214 0044 1B88     		ldrh	r3, [r3]
 215 0046 013B     		sub	r3, r3, #1
 216 0048 9B00     		lsl	r3, r3, #2
 217 004a D318     		add	r3, r2, r3
 218 004c 7B61     		str	r3, [r7, #20]
 561:../Generated_Code/tasks.c ****                         pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack
 219              		.loc 1 561 0
 220 004e 7B69     		ldr	r3, [r7, #20]
 221 0050 0722     		mov	r2, #7
 222 0052 9343     		bic	r3, r2
 223 0054 7B61     		str	r3, [r7, #20]
 562:../Generated_Code/tasks.c **** 
 563:../Generated_Code/tasks.c ****                         /* Check the alignment of the calculated top of stack is correct. */
 564:../Generated_Code/tasks.c ****                         configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNME
 224              		.loc 1 564 0
 225 0056 7A69     		ldr	r2, [r7, #20]
 226 0058 0723     		mov	r3, #7
 227 005a 1340     		and	r3, r2
 228 005c 01D0     		beq	.L7
 229              		.loc 1 564 0 is_stmt 0
 230              	@ 564 "../Generated_Code/tasks.c" 1
 231 005e 72B6     		cpsid i
 232              	@ 0 "" 2
 233              		.code	16
 234              	.L8:
 235              		.loc 1 564 0
 236 0060 FEE7     		b	.L8
 237              	.L7:
 565:../Generated_Code/tasks.c ****                 }
 566:../Generated_Code/tasks.c ****                 #else /* portSTACK_GROWTH */
 567:../Generated_Code/tasks.c ****                 {
 568:../Generated_Code/tasks.c ****                         pxTopOfStack = pxNewTCB->pxStack;
 569:../Generated_Code/tasks.c **** 
 570:../Generated_Code/tasks.c ****                         /* Check the alignment of the stack buffer is correct. */
 571:../Generated_Code/tasks.c ****                         configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_AL
 572:../Generated_Code/tasks.c **** 
 573:../Generated_Code/tasks.c ****                         /* If we want to use stack checking on architectures that use
 574:../Generated_Code/tasks.c ****                         a positive stack growth direction then we also need to store the
 575:../Generated_Code/tasks.c ****                         other extreme of the stack space. */
 576:../Generated_Code/tasks.c ****                         pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 577:../Generated_Code/tasks.c ****                 }
 578:../Generated_Code/tasks.c ****                 #endif /* portSTACK_GROWTH */
 579:../Generated_Code/tasks.c **** 
 580:../Generated_Code/tasks.c ****                 /* Setup the newly allocated TCB with the initial state of the task. */
 581:../Generated_Code/tasks.c ****                 prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 238              		.loc 1 581 0 is_stmt 1
 239 0062 B869     		ldr	r0, [r7, #24]
 240 0064 B968     		ldr	r1, [r7, #8]
 241 0066 3A6B     		ldr	r2, [r7, #48]
 242 0068 FB6B     		ldr	r3, [r7, #60]
 243 006a BC1D     		add	r4, r7, #6
 244 006c 2488     		ldrh	r4, [r4]
 245 006e 0094     		str	r4, [sp]
 246 0070 FFF7FEFF 		bl	_ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt
 582:../Generated_Code/tasks.c **** 
 583:../Generated_Code/tasks.c ****                 /* Initialize the TCB stack to look as if the task was already running,
 584:../Generated_Code/tasks.c ****                 but had been interrupted by the scheduler.  The return address is set
 585:../Generated_Code/tasks.c ****                 to the start of the task function. Once the stack has been initialised
 586:../Generated_Code/tasks.c ****                 the     top of stack variable is updated. */
 587:../Generated_Code/tasks.c ****                 #if( portUSING_MPU_WRAPPERS == 1 )
 588:../Generated_Code/tasks.c ****                 {
 589:../Generated_Code/tasks.c ****                         pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, p
 590:../Generated_Code/tasks.c ****                 }
 591:../Generated_Code/tasks.c ****                 #else /* portUSING_MPU_WRAPPERS */
 592:../Generated_Code/tasks.c ****                 {
 593:../Generated_Code/tasks.c ****                         pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, p
 247              		.loc 1 593 0
 248 0074 7969     		ldr	r1, [r7, #20]
 249 0076 FA68     		ldr	r2, [r7, #12]
 250 0078 3B68     		ldr	r3, [r7]
 251 007a 081C     		mov	r0, r1
 252 007c 111C     		mov	r1, r2
 253 007e 1A1C     		mov	r2, r3
 254 0080 FFF7FEFF 		bl	pxPortInitialiseStack
 255 0084 021C     		mov	r2, r0
 256 0086 BB69     		ldr	r3, [r7, #24]
 257 0088 1A60     		str	r2, [r3]
 594:../Generated_Code/tasks.c ****                 }
 595:../Generated_Code/tasks.c ****                 #endif /* portUSING_MPU_WRAPPERS */
 596:../Generated_Code/tasks.c **** 
 597:../Generated_Code/tasks.c ****                 if( ( void * ) pxCreatedTask != NULL )
 258              		.loc 1 597 0
 259 008a 7B6B     		ldr	r3, [r7, #52]
 260 008c 002B     		cmp	r3, #0
 261 008e 02D0     		beq	.L9
 598:../Generated_Code/tasks.c ****                 {
 599:../Generated_Code/tasks.c ****                         /* Pass the TCB out - in an anonymous way.  The calling function/
 600:../Generated_Code/tasks.c ****                         task can use this as a handle to delete the task later if
 601:../Generated_Code/tasks.c ****                         required.*/
 602:../Generated_Code/tasks.c ****                         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 262              		.loc 1 602 0
 263 0090 7B6B     		ldr	r3, [r7, #52]
 264 0092 BA69     		ldr	r2, [r7, #24]
 265 0094 1A60     		str	r2, [r3]
 266              	.L9:
 603:../Generated_Code/tasks.c ****                 }
 604:../Generated_Code/tasks.c ****                 else
 605:../Generated_Code/tasks.c ****                 {
 606:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 607:../Generated_Code/tasks.c ****                 }
 608:../Generated_Code/tasks.c **** 
 609:../Generated_Code/tasks.c ****                 /* Ensure interrupts don't access the task lists while they are being
 610:../Generated_Code/tasks.c ****                 updated. */
 611:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 267              		.loc 1 611 0
 268 0096 FFF7FEFF 		bl	vPortEnterCritical
 612:../Generated_Code/tasks.c ****                 {
 613:../Generated_Code/tasks.c ****                         uxCurrentNumberOfTasks++;
 269              		.loc 1 613 0
 270 009a 394B     		ldr	r3, .L16
 271 009c 1B68     		ldr	r3, [r3]
 272 009e 5A1C     		add	r2, r3, #1
 273 00a0 374B     		ldr	r3, .L16
 274 00a2 1A60     		str	r2, [r3]
 614:../Generated_Code/tasks.c ****                         if( pxCurrentTCB == NULL )
 275              		.loc 1 614 0
 276 00a4 374B     		ldr	r3, .L16+4
 277 00a6 1B68     		ldr	r3, [r3]
 278 00a8 5A42     		neg	r2, r3
 279 00aa 5341     		adc	r3, r3, r2
 280 00ac DBB2     		uxtb	r3, r3
 281 00ae 002B     		cmp	r3, #0
 282 00b0 0DD0     		beq	.L10
 615:../Generated_Code/tasks.c ****                         {
 616:../Generated_Code/tasks.c ****                                 /* There are no other tasks, or all the other tasks are in
 617:../Generated_Code/tasks.c ****                                 the suspended state - make this the current task. */
 618:../Generated_Code/tasks.c ****                                 pxCurrentTCB =  pxNewTCB;
 283              		.loc 1 618 0
 284 00b2 344B     		ldr	r3, .L16+4
 285 00b4 BA69     		ldr	r2, [r7, #24]
 286 00b6 1A60     		str	r2, [r3]
 619:../Generated_Code/tasks.c **** 
 620:../Generated_Code/tasks.c ****                                 if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 287              		.loc 1 620 0
 288 00b8 314B     		ldr	r3, .L16
 289 00ba 1B68     		ldr	r3, [r3]
 290 00bc 013B     		sub	r3, r3, #1
 291 00be 5A42     		neg	r2, r3
 292 00c0 5341     		adc	r3, r3, r2
 293 00c2 DBB2     		uxtb	r3, r3
 294 00c4 002B     		cmp	r3, #0
 295 00c6 16D0     		beq	.L11
 621:../Generated_Code/tasks.c ****                                 {
 622:../Generated_Code/tasks.c ****                                         /* This is the first task to be created so do the prelimina
 623:../Generated_Code/tasks.c ****                                         initialisation required.  We will not recover if this call
 624:../Generated_Code/tasks.c ****                                         fails, but we will report the failure. */
 625:../Generated_Code/tasks.c ****                                         prvInitialiseTaskLists();
 296              		.loc 1 625 0
 297 00c8 FFF7FEFF 		bl	_ZL22prvInitialiseTaskListsv
 298 00cc 13E0     		b	.L11
 299              	.L10:
 626:../Generated_Code/tasks.c ****                                 }
 627:../Generated_Code/tasks.c ****                                 else
 628:../Generated_Code/tasks.c ****                                 {
 629:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 630:../Generated_Code/tasks.c ****                                 }
 631:../Generated_Code/tasks.c ****                         }
 632:../Generated_Code/tasks.c ****                         else
 633:../Generated_Code/tasks.c ****                         {
 634:../Generated_Code/tasks.c ****                                 /* If the scheduler is not already running, make this task the
 635:../Generated_Code/tasks.c ****                                 current task if it is the highest priority task to be created
 636:../Generated_Code/tasks.c ****                                 so far. */
 637:../Generated_Code/tasks.c ****                                 if( xSchedulerRunning == pdFALSE )
 300              		.loc 1 637 0
 301 00ce 2E4B     		ldr	r3, .L16+8
 302 00d0 1B68     		ldr	r3, [r3]
 303 00d2 5A42     		neg	r2, r3
 304 00d4 5341     		adc	r3, r3, r2
 305 00d6 DBB2     		uxtb	r3, r3
 306 00d8 002B     		cmp	r3, #0
 307 00da 0CD0     		beq	.L11
 638:../Generated_Code/tasks.c ****                                 {
 639:../Generated_Code/tasks.c ****                                         if( pxCurrentTCB->uxPriority <= uxPriority )
 308              		.loc 1 639 0
 309 00dc 294B     		ldr	r3, .L16+4
 310 00de 1B68     		ldr	r3, [r3]
 311 00e0 DA6A     		ldr	r2, [r3, #44]
 312 00e2 396B     		ldr	r1, [r7, #48]
 313 00e4 0023     		mov	r3, #0
 314 00e6 9142     		cmp	r1, r2
 315 00e8 5B41     		adc	r3, r3, r3
 316 00ea DBB2     		uxtb	r3, r3
 317 00ec 002B     		cmp	r3, #0
 318 00ee 02D0     		beq	.L11
 640:../Generated_Code/tasks.c ****                                         {
 641:../Generated_Code/tasks.c ****                                                 pxCurrentTCB = pxNewTCB;
 319              		.loc 1 641 0
 320 00f0 244B     		ldr	r3, .L16+4
 321 00f2 BA69     		ldr	r2, [r7, #24]
 322 00f4 1A60     		str	r2, [r3]
 323              	.L11:
 642:../Generated_Code/tasks.c ****                                         }
 643:../Generated_Code/tasks.c ****                                         else
 644:../Generated_Code/tasks.c ****                                         {
 645:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
 646:../Generated_Code/tasks.c ****                                         }
 647:../Generated_Code/tasks.c ****                                 }
 648:../Generated_Code/tasks.c ****                                 else
 649:../Generated_Code/tasks.c ****                                 {
 650:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 651:../Generated_Code/tasks.c ****                                 }
 652:../Generated_Code/tasks.c ****                         }
 653:../Generated_Code/tasks.c **** 
 654:../Generated_Code/tasks.c ****                         uxTaskNumber++;
 324              		.loc 1 654 0
 325 00f6 254B     		ldr	r3, .L16+12
 326 00f8 1B68     		ldr	r3, [r3]
 327 00fa 5A1C     		add	r2, r3, #1
 328 00fc 234B     		ldr	r3, .L16+12
 329 00fe 1A60     		str	r2, [r3]
 655:../Generated_Code/tasks.c **** 
 656:../Generated_Code/tasks.c ****                         #if ( configUSE_TRACE_FACILITY == 1 )
 657:../Generated_Code/tasks.c ****                         {
 658:../Generated_Code/tasks.c ****                                 /* Add a counter into the TCB for tracing only. */
 659:../Generated_Code/tasks.c ****                                 pxNewTCB->uxTCBNumber = uxTaskNumber;
 660:../Generated_Code/tasks.c ****                         }
 661:../Generated_Code/tasks.c ****                         #endif /* configUSE_TRACE_FACILITY */
 662:../Generated_Code/tasks.c ****                         traceTASK_CREATE( pxNewTCB );
 663:../Generated_Code/tasks.c **** 
 664:../Generated_Code/tasks.c ****                         prvAddTaskToReadyList( pxNewTCB );
 330              		.loc 1 664 0
 331 0100 BB69     		ldr	r3, [r7, #24]
 332 0102 DA6A     		ldr	r2, [r3, #44]
 333 0104 224B     		ldr	r3, .L16+16
 334 0106 1B68     		ldr	r3, [r3]
 335 0108 9342     		cmp	r3, r2
 336 010a 9B41     		sbc	r3, r3, r3
 337 010c 5B42     		neg	r3, r3
 338 010e DBB2     		uxtb	r3, r3
 339 0110 002B     		cmp	r3, #0
 340 0112 03D0     		beq	.L12
 341              		.loc 1 664 0 is_stmt 0
 342 0114 BB69     		ldr	r3, [r7, #24]
 343 0116 DA6A     		ldr	r2, [r3, #44]
 344 0118 1D4B     		ldr	r3, .L16+16
 345 011a 1A60     		str	r2, [r3]
 346              	.L12:
 347              		.loc 1 664 0
 348 011c BB69     		ldr	r3, [r7, #24]
 349 011e DA6A     		ldr	r2, [r3, #44]
 350 0120 131C     		mov	r3, r2
 351 0122 9B00     		lsl	r3, r3, #2
 352 0124 9B18     		add	r3, r3, r2
 353 0126 9B00     		lsl	r3, r3, #2
 354 0128 1A4A     		ldr	r2, .L16+20
 355 012a 9A18     		add	r2, r3, r2
 356 012c BB69     		ldr	r3, [r7, #24]
 357 012e 0433     		add	r3, r3, #4
 358 0130 101C     		mov	r0, r2
 359 0132 191C     		mov	r1, r3
 360 0134 FFF7FEFF 		bl	vListInsertEnd
 665:../Generated_Code/tasks.c **** 
 666:../Generated_Code/tasks.c ****                         xReturn = pdPASS;
 361              		.loc 1 666 0 is_stmt 1
 362 0138 0123     		mov	r3, #1
 363 013a FB61     		str	r3, [r7, #28]
 667:../Generated_Code/tasks.c ****                         portSETUP_TCB( pxNewTCB );
 668:../Generated_Code/tasks.c ****                 }
 669:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 364              		.loc 1 669 0
 365 013c FFF7FEFF 		bl	vPortExitCritical
 366 0140 02E0     		b	.L13
 367              	.L6:
 368              	.LBE4:
 670:../Generated_Code/tasks.c ****         }
 671:../Generated_Code/tasks.c ****         else
 672:../Generated_Code/tasks.c ****         {
 673:../Generated_Code/tasks.c ****                 xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 369              		.loc 1 673 0
 370 0142 0123     		mov	r3, #1
 371 0144 5B42     		neg	r3, r3
 372 0146 FB61     		str	r3, [r7, #28]
 373              	.L13:
 374              	.LBE3:
 674:../Generated_Code/tasks.c ****                 traceTASK_CREATE_FAILED();
 675:../Generated_Code/tasks.c ****         }
 676:../Generated_Code/tasks.c **** 
 677:../Generated_Code/tasks.c ****         if( xReturn == pdPASS )
 375              		.loc 1 677 0
 376 0148 FB69     		ldr	r3, [r7, #28]
 377 014a 012B     		cmp	r3, #1
 378 014c 12D1     		bne	.L14
 678:../Generated_Code/tasks.c ****         {
 679:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
 379              		.loc 1 679 0
 380 014e 0E4B     		ldr	r3, .L16+8
 381 0150 1B68     		ldr	r3, [r3]
 382 0152 5A1E     		sub	r2, r3, #1
 383 0154 9341     		sbc	r3, r3, r2
 384 0156 DBB2     		uxtb	r3, r3
 385 0158 002B     		cmp	r3, #0
 386 015a 0BD0     		beq	.L14
 680:../Generated_Code/tasks.c ****                 {
 681:../Generated_Code/tasks.c ****                         /* If the created task is of a higher priority than the current task
 682:../Generated_Code/tasks.c ****                         then it should run now. */
 683:../Generated_Code/tasks.c ****                         if( pxCurrentTCB->uxPriority < uxPriority )
 387              		.loc 1 683 0
 388 015c 094B     		ldr	r3, .L16+4
 389 015e 1B68     		ldr	r3, [r3]
 390 0160 DA6A     		ldr	r2, [r3, #44]
 391 0162 3B6B     		ldr	r3, [r7, #48]
 392 0164 9A42     		cmp	r2, r3
 393 0166 9B41     		sbc	r3, r3, r3
 394 0168 5B42     		neg	r3, r3
 395 016a DBB2     		uxtb	r3, r3
 396 016c 002B     		cmp	r3, #0
 397 016e 01D0     		beq	.L14
 684:../Generated_Code/tasks.c ****                         {
 685:../Generated_Code/tasks.c ****                                 taskYIELD_IF_USING_PREEMPTION();
 398              		.loc 1 685 0
 399 0170 FFF7FEFF 		bl	vPortYieldFromISR
 400              	.L14:
 686:../Generated_Code/tasks.c ****                         }
 687:../Generated_Code/tasks.c ****                         else
 688:../Generated_Code/tasks.c ****                         {
 689:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 690:../Generated_Code/tasks.c ****                         }
 691:../Generated_Code/tasks.c ****                 }
 692:../Generated_Code/tasks.c ****                 else
 693:../Generated_Code/tasks.c ****                 {
 694:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 695:../Generated_Code/tasks.c ****                 }
 696:../Generated_Code/tasks.c ****         }
 697:../Generated_Code/tasks.c **** 
 698:../Generated_Code/tasks.c ****         return xReturn;
 401              		.loc 1 698 0
 402 0174 FB69     		ldr	r3, [r7, #28]
 403              	.LBE2:
 699:../Generated_Code/tasks.c **** }
 404              		.loc 1 699 0
 405 0176 181C     		mov	r0, r3
 406 0178 BD46     		mov	sp, r7
 407 017a 09B0     		add	sp, sp, #36
 408              		@ sp needed for prologue
 409 017c 90BD     		pop	{r4, r7, pc}
 410              	.L17:
 411 017e C046     		.align	2
 412              	.L16:
 413 0180 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 414 0184 00000000 		.word	pxCurrentTCB
 415 0188 00000000 		.word	_ZL17xSchedulerRunning
 416 018c 00000000 		.word	_ZL12uxTaskNumber
 417 0190 00000000 		.word	_ZL18uxTopReadyPriority
 418 0194 00000000 		.word	_ZL17pxReadyTasksLists
 419              		.cfi_endproc
 420              	.LFE9:
 422              		.section	.text.vTaskDelete,"ax",%progbits
 423              		.align	2
 424              		.global	vTaskDelete
 425              		.code	16
 426              		.thumb_func
 428              	vTaskDelete:
 429              	.LFB10:
 700:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 701:../Generated_Code/tasks.c **** 
 702:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 703:../Generated_Code/tasks.c **** 
 704:../Generated_Code/tasks.c ****         void vTaskDelete( TaskHandle_t xTaskToDelete )
 705:../Generated_Code/tasks.c ****         {
 430              		.loc 1 705 0
 431              		.cfi_startproc
 432 0000 80B5     		push	{r7, lr}
 433              	.LCFI3:
 434              		.cfi_def_cfa_offset 8
 435              		.cfi_offset 7, -8
 436              		.cfi_offset 14, -4
 437 0002 84B0     		sub	sp, sp, #16
 438              	.LCFI4:
 439              		.cfi_def_cfa_offset 24
 440 0004 00AF     		add	r7, sp, #0
 441              	.LCFI5:
 442              		.cfi_def_cfa_register 7
 443 0006 7860     		str	r0, [r7, #4]
 444              	.LBB5:
 706:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
 707:../Generated_Code/tasks.c **** 
 708:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 445              		.loc 1 708 0
 446 0008 FFF7FEFF 		bl	vPortEnterCritical
 709:../Generated_Code/tasks.c ****                 {
 710:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the calling task that is
 711:../Generated_Code/tasks.c ****                         being deleted. */
 712:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 447              		.loc 1 712 0
 448 000c 7B68     		ldr	r3, [r7, #4]
 449 000e 002B     		cmp	r3, #0
 450 0010 02D1     		bne	.L19
 451              		.loc 1 712 0 is_stmt 0
 452 0012 234B     		ldr	r3, .L26
 453 0014 1B68     		ldr	r3, [r3]
 454 0016 00E0     		b	.L20
 455              	.L19:
 456              		.loc 1 712 0
 457 0018 7B68     		ldr	r3, [r7, #4]
 458              	.L20:
 459              		.loc 1 712 0
 460 001a FB60     		str	r3, [r7, #12]
 713:../Generated_Code/tasks.c **** 
 714:../Generated_Code/tasks.c ****                         /* Remove task from the ready list and place in the     termination list.
 715:../Generated_Code/tasks.c ****                         This will stop the task from be scheduled.  The idle task will check
 716:../Generated_Code/tasks.c ****                         the termination list and free up any memory allocated by the
 717:../Generated_Code/tasks.c ****                         scheduler for the TCB and stack. */
 718:../Generated_Code/tasks.c ****                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 461              		.loc 1 718 0 is_stmt 1
 462 001c FB68     		ldr	r3, [r7, #12]
 463 001e 0433     		add	r3, r3, #4
 464 0020 181C     		mov	r0, r3
 465 0022 FFF7FEFF 		bl	uxListRemove
 719:../Generated_Code/tasks.c ****                         {
 720:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 721:../Generated_Code/tasks.c ****                         }
 722:../Generated_Code/tasks.c ****                         else
 723:../Generated_Code/tasks.c ****                         {
 724:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 725:../Generated_Code/tasks.c ****                         }
 726:../Generated_Code/tasks.c **** 
 727:../Generated_Code/tasks.c ****                         /* Is the task waiting on an event also? */
 728:../Generated_Code/tasks.c ****                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 466              		.loc 1 728 0
 467 0026 FB68     		ldr	r3, [r7, #12]
 468 0028 9B6A     		ldr	r3, [r3, #40]
 469 002a 002B     		cmp	r3, #0
 470 002c 04D0     		beq	.L21
 729:../Generated_Code/tasks.c ****                         {
 730:../Generated_Code/tasks.c ****                                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 471              		.loc 1 730 0
 472 002e FB68     		ldr	r3, [r7, #12]
 473 0030 1833     		add	r3, r3, #24
 474 0032 181C     		mov	r0, r3
 475 0034 FFF7FEFF 		bl	uxListRemove
 476              	.L21:
 731:../Generated_Code/tasks.c ****                         }
 732:../Generated_Code/tasks.c ****                         else
 733:../Generated_Code/tasks.c ****                         {
 734:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 735:../Generated_Code/tasks.c ****                         }
 736:../Generated_Code/tasks.c **** 
 737:../Generated_Code/tasks.c ****                         vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 477              		.loc 1 737 0
 478 0038 FB68     		ldr	r3, [r7, #12]
 479 003a 0433     		add	r3, r3, #4
 480 003c 194A     		ldr	r2, .L26+4
 481 003e 101C     		mov	r0, r2
 482 0040 191C     		mov	r1, r3
 483 0042 FFF7FEFF 		bl	vListInsertEnd
 738:../Generated_Code/tasks.c **** 
 739:../Generated_Code/tasks.c ****                         /* Increment the ucTasksDeleted variable so the idle task knows
 740:../Generated_Code/tasks.c ****                         there is a task that has been deleted and that it should therefore
 741:../Generated_Code/tasks.c ****                         check the xTasksWaitingTermination list. */
 742:../Generated_Code/tasks.c ****                         ++uxTasksDeleted;
 484              		.loc 1 742 0
 485 0046 184B     		ldr	r3, .L26+8
 486 0048 1B68     		ldr	r3, [r3]
 487 004a 5A1C     		add	r2, r3, #1
 488 004c 164B     		ldr	r3, .L26+8
 489 004e 1A60     		str	r2, [r3]
 743:../Generated_Code/tasks.c **** 
 744:../Generated_Code/tasks.c ****                         /* Increment the uxTaskNumberVariable also so kernel aware debuggers
 745:../Generated_Code/tasks.c ****                         can detect that the task lists need re-generating. */
 746:../Generated_Code/tasks.c ****                         uxTaskNumber++;
 490              		.loc 1 746 0
 491 0050 164B     		ldr	r3, .L26+12
 492 0052 1B68     		ldr	r3, [r3]
 493 0054 5A1C     		add	r2, r3, #1
 494 0056 154B     		ldr	r3, .L26+12
 495 0058 1A60     		str	r2, [r3]
 747:../Generated_Code/tasks.c **** 
 748:../Generated_Code/tasks.c ****                         traceTASK_DELETE( pxTCB );
 749:../Generated_Code/tasks.c ****                 }
 750:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 496              		.loc 1 750 0
 497 005a FFF7FEFF 		bl	vPortExitCritical
 751:../Generated_Code/tasks.c **** 
 752:../Generated_Code/tasks.c ****                 /* Force a reschedule if it is the currently running task that has just
 753:../Generated_Code/tasks.c ****                 been deleted. */
 754:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
 498              		.loc 1 754 0
 499 005e 144B     		ldr	r3, .L26+16
 500 0060 1B68     		ldr	r3, [r3]
 501 0062 5A1E     		sub	r2, r3, #1
 502 0064 9341     		sbc	r3, r3, r2
 503 0066 DBB2     		uxtb	r3, r3
 504 0068 002B     		cmp	r3, #0
 505 006a 16D0     		beq	.L18
 755:../Generated_Code/tasks.c ****                 {
 756:../Generated_Code/tasks.c ****                         if( pxTCB == pxCurrentTCB )
 506              		.loc 1 756 0
 507 006c 0C4B     		ldr	r3, .L26
 508 006e 1B68     		ldr	r3, [r3]
 509 0070 FA68     		ldr	r2, [r7, #12]
 510 0072 D31A     		sub	r3, r2, r3
 511 0074 5A42     		neg	r2, r3
 512 0076 5341     		adc	r3, r3, r2
 513 0078 DBB2     		uxtb	r3, r3
 514 007a 002B     		cmp	r3, #0
 515 007c 0BD0     		beq	.L23
 757:../Generated_Code/tasks.c ****                         {
 758:../Generated_Code/tasks.c ****                                 configASSERT( uxSchedulerSuspended == 0 );
 516              		.loc 1 758 0
 517 007e 0D4B     		ldr	r3, .L26+20
 518 0080 1B68     		ldr	r3, [r3]
 519 0082 5A1E     		sub	r2, r3, #1
 520 0084 9341     		sbc	r3, r3, r2
 521 0086 DBB2     		uxtb	r3, r3
 522 0088 002B     		cmp	r3, #0
 523 008a 01D0     		beq	.L24
 524              		.loc 1 758 0 is_stmt 0
 525              	@ 758 "../Generated_Code/tasks.c" 1
 526 008c 72B6     		cpsid i
 527              	@ 0 "" 2
 528              		.code	16
 529              	.L25:
 530              		.loc 1 758 0
 531 008e FEE7     		b	.L25
 532              	.L24:
 759:../Generated_Code/tasks.c **** 
 760:../Generated_Code/tasks.c ****                                 /* The pre-delete hook is primarily for the Windows simulator,
 761:../Generated_Code/tasks.c ****                                 in which Windows specific clean up operations are performed,
 762:../Generated_Code/tasks.c ****                                 after which it is not possible to yield away from this task -
 763:../Generated_Code/tasks.c ****                                 hence xYieldPending is used to latch that a context switch is
 764:../Generated_Code/tasks.c ****                                 required. */
 765:../Generated_Code/tasks.c ****                                 portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 766:../Generated_Code/tasks.c ****                                 portYIELD_WITHIN_API();
 533              		.loc 1 766 0 is_stmt 1
 534 0090 FFF7FEFF 		bl	vPortYieldFromISR
 535 0094 01E0     		b	.L18
 536              	.L23:
 767:../Generated_Code/tasks.c ****                         }
 768:../Generated_Code/tasks.c ****                         else
 769:../Generated_Code/tasks.c ****                         {
 770:../Generated_Code/tasks.c ****                                 /* Reset the next expected unblock time in case it referred to
 771:../Generated_Code/tasks.c ****                                 the task that has just been deleted. */
 772:../Generated_Code/tasks.c ****                                 prvResetNextTaskUnblockTime();
 537              		.loc 1 772 0
 538 0096 FFF7FEFF 		bl	_ZL27prvResetNextTaskUnblockTimev
 539              	.L18:
 540              	.LBE5:
 773:../Generated_Code/tasks.c ****                         }
 774:../Generated_Code/tasks.c ****                 }
 775:../Generated_Code/tasks.c ****         }
 541              		.loc 1 775 0
 542 009a BD46     		mov	sp, r7
 543 009c 04B0     		add	sp, sp, #16
 544              		@ sp needed for prologue
 545 009e 80BD     		pop	{r7, pc}
 546              	.L27:
 547              		.align	2
 548              	.L26:
 549 00a0 00000000 		.word	pxCurrentTCB
 550 00a4 00000000 		.word	_ZL24xTasksWaitingTermination
 551 00a8 00000000 		.word	_ZL14uxTasksDeleted
 552 00ac 00000000 		.word	_ZL12uxTaskNumber
 553 00b0 00000000 		.word	_ZL17xSchedulerRunning
 554 00b4 00000000 		.word	_ZL20uxSchedulerSuspended
 555              		.cfi_endproc
 556              	.LFE10:
 558              		.section	.text.vTaskDelayUntil,"ax",%progbits
 559              		.align	2
 560              		.global	vTaskDelayUntil
 561              		.code	16
 562              		.thumb_func
 564              	vTaskDelayUntil:
 565              	.LFB11:
 776:../Generated_Code/tasks.c **** 
 777:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 778:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 779:../Generated_Code/tasks.c **** 
 780:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 781:../Generated_Code/tasks.c **** 
 782:../Generated_Code/tasks.c ****         void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncremen
 783:../Generated_Code/tasks.c ****         {
 566              		.loc 1 783 0
 567              		.cfi_startproc
 568 0000 80B5     		push	{r7, lr}
 569              	.LCFI6:
 570              		.cfi_def_cfa_offset 8
 571              		.cfi_offset 7, -8
 572              		.cfi_offset 14, -4
 573 0002 86B0     		sub	sp, sp, #24
 574              	.LCFI7:
 575              		.cfi_def_cfa_offset 32
 576 0004 00AF     		add	r7, sp, #0
 577              	.LCFI8:
 578              		.cfi_def_cfa_register 7
 579 0006 7860     		str	r0, [r7, #4]
 580 0008 3960     		str	r1, [r7]
 581              	.LBB6:
 784:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
 785:../Generated_Code/tasks.c ****         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 582              		.loc 1 785 0
 583 000a 0023     		mov	r3, #0
 584 000c 7B61     		str	r3, [r7, #20]
 786:../Generated_Code/tasks.c **** 
 787:../Generated_Code/tasks.c ****                 configASSERT( pxPreviousWakeTime );
 585              		.loc 1 787 0
 586 000e 7B68     		ldr	r3, [r7, #4]
 587 0010 002B     		cmp	r3, #0
 588 0012 01D1     		bne	.L29
 589              		.loc 1 787 0 is_stmt 0
 590              	@ 787 "../Generated_Code/tasks.c" 1
 591 0014 72B6     		cpsid i
 592              	@ 0 "" 2
 593              		.code	16
 594              	.L30:
 595              		.loc 1 787 0
 596 0016 FEE7     		b	.L30
 597              	.L29:
 788:../Generated_Code/tasks.c ****                 configASSERT( ( xTimeIncrement > 0U ) );
 598              		.loc 1 788 0 is_stmt 1
 599 0018 3B68     		ldr	r3, [r7]
 600 001a 002B     		cmp	r3, #0
 601 001c 01D1     		bne	.L31
 602              		.loc 1 788 0 is_stmt 0
 603              	@ 788 "../Generated_Code/tasks.c" 1
 604 001e 72B6     		cpsid i
 605              	@ 0 "" 2
 606              		.code	16
 607              	.L32:
 608              		.loc 1 788 0
 609 0020 FEE7     		b	.L32
 610              	.L31:
 789:../Generated_Code/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
 611              		.loc 1 789 0 is_stmt 1
 612 0022 254B     		ldr	r3, .L40
 613 0024 1B68     		ldr	r3, [r3]
 614 0026 5A1E     		sub	r2, r3, #1
 615 0028 9341     		sbc	r3, r3, r2
 616 002a DBB2     		uxtb	r3, r3
 617 002c 002B     		cmp	r3, #0
 618 002e 01D0     		beq	.L33
 619              		.loc 1 789 0 is_stmt 0
 620              	@ 789 "../Generated_Code/tasks.c" 1
 621 0030 72B6     		cpsid i
 622              	@ 0 "" 2
 623              		.code	16
 624              	.L34:
 625              		.loc 1 789 0
 626 0032 FEE7     		b	.L34
 627              	.L33:
 790:../Generated_Code/tasks.c **** 
 791:../Generated_Code/tasks.c ****                 vTaskSuspendAll();
 628              		.loc 1 791 0 is_stmt 1
 629 0034 FFF7FEFF 		bl	vTaskSuspendAll
 630              	.LBB7:
 792:../Generated_Code/tasks.c ****                 {
 793:../Generated_Code/tasks.c ****                         /* Minor optimisation.  The tick count cannot change in this
 794:../Generated_Code/tasks.c ****                         block. */
 795:../Generated_Code/tasks.c ****                         const TickType_t xConstTickCount = xTickCount;
 631              		.loc 1 795 0
 632 0038 204B     		ldr	r3, .L40+4
 633 003a 1B68     		ldr	r3, [r3]
 634 003c 3B61     		str	r3, [r7, #16]
 796:../Generated_Code/tasks.c **** 
 797:../Generated_Code/tasks.c ****                         /* Generate the tick time at which the task wants to wake. */
 798:../Generated_Code/tasks.c ****                         xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 635              		.loc 1 798 0
 636 003e 7B68     		ldr	r3, [r7, #4]
 637 0040 1A68     		ldr	r2, [r3]
 638 0042 3B68     		ldr	r3, [r7]
 639 0044 D318     		add	r3, r2, r3
 640 0046 FB60     		str	r3, [r7, #12]
 799:../Generated_Code/tasks.c **** 
 800:../Generated_Code/tasks.c ****                         if( xConstTickCount < *pxPreviousWakeTime )
 641              		.loc 1 800 0
 642 0048 7B68     		ldr	r3, [r7, #4]
 643 004a 1A68     		ldr	r2, [r3]
 644 004c 3B69     		ldr	r3, [r7, #16]
 645 004e 9A42     		cmp	r2, r3
 646 0050 0BD9     		bls	.L35
 801:../Generated_Code/tasks.c ****                         {
 802:../Generated_Code/tasks.c ****                                 /* The tick count has overflowed since this function was
 803:../Generated_Code/tasks.c ****                                 lasted called.  In this case the only time we should ever
 804:../Generated_Code/tasks.c ****                                 actually delay is if the wake time has also     overflowed,
 805:../Generated_Code/tasks.c ****                                 and the wake time is greater than the tick time.  When this
 806:../Generated_Code/tasks.c ****                                 is the case it is as if neither time had overflowed. */
 807:../Generated_Code/tasks.c ****                                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConst
 647              		.loc 1 807 0
 648 0052 7B68     		ldr	r3, [r7, #4]
 649 0054 1A68     		ldr	r2, [r3]
 650 0056 FB68     		ldr	r3, [r7, #12]
 651 0058 9A42     		cmp	r2, r3
 652 005a 11D9     		bls	.L36
 653              		.loc 1 807 0 is_stmt 0
 654 005c FA68     		ldr	r2, [r7, #12]
 655 005e 3B69     		ldr	r3, [r7, #16]
 656 0060 9A42     		cmp	r2, r3
 657 0062 0DD9     		bls	.L36
 808:../Generated_Code/tasks.c ****                                 {
 809:../Generated_Code/tasks.c ****                                         xShouldDelay = pdTRUE;
 658              		.loc 1 809 0 is_stmt 1
 659 0064 0123     		mov	r3, #1
 660 0066 7B61     		str	r3, [r7, #20]
 661 0068 0AE0     		b	.L36
 662              	.L35:
 810:../Generated_Code/tasks.c ****                                 }
 811:../Generated_Code/tasks.c ****                                 else
 812:../Generated_Code/tasks.c ****                                 {
 813:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 814:../Generated_Code/tasks.c ****                                 }
 815:../Generated_Code/tasks.c ****                         }
 816:../Generated_Code/tasks.c ****                         else
 817:../Generated_Code/tasks.c ****                         {
 818:../Generated_Code/tasks.c ****                                 /* The tick time has not overflowed.  In this case we will
 819:../Generated_Code/tasks.c ****                                 delay if either the wake time has overflowed, and/or the
 820:../Generated_Code/tasks.c ****                                 tick time is less than the wake time. */
 821:../Generated_Code/tasks.c ****                                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConst
 663              		.loc 1 821 0
 664 006a 7B68     		ldr	r3, [r7, #4]
 665 006c 1A68     		ldr	r2, [r3]
 666 006e FB68     		ldr	r3, [r7, #12]
 667 0070 9A42     		cmp	r2, r3
 668 0072 03D8     		bhi	.L37
 669              		.loc 1 821 0 is_stmt 0
 670 0074 FA68     		ldr	r2, [r7, #12]
 671 0076 3B69     		ldr	r3, [r7, #16]
 672 0078 9A42     		cmp	r2, r3
 673 007a 01D9     		bls	.L36
 674              	.L37:
 822:../Generated_Code/tasks.c ****                                 {
 823:../Generated_Code/tasks.c ****                                         xShouldDelay = pdTRUE;
 675              		.loc 1 823 0 is_stmt 1
 676 007c 0123     		mov	r3, #1
 677 007e 7B61     		str	r3, [r7, #20]
 678              	.L36:
 824:../Generated_Code/tasks.c ****                                 }
 825:../Generated_Code/tasks.c ****                                 else
 826:../Generated_Code/tasks.c ****                                 {
 827:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 828:../Generated_Code/tasks.c ****                                 }
 829:../Generated_Code/tasks.c ****                         }
 830:../Generated_Code/tasks.c **** 
 831:../Generated_Code/tasks.c ****                         /* Update the wake time ready for the next call. */
 832:../Generated_Code/tasks.c ****                         *pxPreviousWakeTime = xTimeToWake;
 679              		.loc 1 832 0
 680 0080 7B68     		ldr	r3, [r7, #4]
 681 0082 FA68     		ldr	r2, [r7, #12]
 682 0084 1A60     		str	r2, [r3]
 833:../Generated_Code/tasks.c **** 
 834:../Generated_Code/tasks.c ****                         if( xShouldDelay != pdFALSE )
 683              		.loc 1 834 0
 684 0086 7B69     		ldr	r3, [r7, #20]
 685 0088 002B     		cmp	r3, #0
 686 008a 09D0     		beq	.L38
 835:../Generated_Code/tasks.c ****                         {
 836:../Generated_Code/tasks.c ****                                 traceTASK_DELAY_UNTIL();
 837:../Generated_Code/tasks.c **** 
 838:../Generated_Code/tasks.c ****                                 /* Remove the task from the ready list before adding it to the
 839:../Generated_Code/tasks.c ****                                 blocked list as the same list item is used for both lists. */
 840:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseT
 687              		.loc 1 840 0
 688 008c 0C4B     		ldr	r3, .L40+8
 689 008e 1B68     		ldr	r3, [r3]
 690 0090 0433     		add	r3, r3, #4
 691 0092 181C     		mov	r0, r3
 692 0094 FFF7FEFF 		bl	uxListRemove
 841:../Generated_Code/tasks.c ****                                 {
 842:../Generated_Code/tasks.c ****                                         /* The current task must be in a ready list, so there is
 843:../Generated_Code/tasks.c ****                                         no need to check, and the port reset macro can be called
 844:../Generated_Code/tasks.c ****                                         directly. */
 845:../Generated_Code/tasks.c ****                                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopRe
 846:../Generated_Code/tasks.c ****                                 }
 847:../Generated_Code/tasks.c ****                                 else
 848:../Generated_Code/tasks.c ****                                 {
 849:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 850:../Generated_Code/tasks.c ****                                 }
 851:../Generated_Code/tasks.c **** 
 852:../Generated_Code/tasks.c ****                                 prvAddCurrentTaskToDelayedList( xTimeToWake );
 693              		.loc 1 852 0
 694 0098 FB68     		ldr	r3, [r7, #12]
 695 009a 181C     		mov	r0, r3
 696 009c FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 697              	.L38:
 698              	.LBE7:
 853:../Generated_Code/tasks.c ****                         }
 854:../Generated_Code/tasks.c ****                         else
 855:../Generated_Code/tasks.c ****                         {
 856:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 857:../Generated_Code/tasks.c ****                         }
 858:../Generated_Code/tasks.c ****                 }
 859:../Generated_Code/tasks.c ****                 xAlreadyYielded = xTaskResumeAll();
 699              		.loc 1 859 0
 700 00a0 FFF7FEFF 		bl	xTaskResumeAll
 701 00a4 031C     		mov	r3, r0
 702 00a6 BB60     		str	r3, [r7, #8]
 860:../Generated_Code/tasks.c **** 
 861:../Generated_Code/tasks.c ****                 /* Force a reschedule if xTaskResumeAll has not already done so, we may
 862:../Generated_Code/tasks.c ****                 have put ourselves to sleep. */
 863:../Generated_Code/tasks.c ****                 if( xAlreadyYielded == pdFALSE )
 703              		.loc 1 863 0
 704 00a8 BB68     		ldr	r3, [r7, #8]
 705 00aa 002B     		cmp	r3, #0
 706 00ac 01D1     		bne	.L28
 864:../Generated_Code/tasks.c ****                 {
 865:../Generated_Code/tasks.c ****                         portYIELD_WITHIN_API();
 707              		.loc 1 865 0
 708 00ae FFF7FEFF 		bl	vPortYieldFromISR
 709              	.L28:
 710              	.LBE6:
 866:../Generated_Code/tasks.c ****                 }
 867:../Generated_Code/tasks.c ****                 else
 868:../Generated_Code/tasks.c ****                 {
 869:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 870:../Generated_Code/tasks.c ****                 }
 871:../Generated_Code/tasks.c ****         }
 711              		.loc 1 871 0
 712 00b2 BD46     		mov	sp, r7
 713 00b4 06B0     		add	sp, sp, #24
 714              		@ sp needed for prologue
 715 00b6 80BD     		pop	{r7, pc}
 716              	.L41:
 717              		.align	2
 718              	.L40:
 719 00b8 00000000 		.word	_ZL20uxSchedulerSuspended
 720 00bc 00000000 		.word	_ZL10xTickCount
 721 00c0 00000000 		.word	pxCurrentTCB
 722              		.cfi_endproc
 723              	.LFE11:
 725              		.section	.text.vTaskDelay,"ax",%progbits
 726              		.align	2
 727              		.global	vTaskDelay
 728              		.code	16
 729              		.thumb_func
 731              	vTaskDelay:
 732              	.LFB12:
 872:../Generated_Code/tasks.c **** 
 873:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 874:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 875:../Generated_Code/tasks.c **** 
 876:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 877:../Generated_Code/tasks.c **** 
 878:../Generated_Code/tasks.c ****         void vTaskDelay( const TickType_t xTicksToDelay )
 879:../Generated_Code/tasks.c ****         {
 733              		.loc 1 879 0
 734              		.cfi_startproc
 735 0000 80B5     		push	{r7, lr}
 736              	.LCFI9:
 737              		.cfi_def_cfa_offset 8
 738              		.cfi_offset 7, -8
 739              		.cfi_offset 14, -4
 740 0002 84B0     		sub	sp, sp, #16
 741              	.LCFI10:
 742              		.cfi_def_cfa_offset 24
 743 0004 00AF     		add	r7, sp, #0
 744              	.LCFI11:
 745              		.cfi_def_cfa_register 7
 746 0006 7860     		str	r0, [r7, #4]
 747              	.LBB8:
 880:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
 881:../Generated_Code/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
 748              		.loc 1 881 0
 749 0008 0023     		mov	r3, #0
 750 000a FB60     		str	r3, [r7, #12]
 882:../Generated_Code/tasks.c **** 
 883:../Generated_Code/tasks.c **** 
 884:../Generated_Code/tasks.c ****                 /* A delay time of zero just forces a reschedule. */
 885:../Generated_Code/tasks.c ****                 if( xTicksToDelay > ( TickType_t ) 0U )
 751              		.loc 1 885 0
 752 000c 7B68     		ldr	r3, [r7, #4]
 753 000e 002B     		cmp	r3, #0
 754 0010 1DD0     		beq	.L43
 886:../Generated_Code/tasks.c ****                 {
 887:../Generated_Code/tasks.c ****                         configASSERT( uxSchedulerSuspended == 0 );
 755              		.loc 1 887 0
 756 0012 134B     		ldr	r3, .L47
 757 0014 1B68     		ldr	r3, [r3]
 758 0016 5A1E     		sub	r2, r3, #1
 759 0018 9341     		sbc	r3, r3, r2
 760 001a DBB2     		uxtb	r3, r3
 761 001c 002B     		cmp	r3, #0
 762 001e 01D0     		beq	.L44
 763              		.loc 1 887 0 is_stmt 0
 764              	@ 887 "../Generated_Code/tasks.c" 1
 765 0020 72B6     		cpsid i
 766              	@ 0 "" 2
 767              		.code	16
 768              	.L45:
 769              		.loc 1 887 0
 770 0022 FEE7     		b	.L45
 771              	.L44:
 888:../Generated_Code/tasks.c ****                         vTaskSuspendAll();
 772              		.loc 1 888 0 is_stmt 1
 773 0024 FFF7FEFF 		bl	vTaskSuspendAll
 889:../Generated_Code/tasks.c ****                         {
 890:../Generated_Code/tasks.c ****                                 traceTASK_DELAY();
 891:../Generated_Code/tasks.c **** 
 892:../Generated_Code/tasks.c ****                                 /* A task that is removed from the event list while the
 893:../Generated_Code/tasks.c ****                                 scheduler is suspended will not get placed in the ready
 894:../Generated_Code/tasks.c ****                                 list or removed from the blocked list until the scheduler
 895:../Generated_Code/tasks.c ****                                 is resumed.
 896:../Generated_Code/tasks.c **** 
 897:../Generated_Code/tasks.c ****                                 This task cannot be in an event list as it is the currently
 898:../Generated_Code/tasks.c ****                                 executing task. */
 899:../Generated_Code/tasks.c **** 
 900:../Generated_Code/tasks.c ****                                 /* Calculate the time to wake - this may overflow but this is
 901:../Generated_Code/tasks.c ****                                 not a problem. */
 902:../Generated_Code/tasks.c ****                                 xTimeToWake = xTickCount + xTicksToDelay;
 774              		.loc 1 902 0
 775 0028 0E4B     		ldr	r3, .L47+4
 776 002a 1A68     		ldr	r2, [r3]
 777 002c 7B68     		ldr	r3, [r7, #4]
 778 002e D318     		add	r3, r2, r3
 779 0030 BB60     		str	r3, [r7, #8]
 903:../Generated_Code/tasks.c **** 
 904:../Generated_Code/tasks.c ****                                 /* We must remove ourselves from the ready list before adding
 905:../Generated_Code/tasks.c ****                                 ourselves to the blocked list as the same list item is used for
 906:../Generated_Code/tasks.c ****                                 both lists. */
 907:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseT
 780              		.loc 1 907 0
 781 0032 0D4B     		ldr	r3, .L47+8
 782 0034 1B68     		ldr	r3, [r3]
 783 0036 0433     		add	r3, r3, #4
 784 0038 181C     		mov	r0, r3
 785 003a FFF7FEFF 		bl	uxListRemove
 908:../Generated_Code/tasks.c ****                                 {
 909:../Generated_Code/tasks.c ****                                         /* The current task must be in a ready list, so there is
 910:../Generated_Code/tasks.c ****                                         no need to check, and the port reset macro can be called
 911:../Generated_Code/tasks.c ****                                         directly. */
 912:../Generated_Code/tasks.c ****                                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopRe
 913:../Generated_Code/tasks.c ****                                 }
 914:../Generated_Code/tasks.c ****                                 else
 915:../Generated_Code/tasks.c ****                                 {
 916:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 917:../Generated_Code/tasks.c ****                                 }
 918:../Generated_Code/tasks.c ****                                 prvAddCurrentTaskToDelayedList( xTimeToWake );
 786              		.loc 1 918 0
 787 003e BB68     		ldr	r3, [r7, #8]
 788 0040 181C     		mov	r0, r3
 789 0042 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 919:../Generated_Code/tasks.c ****                         }
 920:../Generated_Code/tasks.c ****                         xAlreadyYielded = xTaskResumeAll();
 790              		.loc 1 920 0
 791 0046 FFF7FEFF 		bl	xTaskResumeAll
 792 004a 031C     		mov	r3, r0
 793 004c FB60     		str	r3, [r7, #12]
 794              	.L43:
 921:../Generated_Code/tasks.c ****                 }
 922:../Generated_Code/tasks.c ****                 else
 923:../Generated_Code/tasks.c ****                 {
 924:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 925:../Generated_Code/tasks.c ****                 }
 926:../Generated_Code/tasks.c **** 
 927:../Generated_Code/tasks.c ****                 /* Force a reschedule if xTaskResumeAll has not already done so, we may
 928:../Generated_Code/tasks.c ****                 have put ourselves to sleep. */
 929:../Generated_Code/tasks.c ****                 if( xAlreadyYielded == pdFALSE )
 795              		.loc 1 929 0
 796 004e FB68     		ldr	r3, [r7, #12]
 797 0050 002B     		cmp	r3, #0
 798 0052 01D1     		bne	.L42
 930:../Generated_Code/tasks.c ****                 {
 931:../Generated_Code/tasks.c ****                         portYIELD_WITHIN_API();
 799              		.loc 1 931 0
 800 0054 FFF7FEFF 		bl	vPortYieldFromISR
 801              	.L42:
 802              	.LBE8:
 932:../Generated_Code/tasks.c ****                 }
 933:../Generated_Code/tasks.c ****                 else
 934:../Generated_Code/tasks.c ****                 {
 935:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 936:../Generated_Code/tasks.c ****                 }
 937:../Generated_Code/tasks.c ****         }
 803              		.loc 1 937 0
 804 0058 BD46     		mov	sp, r7
 805 005a 04B0     		add	sp, sp, #16
 806              		@ sp needed for prologue
 807 005c 80BD     		pop	{r7, pc}
 808              	.L48:
 809 005e C046     		.align	2
 810              	.L47:
 811 0060 00000000 		.word	_ZL20uxSchedulerSuspended
 812 0064 00000000 		.word	_ZL10xTickCount
 813 0068 00000000 		.word	pxCurrentTCB
 814              		.cfi_endproc
 815              	.LFE12:
 817              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 818              		.align	2
 819              		.global	uxTaskPriorityGet
 820              		.code	16
 821              		.thumb_func
 823              	uxTaskPriorityGet:
 824              	.LFB13:
 938:../Generated_Code/tasks.c **** 
 939:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 940:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 941:../Generated_Code/tasks.c **** 
 942:../Generated_Code/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 943:../Generated_Code/tasks.c **** 
 944:../Generated_Code/tasks.c ****         eTaskState eTaskGetState( TaskHandle_t xTask )
 945:../Generated_Code/tasks.c ****         {
 946:../Generated_Code/tasks.c ****         eTaskState eReturn;
 947:../Generated_Code/tasks.c ****         List_t *pxStateList;
 948:../Generated_Code/tasks.c ****         const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 949:../Generated_Code/tasks.c **** 
 950:../Generated_Code/tasks.c ****                 configASSERT( pxTCB );
 951:../Generated_Code/tasks.c **** 
 952:../Generated_Code/tasks.c ****                 if( pxTCB == pxCurrentTCB )
 953:../Generated_Code/tasks.c ****                 {
 954:../Generated_Code/tasks.c ****                         /* The task calling this function is querying its own state. */
 955:../Generated_Code/tasks.c ****                         eReturn = eRunning;
 956:../Generated_Code/tasks.c ****                 }
 957:../Generated_Code/tasks.c ****                 else
 958:../Generated_Code/tasks.c ****                 {
 959:../Generated_Code/tasks.c ****                         taskENTER_CRITICAL();
 960:../Generated_Code/tasks.c ****                         {
 961:../Generated_Code/tasks.c ****                                 pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGene
 962:../Generated_Code/tasks.c ****                         }
 963:../Generated_Code/tasks.c ****                         taskEXIT_CRITICAL();
 964:../Generated_Code/tasks.c **** 
 965:../Generated_Code/tasks.c ****                         if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDela
 966:../Generated_Code/tasks.c ****                         {
 967:../Generated_Code/tasks.c ****                                 /* The task being queried is referenced from one of the Blocked
 968:../Generated_Code/tasks.c ****                                 lists. */
 969:../Generated_Code/tasks.c ****                                 eReturn = eBlocked;
 970:../Generated_Code/tasks.c ****                         }
 971:../Generated_Code/tasks.c **** 
 972:../Generated_Code/tasks.c ****                         #if ( INCLUDE_vTaskSuspend == 1 )
 973:../Generated_Code/tasks.c ****                                 else if( pxStateList == &xSuspendedTaskList )
 974:../Generated_Code/tasks.c ****                                 {
 975:../Generated_Code/tasks.c ****                                         /* The task being queried is referenced from the suspended
 976:../Generated_Code/tasks.c ****                                         list.  Is it genuinely suspended or is it block
 977:../Generated_Code/tasks.c ****                                         indefinitely? */
 978:../Generated_Code/tasks.c ****                                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) =
 979:../Generated_Code/tasks.c ****                                         {
 980:../Generated_Code/tasks.c ****                                                 eReturn = eSuspended;
 981:../Generated_Code/tasks.c ****                                         }
 982:../Generated_Code/tasks.c ****                                         else
 983:../Generated_Code/tasks.c ****                                         {
 984:../Generated_Code/tasks.c ****                                                 eReturn = eBlocked;
 985:../Generated_Code/tasks.c ****                                         }
 986:../Generated_Code/tasks.c ****                                 }
 987:../Generated_Code/tasks.c ****                         #endif
 988:../Generated_Code/tasks.c **** 
 989:../Generated_Code/tasks.c ****                         #if ( INCLUDE_vTaskDelete == 1 )
 990:../Generated_Code/tasks.c ****                                 else if( pxStateList == &xTasksWaitingTermination )
 991:../Generated_Code/tasks.c ****                                 {
 992:../Generated_Code/tasks.c ****                                         /* The task being queried is referenced from the deleted
 993:../Generated_Code/tasks.c ****                                         tasks list. */
 994:../Generated_Code/tasks.c ****                                         eReturn = eDeleted;
 995:../Generated_Code/tasks.c ****                                 }
 996:../Generated_Code/tasks.c ****                         #endif
 997:../Generated_Code/tasks.c **** 
 998:../Generated_Code/tasks.c ****                         else
 999:../Generated_Code/tasks.c ****                         {
1000:../Generated_Code/tasks.c ****                                 /* If the task is not in any other state, it must be in the
1001:../Generated_Code/tasks.c ****                                 Ready (including pending ready) state. */
1002:../Generated_Code/tasks.c ****                                 eReturn = eReady;
1003:../Generated_Code/tasks.c ****                         }
1004:../Generated_Code/tasks.c ****                 }
1005:../Generated_Code/tasks.c **** 
1006:../Generated_Code/tasks.c ****                 return eReturn;
1007:../Generated_Code/tasks.c ****         }
1008:../Generated_Code/tasks.c **** 
1009:../Generated_Code/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1010:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1011:../Generated_Code/tasks.c **** 
1012:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1013:../Generated_Code/tasks.c **** 
1014:../Generated_Code/tasks.c ****         UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1015:../Generated_Code/tasks.c ****         {
 825              		.loc 1 1015 0
 826              		.cfi_startproc
 827 0000 80B5     		push	{r7, lr}
 828              	.LCFI12:
 829              		.cfi_def_cfa_offset 8
 830              		.cfi_offset 7, -8
 831              		.cfi_offset 14, -4
 832 0002 84B0     		sub	sp, sp, #16
 833              	.LCFI13:
 834              		.cfi_def_cfa_offset 24
 835 0004 00AF     		add	r7, sp, #0
 836              	.LCFI14:
 837              		.cfi_def_cfa_register 7
 838 0006 7860     		str	r0, [r7, #4]
 839              	.LBB9:
1016:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1017:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
1018:../Generated_Code/tasks.c **** 
1019:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 840              		.loc 1 1019 0
 841 0008 FFF7FEFF 		bl	vPortEnterCritical
1020:../Generated_Code/tasks.c ****                 {
1021:../Generated_Code/tasks.c ****                         /* If null is passed in here then we are changing the
1022:../Generated_Code/tasks.c ****                         priority of the calling function. */
1023:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTask );
 842              		.loc 1 1023 0
 843 000c 7B68     		ldr	r3, [r7, #4]
 844 000e 002B     		cmp	r3, #0
 845 0010 02D1     		bne	.L50
 846              		.loc 1 1023 0 is_stmt 0
 847 0012 074B     		ldr	r3, .L53
 848 0014 1B68     		ldr	r3, [r3]
 849 0016 00E0     		b	.L51
 850              	.L50:
 851              		.loc 1 1023 0
 852 0018 7B68     		ldr	r3, [r7, #4]
 853              	.L51:
 854              		.loc 1 1023 0
 855 001a FB60     		str	r3, [r7, #12]
1024:../Generated_Code/tasks.c ****                         uxReturn = pxTCB->uxPriority;
 856              		.loc 1 1024 0 is_stmt 1
 857 001c FB68     		ldr	r3, [r7, #12]
 858 001e DB6A     		ldr	r3, [r3, #44]
 859 0020 BB60     		str	r3, [r7, #8]
1025:../Generated_Code/tasks.c ****                 }
1026:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 860              		.loc 1 1026 0
 861 0022 FFF7FEFF 		bl	vPortExitCritical
1027:../Generated_Code/tasks.c **** 
1028:../Generated_Code/tasks.c ****                 return uxReturn;
 862              		.loc 1 1028 0
 863 0026 BB68     		ldr	r3, [r7, #8]
 864              	.LBE9:
1029:../Generated_Code/tasks.c ****         }
 865              		.loc 1 1029 0
 866 0028 181C     		mov	r0, r3
 867 002a BD46     		mov	sp, r7
 868 002c 04B0     		add	sp, sp, #16
 869              		@ sp needed for prologue
 870 002e 80BD     		pop	{r7, pc}
 871              	.L54:
 872              		.align	2
 873              	.L53:
 874 0030 00000000 		.word	pxCurrentTCB
 875              		.cfi_endproc
 876              	.LFE13:
 878              		.section	.text.vTaskPrioritySet,"ax",%progbits
 879              		.align	2
 880              		.global	vTaskPrioritySet
 881              		.code	16
 882              		.thumb_func
 884              	vTaskPrioritySet:
 885              	.LFB14:
1030:../Generated_Code/tasks.c **** 
1031:../Generated_Code/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1032:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1033:../Generated_Code/tasks.c **** 
1034:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1035:../Generated_Code/tasks.c **** 
1036:../Generated_Code/tasks.c ****         void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1037:../Generated_Code/tasks.c ****         {
 886              		.loc 1 1037 0
 887              		.cfi_startproc
 888 0000 80B5     		push	{r7, lr}
 889              	.LCFI15:
 890              		.cfi_def_cfa_offset 8
 891              		.cfi_offset 7, -8
 892              		.cfi_offset 14, -4
 893 0002 86B0     		sub	sp, sp, #24
 894              	.LCFI16:
 895              		.cfi_def_cfa_offset 32
 896 0004 00AF     		add	r7, sp, #0
 897              	.LCFI17:
 898              		.cfi_def_cfa_register 7
 899 0006 7860     		str	r0, [r7, #4]
 900 0008 3960     		str	r1, [r7]
 901              	.LBB10:
1038:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1039:../Generated_Code/tasks.c ****         UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1040:../Generated_Code/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 902              		.loc 1 1040 0
 903 000a 0023     		mov	r3, #0
 904 000c 7B61     		str	r3, [r7, #20]
1041:../Generated_Code/tasks.c **** 
1042:../Generated_Code/tasks.c ****                 configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 905              		.loc 1 1042 0
 906 000e 3B68     		ldr	r3, [r7]
 907 0010 052B     		cmp	r3, #5
 908 0012 01D9     		bls	.L56
 909              		.loc 1 1042 0 is_stmt 0
 910              	@ 1042 "../Generated_Code/tasks.c" 1
 911 0014 72B6     		cpsid i
 912              	@ 0 "" 2
 913              		.code	16
 914              	.L57:
 915              		.loc 1 1042 0
 916 0016 FEE7     		b	.L57
 917              	.L56:
1043:../Generated_Code/tasks.c **** 
1044:../Generated_Code/tasks.c ****                 /* Ensure the new priority is valid. */
1045:../Generated_Code/tasks.c ****                 if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 918              		.loc 1 1045 0 is_stmt 1
 919 0018 3B68     		ldr	r3, [r7]
 920 001a 052B     		cmp	r3, #5
 921 001c 01D9     		bls	.L58
1046:../Generated_Code/tasks.c ****                 {
1047:../Generated_Code/tasks.c ****                         uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 922              		.loc 1 1047 0
 923 001e 0523     		mov	r3, #5
 924 0020 3B60     		str	r3, [r7]
 925              	.L58:
1048:../Generated_Code/tasks.c ****                 }
1049:../Generated_Code/tasks.c ****                 else
1050:../Generated_Code/tasks.c ****                 {
1051:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1052:../Generated_Code/tasks.c ****                 }
1053:../Generated_Code/tasks.c **** 
1054:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 926              		.loc 1 1054 0
 927 0022 FFF7FEFF 		bl	vPortEnterCritical
1055:../Generated_Code/tasks.c ****                 {
1056:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the priority of the calling
1057:../Generated_Code/tasks.c ****                         task that is being changed. */
1058:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTask );
 928              		.loc 1 1058 0
 929 0026 7B68     		ldr	r3, [r7, #4]
 930 0028 002B     		cmp	r3, #0
 931 002a 02D1     		bne	.L59
 932              		.loc 1 1058 0 is_stmt 0
 933 002c 424B     		ldr	r3, .L70
 934 002e 1B68     		ldr	r3, [r3]
 935 0030 00E0     		b	.L60
 936              	.L59:
 937              		.loc 1 1058 0
 938 0032 7B68     		ldr	r3, [r7, #4]
 939              	.L60:
 940              		.loc 1 1058 0
 941 0034 3B61     		str	r3, [r7, #16]
1059:../Generated_Code/tasks.c **** 
1060:../Generated_Code/tasks.c ****                         traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1061:../Generated_Code/tasks.c **** 
1062:../Generated_Code/tasks.c ****                         #if ( configUSE_MUTEXES == 1 )
1063:../Generated_Code/tasks.c ****                         {
1064:../Generated_Code/tasks.c ****                                 uxCurrentBasePriority = pxTCB->uxBasePriority;
 942              		.loc 1 1064 0 is_stmt 1
 943 0036 3B69     		ldr	r3, [r7, #16]
 944 0038 1B6D     		ldr	r3, [r3, #80]
 945 003a FB60     		str	r3, [r7, #12]
1065:../Generated_Code/tasks.c ****                         }
1066:../Generated_Code/tasks.c ****                         #else
1067:../Generated_Code/tasks.c ****                         {
1068:../Generated_Code/tasks.c ****                                 uxCurrentBasePriority = pxTCB->uxPriority;
1069:../Generated_Code/tasks.c ****                         }
1070:../Generated_Code/tasks.c ****                         #endif
1071:../Generated_Code/tasks.c **** 
1072:../Generated_Code/tasks.c ****                         if( uxCurrentBasePriority != uxNewPriority )
 946              		.loc 1 1072 0
 947 003c FA68     		ldr	r2, [r7, #12]
 948 003e 3B68     		ldr	r3, [r7]
 949 0040 9A42     		cmp	r2, r3
 950 0042 00D1     		bne	.LCB693
 951 0044 72E0     		b	.L61	@long jump
 952              	.LCB693:
1073:../Generated_Code/tasks.c ****                         {
1074:../Generated_Code/tasks.c ****                                 /* The priority change may have readied a task of higher
1075:../Generated_Code/tasks.c ****                                 priority than the calling task. */
1076:../Generated_Code/tasks.c ****                                 if( uxNewPriority > uxCurrentBasePriority )
 953              		.loc 1 1076 0
 954 0046 3A68     		ldr	r2, [r7]
 955 0048 FB68     		ldr	r3, [r7, #12]
 956 004a 9A42     		cmp	r2, r3
 957 004c 15D9     		bls	.L62
1077:../Generated_Code/tasks.c ****                                 {
1078:../Generated_Code/tasks.c ****                                         if( pxTCB != pxCurrentTCB )
 958              		.loc 1 1078 0
 959 004e 3A4B     		ldr	r3, .L70
 960 0050 1B68     		ldr	r3, [r3]
 961 0052 3A69     		ldr	r2, [r7, #16]
 962 0054 D31A     		sub	r3, r2, r3
 963 0056 5A1E     		sub	r2, r3, #1
 964 0058 9341     		sbc	r3, r3, r2
 965 005a DBB2     		uxtb	r3, r3
 966 005c 002B     		cmp	r3, #0
 967 005e 17D0     		beq	.L63
1079:../Generated_Code/tasks.c ****                                         {
1080:../Generated_Code/tasks.c ****                                                 /* The priority of a task other than the currently
1081:../Generated_Code/tasks.c ****                                                 running task is being raised.  Is the priority bein
1082:../Generated_Code/tasks.c ****                                                 raised above that of the running task? */
1083:../Generated_Code/tasks.c ****                                                 if( uxNewPriority >= pxCurrentTCB->uxPriority )
 968              		.loc 1 1083 0
 969 0060 354B     		ldr	r3, .L70
 970 0062 1B68     		ldr	r3, [r3]
 971 0064 DA6A     		ldr	r2, [r3, #44]
 972 0066 3968     		ldr	r1, [r7]
 973 0068 0023     		mov	r3, #0
 974 006a 9142     		cmp	r1, r2
 975 006c 5B41     		adc	r3, r3, r3
 976 006e DBB2     		uxtb	r3, r3
 977 0070 002B     		cmp	r3, #0
 978 0072 0DD0     		beq	.L63
1084:../Generated_Code/tasks.c ****                                                 {
1085:../Generated_Code/tasks.c ****                                                         xYieldRequired = pdTRUE;
 979              		.loc 1 1085 0
 980 0074 0123     		mov	r3, #1
 981 0076 7B61     		str	r3, [r7, #20]
 982 0078 0AE0     		b	.L63
 983              	.L62:
1086:../Generated_Code/tasks.c ****                                                 }
1087:../Generated_Code/tasks.c ****                                                 else
1088:../Generated_Code/tasks.c ****                                                 {
1089:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1090:../Generated_Code/tasks.c ****                                                 }
1091:../Generated_Code/tasks.c ****                                         }
1092:../Generated_Code/tasks.c ****                                         else
1093:../Generated_Code/tasks.c ****                                         {
1094:../Generated_Code/tasks.c ****                                                 /* The priority of the running task is being raised
1095:../Generated_Code/tasks.c ****                                                 but the running task must already be the highest
1096:../Generated_Code/tasks.c ****                                                 priority task able to run so no yield is required. 
1097:../Generated_Code/tasks.c ****                                         }
1098:../Generated_Code/tasks.c ****                                 }
1099:../Generated_Code/tasks.c ****                                 else if( pxTCB == pxCurrentTCB )
 984              		.loc 1 1099 0
 985 007a 2F4B     		ldr	r3, .L70
 986 007c 1B68     		ldr	r3, [r3]
 987 007e 3A69     		ldr	r2, [r7, #16]
 988 0080 D31A     		sub	r3, r2, r3
 989 0082 5A42     		neg	r2, r3
 990 0084 5341     		adc	r3, r3, r2
 991 0086 DBB2     		uxtb	r3, r3
 992 0088 002B     		cmp	r3, #0
 993 008a 01D0     		beq	.L63
1100:../Generated_Code/tasks.c ****                                 {
1101:../Generated_Code/tasks.c ****                                         /* Setting the priority of the running task down means
1102:../Generated_Code/tasks.c ****                                         there may now be another task of higher priority that
1103:../Generated_Code/tasks.c ****                                         is ready to execute. */
1104:../Generated_Code/tasks.c ****                                         xYieldRequired = pdTRUE;
 994              		.loc 1 1104 0
 995 008c 0123     		mov	r3, #1
 996 008e 7B61     		str	r3, [r7, #20]
 997              	.L63:
1105:../Generated_Code/tasks.c ****                                 }
1106:../Generated_Code/tasks.c ****                                 else
1107:../Generated_Code/tasks.c ****                                 {
1108:../Generated_Code/tasks.c ****                                         /* Setting the priority of any other task down does not
1109:../Generated_Code/tasks.c ****                                         require a yield as the running task must be above the
1110:../Generated_Code/tasks.c ****                                         new priority of the task being modified. */
1111:../Generated_Code/tasks.c ****                                 }
1112:../Generated_Code/tasks.c **** 
1113:../Generated_Code/tasks.c ****                                 /* Remember the ready list the task might be referenced from
1114:../Generated_Code/tasks.c ****                                 before its uxPriority member is changed so the
1115:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY() macro can function correctly. */
1116:../Generated_Code/tasks.c ****                                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
 998              		.loc 1 1116 0
 999 0090 3B69     		ldr	r3, [r7, #16]
 1000 0092 DB6A     		ldr	r3, [r3, #44]
 1001 0094 BB60     		str	r3, [r7, #8]
1117:../Generated_Code/tasks.c **** 
1118:../Generated_Code/tasks.c ****                                 #if ( configUSE_MUTEXES == 1 )
1119:../Generated_Code/tasks.c ****                                 {
1120:../Generated_Code/tasks.c ****                                         /* Only change the priority being used if the task is not
1121:../Generated_Code/tasks.c ****                                         currently using an inherited priority. */
1122:../Generated_Code/tasks.c ****                                         if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1002              		.loc 1 1122 0
 1003 0096 3B69     		ldr	r3, [r7, #16]
 1004 0098 1A6D     		ldr	r2, [r3, #80]
 1005 009a 3B69     		ldr	r3, [r7, #16]
 1006 009c DB6A     		ldr	r3, [r3, #44]
 1007 009e 9A42     		cmp	r2, r3
 1008 00a0 02D1     		bne	.L64
1123:../Generated_Code/tasks.c ****                                         {
1124:../Generated_Code/tasks.c ****                                                 pxTCB->uxPriority = uxNewPriority;
 1009              		.loc 1 1124 0
 1010 00a2 3B69     		ldr	r3, [r7, #16]
 1011 00a4 3A68     		ldr	r2, [r7]
 1012 00a6 DA62     		str	r2, [r3, #44]
 1013              	.L64:
1125:../Generated_Code/tasks.c ****                                         }
1126:../Generated_Code/tasks.c ****                                         else
1127:../Generated_Code/tasks.c ****                                         {
1128:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1129:../Generated_Code/tasks.c ****                                         }
1130:../Generated_Code/tasks.c **** 
1131:../Generated_Code/tasks.c ****                                         /* The base priority gets set whatever. */
1132:../Generated_Code/tasks.c ****                                         pxTCB->uxBasePriority = uxNewPriority;
 1014              		.loc 1 1132 0
 1015 00a8 3B69     		ldr	r3, [r7, #16]
 1016 00aa 3A68     		ldr	r2, [r7]
 1017 00ac 1A65     		str	r2, [r3, #80]
1133:../Generated_Code/tasks.c ****                                 }
1134:../Generated_Code/tasks.c ****                                 #else
1135:../Generated_Code/tasks.c ****                                 {
1136:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = uxNewPriority;
1137:../Generated_Code/tasks.c ****                                 }
1138:../Generated_Code/tasks.c ****                                 #endif
1139:../Generated_Code/tasks.c **** 
1140:../Generated_Code/tasks.c ****                                 /* Only reset the event list item value if the value is not
1141:../Generated_Code/tasks.c ****                                 being used for anything else. */
1142:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 1018              		.loc 1 1142 0
 1019 00ae 3B69     		ldr	r3, [r7, #16]
 1020 00b0 9B69     		ldr	r3, [r3, #24]
 1021 00b2 002B     		cmp	r3, #0
 1022 00b4 04DB     		blt	.L65
1143:../Generated_Code/tasks.c ****                                 {
1144:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( Ti
 1023              		.loc 1 1144 0
 1024 00b6 3B68     		ldr	r3, [r7]
 1025 00b8 0622     		mov	r2, #6
 1026 00ba D21A     		sub	r2, r2, r3
 1027 00bc 3B69     		ldr	r3, [r7, #16]
 1028 00be 9A61     		str	r2, [r3, #24]
 1029              	.L65:
1145:../Generated_Code/tasks.c ****                                 }
1146:../Generated_Code/tasks.c ****                                 else
1147:../Generated_Code/tasks.c ****                                 {
1148:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1149:../Generated_Code/tasks.c ****                                 }
1150:../Generated_Code/tasks.c **** 
1151:../Generated_Code/tasks.c ****                                 /* If the task is in the blocked or suspended list we need do
1152:../Generated_Code/tasks.c ****                                 nothing more than change it's priority variable. However, if
1153:../Generated_Code/tasks.c ****                                 the task is in a ready list it needs to be removed and placed
1154:../Generated_Code/tasks.c ****                                 in the list appropriate to its new priority. */
1155:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOn
 1030              		.loc 1 1155 0
 1031 00c0 3B69     		ldr	r3, [r7, #16]
 1032 00c2 5969     		ldr	r1, [r3, #20]
 1033 00c4 BA68     		ldr	r2, [r7, #8]
 1034 00c6 131C     		mov	r3, r2
 1035 00c8 9B00     		lsl	r3, r3, #2
 1036 00ca 9B18     		add	r3, r3, r2
 1037 00cc 9B00     		lsl	r3, r3, #2
 1038 00ce 1B4A     		ldr	r2, .L70+4
 1039 00d0 9B18     		add	r3, r3, r2
 1040 00d2 9942     		cmp	r1, r3
 1041 00d4 01D1     		bne	.L66
 1042              		.loc 1 1155 0 is_stmt 0
 1043 00d6 0123     		mov	r3, #1
 1044 00d8 00E0     		b	.L67
 1045              	.L66:
 1046              		.loc 1 1155 0
 1047 00da 0023     		mov	r3, #0
 1048              	.L67:
 1049              		.loc 1 1155 0
 1050 00dc 002B     		cmp	r3, #0
 1051 00de 20D0     		beq	.L68
1156:../Generated_Code/tasks.c ****                                 {
1157:../Generated_Code/tasks.c ****                                         /* The task is currently in its ready list - remove before 
1158:../Generated_Code/tasks.c ****                                         it to it's new ready list.  As we are in a critical section
1159:../Generated_Code/tasks.c ****                                         can do this even if the scheduler is suspended. */
1160:../Generated_Code/tasks.c ****                                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBase
 1052              		.loc 1 1160 0 is_stmt 1
 1053 00e0 3B69     		ldr	r3, [r7, #16]
 1054 00e2 0433     		add	r3, r3, #4
 1055 00e4 181C     		mov	r0, r3
 1056 00e6 FFF7FEFF 		bl	uxListRemove
1161:../Generated_Code/tasks.c ****                                         {
1162:../Generated_Code/tasks.c ****                                                 /* It is known that the task is in its ready list s
1163:../Generated_Code/tasks.c ****                                                 there is no need to check again and the port level
1164:../Generated_Code/tasks.c ****                                                 reset macro can be called directly. */
1165:../Generated_Code/tasks.c ****                                                 portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, ux
1166:../Generated_Code/tasks.c ****                                         }
1167:../Generated_Code/tasks.c ****                                         else
1168:../Generated_Code/tasks.c ****                                         {
1169:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1170:../Generated_Code/tasks.c ****                                         }
1171:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1057              		.loc 1 1171 0
 1058 00ea 3B69     		ldr	r3, [r7, #16]
 1059 00ec DA6A     		ldr	r2, [r3, #44]
 1060 00ee 144B     		ldr	r3, .L70+8
 1061 00f0 1B68     		ldr	r3, [r3]
 1062 00f2 9342     		cmp	r3, r2
 1063 00f4 9B41     		sbc	r3, r3, r3
 1064 00f6 5B42     		neg	r3, r3
 1065 00f8 DBB2     		uxtb	r3, r3
 1066 00fa 002B     		cmp	r3, #0
 1067 00fc 03D0     		beq	.L69
 1068              		.loc 1 1171 0 is_stmt 0
 1069 00fe 3B69     		ldr	r3, [r7, #16]
 1070 0100 DA6A     		ldr	r2, [r3, #44]
 1071 0102 0F4B     		ldr	r3, .L70+8
 1072 0104 1A60     		str	r2, [r3]
 1073              	.L69:
 1074              		.loc 1 1171 0
 1075 0106 3B69     		ldr	r3, [r7, #16]
 1076 0108 DA6A     		ldr	r2, [r3, #44]
 1077 010a 131C     		mov	r3, r2
 1078 010c 9B00     		lsl	r3, r3, #2
 1079 010e 9B18     		add	r3, r3, r2
 1080 0110 9B00     		lsl	r3, r3, #2
 1081 0112 0A4A     		ldr	r2, .L70+4
 1082 0114 9A18     		add	r2, r3, r2
 1083 0116 3B69     		ldr	r3, [r7, #16]
 1084 0118 0433     		add	r3, r3, #4
 1085 011a 101C     		mov	r0, r2
 1086 011c 191C     		mov	r1, r3
 1087 011e FFF7FEFF 		bl	vListInsertEnd
 1088              	.L68:
1172:../Generated_Code/tasks.c ****                                 }
1173:../Generated_Code/tasks.c ****                                 else
1174:../Generated_Code/tasks.c ****                                 {
1175:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1176:../Generated_Code/tasks.c ****                                 }
1177:../Generated_Code/tasks.c **** 
1178:../Generated_Code/tasks.c ****                                 if( xYieldRequired == pdTRUE )
 1089              		.loc 1 1178 0 is_stmt 1
 1090 0122 7B69     		ldr	r3, [r7, #20]
 1091 0124 012B     		cmp	r3, #1
 1092 0126 01D1     		bne	.L61
1179:../Generated_Code/tasks.c ****                                 {
1180:../Generated_Code/tasks.c ****                                         taskYIELD_IF_USING_PREEMPTION();
 1093              		.loc 1 1180 0
 1094 0128 FFF7FEFF 		bl	vPortYieldFromISR
 1095              	.L61:
1181:../Generated_Code/tasks.c ****                                 }
1182:../Generated_Code/tasks.c ****                                 else
1183:../Generated_Code/tasks.c ****                                 {
1184:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1185:../Generated_Code/tasks.c ****                                 }
1186:../Generated_Code/tasks.c **** 
1187:../Generated_Code/tasks.c ****                                 /* Remove compiler warning about unused variables when the port
1188:../Generated_Code/tasks.c ****                                 optimised task selection is not being used. */
1189:../Generated_Code/tasks.c ****                                 ( void ) uxPriorityUsedOnEntry;
1190:../Generated_Code/tasks.c ****                         }
1191:../Generated_Code/tasks.c ****                 }
1192:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 1096              		.loc 1 1192 0
 1097 012c FFF7FEFF 		bl	vPortExitCritical
 1098              	.LBE10:
1193:../Generated_Code/tasks.c ****         }
 1099              		.loc 1 1193 0
 1100 0130 BD46     		mov	sp, r7
 1101 0132 06B0     		add	sp, sp, #24
 1102              		@ sp needed for prologue
 1103 0134 80BD     		pop	{r7, pc}
 1104              	.L71:
 1105 0136 C046     		.align	2
 1106              	.L70:
 1107 0138 00000000 		.word	pxCurrentTCB
 1108 013c 00000000 		.word	_ZL17pxReadyTasksLists
 1109 0140 00000000 		.word	_ZL18uxTopReadyPriority
 1110              		.cfi_endproc
 1111              	.LFE14:
 1113              		.section	.text.vTaskSuspend,"ax",%progbits
 1114              		.align	2
 1115              		.global	vTaskSuspend
 1116              		.code	16
 1117              		.thumb_func
 1119              	vTaskSuspend:
 1120              	.LFB15:
1194:../Generated_Code/tasks.c **** 
1195:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1196:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1197:../Generated_Code/tasks.c **** 
1198:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1199:../Generated_Code/tasks.c **** 
1200:../Generated_Code/tasks.c ****         void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1201:../Generated_Code/tasks.c ****         {
 1121              		.loc 1 1201 0
 1122              		.cfi_startproc
 1123 0000 80B5     		push	{r7, lr}
 1124              	.LCFI18:
 1125              		.cfi_def_cfa_offset 8
 1126              		.cfi_offset 7, -8
 1127              		.cfi_offset 14, -4
 1128 0002 84B0     		sub	sp, sp, #16
 1129              	.LCFI19:
 1130              		.cfi_def_cfa_offset 24
 1131 0004 00AF     		add	r7, sp, #0
 1132              	.LCFI20:
 1133              		.cfi_def_cfa_register 7
 1134 0006 7860     		str	r0, [r7, #4]
 1135              	.LBB11:
1202:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1203:../Generated_Code/tasks.c **** 
1204:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 1136              		.loc 1 1204 0
 1137 0008 FFF7FEFF 		bl	vPortEnterCritical
1205:../Generated_Code/tasks.c ****                 {
1206:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the running task that is
1207:../Generated_Code/tasks.c ****                         being suspended. */
1208:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1138              		.loc 1 1208 0
 1139 000c 7B68     		ldr	r3, [r7, #4]
 1140 000e 002B     		cmp	r3, #0
 1141 0010 02D1     		bne	.L73
 1142              		.loc 1 1208 0 is_stmt 0
 1143 0012 2A4B     		ldr	r3, .L82
 1144 0014 1B68     		ldr	r3, [r3]
 1145 0016 00E0     		b	.L74
 1146              	.L73:
 1147              		.loc 1 1208 0
 1148 0018 7B68     		ldr	r3, [r7, #4]
 1149              	.L74:
 1150              		.loc 1 1208 0
 1151 001a FB60     		str	r3, [r7, #12]
1209:../Generated_Code/tasks.c **** 
1210:../Generated_Code/tasks.c ****                         traceTASK_SUSPEND( pxTCB );
1211:../Generated_Code/tasks.c **** 
1212:../Generated_Code/tasks.c ****                         /* Remove task from the ready/delayed list and place in the
1213:../Generated_Code/tasks.c ****                         suspended list. */
1214:../Generated_Code/tasks.c ****                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1152              		.loc 1 1214 0 is_stmt 1
 1153 001c FB68     		ldr	r3, [r7, #12]
 1154 001e 0433     		add	r3, r3, #4
 1155 0020 181C     		mov	r0, r3
 1156 0022 FFF7FEFF 		bl	uxListRemove
1215:../Generated_Code/tasks.c ****                         {
1216:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1217:../Generated_Code/tasks.c ****                         }
1218:../Generated_Code/tasks.c ****                         else
1219:../Generated_Code/tasks.c ****                         {
1220:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1221:../Generated_Code/tasks.c ****                         }
1222:../Generated_Code/tasks.c **** 
1223:../Generated_Code/tasks.c ****                         /* Is the task waiting on an event also? */
1224:../Generated_Code/tasks.c ****                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1157              		.loc 1 1224 0
 1158 0026 FB68     		ldr	r3, [r7, #12]
 1159 0028 9B6A     		ldr	r3, [r3, #40]
 1160 002a 002B     		cmp	r3, #0
 1161 002c 04D0     		beq	.L75
1225:../Generated_Code/tasks.c ****                         {
1226:../Generated_Code/tasks.c ****                                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1162              		.loc 1 1226 0
 1163 002e FB68     		ldr	r3, [r7, #12]
 1164 0030 1833     		add	r3, r3, #24
 1165 0032 181C     		mov	r0, r3
 1166 0034 FFF7FEFF 		bl	uxListRemove
 1167              	.L75:
1227:../Generated_Code/tasks.c ****                         }
1228:../Generated_Code/tasks.c ****                         else
1229:../Generated_Code/tasks.c ****                         {
1230:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1231:../Generated_Code/tasks.c ****                         }
1232:../Generated_Code/tasks.c **** 
1233:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1168              		.loc 1 1233 0
 1169 0038 FB68     		ldr	r3, [r7, #12]
 1170 003a 0433     		add	r3, r3, #4
 1171 003c 204A     		ldr	r2, .L82+4
 1172 003e 101C     		mov	r0, r2
 1173 0040 191C     		mov	r1, r3
 1174 0042 FFF7FEFF 		bl	vListInsertEnd
1234:../Generated_Code/tasks.c ****                 }
1235:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 1175              		.loc 1 1235 0
 1176 0046 FFF7FEFF 		bl	vPortExitCritical
1236:../Generated_Code/tasks.c **** 
1237:../Generated_Code/tasks.c ****                 if( pxTCB == pxCurrentTCB )
 1177              		.loc 1 1237 0
 1178 004a 1C4B     		ldr	r3, .L82
 1179 004c 1B68     		ldr	r3, [r3]
 1180 004e FA68     		ldr	r2, [r7, #12]
 1181 0050 D31A     		sub	r3, r2, r3
 1182 0052 5A42     		neg	r2, r3
 1183 0054 5341     		adc	r3, r3, r2
 1184 0056 DBB2     		uxtb	r3, r3
 1185 0058 002B     		cmp	r3, #0
 1186 005a 23D0     		beq	.L76
1238:../Generated_Code/tasks.c ****                 {
1239:../Generated_Code/tasks.c ****                         if( xSchedulerRunning != pdFALSE )
 1187              		.loc 1 1239 0
 1188 005c 194B     		ldr	r3, .L82+8
 1189 005e 1B68     		ldr	r3, [r3]
 1190 0060 5A1E     		sub	r2, r3, #1
 1191 0062 9341     		sbc	r3, r3, r2
 1192 0064 DBB2     		uxtb	r3, r3
 1193 0066 002B     		cmp	r3, #0
 1194 0068 0BD0     		beq	.L77
1240:../Generated_Code/tasks.c ****                         {
1241:../Generated_Code/tasks.c ****                                 /* The current task has just been suspended. */
1242:../Generated_Code/tasks.c ****                                 configASSERT( uxSchedulerSuspended == 0 );
 1195              		.loc 1 1242 0
 1196 006a 174B     		ldr	r3, .L82+12
 1197 006c 1B68     		ldr	r3, [r3]
 1198 006e 5A1E     		sub	r2, r3, #1
 1199 0070 9341     		sbc	r3, r3, r2
 1200 0072 DBB2     		uxtb	r3, r3
 1201 0074 002B     		cmp	r3, #0
 1202 0076 01D0     		beq	.L78
 1203              		.loc 1 1242 0 is_stmt 0
 1204              	@ 1242 "../Generated_Code/tasks.c" 1
 1205 0078 72B6     		cpsid i
 1206              	@ 0 "" 2
 1207              		.code	16
 1208              	.L79:
 1209              		.loc 1 1242 0
 1210 007a FEE7     		b	.L79
 1211              	.L78:
1243:../Generated_Code/tasks.c ****                                 portYIELD_WITHIN_API();
 1212              		.loc 1 1243 0 is_stmt 1
 1213 007c FFF7FEFF 		bl	vPortYieldFromISR
 1214 0080 19E0     		b	.L72
 1215              	.L77:
1244:../Generated_Code/tasks.c ****                         }
1245:../Generated_Code/tasks.c ****                         else
1246:../Generated_Code/tasks.c ****                         {
1247:../Generated_Code/tasks.c ****                                 /* The scheduler is not running, but the task that was pointed
1248:../Generated_Code/tasks.c ****                                 to by pxCurrentTCB has just been suspended and pxCurrentTCB
1249:../Generated_Code/tasks.c ****                                 must be adjusted to point to a different task. */
1250:../Generated_Code/tasks.c ****                                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumb
 1216              		.loc 1 1250 0
 1217 0082 0F4B     		ldr	r3, .L82+4
 1218 0084 1A68     		ldr	r2, [r3]
 1219 0086 114B     		ldr	r3, .L82+16
 1220 0088 1B68     		ldr	r3, [r3]
 1221 008a D31A     		sub	r3, r2, r3
 1222 008c 5A42     		neg	r2, r3
 1223 008e 5341     		adc	r3, r3, r2
 1224 0090 DBB2     		uxtb	r3, r3
 1225 0092 002B     		cmp	r3, #0
 1226 0094 03D0     		beq	.L81
1251:../Generated_Code/tasks.c ****                                 {
1252:../Generated_Code/tasks.c ****                                         /* No other tasks are ready, so set pxCurrentTCB back to
1253:../Generated_Code/tasks.c ****                                         NULL so when the next task is created pxCurrentTCB will
1254:../Generated_Code/tasks.c ****                                         be set to point to it no matter what its relative priority
1255:../Generated_Code/tasks.c ****                                         is. */
1256:../Generated_Code/tasks.c ****                                         pxCurrentTCB = NULL;
 1227              		.loc 1 1256 0
 1228 0096 094B     		ldr	r3, .L82
 1229 0098 0022     		mov	r2, #0
 1230 009a 1A60     		str	r2, [r3]
 1231 009c 0BE0     		b	.L72
 1232              	.L81:
1257:../Generated_Code/tasks.c ****                                 }
1258:../Generated_Code/tasks.c ****                                 else
1259:../Generated_Code/tasks.c ****                                 {
1260:../Generated_Code/tasks.c ****                                         vTaskSwitchContext();
 1233              		.loc 1 1260 0
 1234 009e FFF7FEFF 		bl	vTaskSwitchContext
 1235 00a2 08E0     		b	.L72
 1236              	.L76:
1261:../Generated_Code/tasks.c ****                                 }
1262:../Generated_Code/tasks.c ****                         }
1263:../Generated_Code/tasks.c ****                 }
1264:../Generated_Code/tasks.c ****                 else
1265:../Generated_Code/tasks.c ****                 {
1266:../Generated_Code/tasks.c ****                         if( xSchedulerRunning != pdFALSE )
 1237              		.loc 1 1266 0
 1238 00a4 074B     		ldr	r3, .L82+8
 1239 00a6 1B68     		ldr	r3, [r3]
 1240 00a8 5A1E     		sub	r2, r3, #1
 1241 00aa 9341     		sbc	r3, r3, r2
 1242 00ac DBB2     		uxtb	r3, r3
 1243 00ae 002B     		cmp	r3, #0
 1244 00b0 01D0     		beq	.L72
1267:../Generated_Code/tasks.c ****                         {
1268:../Generated_Code/tasks.c ****                                 /* A task other than the currently running task was suspended,
1269:../Generated_Code/tasks.c ****                                 reset the next expected unblock time in case it referred to the
1270:../Generated_Code/tasks.c ****                                 task that is now in the Suspended state. */
1271:../Generated_Code/tasks.c ****                                 prvResetNextTaskUnblockTime();
 1245              		.loc 1 1271 0
 1246 00b2 FFF7FEFF 		bl	_ZL27prvResetNextTaskUnblockTimev
 1247              	.L72:
 1248              	.LBE11:
1272:../Generated_Code/tasks.c ****                         }
1273:../Generated_Code/tasks.c ****                         else
1274:../Generated_Code/tasks.c ****                         {
1275:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1276:../Generated_Code/tasks.c ****                         }
1277:../Generated_Code/tasks.c ****                 }
1278:../Generated_Code/tasks.c ****         }
 1249              		.loc 1 1278 0
 1250 00b6 BD46     		mov	sp, r7
 1251 00b8 04B0     		add	sp, sp, #16
 1252              		@ sp needed for prologue
 1253 00ba 80BD     		pop	{r7, pc}
 1254              	.L83:
 1255              		.align	2
 1256              	.L82:
 1257 00bc 00000000 		.word	pxCurrentTCB
 1258 00c0 00000000 		.word	_ZL18xSuspendedTaskList
 1259 00c4 00000000 		.word	_ZL17xSchedulerRunning
 1260 00c8 00000000 		.word	_ZL20uxSchedulerSuspended
 1261 00cc 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 1262              		.cfi_endproc
 1263              	.LFE15:
 1265              		.section	.text._ZL22prvTaskIsTaskSuspendedPv,"ax",%progbits
 1266              		.align	2
 1267              		.code	16
 1268              		.thumb_func
 1270              	_ZL22prvTaskIsTaskSuspendedPv:
 1271              	.LFB16:
1279:../Generated_Code/tasks.c **** 
1280:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1281:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1282:../Generated_Code/tasks.c **** 
1283:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1284:../Generated_Code/tasks.c **** 
1285:../Generated_Code/tasks.c ****         static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1286:../Generated_Code/tasks.c ****         {
 1272              		.loc 1 1286 0
 1273              		.cfi_startproc
 1274 0000 80B5     		push	{r7, lr}
 1275              	.LCFI21:
 1276              		.cfi_def_cfa_offset 8
 1277              		.cfi_offset 7, -8
 1278              		.cfi_offset 14, -4
 1279 0002 84B0     		sub	sp, sp, #16
 1280              	.LCFI22:
 1281              		.cfi_def_cfa_offset 24
 1282 0004 00AF     		add	r7, sp, #0
 1283              	.LCFI23:
 1284              		.cfi_def_cfa_register 7
 1285 0006 7860     		str	r0, [r7, #4]
 1286              	.LBB12:
1287:../Generated_Code/tasks.c ****         BaseType_t xReturn = pdFALSE;
 1287              		.loc 1 1287 0
 1288 0008 0023     		mov	r3, #0
 1289 000a FB60     		str	r3, [r7, #12]
1288:../Generated_Code/tasks.c ****         const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1290              		.loc 1 1288 0
 1291 000c 7B68     		ldr	r3, [r7, #4]
 1292 000e BB60     		str	r3, [r7, #8]
1289:../Generated_Code/tasks.c **** 
1290:../Generated_Code/tasks.c ****                 /* Accesses xPendingReadyList so must be called from a critical
1291:../Generated_Code/tasks.c ****                 section. */
1292:../Generated_Code/tasks.c **** 
1293:../Generated_Code/tasks.c ****                 /* It does not make sense to check if the calling task is suspended. */
1294:../Generated_Code/tasks.c ****                 configASSERT( xTask );
 1293              		.loc 1 1294 0
 1294 0010 7B68     		ldr	r3, [r7, #4]
 1295 0012 002B     		cmp	r3, #0
 1296 0014 01D1     		bne	.L85
 1297              		.loc 1 1294 0 is_stmt 0
 1298              	@ 1294 "../Generated_Code/tasks.c" 1
 1299 0016 72B6     		cpsid i
 1300              	@ 0 "" 2
 1301              		.code	16
 1302              	.L86:
 1303              		.loc 1 1294 0
 1304 0018 FEE7     		b	.L86
 1305              	.L85:
1295:../Generated_Code/tasks.c **** 
1296:../Generated_Code/tasks.c ****                 /* Is the task being resumed actually in the suspended list? */
1297:../Generated_Code/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) !=
 1306              		.loc 1 1297 0 is_stmt 1
 1307 001a BB68     		ldr	r3, [r7, #8]
 1308 001c 5A69     		ldr	r2, [r3, #20]
 1309 001e 0E4B     		ldr	r3, .L93
 1310 0020 9A42     		cmp	r2, r3
 1311 0022 01D1     		bne	.L87
 1312              		.loc 1 1297 0 is_stmt 0
 1313 0024 0123     		mov	r3, #1
 1314 0026 00E0     		b	.L88
 1315              	.L87:
 1316              		.loc 1 1297 0
 1317 0028 0023     		mov	r3, #0
 1318              	.L88:
 1319              		.loc 1 1297 0
 1320 002a 002B     		cmp	r3, #0
 1321 002c 0FD0     		beq	.L89
1298:../Generated_Code/tasks.c ****                 {
1299:../Generated_Code/tasks.c ****                         /* Has the task already been resumed from within an ISR? */
1300:../Generated_Code/tasks.c ****                         if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem )
 1322              		.loc 1 1300 0 is_stmt 1
 1323 002e BB68     		ldr	r3, [r7, #8]
 1324 0030 9A6A     		ldr	r2, [r3, #40]
 1325 0032 0A4B     		ldr	r3, .L93+4
 1326 0034 9A42     		cmp	r2, r3
 1327 0036 0AD0     		beq	.L89
1301:../Generated_Code/tasks.c ****                         {
1302:../Generated_Code/tasks.c ****                                 /* Is it in the suspended list because it is in the     Suspended
1303:../Generated_Code/tasks.c ****                                 state, or because is is blocked with no timeout? */
1304:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != 
 1328              		.loc 1 1304 0
 1329 0038 BB68     		ldr	r3, [r7, #8]
 1330 003a 9B6A     		ldr	r3, [r3, #40]
 1331 003c 002B     		cmp	r3, #0
 1332 003e 01D1     		bne	.L90
 1333              		.loc 1 1304 0 is_stmt 0
 1334 0040 0123     		mov	r3, #1
 1335 0042 00E0     		b	.L91
 1336              	.L90:
 1337              		.loc 1 1304 0
 1338 0044 0023     		mov	r3, #0
 1339              	.L91:
 1340              		.loc 1 1304 0
 1341 0046 002B     		cmp	r3, #0
 1342 0048 01D0     		beq	.L89
1305:../Generated_Code/tasks.c ****                                 {
1306:../Generated_Code/tasks.c ****                                         xReturn = pdTRUE;
 1343              		.loc 1 1306 0 is_stmt 1
 1344 004a 0123     		mov	r3, #1
 1345 004c FB60     		str	r3, [r7, #12]
 1346              	.L89:
1307:../Generated_Code/tasks.c ****                                 }
1308:../Generated_Code/tasks.c ****                                 else
1309:../Generated_Code/tasks.c ****                                 {
1310:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1311:../Generated_Code/tasks.c ****                                 }
1312:../Generated_Code/tasks.c ****                         }
1313:../Generated_Code/tasks.c ****                         else
1314:../Generated_Code/tasks.c ****                         {
1315:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1316:../Generated_Code/tasks.c ****                         }
1317:../Generated_Code/tasks.c ****                 }
1318:../Generated_Code/tasks.c ****                 else
1319:../Generated_Code/tasks.c ****                 {
1320:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1321:../Generated_Code/tasks.c ****                 }
1322:../Generated_Code/tasks.c **** 
1323:../Generated_Code/tasks.c ****                 return xReturn;
 1347              		.loc 1 1323 0
 1348 004e FB68     		ldr	r3, [r7, #12]
 1349              	.LBE12:
1324:../Generated_Code/tasks.c ****         } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1350              		.loc 1 1324 0
 1351 0050 181C     		mov	r0, r3
 1352 0052 BD46     		mov	sp, r7
 1353 0054 04B0     		add	sp, sp, #16
 1354              		@ sp needed for prologue
 1355 0056 80BD     		pop	{r7, pc}
 1356              	.L94:
 1357              		.align	2
 1358              	.L93:
 1359 0058 00000000 		.word	_ZL18xSuspendedTaskList
 1360 005c 00000000 		.word	_ZL17xPendingReadyList
 1361              		.cfi_endproc
 1362              	.LFE16:
 1364              		.section	.text.vTaskResume,"ax",%progbits
 1365              		.align	2
 1366              		.global	vTaskResume
 1367              		.code	16
 1368              		.thumb_func
 1370              	vTaskResume:
 1371              	.LFB17:
1325:../Generated_Code/tasks.c **** 
1326:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1327:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1328:../Generated_Code/tasks.c **** 
1329:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1330:../Generated_Code/tasks.c **** 
1331:../Generated_Code/tasks.c ****         void vTaskResume( TaskHandle_t xTaskToResume )
1332:../Generated_Code/tasks.c ****         {
 1372              		.loc 1 1332 0
 1373              		.cfi_startproc
 1374 0000 80B5     		push	{r7, lr}
 1375              	.LCFI24:
 1376              		.cfi_def_cfa_offset 8
 1377              		.cfi_offset 7, -8
 1378              		.cfi_offset 14, -4
 1379 0002 84B0     		sub	sp, sp, #16
 1380              	.LCFI25:
 1381              		.cfi_def_cfa_offset 24
 1382 0004 00AF     		add	r7, sp, #0
 1383              	.LCFI26:
 1384              		.cfi_def_cfa_register 7
 1385 0006 7860     		str	r0, [r7, #4]
 1386              	.LBB13:
1333:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1387              		.loc 1 1333 0
 1388 0008 7B68     		ldr	r3, [r7, #4]
 1389 000a FB60     		str	r3, [r7, #12]
1334:../Generated_Code/tasks.c **** 
1335:../Generated_Code/tasks.c ****                 /* It does not make sense to resume the calling task. */
1336:../Generated_Code/tasks.c ****                 configASSERT( xTaskToResume );
 1390              		.loc 1 1336 0
 1391 000c 7B68     		ldr	r3, [r7, #4]
 1392 000e 002B     		cmp	r3, #0
 1393 0010 01D1     		bne	.L96
 1394              		.loc 1 1336 0 is_stmt 0
 1395              	@ 1336 "../Generated_Code/tasks.c" 1
 1396 0012 72B6     		cpsid i
 1397              	@ 0 "" 2
 1398              		.code	16
 1399              	.L97:
 1400              		.loc 1 1336 0
 1401 0014 FEE7     		b	.L97
 1402              	.L96:
1337:../Generated_Code/tasks.c **** 
1338:../Generated_Code/tasks.c ****                 /* The parameter cannot be NULL as it is impossible to resume the
1339:../Generated_Code/tasks.c ****                 currently executing task. */
1340:../Generated_Code/tasks.c ****                 if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1403              		.loc 1 1340 0 is_stmt 1
 1404 0016 FB68     		ldr	r3, [r7, #12]
 1405 0018 002B     		cmp	r3, #0
 1406 001a 06D0     		beq	.L98
 1407              		.loc 1 1340 0 is_stmt 0
 1408 001c 244B     		ldr	r3, .L103
 1409 001e 1B68     		ldr	r3, [r3]
 1410 0020 FA68     		ldr	r2, [r7, #12]
 1411 0022 9A42     		cmp	r2, r3
 1412 0024 01D0     		beq	.L98
 1413              		.loc 1 1340 0
 1414 0026 0123     		mov	r3, #1
 1415 0028 00E0     		b	.L99
 1416              	.L98:
 1417              		.loc 1 1340 0
 1418 002a 0023     		mov	r3, #0
 1419              	.L99:
 1420              		.loc 1 1340 0
 1421 002c 002B     		cmp	r3, #0
 1422 002e 3CD0     		beq	.L95
1341:../Generated_Code/tasks.c ****                 {
1342:../Generated_Code/tasks.c ****                         taskENTER_CRITICAL();
 1423              		.loc 1 1342 0 is_stmt 1
 1424 0030 FFF7FEFF 		bl	vPortEnterCritical
1343:../Generated_Code/tasks.c ****                         {
1344:../Generated_Code/tasks.c ****                                 if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1425              		.loc 1 1344 0
 1426 0034 FB68     		ldr	r3, [r7, #12]
 1427 0036 181C     		mov	r0, r3
 1428 0038 FFF7FEFF 		bl	_ZL22prvTaskIsTaskSuspendedPv
 1429 003c 031C     		mov	r3, r0
 1430 003e 013B     		sub	r3, r3, #1
 1431 0040 5A42     		neg	r2, r3
 1432 0042 5341     		adc	r3, r3, r2
 1433 0044 DBB2     		uxtb	r3, r3
 1434 0046 002B     		cmp	r3, #0
 1435 0048 2DD0     		beq	.L101
1345:../Generated_Code/tasks.c ****                                 {
1346:../Generated_Code/tasks.c ****                                         traceTASK_RESUME( pxTCB );
1347:../Generated_Code/tasks.c **** 
1348:../Generated_Code/tasks.c ****                                         /* As we are in a critical section we can access the ready
1349:../Generated_Code/tasks.c ****                                         lists even if the scheduler is suspended. */
1350:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1436              		.loc 1 1350 0
 1437 004a FB68     		ldr	r3, [r7, #12]
 1438 004c 0433     		add	r3, r3, #4
 1439 004e 181C     		mov	r0, r3
 1440 0050 FFF7FEFF 		bl	uxListRemove
1351:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1441              		.loc 1 1351 0
 1442 0054 FB68     		ldr	r3, [r7, #12]
 1443 0056 DA6A     		ldr	r2, [r3, #44]
 1444 0058 164B     		ldr	r3, .L103+4
 1445 005a 1B68     		ldr	r3, [r3]
 1446 005c 9342     		cmp	r3, r2
 1447 005e 9B41     		sbc	r3, r3, r3
 1448 0060 5B42     		neg	r3, r3
 1449 0062 DBB2     		uxtb	r3, r3
 1450 0064 002B     		cmp	r3, #0
 1451 0066 03D0     		beq	.L102
 1452              		.loc 1 1351 0 is_stmt 0
 1453 0068 FB68     		ldr	r3, [r7, #12]
 1454 006a DA6A     		ldr	r2, [r3, #44]
 1455 006c 114B     		ldr	r3, .L103+4
 1456 006e 1A60     		str	r2, [r3]
 1457              	.L102:
 1458              		.loc 1 1351 0
 1459 0070 FB68     		ldr	r3, [r7, #12]
 1460 0072 DA6A     		ldr	r2, [r3, #44]
 1461 0074 131C     		mov	r3, r2
 1462 0076 9B00     		lsl	r3, r3, #2
 1463 0078 9B18     		add	r3, r3, r2
 1464 007a 9B00     		lsl	r3, r3, #2
 1465 007c 0E4A     		ldr	r2, .L103+8
 1466 007e 9A18     		add	r2, r3, r2
 1467 0080 FB68     		ldr	r3, [r7, #12]
 1468 0082 0433     		add	r3, r3, #4
 1469 0084 101C     		mov	r0, r2
 1470 0086 191C     		mov	r1, r3
 1471 0088 FFF7FEFF 		bl	vListInsertEnd
1352:../Generated_Code/tasks.c **** 
1353:../Generated_Code/tasks.c ****                                         /* We may have just resumed a higher priority task. */
1354:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1472              		.loc 1 1354 0 is_stmt 1
 1473 008c FB68     		ldr	r3, [r7, #12]
 1474 008e D96A     		ldr	r1, [r3, #44]
 1475 0090 074B     		ldr	r3, .L103
 1476 0092 1B68     		ldr	r3, [r3]
 1477 0094 DA6A     		ldr	r2, [r3, #44]
 1478 0096 0023     		mov	r3, #0
 1479 0098 9142     		cmp	r1, r2
 1480 009a 5B41     		adc	r3, r3, r3
 1481 009c DBB2     		uxtb	r3, r3
 1482 009e 002B     		cmp	r3, #0
 1483 00a0 01D0     		beq	.L101
1355:../Generated_Code/tasks.c ****                                         {
1356:../Generated_Code/tasks.c ****                                                 /* This yield may not cause the task just resumed t
1357:../Generated_Code/tasks.c ****                                                 but will leave the lists in the correct state for t
1358:../Generated_Code/tasks.c ****                                                 next yield. */
1359:../Generated_Code/tasks.c ****                                                 taskYIELD_IF_USING_PREEMPTION();
 1484              		.loc 1 1359 0
 1485 00a2 FFF7FEFF 		bl	vPortYieldFromISR
 1486              	.L101:
1360:../Generated_Code/tasks.c ****                                         }
1361:../Generated_Code/tasks.c ****                                         else
1362:../Generated_Code/tasks.c ****                                         {
1363:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1364:../Generated_Code/tasks.c ****                                         }
1365:../Generated_Code/tasks.c ****                                 }
1366:../Generated_Code/tasks.c ****                                 else
1367:../Generated_Code/tasks.c ****                                 {
1368:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1369:../Generated_Code/tasks.c ****                                 }
1370:../Generated_Code/tasks.c ****                         }
1371:../Generated_Code/tasks.c ****                         taskEXIT_CRITICAL();
 1487              		.loc 1 1371 0
 1488 00a6 FFF7FEFF 		bl	vPortExitCritical
 1489              	.L95:
 1490              	.LBE13:
1372:../Generated_Code/tasks.c ****                 }
1373:../Generated_Code/tasks.c ****                 else
1374:../Generated_Code/tasks.c ****                 {
1375:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1376:../Generated_Code/tasks.c ****                 }
1377:../Generated_Code/tasks.c ****         }
 1491              		.loc 1 1377 0
 1492 00aa BD46     		mov	sp, r7
 1493 00ac 04B0     		add	sp, sp, #16
 1494              		@ sp needed for prologue
 1495 00ae 80BD     		pop	{r7, pc}
 1496              	.L104:
 1497              		.align	2
 1498              	.L103:
 1499 00b0 00000000 		.word	pxCurrentTCB
 1500 00b4 00000000 		.word	_ZL18uxTopReadyPriority
 1501 00b8 00000000 		.word	_ZL17pxReadyTasksLists
 1502              		.cfi_endproc
 1503              	.LFE17:
 1505              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1506              		.align	2
 1507              		.global	xTaskResumeFromISR
 1508              		.code	16
 1509              		.thumb_func
 1511              	xTaskResumeFromISR:
 1512              	.LFB18:
1378:../Generated_Code/tasks.c **** 
1379:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1380:../Generated_Code/tasks.c **** 
1381:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1382:../Generated_Code/tasks.c **** 
1383:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1384:../Generated_Code/tasks.c **** 
1385:../Generated_Code/tasks.c ****         BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1386:../Generated_Code/tasks.c ****         {
 1513              		.loc 1 1386 0
 1514              		.cfi_startproc
 1515 0000 80B5     		push	{r7, lr}
 1516              	.LCFI27:
 1517              		.cfi_def_cfa_offset 8
 1518              		.cfi_offset 7, -8
 1519              		.cfi_offset 14, -4
 1520 0002 86B0     		sub	sp, sp, #24
 1521              	.LCFI28:
 1522              		.cfi_def_cfa_offset 32
 1523 0004 00AF     		add	r7, sp, #0
 1524              	.LCFI29:
 1525              		.cfi_def_cfa_register 7
 1526 0006 7860     		str	r0, [r7, #4]
 1527              	.LBB14:
1387:../Generated_Code/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 1528              		.loc 1 1387 0
 1529 0008 0023     		mov	r3, #0
 1530 000a 7B61     		str	r3, [r7, #20]
1388:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1531              		.loc 1 1388 0
 1532 000c 7B68     		ldr	r3, [r7, #4]
 1533 000e 3B61     		str	r3, [r7, #16]
1389:../Generated_Code/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
1390:../Generated_Code/tasks.c **** 
1391:../Generated_Code/tasks.c ****                 configASSERT( xTaskToResume );
 1534              		.loc 1 1391 0
 1535 0010 7B68     		ldr	r3, [r7, #4]
 1536 0012 002B     		cmp	r3, #0
 1537 0014 01D1     		bne	.L106
 1538              		.loc 1 1391 0 is_stmt 0
 1539              	@ 1391 "../Generated_Code/tasks.c" 1
 1540 0016 72B6     		cpsid i
 1541              	@ 0 "" 2
 1542              		.code	16
 1543              	.L107:
 1544              		.loc 1 1391 0
 1545 0018 FEE7     		b	.L107
 1546              	.L106:
1392:../Generated_Code/tasks.c **** 
1393:../Generated_Code/tasks.c ****                 /* RTOS ports that support interrupt nesting have the concept of a
1394:../Generated_Code/tasks.c ****                 maximum system call (or maximum API call) interrupt priority.
1395:../Generated_Code/tasks.c ****                 Interrupts that are     above the maximum system call priority are keep
1396:../Generated_Code/tasks.c ****                 permanently enabled, even when the RTOS kernel is in a critical section,
1397:../Generated_Code/tasks.c ****                 but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1398:../Generated_Code/tasks.c ****                 is defined in FreeRTOSConfig.h then
1399:../Generated_Code/tasks.c ****                 portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1400:../Generated_Code/tasks.c ****                 failure if a FreeRTOS API function is called from an interrupt that has
1401:../Generated_Code/tasks.c ****                 been assigned a priority above the configured maximum system call
1402:../Generated_Code/tasks.c ****                 priority.  Only FreeRTOS functions that end in FromISR can be called
1403:../Generated_Code/tasks.c ****                 from interrupts that have been assigned a priority at or (logically)
1404:../Generated_Code/tasks.c ****                 below the maximum system call interrupt priority.  FreeRTOS maintains a
1405:../Generated_Code/tasks.c ****                 separate interrupt safe API to ensure interrupt entry is as fast and as
1406:../Generated_Code/tasks.c ****                 simple as possible.  More information (albeit Cortex-M specific) is
1407:../Generated_Code/tasks.c ****                 provided on the following link:
1408:../Generated_Code/tasks.c ****                 http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1409:../Generated_Code/tasks.c ****                 portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1410:../Generated_Code/tasks.c **** 
1411:../Generated_Code/tasks.c ****                 uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1547              		.loc 1 1411 0 is_stmt 1
 1548 001a 0023     		mov	r3, #0
 1549 001c FB60     		str	r3, [r7, #12]
 1550              	@ 1411 "../Generated_Code/tasks.c" 1
 1551 001e 72B6     		cpsid i
 1552              	@ 0 "" 2
1412:../Generated_Code/tasks.c ****                 {
1413:../Generated_Code/tasks.c ****                         if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1553              		.loc 1 1413 0
 1554              		.code	16
 1555 0020 3B69     		ldr	r3, [r7, #16]
 1556 0022 181C     		mov	r0, r3
 1557 0024 FFF7FEFF 		bl	_ZL22prvTaskIsTaskSuspendedPv
 1558 0028 031C     		mov	r3, r0
 1559 002a 013B     		sub	r3, r3, #1
 1560 002c 5A42     		neg	r2, r3
 1561 002e 5341     		adc	r3, r3, r2
 1562 0030 DBB2     		uxtb	r3, r3
 1563 0032 002B     		cmp	r3, #0
 1564 0034 3CD0     		beq	.L108
1414:../Generated_Code/tasks.c ****                         {
1415:../Generated_Code/tasks.c ****                                 traceTASK_RESUME_FROM_ISR( pxTCB );
1416:../Generated_Code/tasks.c **** 
1417:../Generated_Code/tasks.c ****                                 /* Check the ready lists can be accessed. */
1418:../Generated_Code/tasks.c ****                                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1565              		.loc 1 1418 0
 1566 0036 214B     		ldr	r3, .L113
 1567 0038 1B68     		ldr	r3, [r3]
 1568 003a 5A42     		neg	r2, r3
 1569 003c 5341     		adc	r3, r3, r2
 1570 003e DBB2     		uxtb	r3, r3
 1571 0040 002B     		cmp	r3, #0
 1572 0042 2ED0     		beq	.L109
1419:../Generated_Code/tasks.c ****                                 {
1420:../Generated_Code/tasks.c ****                                         /* Ready lists can be accessed so move the task from the
1421:../Generated_Code/tasks.c ****                                         suspended list to the ready list directly. */
1422:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1573              		.loc 1 1422 0
 1574 0044 3B69     		ldr	r3, [r7, #16]
 1575 0046 D96A     		ldr	r1, [r3, #44]
 1576 0048 1D4B     		ldr	r3, .L113+4
 1577 004a 1B68     		ldr	r3, [r3]
 1578 004c DA6A     		ldr	r2, [r3, #44]
 1579 004e 0023     		mov	r3, #0
 1580 0050 9142     		cmp	r1, r2
 1581 0052 5B41     		adc	r3, r3, r3
 1582 0054 DBB2     		uxtb	r3, r3
 1583 0056 002B     		cmp	r3, #0
 1584 0058 01D0     		beq	.L110
1423:../Generated_Code/tasks.c ****                                         {
1424:../Generated_Code/tasks.c ****                                                 xYieldRequired = pdTRUE;
 1585              		.loc 1 1424 0
 1586 005a 0123     		mov	r3, #1
 1587 005c 7B61     		str	r3, [r7, #20]
 1588              	.L110:
1425:../Generated_Code/tasks.c ****                                         }
1426:../Generated_Code/tasks.c ****                                         else
1427:../Generated_Code/tasks.c ****                                         {
1428:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1429:../Generated_Code/tasks.c ****                                         }
1430:../Generated_Code/tasks.c **** 
1431:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1589              		.loc 1 1431 0
 1590 005e 3B69     		ldr	r3, [r7, #16]
 1591 0060 0433     		add	r3, r3, #4
 1592 0062 181C     		mov	r0, r3
 1593 0064 FFF7FEFF 		bl	uxListRemove
1432:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1594              		.loc 1 1432 0
 1595 0068 3B69     		ldr	r3, [r7, #16]
 1596 006a DA6A     		ldr	r2, [r3, #44]
 1597 006c 154B     		ldr	r3, .L113+8
 1598 006e 1B68     		ldr	r3, [r3]
 1599 0070 9342     		cmp	r3, r2
 1600 0072 9B41     		sbc	r3, r3, r3
 1601 0074 5B42     		neg	r3, r3
 1602 0076 DBB2     		uxtb	r3, r3
 1603 0078 002B     		cmp	r3, #0
 1604 007a 03D0     		beq	.L111
 1605              		.loc 1 1432 0 is_stmt 0
 1606 007c 3B69     		ldr	r3, [r7, #16]
 1607 007e DA6A     		ldr	r2, [r3, #44]
 1608 0080 104B     		ldr	r3, .L113+8
 1609 0082 1A60     		str	r2, [r3]
 1610              	.L111:
 1611              		.loc 1 1432 0
 1612 0084 3B69     		ldr	r3, [r7, #16]
 1613 0086 DA6A     		ldr	r2, [r3, #44]
 1614 0088 131C     		mov	r3, r2
 1615 008a 9B00     		lsl	r3, r3, #2
 1616 008c 9B18     		add	r3, r3, r2
 1617 008e 9B00     		lsl	r3, r3, #2
 1618 0090 0D4A     		ldr	r2, .L113+12
 1619 0092 9A18     		add	r2, r3, r2
 1620 0094 3B69     		ldr	r3, [r7, #16]
 1621 0096 0433     		add	r3, r3, #4
 1622 0098 101C     		mov	r0, r2
 1623 009a 191C     		mov	r1, r3
 1624 009c FFF7FEFF 		bl	vListInsertEnd
 1625 00a0 06E0     		b	.L108
 1626              	.L109:
1433:../Generated_Code/tasks.c ****                                 }
1434:../Generated_Code/tasks.c ****                                 else
1435:../Generated_Code/tasks.c ****                                 {
1436:../Generated_Code/tasks.c ****                                         /* The delayed or ready lists cannot be accessed so the tas
1437:../Generated_Code/tasks.c ****                                         is held in the pending ready list until the scheduler is
1438:../Generated_Code/tasks.c ****                                         unsuspended. */
1439:../Generated_Code/tasks.c ****                                         vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventLis
 1627              		.loc 1 1439 0 is_stmt 1
 1628 00a2 3B69     		ldr	r3, [r7, #16]
 1629 00a4 1833     		add	r3, r3, #24
 1630 00a6 094A     		ldr	r2, .L113+16
 1631 00a8 101C     		mov	r0, r2
 1632 00aa 191C     		mov	r1, r3
 1633 00ac FFF7FEFF 		bl	vListInsertEnd
 1634              	.L108:
1440:../Generated_Code/tasks.c ****                                 }
1441:../Generated_Code/tasks.c ****                         }
1442:../Generated_Code/tasks.c ****                         else
1443:../Generated_Code/tasks.c ****                         {
1444:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1445:../Generated_Code/tasks.c ****                         }
1446:../Generated_Code/tasks.c ****                 }
1447:../Generated_Code/tasks.c ****                 portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1635              		.loc 1 1447 0
 1636              	@ 1447 "../Generated_Code/tasks.c" 1
 1637 00b0 62B6     		cpsie i
 1638              	@ 0 "" 2
1448:../Generated_Code/tasks.c **** 
1449:../Generated_Code/tasks.c ****                 return xYieldRequired;
 1639              		.loc 1 1449 0
 1640              		.code	16
 1641 00b2 7B69     		ldr	r3, [r7, #20]
 1642              	.LBE14:
1450:../Generated_Code/tasks.c ****         }
 1643              		.loc 1 1450 0
 1644 00b4 181C     		mov	r0, r3
 1645 00b6 BD46     		mov	sp, r7
 1646 00b8 06B0     		add	sp, sp, #24
 1647              		@ sp needed for prologue
 1648 00ba 80BD     		pop	{r7, pc}
 1649              	.L114:
 1650              		.align	2
 1651              	.L113:
 1652 00bc 00000000 		.word	_ZL20uxSchedulerSuspended
 1653 00c0 00000000 		.word	pxCurrentTCB
 1654 00c4 00000000 		.word	_ZL18uxTopReadyPriority
 1655 00c8 00000000 		.word	_ZL17pxReadyTasksLists
 1656 00cc 00000000 		.word	_ZL17xPendingReadyList
 1657              		.cfi_endproc
 1658              	.LFE18:
 1660              		.section	.rodata
 1661              		.align	2
 1662              	.LC38:
 1663 0000 49444C45 		.ascii	"IDLE\000"
 1663      00
 1664 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1665              		.align	2
 1666              		.global	vTaskStartScheduler
 1667              		.code	16
 1668              		.thumb_func
 1670              	vTaskStartScheduler:
 1671              	.LFB19:
1451:../Generated_Code/tasks.c **** 
1452:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1453:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1454:../Generated_Code/tasks.c **** 
1455:../Generated_Code/tasks.c **** void vTaskStartScheduler( void )
1456:../Generated_Code/tasks.c **** {
 1672              		.loc 1 1456 0
 1673              		.cfi_startproc
 1674 0000 80B5     		push	{r7, lr}
 1675              	.LCFI30:
 1676              		.cfi_def_cfa_offset 8
 1677              		.cfi_offset 7, -8
 1678              		.cfi_offset 14, -4
 1679 0002 86B0     		sub	sp, sp, #24
 1680              	.LCFI31:
 1681              		.cfi_def_cfa_offset 32
 1682 0004 04AF     		add	r7, sp, #16
 1683              	.LCFI32:
 1684              		.cfi_def_cfa 7, 16
 1685              	.LBB15:
1457:../Generated_Code/tasks.c **** BaseType_t xReturn;
1458:../Generated_Code/tasks.c **** 
1459:../Generated_Code/tasks.c ****         /* Add the idle task at the lowest priority. */
1460:../Generated_Code/tasks.c ****         #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1461:../Generated_Code/tasks.c ****         {
1462:../Generated_Code/tasks.c ****                 /* Create the idle task, storing its handle in xIdleTaskHandle so it can
1463:../Generated_Code/tasks.c ****                 be returned by the xTaskGetIdleTaskHandle() function. */
1464:../Generated_Code/tasks.c ****                 xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( 
1465:../Generated_Code/tasks.c ****         }
1466:../Generated_Code/tasks.c ****         #else
1467:../Generated_Code/tasks.c ****         {
1468:../Generated_Code/tasks.c ****                 /* Create the idle task without storing its handle. */
1469:../Generated_Code/tasks.c ****                 xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( 
 1686              		.loc 1 1469 0
 1687 0006 134A     		ldr	r2, .L119
 1688 0008 134B     		ldr	r3, .L119+4
 1689 000a 0021     		mov	r1, #0
 1690 000c 0091     		str	r1, [sp]
 1691 000e 0021     		mov	r1, #0
 1692 0010 0191     		str	r1, [sp, #4]
 1693 0012 0021     		mov	r1, #0
 1694 0014 0291     		str	r1, [sp, #8]
 1695 0016 0021     		mov	r1, #0
 1696 0018 0391     		str	r1, [sp, #12]
 1697 001a 101C     		mov	r0, r2
 1698 001c 191C     		mov	r1, r3
 1699 001e C822     		mov	r2, #200
 1700 0020 0023     		mov	r3, #0
 1701 0022 FFF7FEFF 		bl	xTaskGenericCreate
 1702 0026 031C     		mov	r3, r0
 1703 0028 7B60     		str	r3, [r7, #4]
1470:../Generated_Code/tasks.c ****         }
1471:../Generated_Code/tasks.c ****         #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1472:../Generated_Code/tasks.c **** 
1473:../Generated_Code/tasks.c ****         #if ( configUSE_TIMERS == 1 )
1474:../Generated_Code/tasks.c ****         {
1475:../Generated_Code/tasks.c ****                 if( xReturn == pdPASS )
1476:../Generated_Code/tasks.c ****                 {
1477:../Generated_Code/tasks.c ****                         xReturn = xTimerCreateTimerTask();
1478:../Generated_Code/tasks.c ****                 }
1479:../Generated_Code/tasks.c ****                 else
1480:../Generated_Code/tasks.c ****                 {
1481:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1482:../Generated_Code/tasks.c ****                 }
1483:../Generated_Code/tasks.c ****         }
1484:../Generated_Code/tasks.c ****         #endif /* configUSE_TIMERS */
1485:../Generated_Code/tasks.c **** 
1486:../Generated_Code/tasks.c ****         if( xReturn == pdPASS )
 1704              		.loc 1 1486 0
 1705 002a 7B68     		ldr	r3, [r7, #4]
 1706 002c 012B     		cmp	r3, #1
 1707 002e 09D1     		bne	.L116
1487:../Generated_Code/tasks.c ****         {
1488:../Generated_Code/tasks.c ****                 /* Interrupts are turned off here, to ensure a tick does not occur
1489:../Generated_Code/tasks.c ****                 before or during the call to xPortStartScheduler().  The stacks of
1490:../Generated_Code/tasks.c ****                 the created tasks contain a status word with interrupts switched on
1491:../Generated_Code/tasks.c ****                 so interrupts will automatically get re-enabled when the first task
1492:../Generated_Code/tasks.c ****                 starts to run. */
1493:../Generated_Code/tasks.c ****                 portDISABLE_INTERRUPTS();
 1708              		.loc 1 1493 0
 1709              	@ 1493 "../Generated_Code/tasks.c" 1
 1710 0030 72B6     		cpsid i
 1711              	@ 0 "" 2
1494:../Generated_Code/tasks.c **** 
1495:../Generated_Code/tasks.c ****                 #if ( configUSE_NEWLIB_REENTRANT == 1 )
1496:../Generated_Code/tasks.c ****                 {
1497:../Generated_Code/tasks.c ****                         /* Switch Newlib's _impure_ptr variable to point to the _reent
1498:../Generated_Code/tasks.c ****                         structure specific to the task that will run first. */
1499:../Generated_Code/tasks.c ****                         _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1500:../Generated_Code/tasks.c ****                 }
1501:../Generated_Code/tasks.c ****                 #endif /* configUSE_NEWLIB_REENTRANT */
1502:../Generated_Code/tasks.c **** 
1503:../Generated_Code/tasks.c ****                 xSchedulerRunning = pdTRUE;
 1712              		.loc 1 1503 0
 1713              		.code	16
 1714 0032 0A4B     		ldr	r3, .L119+8
 1715 0034 0122     		mov	r2, #1
 1716 0036 1A60     		str	r2, [r3]
1504:../Generated_Code/tasks.c ****                 xTickCount = ( TickType_t ) 0U;
 1717              		.loc 1 1504 0
 1718 0038 094B     		ldr	r3, .L119+12
 1719 003a 0022     		mov	r2, #0
 1720 003c 1A60     		str	r2, [r3]
1505:../Generated_Code/tasks.c **** 
1506:../Generated_Code/tasks.c ****                 /* If configGENERATE_RUN_TIME_STATS is defined then the following
1507:../Generated_Code/tasks.c ****                 macro must be defined to configure the timer/counter used to generate
1508:../Generated_Code/tasks.c ****                 the run time counter time base. */
1509:../Generated_Code/tasks.c ****                 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1510:../Generated_Code/tasks.c **** 
1511:../Generated_Code/tasks.c ****                 /* Setting up the timer tick is hardware specific and thus in the
1512:../Generated_Code/tasks.c ****                 portable interface. */
1513:../Generated_Code/tasks.c ****                 if( xPortStartScheduler() != pdFALSE )
 1721              		.loc 1 1513 0
 1722 003e FFF7FEFF 		bl	xPortStartScheduler
 1723 0042 04E0     		b	.L115
 1724              	.L116:
1514:../Generated_Code/tasks.c ****                 {
1515:../Generated_Code/tasks.c ****                         /* Should not reach here as if the scheduler is running the
1516:../Generated_Code/tasks.c ****                         function will not return. */
1517:../Generated_Code/tasks.c ****                 }
1518:../Generated_Code/tasks.c ****                 else
1519:../Generated_Code/tasks.c ****                 {
1520:../Generated_Code/tasks.c ****                         /* Should only reach here if a task calls xTaskEndScheduler(). */
1521:../Generated_Code/tasks.c ****                 }
1522:../Generated_Code/tasks.c ****         }
1523:../Generated_Code/tasks.c ****         else
1524:../Generated_Code/tasks.c ****         {
1525:../Generated_Code/tasks.c ****                 /* This line will only be reached if the kernel could not be started,
1526:../Generated_Code/tasks.c ****                 because there was not enough FreeRTOS heap to create the idle task
1527:../Generated_Code/tasks.c ****                 or the timer task. */
1528:../Generated_Code/tasks.c ****                 configASSERT( xReturn );
 1725              		.loc 1 1528 0
 1726 0044 7B68     		ldr	r3, [r7, #4]
 1727 0046 002B     		cmp	r3, #0
 1728 0048 01D1     		bne	.L115
 1729              		.loc 1 1528 0 is_stmt 0
 1730              	@ 1528 "../Generated_Code/tasks.c" 1
 1731 004a 72B6     		cpsid i
 1732              	@ 0 "" 2
 1733              		.code	16
 1734              	.L118:
 1735              		.loc 1 1528 0
 1736 004c FEE7     		b	.L118
 1737              	.L115:
 1738              	.LBE15:
1529:../Generated_Code/tasks.c ****         }
1530:../Generated_Code/tasks.c **** }
 1739              		.loc 1 1530 0 is_stmt 1
 1740 004e BD46     		mov	sp, r7
 1741 0050 02B0     		add	sp, sp, #8
 1742              		@ sp needed for prologue
 1743 0052 80BD     		pop	{r7, pc}
 1744              	.L120:
 1745              		.align	2
 1746              	.L119:
 1747 0054 00000000 		.word	_ZL11prvIdleTaskPv
 1748 0058 00000000 		.word	.LC38
 1749 005c 00000000 		.word	_ZL17xSchedulerRunning
 1750 0060 00000000 		.word	_ZL10xTickCount
 1751              		.cfi_endproc
 1752              	.LFE19:
 1754              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1755              		.align	2
 1756              		.global	vTaskEndScheduler
 1757              		.code	16
 1758              		.thumb_func
 1760              	vTaskEndScheduler:
 1761              	.LFB20:
1531:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1532:../Generated_Code/tasks.c **** 
1533:../Generated_Code/tasks.c **** void vTaskEndScheduler( void )
1534:../Generated_Code/tasks.c **** {
 1762              		.loc 1 1534 0
 1763              		.cfi_startproc
 1764 0000 80B5     		push	{r7, lr}
 1765              	.LCFI33:
 1766              		.cfi_def_cfa_offset 8
 1767              		.cfi_offset 7, -8
 1768              		.cfi_offset 14, -4
 1769 0002 00AF     		add	r7, sp, #0
 1770              	.LCFI34:
 1771              		.cfi_def_cfa_register 7
1535:../Generated_Code/tasks.c ****         /* Stop the scheduler interrupts and call the portable scheduler end
1536:../Generated_Code/tasks.c ****         routine so the original ISRs can be restored if necessary.  The port
1537:../Generated_Code/tasks.c ****         layer must ensure interrupts enable     bit is left in the correct state. */
1538:../Generated_Code/tasks.c ****         portDISABLE_INTERRUPTS();
 1772              		.loc 1 1538 0
 1773              	@ 1538 "../Generated_Code/tasks.c" 1
 1774 0004 72B6     		cpsid i
 1775              	@ 0 "" 2
1539:../Generated_Code/tasks.c ****         xSchedulerRunning = pdFALSE;
 1776              		.loc 1 1539 0
 1777              		.code	16
 1778 0006 034B     		ldr	r3, .L122
 1779 0008 0022     		mov	r2, #0
 1780 000a 1A60     		str	r2, [r3]
1540:../Generated_Code/tasks.c ****         vPortEndScheduler();
 1781              		.loc 1 1540 0
 1782 000c FFF7FEFF 		bl	vPortEndScheduler
1541:../Generated_Code/tasks.c **** }
 1783              		.loc 1 1541 0
 1784 0010 BD46     		mov	sp, r7
 1785              		@ sp needed for prologue
 1786 0012 80BD     		pop	{r7, pc}
 1787              	.L123:
 1788              		.align	2
 1789              	.L122:
 1790 0014 00000000 		.word	_ZL17xSchedulerRunning
 1791              		.cfi_endproc
 1792              	.LFE20:
 1794              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1795              		.align	2
 1796              		.global	vTaskSuspendAll
 1797              		.code	16
 1798              		.thumb_func
 1800              	vTaskSuspendAll:
 1801              	.LFB21:
1542:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1543:../Generated_Code/tasks.c **** 
1544:../Generated_Code/tasks.c **** void vTaskSuspendAll( void )
1545:../Generated_Code/tasks.c **** {
 1802              		.loc 1 1545 0
 1803              		.cfi_startproc
 1804 0000 80B5     		push	{r7, lr}
 1805              	.LCFI35:
 1806              		.cfi_def_cfa_offset 8
 1807              		.cfi_offset 7, -8
 1808              		.cfi_offset 14, -4
 1809 0002 00AF     		add	r7, sp, #0
 1810              	.LCFI36:
 1811              		.cfi_def_cfa_register 7
1546:../Generated_Code/tasks.c ****         /* A critical section is not required as the variable is of type
1547:../Generated_Code/tasks.c ****         BaseType_t.  Please read Richard Barry's reply in the following link to a
1548:../Generated_Code/tasks.c ****         post in the FreeRTOS support forum before reporting this as a bug! -
1549:../Generated_Code/tasks.c ****         http://goo.gl/wu4acr */
1550:../Generated_Code/tasks.c ****         ++uxSchedulerSuspended;
 1812              		.loc 1 1550 0
 1813 0004 034B     		ldr	r3, .L125
 1814 0006 1B68     		ldr	r3, [r3]
 1815 0008 5A1C     		add	r2, r3, #1
 1816 000a 024B     		ldr	r3, .L125
 1817 000c 1A60     		str	r2, [r3]
1551:../Generated_Code/tasks.c **** }
 1818              		.loc 1 1551 0
 1819 000e BD46     		mov	sp, r7
 1820              		@ sp needed for prologue
 1821 0010 80BD     		pop	{r7, pc}
 1822              	.L126:
 1823 0012 C046     		.align	2
 1824              	.L125:
 1825 0014 00000000 		.word	_ZL20uxSchedulerSuspended
 1826              		.cfi_endproc
 1827              	.LFE21:
 1829              		.section	.text.xTaskResumeAll,"ax",%progbits
 1830              		.align	2
 1831              		.global	xTaskResumeAll
 1832              		.code	16
 1833              		.thumb_func
 1835              	xTaskResumeAll:
 1836              	.LFB22:
1552:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1553:../Generated_Code/tasks.c **** 
1554:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1555:../Generated_Code/tasks.c **** 
1556:../Generated_Code/tasks.c ****         static TickType_t prvGetExpectedIdleTime( void )
1557:../Generated_Code/tasks.c ****         {
1558:../Generated_Code/tasks.c ****         TickType_t xReturn;
1559:../Generated_Code/tasks.c **** 
1560:../Generated_Code/tasks.c ****                 if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1561:../Generated_Code/tasks.c ****                 {
1562:../Generated_Code/tasks.c ****                         xReturn = 0;
1563:../Generated_Code/tasks.c ****                 }
1564:../Generated_Code/tasks.c ****                 else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 
1565:../Generated_Code/tasks.c ****                 {
1566:../Generated_Code/tasks.c ****                         /* There are other idle priority tasks in the ready state.  If
1567:../Generated_Code/tasks.c ****                         time slicing is used then the very next tick interrupt must be
1568:../Generated_Code/tasks.c ****                         processed. */
1569:../Generated_Code/tasks.c ****                         xReturn = 0;
1570:../Generated_Code/tasks.c ****                 }
1571:../Generated_Code/tasks.c ****                 else
1572:../Generated_Code/tasks.c ****                 {
1573:../Generated_Code/tasks.c ****                         xReturn = xNextTaskUnblockTime - xTickCount;
1574:../Generated_Code/tasks.c ****                 }
1575:../Generated_Code/tasks.c **** 
1576:../Generated_Code/tasks.c ****                 return xReturn;
1577:../Generated_Code/tasks.c ****         }
1578:../Generated_Code/tasks.c **** 
1579:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1580:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1581:../Generated_Code/tasks.c **** 
1582:../Generated_Code/tasks.c **** BaseType_t xTaskResumeAll( void )
1583:../Generated_Code/tasks.c **** {
 1837              		.loc 1 1583 0
 1838              		.cfi_startproc
 1839 0000 80B5     		push	{r7, lr}
 1840              	.LCFI37:
 1841              		.cfi_def_cfa_offset 8
 1842              		.cfi_offset 7, -8
 1843              		.cfi_offset 14, -4
 1844 0002 82B0     		sub	sp, sp, #8
 1845              	.LCFI38:
 1846              		.cfi_def_cfa_offset 16
 1847 0004 00AF     		add	r7, sp, #0
 1848              	.LCFI39:
 1849              		.cfi_def_cfa_register 7
 1850              	.LBB16:
1584:../Generated_Code/tasks.c **** TCB_t *pxTCB;
1585:../Generated_Code/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1851              		.loc 1 1585 0
 1852 0006 0023     		mov	r3, #0
 1853 0008 7B60     		str	r3, [r7, #4]
1586:../Generated_Code/tasks.c **** 
1587:../Generated_Code/tasks.c ****         /* If uxSchedulerSuspended is zero then this function does not match a
1588:../Generated_Code/tasks.c ****         previous call to vTaskSuspendAll(). */
1589:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended );
 1854              		.loc 1 1589 0
 1855 000a 484B     		ldr	r3, .L139
 1856 000c 1B68     		ldr	r3, [r3]
 1857 000e 5A42     		neg	r2, r3
 1858 0010 5341     		adc	r3, r3, r2
 1859 0012 DBB2     		uxtb	r3, r3
 1860 0014 002B     		cmp	r3, #0
 1861 0016 01D0     		beq	.L128
 1862              		.loc 1 1589 0 is_stmt 0
 1863              	@ 1589 "../Generated_Code/tasks.c" 1
 1864 0018 72B6     		cpsid i
 1865              	@ 0 "" 2
 1866              		.code	16
 1867              	.L129:
 1868              		.loc 1 1589 0
 1869 001a FEE7     		b	.L129
 1870              	.L128:
1590:../Generated_Code/tasks.c **** 
1591:../Generated_Code/tasks.c ****         /* It is possible that an ISR caused a task to be removed from an event
1592:../Generated_Code/tasks.c ****         list while the scheduler was suspended.  If this was the case then the
1593:../Generated_Code/tasks.c ****         removed task will have been added to the xPendingReadyList.  Once the
1594:../Generated_Code/tasks.c ****         scheduler has been resumed it is safe to move all the pending ready
1595:../Generated_Code/tasks.c ****         tasks from this list into their appropriate ready list. */
1596:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 1871              		.loc 1 1596 0 is_stmt 1
 1872 001c FFF7FEFF 		bl	vPortEnterCritical
1597:../Generated_Code/tasks.c ****         {
1598:../Generated_Code/tasks.c ****                 --uxSchedulerSuspended;
 1873              		.loc 1 1598 0
 1874 0020 424B     		ldr	r3, .L139
 1875 0022 1B68     		ldr	r3, [r3]
 1876 0024 5A1E     		sub	r2, r3, #1
 1877 0026 414B     		ldr	r3, .L139
 1878 0028 1A60     		str	r2, [r3]
1599:../Generated_Code/tasks.c **** 
1600:../Generated_Code/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1879              		.loc 1 1600 0
 1880 002a 404B     		ldr	r3, .L139
 1881 002c 1B68     		ldr	r3, [r3]
 1882 002e 5A42     		neg	r2, r3
 1883 0030 5341     		adc	r3, r3, r2
 1884 0032 DBB2     		uxtb	r3, r3
 1885 0034 002B     		cmp	r3, #0
 1886 0036 00D1     		bne	.LCB1499
 1887 0038 71E0     		b	.L130	@long jump
 1888              	.LCB1499:
1601:../Generated_Code/tasks.c ****                 {
1602:../Generated_Code/tasks.c ****                         if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1889              		.loc 1 1602 0
 1890 003a 3D4B     		ldr	r3, .L139+4
 1891 003c 1B68     		ldr	r3, [r3]
 1892 003e 5A1E     		sub	r2, r3, #1
 1893 0040 9341     		sbc	r3, r3, r2
 1894 0042 DBB2     		uxtb	r3, r3
 1895 0044 002B     		cmp	r3, #0
 1896 0046 6AD0     		beq	.L130
1603:../Generated_Code/tasks.c ****                         {
1604:../Generated_Code/tasks.c ****                                 /* Move any readied tasks from the pending list into the
1605:../Generated_Code/tasks.c ****                                 appropriate ready list. */
1606:../Generated_Code/tasks.c ****                                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1897              		.loc 1 1606 0
 1898 0048 37E0     		b	.L131
 1899              	.L133:
1607:../Generated_Code/tasks.c ****                                 {
1608:../Generated_Code/tasks.c ****                                         pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendin
 1900              		.loc 1 1608 0
 1901 004a 3A4B     		ldr	r3, .L139+8
 1902 004c DB68     		ldr	r3, [r3, #12]
 1903 004e DB68     		ldr	r3, [r3, #12]
 1904 0050 3B60     		str	r3, [r7]
1609:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1905              		.loc 1 1609 0
 1906 0052 3B68     		ldr	r3, [r7]
 1907 0054 1833     		add	r3, r3, #24
 1908 0056 181C     		mov	r0, r3
 1909 0058 FFF7FEFF 		bl	uxListRemove
1610:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1910              		.loc 1 1610 0
 1911 005c 3B68     		ldr	r3, [r7]
 1912 005e 0433     		add	r3, r3, #4
 1913 0060 181C     		mov	r0, r3
 1914 0062 FFF7FEFF 		bl	uxListRemove
1611:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1915              		.loc 1 1611 0
 1916 0066 3B68     		ldr	r3, [r7]
 1917 0068 DA6A     		ldr	r2, [r3, #44]
 1918 006a 334B     		ldr	r3, .L139+12
 1919 006c 1B68     		ldr	r3, [r3]
 1920 006e 9342     		cmp	r3, r2
 1921 0070 9B41     		sbc	r3, r3, r3
 1922 0072 5B42     		neg	r3, r3
 1923 0074 DBB2     		uxtb	r3, r3
 1924 0076 002B     		cmp	r3, #0
 1925 0078 03D0     		beq	.L132
 1926              		.loc 1 1611 0 is_stmt 0
 1927 007a 3B68     		ldr	r3, [r7]
 1928 007c DA6A     		ldr	r2, [r3, #44]
 1929 007e 2E4B     		ldr	r3, .L139+12
 1930 0080 1A60     		str	r2, [r3]
 1931              	.L132:
 1932              		.loc 1 1611 0
 1933 0082 3B68     		ldr	r3, [r7]
 1934 0084 DA6A     		ldr	r2, [r3, #44]
 1935 0086 131C     		mov	r3, r2
 1936 0088 9B00     		lsl	r3, r3, #2
 1937 008a 9B18     		add	r3, r3, r2
 1938 008c 9B00     		lsl	r3, r3, #2
 1939 008e 2B4A     		ldr	r2, .L139+16
 1940 0090 9A18     		add	r2, r3, r2
 1941 0092 3B68     		ldr	r3, [r7]
 1942 0094 0433     		add	r3, r3, #4
 1943 0096 101C     		mov	r0, r2
 1944 0098 191C     		mov	r1, r3
 1945 009a FFF7FEFF 		bl	vListInsertEnd
1612:../Generated_Code/tasks.c **** 
1613:../Generated_Code/tasks.c ****                                         /* If we have moved a task that has a priority higher than
1614:../Generated_Code/tasks.c ****                                         the current task then we should yield. */
1615:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1946              		.loc 1 1615 0 is_stmt 1
 1947 009e 3B68     		ldr	r3, [r7]
 1948 00a0 D96A     		ldr	r1, [r3, #44]
 1949 00a2 274B     		ldr	r3, .L139+20
 1950 00a4 1B68     		ldr	r3, [r3]
 1951 00a6 DA6A     		ldr	r2, [r3, #44]
 1952 00a8 0023     		mov	r3, #0
 1953 00aa 9142     		cmp	r1, r2
 1954 00ac 5B41     		adc	r3, r3, r3
 1955 00ae DBB2     		uxtb	r3, r3
 1956 00b0 002B     		cmp	r3, #0
 1957 00b2 02D0     		beq	.L131
1616:../Generated_Code/tasks.c ****                                         {
1617:../Generated_Code/tasks.c ****                                                 xYieldPending = pdTRUE;
 1958              		.loc 1 1617 0
 1959 00b4 234B     		ldr	r3, .L139+24
 1960 00b6 0122     		mov	r2, #1
 1961 00b8 1A60     		str	r2, [r3]
 1962              	.L131:
1606:../Generated_Code/tasks.c ****                                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1963              		.loc 1 1606 0
 1964 00ba 1E4B     		ldr	r3, .L139+8
 1965 00bc 1B68     		ldr	r3, [r3]
 1966 00be 5A1E     		sub	r2, r3, #1
 1967 00c0 9341     		sbc	r3, r3, r2
 1968 00c2 DBB2     		uxtb	r3, r3
 1969 00c4 002B     		cmp	r3, #0
 1970 00c6 C0D1     		bne	.L133
1618:../Generated_Code/tasks.c ****                                         }
1619:../Generated_Code/tasks.c ****                                         else
1620:../Generated_Code/tasks.c ****                                         {
1621:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1622:../Generated_Code/tasks.c ****                                         }
1623:../Generated_Code/tasks.c ****                                 }
1624:../Generated_Code/tasks.c **** 
1625:../Generated_Code/tasks.c ****                                 /* If any ticks occurred while the scheduler was suspended then
1626:../Generated_Code/tasks.c ****                                 they should be processed now.  This ensures the tick count does
1627:../Generated_Code/tasks.c ****                                 not     slip, and that any delayed tasks are resumed at the correct
1628:../Generated_Code/tasks.c ****                                 time. */
1629:../Generated_Code/tasks.c ****                                 if( uxPendedTicks > ( UBaseType_t ) 0U )
 1971              		.loc 1 1629 0
 1972 00c8 1F4B     		ldr	r3, .L139+28
 1973 00ca 1B68     		ldr	r3, [r3]
 1974 00cc 5A1E     		sub	r2, r3, #1
 1975 00ce 9341     		sbc	r3, r3, r2
 1976 00d0 DBB2     		uxtb	r3, r3
 1977 00d2 002B     		cmp	r3, #0
 1978 00d4 17D0     		beq	.L134
1630:../Generated_Code/tasks.c ****                                 {
1631:../Generated_Code/tasks.c ****                                         while( uxPendedTicks > ( UBaseType_t ) 0U )
 1979              		.loc 1 1631 0
 1980 00d6 0FE0     		b	.L135
 1981              	.L137:
1632:../Generated_Code/tasks.c ****                                         {
1633:../Generated_Code/tasks.c ****                                                 if( xTaskIncrementTick() != pdFALSE )
 1982              		.loc 1 1633 0
 1983 00d8 FFF7FEFF 		bl	xTaskIncrementTick
 1984 00dc 031C     		mov	r3, r0
 1985 00de 5A1E     		sub	r2, r3, #1
 1986 00e0 9341     		sbc	r3, r3, r2
 1987 00e2 DBB2     		uxtb	r3, r3
 1988 00e4 002B     		cmp	r3, #0
 1989 00e6 02D0     		beq	.L136
1634:../Generated_Code/tasks.c ****                                                 {
1635:../Generated_Code/tasks.c ****                                                         xYieldPending = pdTRUE;
 1990              		.loc 1 1635 0
 1991 00e8 164B     		ldr	r3, .L139+24
 1992 00ea 0122     		mov	r2, #1
 1993 00ec 1A60     		str	r2, [r3]
 1994              	.L136:
1636:../Generated_Code/tasks.c ****                                                 }
1637:../Generated_Code/tasks.c ****                                                 else
1638:../Generated_Code/tasks.c ****                                                 {
1639:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1640:../Generated_Code/tasks.c ****                                                 }
1641:../Generated_Code/tasks.c ****                                                 --uxPendedTicks;
 1995              		.loc 1 1641 0
 1996 00ee 164B     		ldr	r3, .L139+28
 1997 00f0 1B68     		ldr	r3, [r3]
 1998 00f2 5A1E     		sub	r2, r3, #1
 1999 00f4 144B     		ldr	r3, .L139+28
 2000 00f6 1A60     		str	r2, [r3]
 2001              	.L135:
1631:../Generated_Code/tasks.c ****                                         while( uxPendedTicks > ( UBaseType_t ) 0U )
 2002              		.loc 1 1631 0
 2003 00f8 134B     		ldr	r3, .L139+28
 2004 00fa 1B68     		ldr	r3, [r3]
 2005 00fc 5A1E     		sub	r2, r3, #1
 2006 00fe 9341     		sbc	r3, r3, r2
 2007 0100 DBB2     		uxtb	r3, r3
 2008 0102 002B     		cmp	r3, #0
 2009 0104 E8D1     		bne	.L137
 2010              	.L134:
1642:../Generated_Code/tasks.c ****                                         }
1643:../Generated_Code/tasks.c ****                                 }
1644:../Generated_Code/tasks.c ****                                 else
1645:../Generated_Code/tasks.c ****                                 {
1646:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1647:../Generated_Code/tasks.c ****                                 }
1648:../Generated_Code/tasks.c **** 
1649:../Generated_Code/tasks.c ****                                 if( xYieldPending == pdTRUE )
 2011              		.loc 1 1649 0
 2012 0106 0F4B     		ldr	r3, .L139+24
 2013 0108 1B68     		ldr	r3, [r3]
 2014 010a 013B     		sub	r3, r3, #1
 2015 010c 5A42     		neg	r2, r3
 2016 010e 5341     		adc	r3, r3, r2
 2017 0110 DBB2     		uxtb	r3, r3
 2018 0112 002B     		cmp	r3, #0
 2019 0114 03D0     		beq	.L130
1650:../Generated_Code/tasks.c ****                                 {
1651:../Generated_Code/tasks.c ****                                         #if( configUSE_PREEMPTION != 0 )
1652:../Generated_Code/tasks.c ****                                         {
1653:../Generated_Code/tasks.c ****                                                 xAlreadyYielded = pdTRUE;
 2020              		.loc 1 1653 0
 2021 0116 0123     		mov	r3, #1
 2022 0118 7B60     		str	r3, [r7, #4]
1654:../Generated_Code/tasks.c ****                                         }
1655:../Generated_Code/tasks.c ****                                         #endif
1656:../Generated_Code/tasks.c ****                                         taskYIELD_IF_USING_PREEMPTION();
 2023              		.loc 1 1656 0
 2024 011a FFF7FEFF 		bl	vPortYieldFromISR
 2025              	.L130:
1657:../Generated_Code/tasks.c ****                                 }
1658:../Generated_Code/tasks.c ****                                 else
1659:../Generated_Code/tasks.c ****                                 {
1660:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1661:../Generated_Code/tasks.c ****                                 }
1662:../Generated_Code/tasks.c ****                         }
1663:../Generated_Code/tasks.c ****                 }
1664:../Generated_Code/tasks.c ****                 else
1665:../Generated_Code/tasks.c ****                 {
1666:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1667:../Generated_Code/tasks.c ****                 }
1668:../Generated_Code/tasks.c ****         }
1669:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 2026              		.loc 1 1669 0
 2027 011e FFF7FEFF 		bl	vPortExitCritical
1670:../Generated_Code/tasks.c **** 
1671:../Generated_Code/tasks.c ****         return xAlreadyYielded;
 2028              		.loc 1 1671 0
 2029 0122 7B68     		ldr	r3, [r7, #4]
 2030              	.LBE16:
1672:../Generated_Code/tasks.c **** }
 2031              		.loc 1 1672 0
 2032 0124 181C     		mov	r0, r3
 2033 0126 BD46     		mov	sp, r7
 2034 0128 02B0     		add	sp, sp, #8
 2035              		@ sp needed for prologue
 2036 012a 80BD     		pop	{r7, pc}
 2037              	.L140:
 2038              		.align	2
 2039              	.L139:
 2040 012c 00000000 		.word	_ZL20uxSchedulerSuspended
 2041 0130 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 2042 0134 00000000 		.word	_ZL17xPendingReadyList
 2043 0138 00000000 		.word	_ZL18uxTopReadyPriority
 2044 013c 00000000 		.word	_ZL17pxReadyTasksLists
 2045 0140 00000000 		.word	pxCurrentTCB
 2046 0144 00000000 		.word	_ZL13xYieldPending
 2047 0148 00000000 		.word	_ZL13uxPendedTicks
 2048              		.cfi_endproc
 2049              	.LFE22:
 2051              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2052              		.align	2
 2053              		.global	xTaskGetTickCount
 2054              		.code	16
 2055              		.thumb_func
 2057              	xTaskGetTickCount:
 2058              	.LFB23:
1673:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1674:../Generated_Code/tasks.c **** 
1675:../Generated_Code/tasks.c **** TickType_t xTaskGetTickCount( void )
1676:../Generated_Code/tasks.c **** {
 2059              		.loc 1 1676 0
 2060              		.cfi_startproc
 2061 0000 80B5     		push	{r7, lr}
 2062              	.LCFI40:
 2063              		.cfi_def_cfa_offset 8
 2064              		.cfi_offset 7, -8
 2065              		.cfi_offset 14, -4
 2066 0002 82B0     		sub	sp, sp, #8
 2067              	.LCFI41:
 2068              		.cfi_def_cfa_offset 16
 2069 0004 00AF     		add	r7, sp, #0
 2070              	.LCFI42:
 2071              		.cfi_def_cfa_register 7
 2072              	.LBB17:
1677:../Generated_Code/tasks.c **** TickType_t xTicks;
1678:../Generated_Code/tasks.c **** 
1679:../Generated_Code/tasks.c ****         /* Critical section required if running on a 16 bit processor. */
1680:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 2073              		.loc 1 1680 0
 2074 0006 FFF7FEFF 		bl	vPortEnterCritical
1681:../Generated_Code/tasks.c ****         {
1682:../Generated_Code/tasks.c ****                 xTicks = xTickCount;
 2075              		.loc 1 1682 0
 2076 000a 054B     		ldr	r3, .L143
 2077 000c 1B68     		ldr	r3, [r3]
 2078 000e 7B60     		str	r3, [r7, #4]
1683:../Generated_Code/tasks.c ****         }
1684:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 2079              		.loc 1 1684 0
 2080 0010 FFF7FEFF 		bl	vPortExitCritical
1685:../Generated_Code/tasks.c **** 
1686:../Generated_Code/tasks.c ****         return xTicks;
 2081              		.loc 1 1686 0
 2082 0014 7B68     		ldr	r3, [r7, #4]
 2083              	.LBE17:
1687:../Generated_Code/tasks.c **** }
 2084              		.loc 1 1687 0
 2085 0016 181C     		mov	r0, r3
 2086 0018 BD46     		mov	sp, r7
 2087 001a 02B0     		add	sp, sp, #8
 2088              		@ sp needed for prologue
 2089 001c 80BD     		pop	{r7, pc}
 2090              	.L144:
 2091 001e C046     		.align	2
 2092              	.L143:
 2093 0020 00000000 		.word	_ZL10xTickCount
 2094              		.cfi_endproc
 2095              	.LFE23:
 2097              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2098              		.align	2
 2099              		.global	xTaskGetTickCountFromISR
 2100              		.code	16
 2101              		.thumb_func
 2103              	xTaskGetTickCountFromISR:
 2104              	.LFB24:
1688:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1689:../Generated_Code/tasks.c **** 
1690:../Generated_Code/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1691:../Generated_Code/tasks.c **** {
 2105              		.loc 1 1691 0
 2106              		.cfi_startproc
 2107 0000 80B5     		push	{r7, lr}
 2108              	.LCFI43:
 2109              		.cfi_def_cfa_offset 8
 2110              		.cfi_offset 7, -8
 2111              		.cfi_offset 14, -4
 2112 0002 82B0     		sub	sp, sp, #8
 2113              	.LCFI44:
 2114              		.cfi_def_cfa_offset 16
 2115 0004 00AF     		add	r7, sp, #0
 2116              	.LCFI45:
 2117              		.cfi_def_cfa_register 7
 2118              	.LBB18:
1692:../Generated_Code/tasks.c **** TickType_t xReturn;
1693:../Generated_Code/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1694:../Generated_Code/tasks.c **** 
1695:../Generated_Code/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a maximum
1696:../Generated_Code/tasks.c ****         system call (or maximum API call) interrupt priority.  Interrupts that are
1697:../Generated_Code/tasks.c ****         above the maximum system call priority are kept permanently enabled, even
1698:../Generated_Code/tasks.c ****         when the RTOS kernel is in a critical section, but cannot make any calls to
1699:../Generated_Code/tasks.c ****         FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1700:../Generated_Code/tasks.c ****         then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1701:../Generated_Code/tasks.c ****         failure if a FreeRTOS API function is called from an interrupt that has been
1702:../Generated_Code/tasks.c ****         assigned a priority above the configured maximum system call priority.
1703:../Generated_Code/tasks.c ****         Only FreeRTOS functions that end in FromISR can be called from interrupts
1704:../Generated_Code/tasks.c ****         that have been assigned a priority at or (logically) below the maximum
1705:../Generated_Code/tasks.c ****         system call     interrupt priority.  FreeRTOS maintains a separate interrupt
1706:../Generated_Code/tasks.c ****         safe API to ensure interrupt entry is as fast and as simple as possible.
1707:../Generated_Code/tasks.c ****         More information (albeit Cortex-M specific) is provided on the following
1708:../Generated_Code/tasks.c ****         link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1709:../Generated_Code/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1710:../Generated_Code/tasks.c **** 
1711:../Generated_Code/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2119              		.loc 1 1711 0
 2120 0006 0023     		mov	r3, #0
 2121 0008 7B60     		str	r3, [r7, #4]
 2122              	@ 1711 "../Generated_Code/tasks.c" 1
 2123 000a 72B6     		cpsid i
 2124              	@ 0 "" 2
1712:../Generated_Code/tasks.c ****         {
1713:../Generated_Code/tasks.c ****                 xReturn = xTickCount;
 2125              		.loc 1 1713 0
 2126              		.code	16
 2127 000c 044B     		ldr	r3, .L147
 2128 000e 1B68     		ldr	r3, [r3]
 2129 0010 3B60     		str	r3, [r7]
1714:../Generated_Code/tasks.c ****         }
1715:../Generated_Code/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2130              		.loc 1 1715 0
 2131              	@ 1715 "../Generated_Code/tasks.c" 1
 2132 0012 62B6     		cpsie i
 2133              	@ 0 "" 2
1716:../Generated_Code/tasks.c **** 
1717:../Generated_Code/tasks.c ****         return xReturn;
 2134              		.loc 1 1717 0
 2135              		.code	16
 2136 0014 3B68     		ldr	r3, [r7]
 2137              	.LBE18:
1718:../Generated_Code/tasks.c **** }
 2138              		.loc 1 1718 0
 2139 0016 181C     		mov	r0, r3
 2140 0018 BD46     		mov	sp, r7
 2141 001a 02B0     		add	sp, sp, #8
 2142              		@ sp needed for prologue
 2143 001c 80BD     		pop	{r7, pc}
 2144              	.L148:
 2145 001e C046     		.align	2
 2146              	.L147:
 2147 0020 00000000 		.word	_ZL10xTickCount
 2148              		.cfi_endproc
 2149              	.LFE24:
 2151              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2152              		.align	2
 2153              		.global	uxTaskGetNumberOfTasks
 2154              		.code	16
 2155              		.thumb_func
 2157              	uxTaskGetNumberOfTasks:
 2158              	.LFB25:
1719:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1720:../Generated_Code/tasks.c **** 
1721:../Generated_Code/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1722:../Generated_Code/tasks.c **** {
 2159              		.loc 1 1722 0
 2160              		.cfi_startproc
 2161 0000 80B5     		push	{r7, lr}
 2162              	.LCFI46:
 2163              		.cfi_def_cfa_offset 8
 2164              		.cfi_offset 7, -8
 2165              		.cfi_offset 14, -4
 2166 0002 00AF     		add	r7, sp, #0
 2167              	.LCFI47:
 2168              		.cfi_def_cfa_register 7
1723:../Generated_Code/tasks.c ****         /* A critical section is not required because the variables are of type
1724:../Generated_Code/tasks.c ****         BaseType_t. */
1725:../Generated_Code/tasks.c ****         return uxCurrentNumberOfTasks;
 2169              		.loc 1 1725 0
 2170 0004 024B     		ldr	r3, .L151
 2171 0006 1B68     		ldr	r3, [r3]
1726:../Generated_Code/tasks.c **** }
 2172              		.loc 1 1726 0
 2173 0008 181C     		mov	r0, r3
 2174 000a BD46     		mov	sp, r7
 2175              		@ sp needed for prologue
 2176 000c 80BD     		pop	{r7, pc}
 2177              	.L152:
 2178 000e C046     		.align	2
 2179              	.L151:
 2180 0010 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 2181              		.cfi_endproc
 2182              	.LFE25:
 2184              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2185              		.align	2
 2186              		.global	xTaskIncrementTick
 2187              		.code	16
 2188              		.thumb_func
 2190              	xTaskIncrementTick:
 2191              	.LFB26:
1727:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1728:../Generated_Code/tasks.c **** 
1729:../Generated_Code/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1730:../Generated_Code/tasks.c **** 
1731:../Generated_Code/tasks.c ****         char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
1732:../Generated_Code/tasks.c ****         {
1733:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1734:../Generated_Code/tasks.c **** 
1735:../Generated_Code/tasks.c ****                 /* If null is passed in here then the name of the calling task is being queried. */
1736:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1737:../Generated_Code/tasks.c ****                 configASSERT( pxTCB );
1738:../Generated_Code/tasks.c ****                 return &( pxTCB->pcTaskName[ 0 ] );
1739:../Generated_Code/tasks.c ****         }
1740:../Generated_Code/tasks.c **** 
1741:../Generated_Code/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1742:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1743:../Generated_Code/tasks.c **** 
1744:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1745:../Generated_Code/tasks.c **** 
1746:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t
1747:../Generated_Code/tasks.c ****         {
1748:../Generated_Code/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1749:../Generated_Code/tasks.c **** 
1750:../Generated_Code/tasks.c ****                 vTaskSuspendAll();
1751:../Generated_Code/tasks.c ****                 {
1752:../Generated_Code/tasks.c ****                         /* Is there a space in the array for each task in the system? */
1753:../Generated_Code/tasks.c ****                         if( uxArraySize >= uxCurrentNumberOfTasks )
1754:../Generated_Code/tasks.c ****                         {
1755:../Generated_Code/tasks.c ****                                 /* Fill in an TaskStatus_t structure with information on each
1756:../Generated_Code/tasks.c ****                                 task in the Ready state. */
1757:../Generated_Code/tasks.c ****                                 do
1758:../Generated_Code/tasks.c ****                                 {
1759:../Generated_Code/tasks.c ****                                         uxQueue--;
1760:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1761:../Generated_Code/tasks.c **** 
1762:../Generated_Code/tasks.c ****                                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961
1763:../Generated_Code/tasks.c **** 
1764:../Generated_Code/tasks.c ****                                 /* Fill in an TaskStatus_t structure with information on each
1765:../Generated_Code/tasks.c ****                                 task in the Blocked state. */
1766:../Generated_Code/tasks.c ****                                 uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask
1767:../Generated_Code/tasks.c ****                                 uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask
1768:../Generated_Code/tasks.c **** 
1769:../Generated_Code/tasks.c ****                                 #if( INCLUDE_vTaskDelete == 1 )
1770:../Generated_Code/tasks.c ****                                 {
1771:../Generated_Code/tasks.c ****                                         /* Fill in an TaskStatus_t structure with information on
1772:../Generated_Code/tasks.c ****                                         each task that has been deleted but not yet cleaned up. */
1773:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1774:../Generated_Code/tasks.c ****                                 }
1775:../Generated_Code/tasks.c ****                                 #endif
1776:../Generated_Code/tasks.c **** 
1777:../Generated_Code/tasks.c ****                                 #if ( INCLUDE_vTaskSuspend == 1 )
1778:../Generated_Code/tasks.c ****                                 {
1779:../Generated_Code/tasks.c ****                                         /* Fill in an TaskStatus_t structure with information on
1780:../Generated_Code/tasks.c ****                                         each task in the Suspended state. */
1781:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1782:../Generated_Code/tasks.c ****                                 }
1783:../Generated_Code/tasks.c ****                                 #endif
1784:../Generated_Code/tasks.c **** 
1785:../Generated_Code/tasks.c ****                                 #if ( configGENERATE_RUN_TIME_STATS == 1)
1786:../Generated_Code/tasks.c ****                                 {
1787:../Generated_Code/tasks.c ****                                         if( pulTotalRunTime != NULL )
1788:../Generated_Code/tasks.c ****                                         {
1789:../Generated_Code/tasks.c ****                                                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1790:../Generated_Code/tasks.c ****                                                         portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulT
1791:../Generated_Code/tasks.c ****                                                 #else
1792:../Generated_Code/tasks.c ****                                                         *pulTotalRunTime = portGET_RUN_TIME_COUNTER
1793:../Generated_Code/tasks.c ****                                                 #endif
1794:../Generated_Code/tasks.c ****                                         }
1795:../Generated_Code/tasks.c ****                                 }
1796:../Generated_Code/tasks.c ****                                 #else
1797:../Generated_Code/tasks.c ****                                 {
1798:../Generated_Code/tasks.c ****                                         if( pulTotalRunTime != NULL )
1799:../Generated_Code/tasks.c ****                                         {
1800:../Generated_Code/tasks.c ****                                                 *pulTotalRunTime = 0;
1801:../Generated_Code/tasks.c ****                                         }
1802:../Generated_Code/tasks.c ****                                 }
1803:../Generated_Code/tasks.c ****                                 #endif
1804:../Generated_Code/tasks.c ****                         }
1805:../Generated_Code/tasks.c ****                         else
1806:../Generated_Code/tasks.c ****                         {
1807:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1808:../Generated_Code/tasks.c ****                         }
1809:../Generated_Code/tasks.c ****                 }
1810:../Generated_Code/tasks.c ****                 ( void ) xTaskResumeAll();
1811:../Generated_Code/tasks.c **** 
1812:../Generated_Code/tasks.c ****                 return uxTask;
1813:../Generated_Code/tasks.c ****         }
1814:../Generated_Code/tasks.c **** 
1815:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1816:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1817:../Generated_Code/tasks.c **** 
1818:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1819:../Generated_Code/tasks.c **** 
1820:../Generated_Code/tasks.c ****         TaskHandle_t xTaskGetIdleTaskHandle( void )
1821:../Generated_Code/tasks.c ****         {
1822:../Generated_Code/tasks.c ****                 /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1823:../Generated_Code/tasks.c ****                 started, then xIdleTaskHandle will be NULL. */
1824:../Generated_Code/tasks.c ****                 configASSERT( ( xIdleTaskHandle != NULL ) );
1825:../Generated_Code/tasks.c ****                 return xIdleTaskHandle;
1826:../Generated_Code/tasks.c ****         }
1827:../Generated_Code/tasks.c **** 
1828:../Generated_Code/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1829:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1830:../Generated_Code/tasks.c **** 
1831:../Generated_Code/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1832:../Generated_Code/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1833:../Generated_Code/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1834:../Generated_Code/tasks.c **** 1. */
1835:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1836:../Generated_Code/tasks.c **** 
1837:../Generated_Code/tasks.c ****         void vTaskStepTick( const TickType_t xTicksToJump )
1838:../Generated_Code/tasks.c ****         {
1839:../Generated_Code/tasks.c ****                 /* Correct the tick count value after a period during which the tick
1840:../Generated_Code/tasks.c ****                 was suppressed.  Note this does *not* call the tick hook function for
1841:../Generated_Code/tasks.c ****                 each stepped tick. */
1842:../Generated_Code/tasks.c ****                 configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1843:../Generated_Code/tasks.c ****                 xTickCount += xTicksToJump;
1844:../Generated_Code/tasks.c ****                 traceINCREASE_TICK_COUNT( xTicksToJump );
1845:../Generated_Code/tasks.c ****         }
1846:../Generated_Code/tasks.c **** 
1847:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1848:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1849:../Generated_Code/tasks.c **** 
1850:../Generated_Code/tasks.c **** BaseType_t xTaskIncrementTick( void )
1851:../Generated_Code/tasks.c **** {
 2192              		.loc 1 1851 0
 2193              		.cfi_startproc
 2194 0000 80B5     		push	{r7, lr}
 2195              	.LCFI48:
 2196              		.cfi_def_cfa_offset 8
 2197              		.cfi_offset 7, -8
 2198              		.cfi_offset 14, -4
 2199 0002 86B0     		sub	sp, sp, #24
 2200              	.LCFI49:
 2201              		.cfi_def_cfa_offset 32
 2202 0004 00AF     		add	r7, sp, #0
 2203              	.LCFI50:
 2204              		.cfi_def_cfa_register 7
 2205              	.LBB19:
1852:../Generated_Code/tasks.c **** TCB_t * pxTCB;
1853:../Generated_Code/tasks.c **** TickType_t xItemValue;
1854:../Generated_Code/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2206              		.loc 1 1854 0
 2207 0006 0023     		mov	r3, #0
 2208 0008 7B61     		str	r3, [r7, #20]
 2209              	.LBB20:
1855:../Generated_Code/tasks.c **** 
1856:../Generated_Code/tasks.c ****         /* Called by the portable layer each time a tick interrupt occurs.
1857:../Generated_Code/tasks.c ****         Increments the tick then checks to see if the new tick value will cause any
1858:../Generated_Code/tasks.c ****         tasks to be unblocked. */
1859:../Generated_Code/tasks.c ****         traceTASK_INCREMENT_TICK( xTickCount );
1860:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2210              		.loc 1 1860 0
 2211 000a 614B     		ldr	r3, .L173
 2212 000c 1B68     		ldr	r3, [r3]
 2213 000e 5A42     		neg	r2, r3
 2214 0010 5341     		adc	r3, r3, r2
 2215 0012 DBB2     		uxtb	r3, r3
 2216 0014 002B     		cmp	r3, #0
 2217 0016 00D1     		bne	.LCB1782
 2218 0018 A4E0     		b	.L154	@long jump
 2219              	.LCB1782:
 2220              	.LBB21:
1861:../Generated_Code/tasks.c ****         {
1862:../Generated_Code/tasks.c ****                 /* Increment the RTOS tick, switching the delayed and overflowed
1863:../Generated_Code/tasks.c ****                 delayed lists if it wraps to 0. */
1864:../Generated_Code/tasks.c ****                 ++xTickCount;
 2221              		.loc 1 1864 0
 2222 001a 5E4B     		ldr	r3, .L173+4
 2223 001c 1B68     		ldr	r3, [r3]
 2224 001e 5A1C     		add	r2, r3, #1
 2225 0020 5C4B     		ldr	r3, .L173+4
 2226 0022 1A60     		str	r2, [r3]
 2227              	.LBB22:
1865:../Generated_Code/tasks.c **** 
1866:../Generated_Code/tasks.c ****                 {
1867:../Generated_Code/tasks.c ****                         /* Minor optimisation.  The tick count cannot change in this
1868:../Generated_Code/tasks.c ****                         block. */
1869:../Generated_Code/tasks.c ****                         const TickType_t xConstTickCount = xTickCount;
 2228              		.loc 1 1869 0
 2229 0024 5B4B     		ldr	r3, .L173+4
 2230 0026 1B68     		ldr	r3, [r3]
 2231 0028 3B61     		str	r3, [r7, #16]
 2232              	.LBB23:
1870:../Generated_Code/tasks.c **** 
1871:../Generated_Code/tasks.c ****                         if( xConstTickCount == ( TickType_t ) 0U )
 2233              		.loc 1 1871 0
 2234 002a 3B69     		ldr	r3, [r7, #16]
 2235 002c 002B     		cmp	r3, #0
 2236 002e 1AD1     		bne	.L155
 2237              	.LBB24:
 2238              	.LBB25:
1872:../Generated_Code/tasks.c ****                         {
1873:../Generated_Code/tasks.c ****                                 taskSWITCH_DELAYED_LISTS();
 2239              		.loc 1 1873 0
 2240 0030 594B     		ldr	r3, .L173+8
 2241 0032 1B68     		ldr	r3, [r3]
 2242 0034 1B68     		ldr	r3, [r3]
 2243 0036 5A1E     		sub	r2, r3, #1
 2244 0038 9341     		sbc	r3, r3, r2
 2245 003a DBB2     		uxtb	r3, r3
 2246 003c 002B     		cmp	r3, #0
 2247 003e 01D0     		beq	.L156
 2248              		.loc 1 1873 0 is_stmt 0
 2249              	@ 1873 "../Generated_Code/tasks.c" 1
 2250 0040 72B6     		cpsid i
 2251              	@ 0 "" 2
 2252              		.code	16
 2253              	.L157:
 2254              		.loc 1 1873 0
 2255 0042 FEE7     		b	.L157
 2256              	.L156:
 2257              		.loc 1 1873 0
 2258 0044 544B     		ldr	r3, .L173+8
 2259 0046 1B68     		ldr	r3, [r3]
 2260 0048 FB60     		str	r3, [r7, #12]
 2261 004a 544B     		ldr	r3, .L173+12
 2262 004c 1A68     		ldr	r2, [r3]
 2263 004e 524B     		ldr	r3, .L173+8
 2264 0050 1A60     		str	r2, [r3]
 2265 0052 524B     		ldr	r3, .L173+12
 2266 0054 FA68     		ldr	r2, [r7, #12]
 2267 0056 1A60     		str	r2, [r3]
 2268 0058 514B     		ldr	r3, .L173+16
 2269 005a 1B68     		ldr	r3, [r3]
 2270 005c 5A1C     		add	r2, r3, #1
 2271 005e 504B     		ldr	r3, .L173+16
 2272 0060 1A60     		str	r2, [r3]
 2273 0062 FFF7FEFF 		bl	_ZL27prvResetNextTaskUnblockTimev
 2274              	.L155:
 2275              	.LBE25:
 2276              	.LBE24:
 2277              	.LBE23:
1874:../Generated_Code/tasks.c ****                         }
1875:../Generated_Code/tasks.c ****                         else
1876:../Generated_Code/tasks.c ****                         {
1877:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1878:../Generated_Code/tasks.c ****                         }
1879:../Generated_Code/tasks.c **** 
1880:../Generated_Code/tasks.c ****                         /* See if this tick has made a timeout expire.  Tasks are stored in
1881:../Generated_Code/tasks.c ****                         the     queue in the order of their wake time - meaning once one task
1882:../Generated_Code/tasks.c ****                         has been found whose block time has not expired there is no need to
1883:../Generated_Code/tasks.c ****                         look any further        down the list. */
1884:../Generated_Code/tasks.c ****                         if( xConstTickCount >= xNextTaskUnblockTime )
 2278              		.loc 1 1884 0 is_stmt 1
 2279 0066 4F4B     		ldr	r3, .L173+20
 2280 0068 1A68     		ldr	r2, [r3]
 2281 006a 3969     		ldr	r1, [r7, #16]
 2282 006c 0023     		mov	r3, #0
 2283 006e 9142     		cmp	r1, r2
 2284 0070 5B41     		adc	r3, r3, r3
 2285 0072 DBB2     		uxtb	r3, r3
 2286 0074 002B     		cmp	r3, #0
 2287 0076 59D0     		beq	.L158
 2288 0078 00E0     		b	.L167
 2289              	.L172:
1885:../Generated_Code/tasks.c ****                         {
1886:../Generated_Code/tasks.c ****                                 for( ;; )
 2290              		.loc 1 1886 0
 2291 007a C046     		mov	r8, r8
 2292              	.L167:
1887:../Generated_Code/tasks.c ****                                 {
1888:../Generated_Code/tasks.c ****                                         if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2293              		.loc 1 1888 0
 2294 007c 464B     		ldr	r3, .L173+8
 2295 007e 1B68     		ldr	r3, [r3]
 2296 0080 1B68     		ldr	r3, [r3]
 2297 0082 002B     		cmp	r3, #0
 2298 0084 01D1     		bne	.L159
 2299              		.loc 1 1888 0 is_stmt 0
 2300 0086 0123     		mov	r3, #1
 2301 0088 00E0     		b	.L160
 2302              	.L159:
 2303              		.loc 1 1888 0
 2304 008a 0023     		mov	r3, #0
 2305              	.L160:
 2306              		.loc 1 1888 0
 2307 008c 002B     		cmp	r3, #0
 2308 008e 04D0     		beq	.L161
1889:../Generated_Code/tasks.c ****                                         {
1890:../Generated_Code/tasks.c ****                                                 /* The delayed list is empty.  Set xNextTaskUnblock
1891:../Generated_Code/tasks.c ****                                                 to the maximum possible value so it is extremely
1892:../Generated_Code/tasks.c ****                                                 unlikely that the
1893:../Generated_Code/tasks.c ****                                                 if( xTickCount >= xNextTaskUnblockTime ) test will 
1894:../Generated_Code/tasks.c ****                                                 next time through. */
1895:../Generated_Code/tasks.c ****                                                 xNextTaskUnblockTime = portMAX_DELAY;
 2309              		.loc 1 1895 0 is_stmt 1
 2310 0090 444B     		ldr	r3, .L173+20
 2311 0092 0122     		mov	r2, #1
 2312 0094 5242     		neg	r2, r2
 2313 0096 1A60     		str	r2, [r3]
1896:../Generated_Code/tasks.c ****                                                 break;
 2314              		.loc 1 1896 0
 2315 0098 48E0     		b	.L158
 2316              	.L161:
1897:../Generated_Code/tasks.c ****                                         }
1898:../Generated_Code/tasks.c ****                                         else
1899:../Generated_Code/tasks.c ****                                         {
1900:../Generated_Code/tasks.c ****                                                 /* The delayed list is not empty, get the value of 
1901:../Generated_Code/tasks.c ****                                                 item at the head of the delayed list.  This is the 
1902:../Generated_Code/tasks.c ****                                                 at which the task at the head of the delayed list m
1903:../Generated_Code/tasks.c ****                                                 be removed from the Blocked state. */
1904:../Generated_Code/tasks.c ****                                                 pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( px
 2317              		.loc 1 1904 0
 2318 009a 3F4B     		ldr	r3, .L173+8
 2319 009c 1B68     		ldr	r3, [r3]
 2320 009e DB68     		ldr	r3, [r3, #12]
 2321 00a0 DB68     		ldr	r3, [r3, #12]
 2322 00a2 BB60     		str	r3, [r7, #8]
1905:../Generated_Code/tasks.c ****                                                 xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGe
 2323              		.loc 1 1905 0
 2324 00a4 BB68     		ldr	r3, [r7, #8]
 2325 00a6 5B68     		ldr	r3, [r3, #4]
 2326 00a8 7B60     		str	r3, [r7, #4]
1906:../Generated_Code/tasks.c **** 
1907:../Generated_Code/tasks.c ****                                                 if( xConstTickCount < xItemValue )
 2327              		.loc 1 1907 0
 2328 00aa 3A69     		ldr	r2, [r7, #16]
 2329 00ac 7B68     		ldr	r3, [r7, #4]
 2330 00ae 9A42     		cmp	r2, r3
 2331 00b0 04D2     		bcs	.L163
1908:../Generated_Code/tasks.c ****                                                 {
1909:../Generated_Code/tasks.c ****                                                         /* It is not time to unblock this item yet,
1910:../Generated_Code/tasks.c ****                                                         item value is the time at which the task at
1911:../Generated_Code/tasks.c ****                                                         of the blocked list must be removed from th
1912:../Generated_Code/tasks.c ****                                                         state - so record the item value in
1913:../Generated_Code/tasks.c ****                                                         xNextTaskUnblockTime. */
1914:../Generated_Code/tasks.c ****                                                         xNextTaskUnblockTime = xItemValue;
 2332              		.loc 1 1914 0
 2333 00b2 3C4B     		ldr	r3, .L173+20
 2334 00b4 7A68     		ldr	r2, [r7, #4]
 2335 00b6 1A60     		str	r2, [r3]
1915:../Generated_Code/tasks.c ****                                                         break;
 2336              		.loc 1 1915 0
 2337 00b8 C046     		mov	r8, r8
 2338 00ba 37E0     		b	.L158
 2339              	.L163:
1916:../Generated_Code/tasks.c ****                                                 }
1917:../Generated_Code/tasks.c ****                                                 else
1918:../Generated_Code/tasks.c ****                                                 {
1919:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1920:../Generated_Code/tasks.c ****                                                 }
1921:../Generated_Code/tasks.c **** 
1922:../Generated_Code/tasks.c ****                                                 /* It is time to remove the item from the Blocked s
1923:../Generated_Code/tasks.c ****                                                 ( void ) uxListRemove( &( pxTCB->xGenericListItem )
 2340              		.loc 1 1923 0
 2341 00bc BB68     		ldr	r3, [r7, #8]
 2342 00be 0433     		add	r3, r3, #4
 2343 00c0 181C     		mov	r0, r3
 2344 00c2 FFF7FEFF 		bl	uxListRemove
1924:../Generated_Code/tasks.c **** 
1925:../Generated_Code/tasks.c ****                                                 /* Is the task waiting on an event also?  If so rem
1926:../Generated_Code/tasks.c ****                                                 it from the event list. */
1927:../Generated_Code/tasks.c ****                                                 if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListIt
 2345              		.loc 1 1927 0
 2346 00c6 BB68     		ldr	r3, [r7, #8]
 2347 00c8 9B6A     		ldr	r3, [r3, #40]
 2348 00ca 002B     		cmp	r3, #0
 2349 00cc 04D0     		beq	.L164
1928:../Generated_Code/tasks.c ****                                                 {
1929:../Generated_Code/tasks.c ****                                                         ( void ) uxListRemove( &( pxTCB->xEventList
 2350              		.loc 1 1929 0
 2351 00ce BB68     		ldr	r3, [r7, #8]
 2352 00d0 1833     		add	r3, r3, #24
 2353 00d2 181C     		mov	r0, r3
 2354 00d4 FFF7FEFF 		bl	uxListRemove
 2355              	.L164:
1930:../Generated_Code/tasks.c ****                                                 }
1931:../Generated_Code/tasks.c ****                                                 else
1932:../Generated_Code/tasks.c ****                                                 {
1933:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1934:../Generated_Code/tasks.c ****                                                 }
1935:../Generated_Code/tasks.c **** 
1936:../Generated_Code/tasks.c ****                                                 /* Place the unblocked task into the appropriate re
1937:../Generated_Code/tasks.c ****                                                 list. */
1938:../Generated_Code/tasks.c ****                                                 prvAddTaskToReadyList( pxTCB );
 2356              		.loc 1 1938 0
 2357 00d8 BB68     		ldr	r3, [r7, #8]
 2358 00da DA6A     		ldr	r2, [r3, #44]
 2359 00dc 324B     		ldr	r3, .L173+24
 2360 00de 1B68     		ldr	r3, [r3]
 2361 00e0 9342     		cmp	r3, r2
 2362 00e2 9B41     		sbc	r3, r3, r3
 2363 00e4 5B42     		neg	r3, r3
 2364 00e6 DBB2     		uxtb	r3, r3
 2365 00e8 002B     		cmp	r3, #0
 2366 00ea 03D0     		beq	.L165
 2367              		.loc 1 1938 0 is_stmt 0
 2368 00ec BB68     		ldr	r3, [r7, #8]
 2369 00ee DA6A     		ldr	r2, [r3, #44]
 2370 00f0 2D4B     		ldr	r3, .L173+24
 2371 00f2 1A60     		str	r2, [r3]
 2372              	.L165:
 2373              		.loc 1 1938 0
 2374 00f4 BB68     		ldr	r3, [r7, #8]
 2375 00f6 DA6A     		ldr	r2, [r3, #44]
 2376 00f8 131C     		mov	r3, r2
 2377 00fa 9B00     		lsl	r3, r3, #2
 2378 00fc 9B18     		add	r3, r3, r2
 2379 00fe 9B00     		lsl	r3, r3, #2
 2380 0100 2A4A     		ldr	r2, .L173+28
 2381 0102 9A18     		add	r2, r3, r2
 2382 0104 BB68     		ldr	r3, [r7, #8]
 2383 0106 0433     		add	r3, r3, #4
 2384 0108 101C     		mov	r0, r2
 2385 010a 191C     		mov	r1, r3
 2386 010c FFF7FEFF 		bl	vListInsertEnd
1939:../Generated_Code/tasks.c **** 
1940:../Generated_Code/tasks.c ****                                                 /* A task being unblocked cannot cause an immediate
1941:../Generated_Code/tasks.c ****                                                 context switch if preemption is turned off. */
1942:../Generated_Code/tasks.c ****                                                 #if (  configUSE_PREEMPTION == 1 )
1943:../Generated_Code/tasks.c ****                                                 {
1944:../Generated_Code/tasks.c ****                                                         /* Preemption is on, but a context switch s
1945:../Generated_Code/tasks.c ****                                                         only be performed if the unblocked task has
1946:../Generated_Code/tasks.c ****                                                         priority that is equal to or higher than th
1947:../Generated_Code/tasks.c ****                                                         currently executing task. */
1948:../Generated_Code/tasks.c ****                                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPr
 2387              		.loc 1 1948 0 is_stmt 1
 2388 0110 BB68     		ldr	r3, [r7, #8]
 2389 0112 D96A     		ldr	r1, [r3, #44]
 2390 0114 264B     		ldr	r3, .L173+32
 2391 0116 1B68     		ldr	r3, [r3]
 2392 0118 DA6A     		ldr	r2, [r3, #44]
 2393 011a 0023     		mov	r3, #0
 2394 011c 9142     		cmp	r1, r2
 2395 011e 5B41     		adc	r3, r3, r3
 2396 0120 DBB2     		uxtb	r3, r3
 2397 0122 002B     		cmp	r3, #0
 2398 0124 A9D0     		beq	.L172
1949:../Generated_Code/tasks.c ****                                                         {
1950:../Generated_Code/tasks.c ****                                                                 xSwitchRequired = pdTRUE;
 2399              		.loc 1 1950 0
 2400 0126 0123     		mov	r3, #1
 2401 0128 7B61     		str	r3, [r7, #20]
1886:../Generated_Code/tasks.c ****                                 for( ;; )
 2402              		.loc 1 1886 0
 2403 012a A6E7     		b	.L172
 2404              	.L158:
 2405              	.LBE22:
1951:../Generated_Code/tasks.c ****                                                         }
1952:../Generated_Code/tasks.c ****                                                         else
1953:../Generated_Code/tasks.c ****                                                         {
1954:../Generated_Code/tasks.c ****                                                                 mtCOVERAGE_TEST_MARKER();
1955:../Generated_Code/tasks.c ****                                                         }
1956:../Generated_Code/tasks.c ****                                                 }
1957:../Generated_Code/tasks.c ****                                                 #endif /* configUSE_PREEMPTION */
1958:../Generated_Code/tasks.c ****                                         }
1959:../Generated_Code/tasks.c ****                                 }
1960:../Generated_Code/tasks.c ****                         }
1961:../Generated_Code/tasks.c ****                 }
1962:../Generated_Code/tasks.c **** 
1963:../Generated_Code/tasks.c ****                 /* Tasks of equal priority to the currently running task will share
1964:../Generated_Code/tasks.c ****                 processing time (time slice) if preemption is on, and the application
1965:../Generated_Code/tasks.c ****                 writer has not explicitly turned time slicing off. */
1966:../Generated_Code/tasks.c ****                 #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1967:../Generated_Code/tasks.c ****                 {
1968:../Generated_Code/tasks.c ****                         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority
 2406              		.loc 1 1968 0
 2407 012c 204B     		ldr	r3, .L173+32
 2408 012e 1B68     		ldr	r3, [r3]
 2409 0130 DA6A     		ldr	r2, [r3, #44]
 2410 0132 1E49     		ldr	r1, .L173+28
 2411 0134 131C     		mov	r3, r2
 2412 0136 9B00     		lsl	r3, r3, #2
 2413 0138 9B18     		add	r3, r3, r2
 2414 013a 9B00     		lsl	r3, r3, #2
 2415 013c 5B58     		ldr	r3, [r3, r1]
 2416 013e 0122     		mov	r2, #1
 2417 0140 9A42     		cmp	r2, r3
 2418 0142 9B41     		sbc	r3, r3, r3
 2419 0144 5B42     		neg	r3, r3
 2420 0146 DBB2     		uxtb	r3, r3
 2421 0148 002B     		cmp	r3, #0
 2422 014a 01D0     		beq	.L168
1969:../Generated_Code/tasks.c ****                         {
1970:../Generated_Code/tasks.c ****                                 xSwitchRequired = pdTRUE;
 2423              		.loc 1 1970 0
 2424 014c 0123     		mov	r3, #1
 2425 014e 7B61     		str	r3, [r7, #20]
 2426              	.L168:
 2427              	.LBB26:
 2428              	.LBB27:
1971:../Generated_Code/tasks.c ****                         }
1972:../Generated_Code/tasks.c ****                         else
1973:../Generated_Code/tasks.c ****                         {
1974:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1975:../Generated_Code/tasks.c ****                         }
1976:../Generated_Code/tasks.c ****                 }
1977:../Generated_Code/tasks.c ****                 #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1978:../Generated_Code/tasks.c **** 
1979:../Generated_Code/tasks.c ****                 #if ( configUSE_TICK_HOOK == 1 )
1980:../Generated_Code/tasks.c ****                 {
1981:../Generated_Code/tasks.c ****                         /* Guard against the tick hook being called when the pended tick
1982:../Generated_Code/tasks.c ****                         count is being unwound (when the scheduler is being unlocked). */
1983:../Generated_Code/tasks.c ****                         if( uxPendedTicks == ( UBaseType_t ) 0U )
 2429              		.loc 1 1983 0
 2430 0150 184B     		ldr	r3, .L173+36
 2431 0152 1B68     		ldr	r3, [r3]
 2432 0154 5A42     		neg	r2, r3
 2433 0156 5341     		adc	r3, r3, r2
 2434 0158 DBB2     		uxtb	r3, r3
 2435 015a 002B     		cmp	r3, #0
 2436 015c 09D0     		beq	.L169
 2437              	.LBB28:
1984:../Generated_Code/tasks.c ****                         {
1985:../Generated_Code/tasks.c ****       extern void vApplicationTickHook( void );
1986:../Generated_Code/tasks.c ****       FreeRTOS0_vApplicationTickHook();
 2438              		.loc 1 1986 0
 2439 015e FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationTickHookv
 2440 0162 06E0     		b	.L169
 2441              	.L154:
 2442              	.LBE28:
 2443              	.LBE27:
 2444              	.LBE26:
 2445              	.LBE21:
1987:../Generated_Code/tasks.c ****                         }
1988:../Generated_Code/tasks.c ****                         else
1989:../Generated_Code/tasks.c ****                         {
1990:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1991:../Generated_Code/tasks.c ****                         }
1992:../Generated_Code/tasks.c ****                 }
1993:../Generated_Code/tasks.c ****                 #endif /* configUSE_TICK_HOOK */
1994:../Generated_Code/tasks.c ****         }
1995:../Generated_Code/tasks.c ****         else
1996:../Generated_Code/tasks.c ****         {
1997:../Generated_Code/tasks.c ****                 ++uxPendedTicks;
 2446              		.loc 1 1997 0
 2447 0164 134B     		ldr	r3, .L173+36
 2448 0166 1B68     		ldr	r3, [r3]
 2449 0168 5A1C     		add	r2, r3, #1
 2450 016a 124B     		ldr	r3, .L173+36
 2451 016c 1A60     		str	r2, [r3]
1998:../Generated_Code/tasks.c **** 
1999:../Generated_Code/tasks.c ****                 /* The tick hook gets called at regular intervals, even if the
2000:../Generated_Code/tasks.c ****                 scheduler is locked. */
2001:../Generated_Code/tasks.c ****                 #if ( configUSE_TICK_HOOK == 1 )
2002:../Generated_Code/tasks.c ****                 {
2003:../Generated_Code/tasks.c ****       FreeRTOS0_vApplicationTickHook();
 2452              		.loc 1 2003 0
 2453 016e FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationTickHookv
 2454              	.L169:
 2455              	.LBE20:
2004:../Generated_Code/tasks.c ****                 }
2005:../Generated_Code/tasks.c ****                 #endif
2006:../Generated_Code/tasks.c ****         }
2007:../Generated_Code/tasks.c **** 
2008:../Generated_Code/tasks.c ****         #if ( configUSE_PREEMPTION == 1 )
2009:../Generated_Code/tasks.c ****         {
2010:../Generated_Code/tasks.c ****                 if( xYieldPending != pdFALSE )
 2456              		.loc 1 2010 0
 2457 0172 114B     		ldr	r3, .L173+40
 2458 0174 1B68     		ldr	r3, [r3]
 2459 0176 5A1E     		sub	r2, r3, #1
 2460 0178 9341     		sbc	r3, r3, r2
 2461 017a DBB2     		uxtb	r3, r3
 2462 017c 002B     		cmp	r3, #0
 2463 017e 01D0     		beq	.L170
2011:../Generated_Code/tasks.c ****                 {
2012:../Generated_Code/tasks.c ****                         xSwitchRequired = pdTRUE;
 2464              		.loc 1 2012 0
 2465 0180 0123     		mov	r3, #1
 2466 0182 7B61     		str	r3, [r7, #20]
 2467              	.L170:
2013:../Generated_Code/tasks.c ****                 }
2014:../Generated_Code/tasks.c ****                 else
2015:../Generated_Code/tasks.c ****                 {
2016:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2017:../Generated_Code/tasks.c ****                 }
2018:../Generated_Code/tasks.c ****         }
2019:../Generated_Code/tasks.c ****         #endif /* configUSE_PREEMPTION */
2020:../Generated_Code/tasks.c **** 
2021:../Generated_Code/tasks.c ****         return xSwitchRequired;
 2468              		.loc 1 2021 0
 2469 0184 7B69     		ldr	r3, [r7, #20]
 2470              	.LBE19:
2022:../Generated_Code/tasks.c **** }
 2471              		.loc 1 2022 0
 2472 0186 181C     		mov	r0, r3
 2473 0188 BD46     		mov	sp, r7
 2474 018a 06B0     		add	sp, sp, #24
 2475              		@ sp needed for prologue
 2476 018c 80BD     		pop	{r7, pc}
 2477              	.L174:
 2478 018e C046     		.align	2
 2479              	.L173:
 2480 0190 00000000 		.word	_ZL20uxSchedulerSuspended
 2481 0194 00000000 		.word	_ZL10xTickCount
 2482 0198 00000000 		.word	_ZL17pxDelayedTaskList
 2483 019c 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 2484 01a0 00000000 		.word	_ZL15xNumOfOverflows
 2485 01a4 00000000 		.word	_ZL20xNextTaskUnblockTime
 2486 01a8 00000000 		.word	_ZL18uxTopReadyPriority
 2487 01ac 00000000 		.word	_ZL17pxReadyTasksLists
 2488 01b0 00000000 		.word	pxCurrentTCB
 2489 01b4 00000000 		.word	_ZL13uxPendedTicks
 2490 01b8 00000000 		.word	_ZL13xYieldPending
 2491              		.cfi_endproc
 2492              	.LFE26:
 2494              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2495              		.align	2
 2496              		.global	vTaskSwitchContext
 2497              		.code	16
 2498              		.thumb_func
 2500              	vTaskSwitchContext:
 2501              	.LFB27:
2023:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2024:../Generated_Code/tasks.c **** 
2025:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2026:../Generated_Code/tasks.c **** 
2027:../Generated_Code/tasks.c ****         void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2028:../Generated_Code/tasks.c ****         {
2029:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2030:../Generated_Code/tasks.c **** 
2031:../Generated_Code/tasks.c ****                 /* If xTask is NULL then it is the task hook of the calling task that is
2032:../Generated_Code/tasks.c ****                 getting set. */
2033:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2034:../Generated_Code/tasks.c ****                 {
2035:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2036:../Generated_Code/tasks.c ****                 }
2037:../Generated_Code/tasks.c ****                 else
2038:../Generated_Code/tasks.c ****                 {
2039:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2040:../Generated_Code/tasks.c ****                 }
2041:../Generated_Code/tasks.c **** 
2042:../Generated_Code/tasks.c ****                 /* Save the hook function in the TCB.  A critical section is required as
2043:../Generated_Code/tasks.c ****                 the value can be accessed from an interrupt. */
2044:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
2045:../Generated_Code/tasks.c ****                         xTCB->pxTaskTag = pxHookFunction;
2046:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
2047:../Generated_Code/tasks.c ****         }
2048:../Generated_Code/tasks.c **** 
2049:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2050:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2051:../Generated_Code/tasks.c **** 
2052:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2053:../Generated_Code/tasks.c **** 
2054:../Generated_Code/tasks.c ****         TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2055:../Generated_Code/tasks.c ****         {
2056:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2057:../Generated_Code/tasks.c ****         TaskHookFunction_t xReturn;
2058:../Generated_Code/tasks.c **** 
2059:../Generated_Code/tasks.c ****                 /* If xTask is NULL then we are setting our own task hook. */
2060:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2061:../Generated_Code/tasks.c ****                 {
2062:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2063:../Generated_Code/tasks.c ****                 }
2064:../Generated_Code/tasks.c ****                 else
2065:../Generated_Code/tasks.c ****                 {
2066:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2067:../Generated_Code/tasks.c ****                 }
2068:../Generated_Code/tasks.c **** 
2069:../Generated_Code/tasks.c ****                 /* Save the hook function in the TCB.  A critical section is required as
2070:../Generated_Code/tasks.c ****                 the value can be accessed from an interrupt. */
2071:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
2072:../Generated_Code/tasks.c ****                 {
2073:../Generated_Code/tasks.c ****                         xReturn = xTCB->pxTaskTag;
2074:../Generated_Code/tasks.c ****                 }
2075:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
2076:../Generated_Code/tasks.c **** 
2077:../Generated_Code/tasks.c ****                 return xReturn;
2078:../Generated_Code/tasks.c ****         }
2079:../Generated_Code/tasks.c **** 
2080:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2081:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2082:../Generated_Code/tasks.c **** 
2083:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2084:../Generated_Code/tasks.c **** 
2085:../Generated_Code/tasks.c ****         BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2086:../Generated_Code/tasks.c ****         {
2087:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2088:../Generated_Code/tasks.c ****         BaseType_t xReturn;
2089:../Generated_Code/tasks.c **** 
2090:../Generated_Code/tasks.c ****                 /* If xTask is NULL then we are calling our own task hook. */
2091:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2092:../Generated_Code/tasks.c ****                 {
2093:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2094:../Generated_Code/tasks.c ****                 }
2095:../Generated_Code/tasks.c ****                 else
2096:../Generated_Code/tasks.c ****                 {
2097:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2098:../Generated_Code/tasks.c ****                 }
2099:../Generated_Code/tasks.c **** 
2100:../Generated_Code/tasks.c ****                 if( xTCB->pxTaskTag != NULL )
2101:../Generated_Code/tasks.c ****                 {
2102:../Generated_Code/tasks.c ****                         xReturn = xTCB->pxTaskTag( pvParameter );
2103:../Generated_Code/tasks.c ****                 }
2104:../Generated_Code/tasks.c ****                 else
2105:../Generated_Code/tasks.c ****                 {
2106:../Generated_Code/tasks.c ****                         xReturn = pdFAIL;
2107:../Generated_Code/tasks.c ****                 }
2108:../Generated_Code/tasks.c **** 
2109:../Generated_Code/tasks.c ****                 return xReturn;
2110:../Generated_Code/tasks.c ****         }
2111:../Generated_Code/tasks.c **** 
2112:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2113:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2114:../Generated_Code/tasks.c **** 
2115:../Generated_Code/tasks.c **** void vTaskSwitchContext( void )
2116:../Generated_Code/tasks.c **** {
 2502              		.loc 1 2116 0
 2503              		.cfi_startproc
 2504 0000 80B5     		push	{r7, lr}
 2505              	.LCFI51:
 2506              		.cfi_def_cfa_offset 8
 2507              		.cfi_offset 7, -8
 2508              		.cfi_offset 14, -4
 2509 0002 82B0     		sub	sp, sp, #8
 2510              	.LCFI52:
 2511              		.cfi_def_cfa_offset 16
 2512 0004 00AF     		add	r7, sp, #0
 2513              	.LCFI53:
 2514              		.cfi_def_cfa_register 7
 2515              	.LBB29:
 2516              	.LBB30:
2117:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2517              		.loc 1 2117 0
 2518 0006 304B     		ldr	r3, .L184
 2519 0008 1B68     		ldr	r3, [r3]
 2520 000a 5A1E     		sub	r2, r3, #1
 2521 000c 9341     		sbc	r3, r3, r2
 2522 000e DBB2     		uxtb	r3, r3
 2523 0010 002B     		cmp	r3, #0
 2524 0012 03D0     		beq	.L176
2118:../Generated_Code/tasks.c ****         {
2119:../Generated_Code/tasks.c ****                 /* The scheduler is currently suspended - do not allow a context
2120:../Generated_Code/tasks.c ****                 switch. */
2121:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 2525              		.loc 1 2121 0
 2526 0014 2D4B     		ldr	r3, .L184+4
 2527 0016 0122     		mov	r2, #1
 2528 0018 1A60     		str	r2, [r3]
 2529 001a 51E0     		b	.L175
 2530              	.L176:
 2531              	.LBB31:
2122:../Generated_Code/tasks.c ****         }
2123:../Generated_Code/tasks.c ****         else
2124:../Generated_Code/tasks.c ****         {
2125:../Generated_Code/tasks.c ****                 xYieldPending = pdFALSE;
 2532              		.loc 1 2125 0
 2533 001c 2B4B     		ldr	r3, .L184+4
 2534 001e 0022     		mov	r2, #0
 2535 0020 1A60     		str	r2, [r3]
2126:../Generated_Code/tasks.c ****                 traceTASK_SWITCHED_OUT();
2127:../Generated_Code/tasks.c **** 
2128:../Generated_Code/tasks.c ****                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2129:../Generated_Code/tasks.c ****                 {
2130:../Generated_Code/tasks.c ****                                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2131:../Generated_Code/tasks.c ****                                         portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2132:../Generated_Code/tasks.c ****                                 #else
2133:../Generated_Code/tasks.c ****                                         ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2134:../Generated_Code/tasks.c ****                                 #endif
2135:../Generated_Code/tasks.c **** 
2136:../Generated_Code/tasks.c ****                                 /* Add the amount of time the task has been running to the
2137:../Generated_Code/tasks.c ****                                 accumulated     time so far.  The time the task started running was
2138:../Generated_Code/tasks.c ****                                 stored in ulTaskSwitchedInTime.  Note that there is no overflow
2139:../Generated_Code/tasks.c ****                                 protection here so count values are only valid until the timer
2140:../Generated_Code/tasks.c ****                                 overflows.  The guard against negative values is to protect
2141:../Generated_Code/tasks.c ****                                 against suspect run time stat counter implementations - which
2142:../Generated_Code/tasks.c ****                                 are provided by the application, not the kernel. */
2143:../Generated_Code/tasks.c ****                                 if( ulTotalRunTime > ulTaskSwitchedInTime )
2144:../Generated_Code/tasks.c ****                                 {
2145:../Generated_Code/tasks.c ****                                         pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTask
2146:../Generated_Code/tasks.c ****                                 }
2147:../Generated_Code/tasks.c ****                                 else
2148:../Generated_Code/tasks.c ****                                 {
2149:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
2150:../Generated_Code/tasks.c ****                                 }
2151:../Generated_Code/tasks.c ****                                 ulTaskSwitchedInTime = ulTotalRunTime;
2152:../Generated_Code/tasks.c ****                 }
2153:../Generated_Code/tasks.c ****                 #endif /* configGENERATE_RUN_TIME_STATS */
2154:../Generated_Code/tasks.c **** 
2155:../Generated_Code/tasks.c ****                 taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2536              		.loc 1 2155 0
 2537 0022 2B4B     		ldr	r3, .L184+8
 2538 0024 1B68     		ldr	r3, [r3]
 2539 0026 1A68     		ldr	r2, [r3]
 2540 0028 294B     		ldr	r3, .L184+8
 2541 002a 1B68     		ldr	r3, [r3]
 2542 002c 196B     		ldr	r1, [r3, #48]
 2543 002e 0023     		mov	r3, #0
 2544 0030 9142     		cmp	r1, r2
 2545 0032 5B41     		adc	r3, r3, r3
 2546 0034 DBB2     		uxtb	r3, r3
 2547 0036 002B     		cmp	r3, #0
 2548 0038 17D0     		beq	.L179
 2549              		.loc 1 2155 0 is_stmt 0
 2550 003a 254B     		ldr	r3, .L184+8
 2551 003c 1A68     		ldr	r2, [r3]
 2552 003e 244B     		ldr	r3, .L184+8
 2553 0040 1B68     		ldr	r3, [r3]
 2554 0042 3433     		add	r3, r3, #52
 2555 0044 101C     		mov	r0, r2
 2556 0046 191C     		mov	r1, r3
 2557 0048 FFF7FEFF 		bl	_Z39FreeRTOS0_vApplicationStackOverflowHookPvPc
 2558              	.LBB32:
2156:../Generated_Code/tasks.c ****                 taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2157:../Generated_Code/tasks.c **** 
2158:../Generated_Code/tasks.c ****                 taskSELECT_HIGHEST_PRIORITY_TASK();
 2559              		.loc 1 2158 0 is_stmt 1
 2560 004c 0DE0     		b	.L179
 2561              	.L182:
 2562              		.loc 1 2158 0 is_stmt 0
 2563 004e 214B     		ldr	r3, .L184+12
 2564 0050 1B68     		ldr	r3, [r3]
 2565 0052 5A42     		neg	r2, r3
 2566 0054 5341     		adc	r3, r3, r2
 2567 0056 DBB2     		uxtb	r3, r3
 2568 0058 002B     		cmp	r3, #0
 2569 005a 01D0     		beq	.L180
 2570              		.loc 1 2158 0
 2571              	@ 2158 "../Generated_Code/tasks.c" 1
 2572 005c 72B6     		cpsid i
 2573              	@ 0 "" 2
 2574              		.code	16
 2575              	.L181:
 2576              		.loc 1 2158 0
 2577 005e FEE7     		b	.L181
 2578              	.L180:
 2579              		.loc 1 2158 0
 2580 0060 1C4B     		ldr	r3, .L184+12
 2581 0062 1B68     		ldr	r3, [r3]
 2582 0064 5A1E     		sub	r2, r3, #1
 2583 0066 1B4B     		ldr	r3, .L184+12
 2584 0068 1A60     		str	r2, [r3]
 2585              	.L179:
 2586              		.loc 1 2158 0
 2587 006a 1A4B     		ldr	r3, .L184+12
 2588 006c 1A68     		ldr	r2, [r3]
 2589 006e 1A49     		ldr	r1, .L184+16
 2590 0070 131C     		mov	r3, r2
 2591 0072 9B00     		lsl	r3, r3, #2
 2592 0074 9B18     		add	r3, r3, r2
 2593 0076 9B00     		lsl	r3, r3, #2
 2594 0078 5B58     		ldr	r3, [r3, r1]
 2595 007a 5A42     		neg	r2, r3
 2596 007c 5341     		adc	r3, r3, r2
 2597 007e DBB2     		uxtb	r3, r3
 2598 0080 002B     		cmp	r3, #0
 2599 0082 E4D1     		bne	.L182
 2600              	.LBB33:
 2601              		.loc 1 2158 0
 2602 0084 134B     		ldr	r3, .L184+12
 2603 0086 1A68     		ldr	r2, [r3]
 2604 0088 131C     		mov	r3, r2
 2605 008a 9B00     		lsl	r3, r3, #2
 2606 008c 9B18     		add	r3, r3, r2
 2607 008e 9B00     		lsl	r3, r3, #2
 2608 0090 114A     		ldr	r2, .L184+16
 2609 0092 9B18     		add	r3, r3, r2
 2610 0094 7B60     		str	r3, [r7, #4]
 2611 0096 7B68     		ldr	r3, [r7, #4]
 2612 0098 5B68     		ldr	r3, [r3, #4]
 2613 009a 5A68     		ldr	r2, [r3, #4]
 2614 009c 7B68     		ldr	r3, [r7, #4]
 2615 009e 5A60     		str	r2, [r3, #4]
 2616 00a0 7B68     		ldr	r3, [r7, #4]
 2617 00a2 5A68     		ldr	r2, [r3, #4]
 2618 00a4 7B68     		ldr	r3, [r7, #4]
 2619 00a6 0833     		add	r3, r3, #8
 2620 00a8 9A42     		cmp	r2, r3
 2621 00aa 04D1     		bne	.L183
 2622              		.loc 1 2158 0
 2623 00ac 7B68     		ldr	r3, [r7, #4]
 2624 00ae 5B68     		ldr	r3, [r3, #4]
 2625 00b0 5A68     		ldr	r2, [r3, #4]
 2626 00b2 7B68     		ldr	r3, [r7, #4]
 2627 00b4 5A60     		str	r2, [r3, #4]
 2628              	.L183:
 2629              		.loc 1 2158 0
 2630 00b6 7B68     		ldr	r3, [r7, #4]
 2631 00b8 5B68     		ldr	r3, [r3, #4]
 2632 00ba DA68     		ldr	r2, [r3, #12]
 2633 00bc 044B     		ldr	r3, .L184+8
 2634 00be 1A60     		str	r2, [r3]
 2635              	.L175:
 2636              	.LBE33:
 2637              	.LBE32:
 2638              	.LBE31:
 2639              	.LBE30:
 2640              	.LBE29:
2159:../Generated_Code/tasks.c **** 
2160:../Generated_Code/tasks.c ****                 traceTASK_SWITCHED_IN();
2161:../Generated_Code/tasks.c **** 
2162:../Generated_Code/tasks.c ****                 #if ( configUSE_NEWLIB_REENTRANT == 1 )
2163:../Generated_Code/tasks.c ****                 {
2164:../Generated_Code/tasks.c ****                         /* Switch Newlib's _impure_ptr variable to point to the _reent
2165:../Generated_Code/tasks.c ****                         structure specific to this task. */
2166:../Generated_Code/tasks.c ****                         _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2167:../Generated_Code/tasks.c ****                 }
2168:../Generated_Code/tasks.c ****                 #endif /* configUSE_NEWLIB_REENTRANT */
2169:../Generated_Code/tasks.c ****         }
2170:../Generated_Code/tasks.c **** }
 2641              		.loc 1 2170 0 is_stmt 1
 2642 00c0 BD46     		mov	sp, r7
 2643 00c2 02B0     		add	sp, sp, #8
 2644              		@ sp needed for prologue
 2645 00c4 80BD     		pop	{r7, pc}
 2646              	.L185:
 2647 00c6 C046     		.align	2
 2648              	.L184:
 2649 00c8 00000000 		.word	_ZL20uxSchedulerSuspended
 2650 00cc 00000000 		.word	_ZL13xYieldPending
 2651 00d0 00000000 		.word	pxCurrentTCB
 2652 00d4 00000000 		.word	_ZL18uxTopReadyPriority
 2653 00d8 00000000 		.word	_ZL17pxReadyTasksLists
 2654              		.cfi_endproc
 2655              	.LFE27:
 2657              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2658              		.align	2
 2659              		.global	vTaskPlaceOnEventList
 2660              		.code	16
 2661              		.thumb_func
 2663              	vTaskPlaceOnEventList:
 2664              	.LFB28:
2171:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2172:../Generated_Code/tasks.c **** 
2173:../Generated_Code/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2174:../Generated_Code/tasks.c **** {
 2665              		.loc 1 2174 0
 2666              		.cfi_startproc
 2667 0000 80B5     		push	{r7, lr}
 2668              	.LCFI54:
 2669              		.cfi_def_cfa_offset 8
 2670              		.cfi_offset 7, -8
 2671              		.cfi_offset 14, -4
 2672 0002 84B0     		sub	sp, sp, #16
 2673              	.LCFI55:
 2674              		.cfi_def_cfa_offset 24
 2675 0004 00AF     		add	r7, sp, #0
 2676              	.LCFI56:
 2677              		.cfi_def_cfa_register 7
 2678 0006 7860     		str	r0, [r7, #4]
 2679 0008 3960     		str	r1, [r7]
 2680              	.LBB34:
2175:../Generated_Code/tasks.c **** TickType_t xTimeToWake;
2176:../Generated_Code/tasks.c **** 
2177:../Generated_Code/tasks.c ****         configASSERT( pxEventList );
 2681              		.loc 1 2177 0
 2682 000a 7B68     		ldr	r3, [r7, #4]
 2683 000c 002B     		cmp	r3, #0
 2684 000e 01D1     		bne	.L187
 2685              		.loc 1 2177 0 is_stmt 0
 2686              	@ 2177 "../Generated_Code/tasks.c" 1
 2687 0010 72B6     		cpsid i
 2688              	@ 0 "" 2
 2689              		.code	16
 2690              	.L188:
 2691              		.loc 1 2177 0
 2692 0012 FEE7     		b	.L188
 2693              	.L187:
2178:../Generated_Code/tasks.c **** 
2179:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2180:../Generated_Code/tasks.c ****         SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2181:../Generated_Code/tasks.c **** 
2182:../Generated_Code/tasks.c ****         /* Place the event list item of the TCB in the appropriate event list.
2183:../Generated_Code/tasks.c ****         This is placed in the list in priority order so the highest priority task
2184:../Generated_Code/tasks.c ****         is the first to be woken by the event.  The queue that contains the event
2185:../Generated_Code/tasks.c ****         list is locked, preventing simultaneous access from interrupts. */
2186:../Generated_Code/tasks.c ****         vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2694              		.loc 1 2186 0 is_stmt 1
 2695 0014 124B     		ldr	r3, .L191
 2696 0016 1B68     		ldr	r3, [r3]
 2697 0018 1833     		add	r3, r3, #24
 2698 001a 7A68     		ldr	r2, [r7, #4]
 2699 001c 101C     		mov	r0, r2
 2700 001e 191C     		mov	r1, r3
 2701 0020 FFF7FEFF 		bl	vListInsert
2187:../Generated_Code/tasks.c **** 
2188:../Generated_Code/tasks.c ****         /* The task must be removed from from the ready list before it is added to
2189:../Generated_Code/tasks.c ****         the blocked list as the same list item is used for both lists.  Exclusive
2190:../Generated_Code/tasks.c ****         access to the ready lists guaranteed because the scheduler is locked. */
2191:../Generated_Code/tasks.c ****         if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2702              		.loc 1 2191 0
 2703 0024 0E4B     		ldr	r3, .L191
 2704 0026 1B68     		ldr	r3, [r3]
 2705 0028 0433     		add	r3, r3, #4
 2706 002a 181C     		mov	r0, r3
 2707 002c FFF7FEFF 		bl	uxListRemove
2192:../Generated_Code/tasks.c ****         {
2193:../Generated_Code/tasks.c ****                 /* The current task must be in a ready list, so there is no need to
2194:../Generated_Code/tasks.c ****                 check, and the port reset macro can be called directly. */
2195:../Generated_Code/tasks.c ****                 portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2196:../Generated_Code/tasks.c ****         }
2197:../Generated_Code/tasks.c ****         else
2198:../Generated_Code/tasks.c ****         {
2199:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2200:../Generated_Code/tasks.c ****         }
2201:../Generated_Code/tasks.c **** 
2202:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2203:../Generated_Code/tasks.c ****         {
2204:../Generated_Code/tasks.c ****                 if( xTicksToWait == portMAX_DELAY )
 2708              		.loc 1 2204 0
 2709 0030 3B68     		ldr	r3, [r7]
 2710 0032 0133     		add	r3, r3, #1
 2711 0034 08D1     		bne	.L189
2205:../Generated_Code/tasks.c ****                 {
2206:../Generated_Code/tasks.c ****                         /* Add the task to the suspended task list instead of a delayed task
2207:../Generated_Code/tasks.c ****                         list to ensure the task is not woken by a timing event.  It will
2208:../Generated_Code/tasks.c ****                         block indefinitely. */
2209:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2712              		.loc 1 2209 0
 2713 0036 0A4B     		ldr	r3, .L191
 2714 0038 1B68     		ldr	r3, [r3]
 2715 003a 0433     		add	r3, r3, #4
 2716 003c 094A     		ldr	r2, .L191+4
 2717 003e 101C     		mov	r0, r2
 2718 0040 191C     		mov	r1, r3
 2719 0042 FFF7FEFF 		bl	vListInsertEnd
 2720 0046 08E0     		b	.L186
 2721              	.L189:
2210:../Generated_Code/tasks.c ****                 }
2211:../Generated_Code/tasks.c ****                 else
2212:../Generated_Code/tasks.c ****                 {
2213:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event
2214:../Generated_Code/tasks.c ****                         does not occur.  This may overflow but this doesn't matter, the
2215:../Generated_Code/tasks.c ****                         scheduler will handle it. */
2216:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
 2722              		.loc 1 2216 0
 2723 0048 074B     		ldr	r3, .L191+8
 2724 004a 1A68     		ldr	r2, [r3]
 2725 004c 3B68     		ldr	r3, [r7]
 2726 004e D318     		add	r3, r2, r3
 2727 0050 FB60     		str	r3, [r7, #12]
2217:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
 2728              		.loc 1 2217 0
 2729 0052 FB68     		ldr	r3, [r7, #12]
 2730 0054 181C     		mov	r0, r3
 2731 0056 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 2732              	.L186:
 2733              	.LBE34:
2218:../Generated_Code/tasks.c ****                 }
2219:../Generated_Code/tasks.c ****         }
2220:../Generated_Code/tasks.c ****         #else /* INCLUDE_vTaskSuspend */
2221:../Generated_Code/tasks.c ****         {
2222:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event does
2223:../Generated_Code/tasks.c ****                         not occur.  This may overflow but this doesn't matter, the scheduler
2224:../Generated_Code/tasks.c ****                         will handle it. */
2225:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
2226:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
2227:../Generated_Code/tasks.c ****         }
2228:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2229:../Generated_Code/tasks.c **** }
 2734              		.loc 1 2229 0
 2735 005a BD46     		mov	sp, r7
 2736 005c 04B0     		add	sp, sp, #16
 2737              		@ sp needed for prologue
 2738 005e 80BD     		pop	{r7, pc}
 2739              	.L192:
 2740              		.align	2
 2741              	.L191:
 2742 0060 00000000 		.word	pxCurrentTCB
 2743 0064 00000000 		.word	_ZL18xSuspendedTaskList
 2744 0068 00000000 		.word	_ZL10xTickCount
 2745              		.cfi_endproc
 2746              	.LFE28:
 2748              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2749              		.align	2
 2750              		.global	vTaskPlaceOnUnorderedEventList
 2751              		.code	16
 2752              		.thumb_func
 2754              	vTaskPlaceOnUnorderedEventList:
 2755              	.LFB29:
2230:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2231:../Generated_Code/tasks.c **** 
2232:../Generated_Code/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2233:../Generated_Code/tasks.c **** {
 2756              		.loc 1 2233 0
 2757              		.cfi_startproc
 2758 0000 80B5     		push	{r7, lr}
 2759              	.LCFI57:
 2760              		.cfi_def_cfa_offset 8
 2761              		.cfi_offset 7, -8
 2762              		.cfi_offset 14, -4
 2763 0002 86B0     		sub	sp, sp, #24
 2764              	.LCFI58:
 2765              		.cfi_def_cfa_offset 32
 2766 0004 00AF     		add	r7, sp, #0
 2767              	.LCFI59:
 2768              		.cfi_def_cfa_register 7
 2769 0006 F860     		str	r0, [r7, #12]
 2770 0008 B960     		str	r1, [r7, #8]
 2771 000a 7A60     		str	r2, [r7, #4]
 2772              	.LBB35:
2234:../Generated_Code/tasks.c **** TickType_t xTimeToWake;
2235:../Generated_Code/tasks.c **** 
2236:../Generated_Code/tasks.c ****         configASSERT( pxEventList );
 2773              		.loc 1 2236 0
 2774 000c FB68     		ldr	r3, [r7, #12]
 2775 000e 002B     		cmp	r3, #0
 2776 0010 01D1     		bne	.L194
 2777              		.loc 1 2236 0 is_stmt 0
 2778              	@ 2236 "../Generated_Code/tasks.c" 1
 2779 0012 72B6     		cpsid i
 2780              	@ 0 "" 2
 2781              		.code	16
 2782              	.L195:
 2783              		.loc 1 2236 0
 2784 0014 FEE7     		b	.L195
 2785              	.L194:
2237:../Generated_Code/tasks.c **** 
2238:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2239:../Generated_Code/tasks.c ****         the event groups implementation. */
2240:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended != 0 );
 2786              		.loc 1 2240 0 is_stmt 1
 2787 0016 1B4B     		ldr	r3, .L200
 2788 0018 1B68     		ldr	r3, [r3]
 2789 001a 5A42     		neg	r2, r3
 2790 001c 5341     		adc	r3, r3, r2
 2791 001e DBB2     		uxtb	r3, r3
 2792 0020 002B     		cmp	r3, #0
 2793 0022 01D0     		beq	.L196
 2794              		.loc 1 2240 0 is_stmt 0
 2795              	@ 2240 "../Generated_Code/tasks.c" 1
 2796 0024 72B6     		cpsid i
 2797              	@ 0 "" 2
 2798              		.code	16
 2799              	.L197:
 2800              		.loc 1 2240 0
 2801 0026 FEE7     		b	.L197
 2802              	.L196:
2241:../Generated_Code/tasks.c **** 
2242:../Generated_Code/tasks.c ****         /* Store the item value in the event list item.  It is safe to access the
2243:../Generated_Code/tasks.c ****         event list item here as interrupts won't access the event list item of a
2244:../Generated_Code/tasks.c ****         task that is not in the Blocked state. */
2245:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITE
 2803              		.loc 1 2245 0 is_stmt 1
 2804 0028 174B     		ldr	r3, .L200+4
 2805 002a 1B68     		ldr	r3, [r3]
 2806 002c BA68     		ldr	r2, [r7, #8]
 2807 002e 8021     		mov	r1, #128
 2808 0030 0906     		lsl	r1, r1, #24
 2809 0032 0A43     		orr	r2, r1
 2810 0034 9A61     		str	r2, [r3, #24]
2246:../Generated_Code/tasks.c **** 
2247:../Generated_Code/tasks.c ****         /* Place the event list item of the TCB at the end of the appropriate event
2248:../Generated_Code/tasks.c ****         list.  It is safe to access the event list here because it is part of an
2249:../Generated_Code/tasks.c ****         event group implementation - and interrupts don't access event groups
2250:../Generated_Code/tasks.c ****         directly (instead they access them indirectly by pending function calls to
2251:../Generated_Code/tasks.c ****         the task level). */
2252:../Generated_Code/tasks.c ****         vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2811              		.loc 1 2252 0
 2812 0036 144B     		ldr	r3, .L200+4
 2813 0038 1B68     		ldr	r3, [r3]
 2814 003a 1833     		add	r3, r3, #24
 2815 003c FA68     		ldr	r2, [r7, #12]
 2816 003e 101C     		mov	r0, r2
 2817 0040 191C     		mov	r1, r3
 2818 0042 FFF7FEFF 		bl	vListInsertEnd
2253:../Generated_Code/tasks.c **** 
2254:../Generated_Code/tasks.c ****         /* The task must be removed from the ready list before it is added to the
2255:../Generated_Code/tasks.c ****         blocked list.  Exclusive access can be assured to the ready list as the
2256:../Generated_Code/tasks.c ****         scheduler is locked. */
2257:../Generated_Code/tasks.c ****         if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2819              		.loc 1 2257 0
 2820 0046 104B     		ldr	r3, .L200+4
 2821 0048 1B68     		ldr	r3, [r3]
 2822 004a 0433     		add	r3, r3, #4
 2823 004c 181C     		mov	r0, r3
 2824 004e FFF7FEFF 		bl	uxListRemove
2258:../Generated_Code/tasks.c ****         {
2259:../Generated_Code/tasks.c ****                 /* The current task must be in a ready list, so there is no need to
2260:../Generated_Code/tasks.c ****                 check, and the port reset macro can be called directly. */
2261:../Generated_Code/tasks.c ****                 portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2262:../Generated_Code/tasks.c ****         }
2263:../Generated_Code/tasks.c ****         else
2264:../Generated_Code/tasks.c ****         {
2265:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2266:../Generated_Code/tasks.c ****         }
2267:../Generated_Code/tasks.c **** 
2268:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2269:../Generated_Code/tasks.c ****         {
2270:../Generated_Code/tasks.c ****                 if( xTicksToWait == portMAX_DELAY )
 2825              		.loc 1 2270 0
 2826 0052 7B68     		ldr	r3, [r7, #4]
 2827 0054 0133     		add	r3, r3, #1
 2828 0056 08D1     		bne	.L198
2271:../Generated_Code/tasks.c ****                 {
2272:../Generated_Code/tasks.c ****                         /* Add the task to the suspended task list instead of a delayed task
2273:../Generated_Code/tasks.c ****                         list to ensure it is not woken by a timing event.  It will block
2274:../Generated_Code/tasks.c ****                         indefinitely. */
2275:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2829              		.loc 1 2275 0
 2830 0058 0B4B     		ldr	r3, .L200+4
 2831 005a 1B68     		ldr	r3, [r3]
 2832 005c 0433     		add	r3, r3, #4
 2833 005e 0B4A     		ldr	r2, .L200+8
 2834 0060 101C     		mov	r0, r2
 2835 0062 191C     		mov	r1, r3
 2836 0064 FFF7FEFF 		bl	vListInsertEnd
 2837 0068 08E0     		b	.L193
 2838              	.L198:
2276:../Generated_Code/tasks.c ****                 }
2277:../Generated_Code/tasks.c ****                 else
2278:../Generated_Code/tasks.c ****                 {
2279:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event
2280:../Generated_Code/tasks.c ****                         does not occur.  This may overflow but this doesn't matter, the
2281:../Generated_Code/tasks.c ****                         kernel will manage it correctly. */
2282:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
 2839              		.loc 1 2282 0
 2840 006a 094B     		ldr	r3, .L200+12
 2841 006c 1A68     		ldr	r2, [r3]
 2842 006e 7B68     		ldr	r3, [r7, #4]
 2843 0070 D318     		add	r3, r2, r3
 2844 0072 7B61     		str	r3, [r7, #20]
2283:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
 2845              		.loc 1 2283 0
 2846 0074 7B69     		ldr	r3, [r7, #20]
 2847 0076 181C     		mov	r0, r3
 2848 0078 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 2849              	.L193:
 2850              	.LBE35:
2284:../Generated_Code/tasks.c ****                 }
2285:../Generated_Code/tasks.c ****         }
2286:../Generated_Code/tasks.c ****         #else /* INCLUDE_vTaskSuspend */
2287:../Generated_Code/tasks.c ****         {
2288:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event does
2289:../Generated_Code/tasks.c ****                         not occur.  This may overflow but this doesn't matter, the kernel
2290:../Generated_Code/tasks.c ****                         will manage it correctly. */
2291:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
2292:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
2293:../Generated_Code/tasks.c ****         }
2294:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2295:../Generated_Code/tasks.c **** }
 2851              		.loc 1 2295 0
 2852 007c BD46     		mov	sp, r7
 2853 007e 06B0     		add	sp, sp, #24
 2854              		@ sp needed for prologue
 2855 0080 80BD     		pop	{r7, pc}
 2856              	.L201:
 2857 0082 C046     		.align	2
 2858              	.L200:
 2859 0084 00000000 		.word	_ZL20uxSchedulerSuspended
 2860 0088 00000000 		.word	pxCurrentTCB
 2861 008c 00000000 		.word	_ZL18xSuspendedTaskList
 2862 0090 00000000 		.word	_ZL10xTickCount
 2863              		.cfi_endproc
 2864              	.LFE29:
 2866              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2867              		.align	2
 2868              		.global	xTaskRemoveFromEventList
 2869              		.code	16
 2870              		.thumb_func
 2872              	xTaskRemoveFromEventList:
 2873              	.LFB30:
2296:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2297:../Generated_Code/tasks.c **** 
2298:../Generated_Code/tasks.c **** #if configUSE_TIMERS == 1
2299:../Generated_Code/tasks.c **** 
2300:../Generated_Code/tasks.c ****         void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksTo
2301:../Generated_Code/tasks.c ****         {
2302:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
2303:../Generated_Code/tasks.c **** 
2304:../Generated_Code/tasks.c ****                 configASSERT( pxEventList );
2305:../Generated_Code/tasks.c **** 
2306:../Generated_Code/tasks.c ****                 /* This function should not be called by application code hence the
2307:../Generated_Code/tasks.c ****                 'Restricted' in its name.  It is not part of the public API.  It is
2308:../Generated_Code/tasks.c ****                 designed for use by kernel code, and has special calling requirements -
2309:../Generated_Code/tasks.c ****                 it should be called from a critical section. */
2310:../Generated_Code/tasks.c **** 
2311:../Generated_Code/tasks.c **** 
2312:../Generated_Code/tasks.c ****                 /* Place the event list item of the TCB in the appropriate event list.
2313:../Generated_Code/tasks.c ****                 In this case it is assume that this is the only task that is going to
2314:../Generated_Code/tasks.c ****                 be waiting on this event list, so the faster vListInsertEnd() function
2315:../Generated_Code/tasks.c ****                 can be used in place of vListInsert. */
2316:../Generated_Code/tasks.c ****                 vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2317:../Generated_Code/tasks.c **** 
2318:../Generated_Code/tasks.c ****                 /* We must remove this task from the ready list before adding it to the
2319:../Generated_Code/tasks.c ****                 blocked list as the same list item is used for both lists.  This
2320:../Generated_Code/tasks.c ****                 function is called form a critical section. */
2321:../Generated_Code/tasks.c ****                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2322:../Generated_Code/tasks.c ****                 {
2323:../Generated_Code/tasks.c ****                         /* The current task must be in a ready list, so there is no need to
2324:../Generated_Code/tasks.c ****                         check, and the port reset macro can be called directly. */
2325:../Generated_Code/tasks.c ****                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2326:../Generated_Code/tasks.c ****                 }
2327:../Generated_Code/tasks.c ****                 else
2328:../Generated_Code/tasks.c ****                 {
2329:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2330:../Generated_Code/tasks.c ****                 }
2331:../Generated_Code/tasks.c **** 
2332:../Generated_Code/tasks.c ****                 /* Calculate the time at which the task should be woken if the event does
2333:../Generated_Code/tasks.c ****                 not occur.  This may overflow but this doesn't matter. */
2334:../Generated_Code/tasks.c ****                 xTimeToWake = xTickCount + xTicksToWait;
2335:../Generated_Code/tasks.c **** 
2336:../Generated_Code/tasks.c ****                 traceTASK_DELAY_UNTIL();
2337:../Generated_Code/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTimeToWake );
2338:../Generated_Code/tasks.c ****         }
2339:../Generated_Code/tasks.c **** 
2340:../Generated_Code/tasks.c **** #endif /* configUSE_TIMERS */
2341:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2342:../Generated_Code/tasks.c **** 
2343:../Generated_Code/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2344:../Generated_Code/tasks.c **** {
 2874              		.loc 1 2344 0
 2875              		.cfi_startproc
 2876 0000 80B5     		push	{r7, lr}
 2877              	.LCFI60:
 2878              		.cfi_def_cfa_offset 8
 2879              		.cfi_offset 7, -8
 2880              		.cfi_offset 14, -4
 2881 0002 84B0     		sub	sp, sp, #16
 2882              	.LCFI61:
 2883              		.cfi_def_cfa_offset 24
 2884 0004 00AF     		add	r7, sp, #0
 2885              	.LCFI62:
 2886              		.cfi_def_cfa_register 7
 2887 0006 7860     		str	r0, [r7, #4]
 2888              	.LBB36:
2345:../Generated_Code/tasks.c **** TCB_t *pxUnblockedTCB;
2346:../Generated_Code/tasks.c **** BaseType_t xReturn;
2347:../Generated_Code/tasks.c **** 
2348:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2349:../Generated_Code/tasks.c ****         called from a critical section within an ISR. */
2350:../Generated_Code/tasks.c **** 
2351:../Generated_Code/tasks.c ****         /* The event list is sorted in priority order, so the first in the list can
2352:../Generated_Code/tasks.c ****         be removed as it is known to be the highest priority.  Remove the TCB from
2353:../Generated_Code/tasks.c ****         the delayed list, and add it to the ready list.
2354:../Generated_Code/tasks.c **** 
2355:../Generated_Code/tasks.c ****         If an event is for a queue that is locked then this function will never
2356:../Generated_Code/tasks.c ****         get called - the lock count on the queue will get modified instead.  This
2357:../Generated_Code/tasks.c ****         means exclusive access to the event list is guaranteed here.
2358:../Generated_Code/tasks.c **** 
2359:../Generated_Code/tasks.c ****         This function assumes that a check has already been made to ensure that
2360:../Generated_Code/tasks.c ****         pxEventList is not empty. */
2361:../Generated_Code/tasks.c ****         pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2889              		.loc 1 2361 0
 2890 0008 7B68     		ldr	r3, [r7, #4]
 2891 000a DB68     		ldr	r3, [r3, #12]
 2892 000c DB68     		ldr	r3, [r3, #12]
 2893 000e BB60     		str	r3, [r7, #8]
2362:../Generated_Code/tasks.c ****         configASSERT( pxUnblockedTCB );
 2894              		.loc 1 2362 0
 2895 0010 BB68     		ldr	r3, [r7, #8]
 2896 0012 002B     		cmp	r3, #0
 2897 0014 01D1     		bne	.L203
 2898              		.loc 1 2362 0 is_stmt 0
 2899              	@ 2362 "../Generated_Code/tasks.c" 1
 2900 0016 72B6     		cpsid i
 2901              	@ 0 "" 2
 2902              		.code	16
 2903              	.L204:
 2904              		.loc 1 2362 0
 2905 0018 FEE7     		b	.L204
 2906              	.L203:
2363:../Generated_Code/tasks.c ****         ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2907              		.loc 1 2363 0 is_stmt 1
 2908 001a BB68     		ldr	r3, [r7, #8]
 2909 001c 1833     		add	r3, r3, #24
 2910 001e 181C     		mov	r0, r3
 2911 0020 FFF7FEFF 		bl	uxListRemove
2364:../Generated_Code/tasks.c **** 
2365:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2912              		.loc 1 2365 0
 2913 0024 234B     		ldr	r3, .L211
 2914 0026 1B68     		ldr	r3, [r3]
 2915 0028 5A42     		neg	r2, r3
 2916 002a 5341     		adc	r3, r3, r2
 2917 002c DBB2     		uxtb	r3, r3
 2918 002e 002B     		cmp	r3, #0
 2919 0030 21D0     		beq	.L205
2366:../Generated_Code/tasks.c ****         {
2367:../Generated_Code/tasks.c ****                 ( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2920              		.loc 1 2367 0
 2921 0032 BB68     		ldr	r3, [r7, #8]
 2922 0034 0433     		add	r3, r3, #4
 2923 0036 181C     		mov	r0, r3
 2924 0038 FFF7FEFF 		bl	uxListRemove
2368:../Generated_Code/tasks.c ****                 prvAddTaskToReadyList( pxUnblockedTCB );
 2925              		.loc 1 2368 0
 2926 003c BB68     		ldr	r3, [r7, #8]
 2927 003e DA6A     		ldr	r2, [r3, #44]
 2928 0040 1D4B     		ldr	r3, .L211+4
 2929 0042 1B68     		ldr	r3, [r3]
 2930 0044 9342     		cmp	r3, r2
 2931 0046 9B41     		sbc	r3, r3, r3
 2932 0048 5B42     		neg	r3, r3
 2933 004a DBB2     		uxtb	r3, r3
 2934 004c 002B     		cmp	r3, #0
 2935 004e 03D0     		beq	.L206
 2936              		.loc 1 2368 0 is_stmt 0
 2937 0050 BB68     		ldr	r3, [r7, #8]
 2938 0052 DA6A     		ldr	r2, [r3, #44]
 2939 0054 184B     		ldr	r3, .L211+4
 2940 0056 1A60     		str	r2, [r3]
 2941              	.L206:
 2942              		.loc 1 2368 0
 2943 0058 BB68     		ldr	r3, [r7, #8]
 2944 005a DA6A     		ldr	r2, [r3, #44]
 2945 005c 131C     		mov	r3, r2
 2946 005e 9B00     		lsl	r3, r3, #2
 2947 0060 9B18     		add	r3, r3, r2
 2948 0062 9B00     		lsl	r3, r3, #2
 2949 0064 154A     		ldr	r2, .L211+8
 2950 0066 9A18     		add	r2, r3, r2
 2951 0068 BB68     		ldr	r3, [r7, #8]
 2952 006a 0433     		add	r3, r3, #4
 2953 006c 101C     		mov	r0, r2
 2954 006e 191C     		mov	r1, r3
 2955 0070 FFF7FEFF 		bl	vListInsertEnd
 2956 0074 06E0     		b	.L207
 2957              	.L205:
2369:../Generated_Code/tasks.c ****         }
2370:../Generated_Code/tasks.c ****         else
2371:../Generated_Code/tasks.c ****         {
2372:../Generated_Code/tasks.c ****                 /* The delayed and ready lists cannot be accessed, so hold this task
2373:../Generated_Code/tasks.c ****                 pending until the scheduler is resumed. */
2374:../Generated_Code/tasks.c ****                 vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2958              		.loc 1 2374 0 is_stmt 1
 2959 0076 BB68     		ldr	r3, [r7, #8]
 2960 0078 1833     		add	r3, r3, #24
 2961 007a 114A     		ldr	r2, .L211+12
 2962 007c 101C     		mov	r0, r2
 2963 007e 191C     		mov	r1, r3
 2964 0080 FFF7FEFF 		bl	vListInsertEnd
 2965              	.L207:
2375:../Generated_Code/tasks.c ****         }
2376:../Generated_Code/tasks.c **** 
2377:../Generated_Code/tasks.c ****         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2966              		.loc 1 2377 0
 2967 0084 BB68     		ldr	r3, [r7, #8]
 2968 0086 DA6A     		ldr	r2, [r3, #44]
 2969 0088 0E4B     		ldr	r3, .L211+16
 2970 008a 1B68     		ldr	r3, [r3]
 2971 008c DB6A     		ldr	r3, [r3, #44]
 2972 008e 9342     		cmp	r3, r2
 2973 0090 9B41     		sbc	r3, r3, r3
 2974 0092 5B42     		neg	r3, r3
 2975 0094 DBB2     		uxtb	r3, r3
 2976 0096 002B     		cmp	r3, #0
 2977 0098 05D0     		beq	.L208
2378:../Generated_Code/tasks.c ****         {
2379:../Generated_Code/tasks.c ****                 /* Return true if the task removed from the event list has a higher
2380:../Generated_Code/tasks.c ****                 priority than the calling task.  This allows the calling task to know if
2381:../Generated_Code/tasks.c ****                 it should force a context switch now. */
2382:../Generated_Code/tasks.c ****                 xReturn = pdTRUE;
 2978              		.loc 1 2382 0
 2979 009a 0123     		mov	r3, #1
 2980 009c FB60     		str	r3, [r7, #12]
2383:../Generated_Code/tasks.c **** 
2384:../Generated_Code/tasks.c ****                 /* Mark that a yield is pending in case the user is not using the
2385:../Generated_Code/tasks.c ****                 "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2386:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 2981              		.loc 1 2386 0
 2982 009e 0A4B     		ldr	r3, .L211+20
 2983 00a0 0122     		mov	r2, #1
 2984 00a2 1A60     		str	r2, [r3]
 2985 00a4 01E0     		b	.L209
 2986              	.L208:
2387:../Generated_Code/tasks.c ****         }
2388:../Generated_Code/tasks.c ****         else
2389:../Generated_Code/tasks.c ****         {
2390:../Generated_Code/tasks.c ****                 xReturn = pdFALSE;
 2987              		.loc 1 2390 0
 2988 00a6 0023     		mov	r3, #0
 2989 00a8 FB60     		str	r3, [r7, #12]
 2990              	.L209:
2391:../Generated_Code/tasks.c ****         }
2392:../Generated_Code/tasks.c **** 
2393:../Generated_Code/tasks.c ****         return xReturn;
 2991              		.loc 1 2393 0
 2992 00aa FB68     		ldr	r3, [r7, #12]
 2993              	.LBE36:
2394:../Generated_Code/tasks.c **** }
 2994              		.loc 1 2394 0
 2995 00ac 181C     		mov	r0, r3
 2996 00ae BD46     		mov	sp, r7
 2997 00b0 04B0     		add	sp, sp, #16
 2998              		@ sp needed for prologue
 2999 00b2 80BD     		pop	{r7, pc}
 3000              	.L212:
 3001              		.align	2
 3002              	.L211:
 3003 00b4 00000000 		.word	_ZL20uxSchedulerSuspended
 3004 00b8 00000000 		.word	_ZL18uxTopReadyPriority
 3005 00bc 00000000 		.word	_ZL17pxReadyTasksLists
 3006 00c0 00000000 		.word	_ZL17xPendingReadyList
 3007 00c4 00000000 		.word	pxCurrentTCB
 3008 00c8 00000000 		.word	_ZL13xYieldPending
 3009              		.cfi_endproc
 3010              	.LFE30:
 3012              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3013              		.align	2
 3014              		.global	xTaskRemoveFromUnorderedEventList
 3015              		.code	16
 3016              		.thumb_func
 3018              	xTaskRemoveFromUnorderedEventList:
 3019              	.LFB31:
2395:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2396:../Generated_Code/tasks.c **** 
2397:../Generated_Code/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2398:../Generated_Code/tasks.c **** {
 3020              		.loc 1 2398 0
 3021              		.cfi_startproc
 3022 0000 80B5     		push	{r7, lr}
 3023              	.LCFI63:
 3024              		.cfi_def_cfa_offset 8
 3025              		.cfi_offset 7, -8
 3026              		.cfi_offset 14, -4
 3027 0002 84B0     		sub	sp, sp, #16
 3028              	.LCFI64:
 3029              		.cfi_def_cfa_offset 24
 3030 0004 00AF     		add	r7, sp, #0
 3031              	.LCFI65:
 3032              		.cfi_def_cfa_register 7
 3033 0006 7860     		str	r0, [r7, #4]
 3034 0008 3960     		str	r1, [r7]
 3035              	.LBB37:
2399:../Generated_Code/tasks.c **** TCB_t *pxUnblockedTCB;
2400:../Generated_Code/tasks.c **** BaseType_t xReturn;
2401:../Generated_Code/tasks.c **** 
2402:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2403:../Generated_Code/tasks.c ****         the event flags implementation. */
2404:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended != pdFALSE );
 3036              		.loc 1 2404 0
 3037 000a 2A4B     		ldr	r3, .L222
 3038 000c 1B68     		ldr	r3, [r3]
 3039 000e 5A42     		neg	r2, r3
 3040 0010 5341     		adc	r3, r3, r2
 3041 0012 DBB2     		uxtb	r3, r3
 3042 0014 002B     		cmp	r3, #0
 3043 0016 01D0     		beq	.L214
 3044              		.loc 1 2404 0 is_stmt 0
 3045              	@ 2404 "../Generated_Code/tasks.c" 1
 3046 0018 72B6     		cpsid i
 3047              	@ 0 "" 2
 3048              		.code	16
 3049              	.L215:
 3050              		.loc 1 2404 0
 3051 001a FEE7     		b	.L215
 3052              	.L214:
2405:../Generated_Code/tasks.c **** 
2406:../Generated_Code/tasks.c ****         /* Store the new item value in the event list. */
2407:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3053              		.loc 1 2407 0 is_stmt 1
 3054 001c 3B68     		ldr	r3, [r7]
 3055 001e 8022     		mov	r2, #128
 3056 0020 1206     		lsl	r2, r2, #24
 3057 0022 1A43     		orr	r2, r3
 3058 0024 7B68     		ldr	r3, [r7, #4]
 3059 0026 1A60     		str	r2, [r3]
2408:../Generated_Code/tasks.c **** 
2409:../Generated_Code/tasks.c ****         /* Remove the event list form the event flag.  Interrupts do not access
2410:../Generated_Code/tasks.c ****         event flags. */
2411:../Generated_Code/tasks.c ****         pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3060              		.loc 1 2411 0
 3061 0028 7B68     		ldr	r3, [r7, #4]
 3062 002a DB68     		ldr	r3, [r3, #12]
 3063 002c BB60     		str	r3, [r7, #8]
2412:../Generated_Code/tasks.c ****         configASSERT( pxUnblockedTCB );
 3064              		.loc 1 2412 0
 3065 002e BB68     		ldr	r3, [r7, #8]
 3066 0030 002B     		cmp	r3, #0
 3067 0032 01D1     		bne	.L216
 3068              		.loc 1 2412 0 is_stmt 0
 3069              	@ 2412 "../Generated_Code/tasks.c" 1
 3070 0034 72B6     		cpsid i
 3071              	@ 0 "" 2
 3072              		.code	16
 3073              	.L217:
 3074              		.loc 1 2412 0
 3075 0036 FEE7     		b	.L217
 3076              	.L216:
2413:../Generated_Code/tasks.c ****         ( void ) uxListRemove( pxEventListItem );
 3077              		.loc 1 2413 0 is_stmt 1
 3078 0038 7B68     		ldr	r3, [r7, #4]
 3079 003a 181C     		mov	r0, r3
 3080 003c FFF7FEFF 		bl	uxListRemove
2414:../Generated_Code/tasks.c **** 
2415:../Generated_Code/tasks.c ****         /* Remove the task from the delayed list and add it to the ready list.  The
2416:../Generated_Code/tasks.c ****         scheduler is suspended so interrupts will not be accessing the ready
2417:../Generated_Code/tasks.c ****         lists. */
2418:../Generated_Code/tasks.c ****         ( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3081              		.loc 1 2418 0
 3082 0040 BB68     		ldr	r3, [r7, #8]
 3083 0042 0433     		add	r3, r3, #4
 3084 0044 181C     		mov	r0, r3
 3085 0046 FFF7FEFF 		bl	uxListRemove
2419:../Generated_Code/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 3086              		.loc 1 2419 0
 3087 004a BB68     		ldr	r3, [r7, #8]
 3088 004c DA6A     		ldr	r2, [r3, #44]
 3089 004e 1A4B     		ldr	r3, .L222+4
 3090 0050 1B68     		ldr	r3, [r3]
 3091 0052 9342     		cmp	r3, r2
 3092 0054 9B41     		sbc	r3, r3, r3
 3093 0056 5B42     		neg	r3, r3
 3094 0058 DBB2     		uxtb	r3, r3
 3095 005a 002B     		cmp	r3, #0
 3096 005c 03D0     		beq	.L218
 3097              		.loc 1 2419 0 is_stmt 0
 3098 005e BB68     		ldr	r3, [r7, #8]
 3099 0060 DA6A     		ldr	r2, [r3, #44]
 3100 0062 154B     		ldr	r3, .L222+4
 3101 0064 1A60     		str	r2, [r3]
 3102              	.L218:
 3103              		.loc 1 2419 0
 3104 0066 BB68     		ldr	r3, [r7, #8]
 3105 0068 DA6A     		ldr	r2, [r3, #44]
 3106 006a 131C     		mov	r3, r2
 3107 006c 9B00     		lsl	r3, r3, #2
 3108 006e 9B18     		add	r3, r3, r2
 3109 0070 9B00     		lsl	r3, r3, #2
 3110 0072 124A     		ldr	r2, .L222+8
 3111 0074 9A18     		add	r2, r3, r2
 3112 0076 BB68     		ldr	r3, [r7, #8]
 3113 0078 0433     		add	r3, r3, #4
 3114 007a 101C     		mov	r0, r2
 3115 007c 191C     		mov	r1, r3
 3116 007e FFF7FEFF 		bl	vListInsertEnd
2420:../Generated_Code/tasks.c **** 
2421:../Generated_Code/tasks.c ****         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3117              		.loc 1 2421 0 is_stmt 1
 3118 0082 BB68     		ldr	r3, [r7, #8]
 3119 0084 DA6A     		ldr	r2, [r3, #44]
 3120 0086 0E4B     		ldr	r3, .L222+12
 3121 0088 1B68     		ldr	r3, [r3]
 3122 008a DB6A     		ldr	r3, [r3, #44]
 3123 008c 9342     		cmp	r3, r2
 3124 008e 9B41     		sbc	r3, r3, r3
 3125 0090 5B42     		neg	r3, r3
 3126 0092 DBB2     		uxtb	r3, r3
 3127 0094 002B     		cmp	r3, #0
 3128 0096 05D0     		beq	.L219
2422:../Generated_Code/tasks.c ****         {
2423:../Generated_Code/tasks.c ****                 /* Return true if the task removed from the event list has
2424:../Generated_Code/tasks.c ****                 a higher priority than the calling task.  This allows
2425:../Generated_Code/tasks.c ****                 the calling task to know if it should force a context
2426:../Generated_Code/tasks.c ****                 switch now. */
2427:../Generated_Code/tasks.c ****                 xReturn = pdTRUE;
 3129              		.loc 1 2427 0
 3130 0098 0123     		mov	r3, #1
 3131 009a FB60     		str	r3, [r7, #12]
2428:../Generated_Code/tasks.c **** 
2429:../Generated_Code/tasks.c ****                 /* Mark that a yield is pending in case the user is not using the
2430:../Generated_Code/tasks.c ****                 "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2431:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 3132              		.loc 1 2431 0
 3133 009c 094B     		ldr	r3, .L222+16
 3134 009e 0122     		mov	r2, #1
 3135 00a0 1A60     		str	r2, [r3]
 3136 00a2 01E0     		b	.L220
 3137              	.L219:
2432:../Generated_Code/tasks.c ****         }
2433:../Generated_Code/tasks.c ****         else
2434:../Generated_Code/tasks.c ****         {
2435:../Generated_Code/tasks.c ****                 xReturn = pdFALSE;
 3138              		.loc 1 2435 0
 3139 00a4 0023     		mov	r3, #0
 3140 00a6 FB60     		str	r3, [r7, #12]
 3141              	.L220:
2436:../Generated_Code/tasks.c ****         }
2437:../Generated_Code/tasks.c **** 
2438:../Generated_Code/tasks.c ****         return xReturn;
 3142              		.loc 1 2438 0
 3143 00a8 FB68     		ldr	r3, [r7, #12]
 3144              	.LBE37:
2439:../Generated_Code/tasks.c **** }
 3145              		.loc 1 2439 0
 3146 00aa 181C     		mov	r0, r3
 3147 00ac BD46     		mov	sp, r7
 3148 00ae 04B0     		add	sp, sp, #16
 3149              		@ sp needed for prologue
 3150 00b0 80BD     		pop	{r7, pc}
 3151              	.L223:
 3152 00b2 C046     		.align	2
 3153              	.L222:
 3154 00b4 00000000 		.word	_ZL20uxSchedulerSuspended
 3155 00b8 00000000 		.word	_ZL18uxTopReadyPriority
 3156 00bc 00000000 		.word	_ZL17pxReadyTasksLists
 3157 00c0 00000000 		.word	pxCurrentTCB
 3158 00c4 00000000 		.word	_ZL13xYieldPending
 3159              		.cfi_endproc
 3160              	.LFE31:
 3162              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3163              		.align	2
 3164              		.global	vTaskSetTimeOutState
 3165              		.code	16
 3166              		.thumb_func
 3168              	vTaskSetTimeOutState:
 3169              	.LFB32:
2440:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2441:../Generated_Code/tasks.c **** 
2442:../Generated_Code/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2443:../Generated_Code/tasks.c **** {
 3170              		.loc 1 2443 0
 3171              		.cfi_startproc
 3172 0000 80B5     		push	{r7, lr}
 3173              	.LCFI66:
 3174              		.cfi_def_cfa_offset 8
 3175              		.cfi_offset 7, -8
 3176              		.cfi_offset 14, -4
 3177 0002 82B0     		sub	sp, sp, #8
 3178              	.LCFI67:
 3179              		.cfi_def_cfa_offset 16
 3180 0004 00AF     		add	r7, sp, #0
 3181              	.LCFI68:
 3182              		.cfi_def_cfa_register 7
 3183 0006 7860     		str	r0, [r7, #4]
2444:../Generated_Code/tasks.c ****         configASSERT( pxTimeOut );
 3184              		.loc 1 2444 0
 3185 0008 7B68     		ldr	r3, [r7, #4]
 3186 000a 002B     		cmp	r3, #0
 3187 000c 01D1     		bne	.L225
 3188              		.loc 1 2444 0 is_stmt 0
 3189              	@ 2444 "../Generated_Code/tasks.c" 1
 3190 000e 72B6     		cpsid i
 3191              	@ 0 "" 2
 3192              		.code	16
 3193              	.L226:
 3194              		.loc 1 2444 0
 3195 0010 FEE7     		b	.L226
 3196              	.L225:
2445:../Generated_Code/tasks.c ****         pxTimeOut->xOverflowCount = xNumOfOverflows;
 3197              		.loc 1 2445 0 is_stmt 1
 3198 0012 054B     		ldr	r3, .L227
 3199 0014 1A68     		ldr	r2, [r3]
 3200 0016 7B68     		ldr	r3, [r7, #4]
 3201 0018 1A60     		str	r2, [r3]
2446:../Generated_Code/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
 3202              		.loc 1 2446 0
 3203 001a 044B     		ldr	r3, .L227+4
 3204 001c 1A68     		ldr	r2, [r3]
 3205 001e 7B68     		ldr	r3, [r7, #4]
 3206 0020 5A60     		str	r2, [r3, #4]
2447:../Generated_Code/tasks.c **** }
 3207              		.loc 1 2447 0
 3208 0022 BD46     		mov	sp, r7
 3209 0024 02B0     		add	sp, sp, #8
 3210              		@ sp needed for prologue
 3211 0026 80BD     		pop	{r7, pc}
 3212              	.L228:
 3213              		.align	2
 3214              	.L227:
 3215 0028 00000000 		.word	_ZL15xNumOfOverflows
 3216 002c 00000000 		.word	_ZL10xTickCount
 3217              		.cfi_endproc
 3218              	.LFE32:
 3220              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3221              		.align	2
 3222              		.global	xTaskCheckForTimeOut
 3223              		.code	16
 3224              		.thumb_func
 3226              	xTaskCheckForTimeOut:
 3227              	.LFB33:
2448:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2449:../Generated_Code/tasks.c **** 
2450:../Generated_Code/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2451:../Generated_Code/tasks.c **** {
 3228              		.loc 1 2451 0
 3229              		.cfi_startproc
 3230 0000 80B5     		push	{r7, lr}
 3231              	.LCFI69:
 3232              		.cfi_def_cfa_offset 8
 3233              		.cfi_offset 7, -8
 3234              		.cfi_offset 14, -4
 3235 0002 84B0     		sub	sp, sp, #16
 3236              	.LCFI70:
 3237              		.cfi_def_cfa_offset 24
 3238 0004 00AF     		add	r7, sp, #0
 3239              	.LCFI71:
 3240              		.cfi_def_cfa_register 7
 3241 0006 7860     		str	r0, [r7, #4]
 3242 0008 3960     		str	r1, [r7]
 3243              	.LBB38:
2452:../Generated_Code/tasks.c **** BaseType_t xReturn;
2453:../Generated_Code/tasks.c **** 
2454:../Generated_Code/tasks.c ****         configASSERT( pxTimeOut );
 3244              		.loc 1 2454 0
 3245 000a 7B68     		ldr	r3, [r7, #4]
 3246 000c 002B     		cmp	r3, #0
 3247 000e 01D1     		bne	.L230
 3248              		.loc 1 2454 0 is_stmt 0
 3249              	@ 2454 "../Generated_Code/tasks.c" 1
 3250 0010 72B6     		cpsid i
 3251              	@ 0 "" 2
 3252              		.code	16
 3253              	.L231:
 3254              		.loc 1 2454 0
 3255 0012 FEE7     		b	.L231
 3256              	.L230:
2455:../Generated_Code/tasks.c ****         configASSERT( pxTicksToWait );
 3257              		.loc 1 2455 0 is_stmt 1
 3258 0014 3B68     		ldr	r3, [r7]
 3259 0016 002B     		cmp	r3, #0
 3260 0018 01D1     		bne	.L232
 3261              		.loc 1 2455 0 is_stmt 0
 3262              	@ 2455 "../Generated_Code/tasks.c" 1
 3263 001a 72B6     		cpsid i
 3264              	@ 0 "" 2
 3265              		.code	16
 3266              	.L233:
 3267              		.loc 1 2455 0
 3268 001c FEE7     		b	.L233
 3269              	.L232:
2456:../Generated_Code/tasks.c **** 
2457:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 3270              		.loc 1 2457 0 is_stmt 1
 3271 001e FFF7FEFF 		bl	vPortEnterCritical
 3272              	.LBB39:
2458:../Generated_Code/tasks.c ****         {
2459:../Generated_Code/tasks.c ****                 /* Minor optimisation.  The tick count cannot change in this block. */
2460:../Generated_Code/tasks.c ****                 const TickType_t xConstTickCount = xTickCount;
 3273              		.loc 1 2460 0
 3274 0022 1F4B     		ldr	r3, .L241
 3275 0024 1B68     		ldr	r3, [r3]
 3276 0026 BB60     		str	r3, [r7, #8]
2461:../Generated_Code/tasks.c **** 
2462:../Generated_Code/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
2463:../Generated_Code/tasks.c ****                         /* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2464:../Generated_Code/tasks.c ****                         the maximum block time then the task should block indefinitely, and
2465:../Generated_Code/tasks.c ****                         therefore never time out. */
2466:../Generated_Code/tasks.c ****                         if( *pxTicksToWait == portMAX_DELAY )
 3277              		.loc 1 2466 0
 3278 0028 3B68     		ldr	r3, [r7]
 3279 002a 1B68     		ldr	r3, [r3]
 3280 002c 0133     		add	r3, r3, #1
 3281 002e 02D1     		bne	.L234
2467:../Generated_Code/tasks.c ****                         {
2468:../Generated_Code/tasks.c ****                                 xReturn = pdFALSE;
 3282              		.loc 1 2468 0
 3283 0030 0023     		mov	r3, #0
 3284 0032 FB60     		str	r3, [r7, #12]
 3285 0034 2CE0     		b	.L235
 3286              	.L234:
2469:../Generated_Code/tasks.c ****                         }
2470:../Generated_Code/tasks.c ****                         else /* We are not blocking indefinitely, perform the checks below. */
2471:../Generated_Code/tasks.c ****                 #endif
2472:../Generated_Code/tasks.c **** 
2473:../Generated_Code/tasks.c ****                 if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTime
 3287              		.loc 1 2473 0
 3288 0036 7B68     		ldr	r3, [r7, #4]
 3289 0038 1A68     		ldr	r2, [r3]
 3290 003a 1A4B     		ldr	r3, .L241+4
 3291 003c 1B68     		ldr	r3, [r3]
 3292 003e 9A42     		cmp	r2, r3
 3293 0040 06D0     		beq	.L236
 3294              		.loc 1 2473 0 is_stmt 0
 3295 0042 7B68     		ldr	r3, [r7, #4]
 3296 0044 5A68     		ldr	r2, [r3, #4]
 3297 0046 BB68     		ldr	r3, [r7, #8]
 3298 0048 9A42     		cmp	r2, r3
 3299 004a 01D8     		bhi	.L236
 3300              		.loc 1 2473 0
 3301 004c 0123     		mov	r3, #1
 3302 004e 00E0     		b	.L237
 3303              	.L236:
 3304              		.loc 1 2473 0
 3305 0050 0023     		mov	r3, #0
 3306              	.L237:
 3307              		.loc 1 2473 0
 3308 0052 002B     		cmp	r3, #0
 3309 0054 02D0     		beq	.L238
2474:../Generated_Code/tasks.c ****                 {
2475:../Generated_Code/tasks.c ****                         /* The tick count is greater than the time at which vTaskSetTimeout()
2476:../Generated_Code/tasks.c ****                         was called, but has also overflowed since vTaskSetTimeOut() was called.
2477:../Generated_Code/tasks.c ****                         It must have wrapped all the way around and gone past us again. This
2478:../Generated_Code/tasks.c ****                         passed since vTaskSetTimeout() was called. */
2479:../Generated_Code/tasks.c ****                         xReturn = pdTRUE;
 3310              		.loc 1 2479 0 is_stmt 1
 3311 0056 0123     		mov	r3, #1
 3312 0058 FB60     		str	r3, [r7, #12]
 3313 005a 19E0     		b	.L235
 3314              	.L238:
2480:../Generated_Code/tasks.c ****                 }
2481:../Generated_Code/tasks.c ****                 else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 3315              		.loc 1 2481 0
 3316 005c 7B68     		ldr	r3, [r7, #4]
 3317 005e 5B68     		ldr	r3, [r3, #4]
 3318 0060 BA68     		ldr	r2, [r7, #8]
 3319 0062 D21A     		sub	r2, r2, r3
 3320 0064 3B68     		ldr	r3, [r7]
 3321 0066 1B68     		ldr	r3, [r3]
 3322 0068 9A42     		cmp	r2, r3
 3323 006a 0FD2     		bcs	.L239
2482:../Generated_Code/tasks.c ****                 {
2483:../Generated_Code/tasks.c ****                         /* Not a genuine timeout. Adjust parameters for time remaining. */
2484:../Generated_Code/tasks.c ****                         *pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 3324              		.loc 1 2484 0
 3325 006c 3B68     		ldr	r3, [r7]
 3326 006e 1A68     		ldr	r2, [r3]
 3327 0070 7B68     		ldr	r3, [r7, #4]
 3328 0072 5968     		ldr	r1, [r3, #4]
 3329 0074 BB68     		ldr	r3, [r7, #8]
 3330 0076 CB1A     		sub	r3, r1, r3
 3331 0078 D218     		add	r2, r2, r3
 3332 007a 3B68     		ldr	r3, [r7]
 3333 007c 1A60     		str	r2, [r3]
2485:../Generated_Code/tasks.c ****                         vTaskSetTimeOutState( pxTimeOut );
 3334              		.loc 1 2485 0
 3335 007e 7B68     		ldr	r3, [r7, #4]
 3336 0080 181C     		mov	r0, r3
 3337 0082 FFF7FEFF 		bl	vTaskSetTimeOutState
2486:../Generated_Code/tasks.c ****                         xReturn = pdFALSE;
 3338              		.loc 1 2486 0
 3339 0086 0023     		mov	r3, #0
 3340 0088 FB60     		str	r3, [r7, #12]
 3341 008a 01E0     		b	.L235
 3342              	.L239:
2487:../Generated_Code/tasks.c ****                 }
2488:../Generated_Code/tasks.c ****                 else
2489:../Generated_Code/tasks.c ****                 {
2490:../Generated_Code/tasks.c ****                         xReturn = pdTRUE;
 3343              		.loc 1 2490 0
 3344 008c 0123     		mov	r3, #1
 3345 008e FB60     		str	r3, [r7, #12]
 3346              	.L235:
 3347              	.LBE39:
2491:../Generated_Code/tasks.c ****                 }
2492:../Generated_Code/tasks.c ****         }
2493:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 3348              		.loc 1 2493 0
 3349 0090 FFF7FEFF 		bl	vPortExitCritical
2494:../Generated_Code/tasks.c **** 
2495:../Generated_Code/tasks.c ****         return xReturn;
 3350              		.loc 1 2495 0
 3351 0094 FB68     		ldr	r3, [r7, #12]
 3352              	.LBE38:
2496:../Generated_Code/tasks.c **** }
 3353              		.loc 1 2496 0
 3354 0096 181C     		mov	r0, r3
 3355 0098 BD46     		mov	sp, r7
 3356 009a 04B0     		add	sp, sp, #16
 3357              		@ sp needed for prologue
 3358 009c 80BD     		pop	{r7, pc}
 3359              	.L242:
 3360 009e C046     		.align	2
 3361              	.L241:
 3362 00a0 00000000 		.word	_ZL10xTickCount
 3363 00a4 00000000 		.word	_ZL15xNumOfOverflows
 3364              		.cfi_endproc
 3365              	.LFE33:
 3367              		.section	.text.vTaskMissedYield,"ax",%progbits
 3368              		.align	2
 3369              		.global	vTaskMissedYield
 3370              		.code	16
 3371              		.thumb_func
 3373              	vTaskMissedYield:
 3374              	.LFB34:
2497:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2498:../Generated_Code/tasks.c **** 
2499:../Generated_Code/tasks.c **** void vTaskMissedYield( void )
2500:../Generated_Code/tasks.c **** {
 3375              		.loc 1 2500 0
 3376              		.cfi_startproc
 3377 0000 80B5     		push	{r7, lr}
 3378              	.LCFI72:
 3379              		.cfi_def_cfa_offset 8
 3380              		.cfi_offset 7, -8
 3381              		.cfi_offset 14, -4
 3382 0002 00AF     		add	r7, sp, #0
 3383              	.LCFI73:
 3384              		.cfi_def_cfa_register 7
2501:../Generated_Code/tasks.c ****         xYieldPending = pdTRUE;
 3385              		.loc 1 2501 0
 3386 0004 024B     		ldr	r3, .L244
 3387 0006 0122     		mov	r2, #1
 3388 0008 1A60     		str	r2, [r3]
2502:../Generated_Code/tasks.c **** }
 3389              		.loc 1 2502 0
 3390 000a BD46     		mov	sp, r7
 3391              		@ sp needed for prologue
 3392 000c 80BD     		pop	{r7, pc}
 3393              	.L245:
 3394 000e C046     		.align	2
 3395              	.L244:
 3396 0010 00000000 		.word	_ZL13xYieldPending
 3397              		.cfi_endproc
 3398              	.LFE34:
 3400              		.section	.text._ZL11prvIdleTaskPv,"ax",%progbits
 3401              		.align	2
 3402              		.code	16
 3403              		.thumb_func
 3405              	_ZL11prvIdleTaskPv:
 3406              	.LFB35:
2503:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2504:../Generated_Code/tasks.c **** 
2505:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2506:../Generated_Code/tasks.c **** 
2507:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2508:../Generated_Code/tasks.c ****         {
2509:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
2510:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2511:../Generated_Code/tasks.c **** 
2512:../Generated_Code/tasks.c ****                 if( xTask != NULL )
2513:../Generated_Code/tasks.c ****                 {
2514:../Generated_Code/tasks.c ****                         pxTCB = ( TCB_t * ) xTask;
2515:../Generated_Code/tasks.c ****                         uxReturn = pxTCB->uxTaskNumber;
2516:../Generated_Code/tasks.c ****                 }
2517:../Generated_Code/tasks.c ****                 else
2518:../Generated_Code/tasks.c ****                 {
2519:../Generated_Code/tasks.c ****                         uxReturn = 0U;
2520:../Generated_Code/tasks.c ****                 }
2521:../Generated_Code/tasks.c **** 
2522:../Generated_Code/tasks.c ****                 return uxReturn;
2523:../Generated_Code/tasks.c ****         }
2524:../Generated_Code/tasks.c **** 
2525:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2527:../Generated_Code/tasks.c **** 
2528:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2529:../Generated_Code/tasks.c **** 
2530:../Generated_Code/tasks.c ****         void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2531:../Generated_Code/tasks.c ****         {
2532:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2533:../Generated_Code/tasks.c **** 
2534:../Generated_Code/tasks.c ****                 if( xTask != NULL )
2535:../Generated_Code/tasks.c ****                 {
2536:../Generated_Code/tasks.c ****                         pxTCB = ( TCB_t * ) xTask;
2537:../Generated_Code/tasks.c ****                         pxTCB->uxTaskNumber = uxHandle;
2538:../Generated_Code/tasks.c ****                 }
2539:../Generated_Code/tasks.c ****         }
2540:../Generated_Code/tasks.c **** 
2541:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2542:../Generated_Code/tasks.c **** 
2543:../Generated_Code/tasks.c **** /*
2544:../Generated_Code/tasks.c ****  * -----------------------------------------------------------
2545:../Generated_Code/tasks.c ****  * The Idle task.
2546:../Generated_Code/tasks.c ****  * ----------------------------------------------------------
2547:../Generated_Code/tasks.c ****  *
2548:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2549:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2550:../Generated_Code/tasks.c ****  *
2551:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
2552:../Generated_Code/tasks.c ****  *
2553:../Generated_Code/tasks.c ****  */
2554:../Generated_Code/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2555:../Generated_Code/tasks.c **** {
 3407              		.loc 1 2555 0
 3408              		.cfi_startproc
 3409 0000 80B5     		push	{r7, lr}
 3410              	.LCFI74:
 3411              		.cfi_def_cfa_offset 8
 3412              		.cfi_offset 7, -8
 3413              		.cfi_offset 14, -4
 3414 0002 82B0     		sub	sp, sp, #8
 3415              	.LCFI75:
 3416              		.cfi_def_cfa_offset 16
 3417 0004 00AF     		add	r7, sp, #0
 3418              	.LCFI76:
 3419              		.cfi_def_cfa_register 7
 3420 0006 7860     		str	r0, [r7, #4]
 3421              	.L248:
2556:../Generated_Code/tasks.c ****         /* Stop warnings. */
2557:../Generated_Code/tasks.c ****         ( void ) pvParameters;
2558:../Generated_Code/tasks.c **** 
2559:../Generated_Code/tasks.c ****         for( ;; )
2560:../Generated_Code/tasks.c ****         {
2561:../Generated_Code/tasks.c ****                 /* See if any tasks have been deleted. */
2562:../Generated_Code/tasks.c ****                 prvCheckTasksWaitingTermination();
 3422              		.loc 1 2562 0
 3423 0008 FFF7FEFF 		bl	_ZL31prvCheckTasksWaitingTerminationv
2563:../Generated_Code/tasks.c **** 
2564:../Generated_Code/tasks.c ****                 #if ( configUSE_PREEMPTION == 0 )
2565:../Generated_Code/tasks.c ****                 {
2566:../Generated_Code/tasks.c ****                         /* If we are not using preemption we keep forcing a task switch to
2567:../Generated_Code/tasks.c ****                         see if any other task has become available.  If we are using
2568:../Generated_Code/tasks.c ****                         preemption we don't need to do this as any task becoming available
2569:../Generated_Code/tasks.c ****                         will automatically get the processor anyway. */
2570:../Generated_Code/tasks.c ****                         taskYIELD();
2571:../Generated_Code/tasks.c ****                 }
2572:../Generated_Code/tasks.c ****                 #endif /* configUSE_PREEMPTION */
2573:../Generated_Code/tasks.c **** 
2574:../Generated_Code/tasks.c ****                 #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2575:../Generated_Code/tasks.c ****                 {
2576:../Generated_Code/tasks.c ****                         /* When using preemption tasks of equal priority will be
2577:../Generated_Code/tasks.c ****                         timesliced.  If a task that is sharing the idle priority is ready
2578:../Generated_Code/tasks.c ****                         to run then the idle task should yield before the end of the
2579:../Generated_Code/tasks.c ****                         timeslice.
2580:../Generated_Code/tasks.c **** 
2581:../Generated_Code/tasks.c ****                         A critical region is not required here as we are just reading from
2582:../Generated_Code/tasks.c ****                         the list, and an occasional incorrect value will not matter.  If
2583:../Generated_Code/tasks.c ****                         the ready list at the idle priority contains more than one task
2584:../Generated_Code/tasks.c ****                         then a task other than the idle task is ready to execute. */
2585:../Generated_Code/tasks.c ****                         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) >
 3424              		.loc 1 2585 0
 3425 000c 044B     		ldr	r3, .L249
 3426 000e 1B68     		ldr	r3, [r3]
 3427 0010 012B     		cmp	r3, #1
 3428 0012 01D9     		bls	.L247
2586:../Generated_Code/tasks.c ****                         {
2587:../Generated_Code/tasks.c ****                                 taskYIELD();
 3429              		.loc 1 2587 0
 3430 0014 FFF7FEFF 		bl	vPortYieldFromISR
 3431              	.L247:
2588:../Generated_Code/tasks.c ****                         }
2589:../Generated_Code/tasks.c ****                         else
2590:../Generated_Code/tasks.c ****                         {
2591:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2592:../Generated_Code/tasks.c ****                         }
2593:../Generated_Code/tasks.c ****                 }
2594:../Generated_Code/tasks.c ****                 #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2595:../Generated_Code/tasks.c **** 
2596:../Generated_Code/tasks.c ****                 #if ( configUSE_IDLE_HOOK == 1 )
2597:../Generated_Code/tasks.c ****                 {
2598:../Generated_Code/tasks.c **** 
2599:../Generated_Code/tasks.c ****                         /* Call the user defined function from within the idle task.  This
2600:../Generated_Code/tasks.c ****                         allows the application designer to add background functionality
2601:../Generated_Code/tasks.c ****                         without the overhead of a separate task.
2602:../Generated_Code/tasks.c ****                         NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2603:../Generated_Code/tasks.c ****                         CALL A FUNCTION THAT MIGHT BLOCK. */
2604:../Generated_Code/tasks.c ****                         FreeRTOS0_vApplicationIdleHook();
 3432              		.loc 1 2604 0
 3433 0018 FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationIdleHookv
2559:../Generated_Code/tasks.c ****         for( ;; )
 3434              		.loc 1 2559 0
 3435 001c F4E7     		b	.L248
 3436              	.L250:
 3437 001e C046     		.align	2
 3438              	.L249:
 3439 0020 00000000 		.word	_ZL17pxReadyTasksLists
 3440              		.cfi_endproc
 3441              	.LFE35:
 3443              		.section	.text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt,"ax",%p
 3444              		.align	2
 3445              		.code	16
 3446              		.thumb_func
 3448              	_ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:
 3449              	.LFB36:
2605:../Generated_Code/tasks.c ****                 }
2606:../Generated_Code/tasks.c ****                 #endif /* configUSE_IDLE_HOOK */
2607:../Generated_Code/tasks.c **** 
2608:../Generated_Code/tasks.c ****                 /* This conditional compilation should use inequality to 0, not equality
2609:../Generated_Code/tasks.c ****                 to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2610:../Generated_Code/tasks.c ****                 user defined low power mode     implementations require
2611:../Generated_Code/tasks.c ****                 configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2612:../Generated_Code/tasks.c ****                 #if ( configUSE_TICKLESS_IDLE != 0 )
2613:../Generated_Code/tasks.c ****                 {
2614:../Generated_Code/tasks.c ****                 TickType_t xExpectedIdleTime;
2615:../Generated_Code/tasks.c **** 
2616:../Generated_Code/tasks.c ****                         /* It is not desirable to suspend then resume the scheduler on
2617:../Generated_Code/tasks.c ****                         each iteration of the idle task.  Therefore, a preliminary
2618:../Generated_Code/tasks.c ****                         test of the expected idle time is performed without the
2619:../Generated_Code/tasks.c ****                         scheduler suspended.  The result here is not necessarily
2620:../Generated_Code/tasks.c ****                         valid. */
2621:../Generated_Code/tasks.c ****                         xExpectedIdleTime = prvGetExpectedIdleTime();
2622:../Generated_Code/tasks.c **** 
2623:../Generated_Code/tasks.c ****                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2624:../Generated_Code/tasks.c ****                         {
2625:../Generated_Code/tasks.c ****                                 vTaskSuspendAll();
2626:../Generated_Code/tasks.c ****                                 {
2627:../Generated_Code/tasks.c ****                                         /* Now the scheduler is suspended, the expected idle
2628:../Generated_Code/tasks.c ****                                         time can be sampled again, and this time its value can
2629:../Generated_Code/tasks.c ****                                         be used. */
2630:../Generated_Code/tasks.c ****                                         configASSERT( xNextTaskUnblockTime >= xTickCount );
2631:../Generated_Code/tasks.c ****                                         xExpectedIdleTime = prvGetExpectedIdleTime();
2632:../Generated_Code/tasks.c **** 
2633:../Generated_Code/tasks.c ****                                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SL
2634:../Generated_Code/tasks.c ****                                         {
2635:../Generated_Code/tasks.c ****                                                 traceLOW_POWER_IDLE_BEGIN();
2636:../Generated_Code/tasks.c ****                                                 portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2637:../Generated_Code/tasks.c ****                                                 traceLOW_POWER_IDLE_END();
2638:../Generated_Code/tasks.c ****                                         }
2639:../Generated_Code/tasks.c ****                                         else
2640:../Generated_Code/tasks.c ****                                         {
2641:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
2642:../Generated_Code/tasks.c ****                                         }
2643:../Generated_Code/tasks.c ****                                 }
2644:../Generated_Code/tasks.c ****                                 ( void ) xTaskResumeAll();
2645:../Generated_Code/tasks.c ****                         }
2646:../Generated_Code/tasks.c ****                         else
2647:../Generated_Code/tasks.c ****                         {
2648:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2649:../Generated_Code/tasks.c ****                         }
2650:../Generated_Code/tasks.c ****                 }
2651:../Generated_Code/tasks.c ****                 #endif /* configUSE_TICKLESS_IDLE */
2652:../Generated_Code/tasks.c ****         }
2653:../Generated_Code/tasks.c **** }
2654:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2655:../Generated_Code/tasks.c **** 
2656:../Generated_Code/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2657:../Generated_Code/tasks.c **** 
2658:../Generated_Code/tasks.c ****         eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2659:../Generated_Code/tasks.c ****         {
2660:../Generated_Code/tasks.c ****         eSleepModeStatus eReturn = eStandardSleep;
2661:../Generated_Code/tasks.c **** 
2662:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2663:../Generated_Code/tasks.c ****                 {
2664:../Generated_Code/tasks.c ****                         /* A task was made ready while the scheduler was suspended. */
2665:../Generated_Code/tasks.c ****                         eReturn = eAbortSleep;
2666:../Generated_Code/tasks.c ****                 }
2667:../Generated_Code/tasks.c ****                 else if( xYieldPending != pdFALSE )
2668:../Generated_Code/tasks.c ****                 {
2669:../Generated_Code/tasks.c ****                         /* A yield was pended while the scheduler was suspended. */
2670:../Generated_Code/tasks.c ****                         eReturn = eAbortSleep;
2671:../Generated_Code/tasks.c ****                 }
2672:../Generated_Code/tasks.c ****                 else
2673:../Generated_Code/tasks.c ****                 {
2674:../Generated_Code/tasks.c ****                         #if configUSE_TIMERS == 0
2675:../Generated_Code/tasks.c ****                         {
2676:../Generated_Code/tasks.c ****                                 /* The idle task exists in addition to the application tasks. */
2677:../Generated_Code/tasks.c ****                                 const UBaseType_t uxNonApplicationTasks = 1;
2678:../Generated_Code/tasks.c **** 
2679:../Generated_Code/tasks.c ****                                 /* If timers are not being used and all the tasks are in the
2680:../Generated_Code/tasks.c ****                                 suspended list (which might mean they have an infinite block
2681:../Generated_Code/tasks.c ****                                 time rather than actually being suspended) then it is safe to
2682:../Generated_Code/tasks.c ****                                 turn all clocks off and just wait for external interrupts. */
2683:../Generated_Code/tasks.c ****                                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNu
2684:../Generated_Code/tasks.c ****                                 {
2685:../Generated_Code/tasks.c ****                                         eReturn = eNoTasksWaitingTimeout;
2686:../Generated_Code/tasks.c ****                                 }
2687:../Generated_Code/tasks.c ****                                 else
2688:../Generated_Code/tasks.c ****                                 {
2689:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
2690:../Generated_Code/tasks.c ****                                 }
2691:../Generated_Code/tasks.c ****                         }
2692:../Generated_Code/tasks.c ****                         #endif /* configUSE_TIMERS */
2693:../Generated_Code/tasks.c ****                 }
2694:../Generated_Code/tasks.c **** 
2695:../Generated_Code/tasks.c ****                 return eReturn;
2696:../Generated_Code/tasks.c ****         }
2697:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2698:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2699:../Generated_Code/tasks.c **** 
2700:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2701:../Generated_Code/tasks.c **** {
 3450              		.loc 1 2701 0
 3451              		.cfi_startproc
 3452 0000 80B5     		push	{r7, lr}
 3453              	.LCFI77:
 3454              		.cfi_def_cfa_offset 8
 3455              		.cfi_offset 7, -8
 3456              		.cfi_offset 14, -4
 3457 0002 86B0     		sub	sp, sp, #24
 3458              	.LCFI78:
 3459              		.cfi_def_cfa_offset 32
 3460 0004 00AF     		add	r7, sp, #0
 3461              	.LCFI79:
 3462              		.cfi_def_cfa_register 7
 3463 0006 F860     		str	r0, [r7, #12]
 3464 0008 B960     		str	r1, [r7, #8]
 3465 000a 7A60     		str	r2, [r7, #4]
 3466 000c 3B60     		str	r3, [r7]
 3467              	.LBB40:
2702:../Generated_Code/tasks.c **** UBaseType_t x;
2703:../Generated_Code/tasks.c **** 
2704:../Generated_Code/tasks.c ****         /* Store the task name in the TCB. */
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3468              		.loc 1 2705 0
 3469 000e 0023     		mov	r3, #0
 3470 0010 7B61     		str	r3, [r7, #20]
 3471 0012 12E0     		b	.L252
 3472              	.L255:
2706:../Generated_Code/tasks.c ****         {
2707:../Generated_Code/tasks.c ****                 pxTCB->pcTaskName[ x ] = pcName[ x ];
 3473              		.loc 1 2707 0
 3474 0014 BA68     		ldr	r2, [r7, #8]
 3475 0016 7B69     		ldr	r3, [r7, #20]
 3476 0018 D318     		add	r3, r2, r3
 3477 001a 1A78     		ldrb	r2, [r3]
 3478 001c F868     		ldr	r0, [r7, #12]
 3479 001e 3023     		mov	r3, #48
 3480 0020 7969     		ldr	r1, [r7, #20]
 3481 0022 4118     		add	r1, r0, r1
 3482 0024 CB18     		add	r3, r1, r3
 3483 0026 1A71     		strb	r2, [r3, #4]
2708:../Generated_Code/tasks.c **** 
2709:../Generated_Code/tasks.c ****                 /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2710:../Generated_Code/tasks.c ****                 configMAX_TASK_NAME_LEN characters just in case the memory after the
2711:../Generated_Code/tasks.c ****                 string is not accessible (extremely unlikely). */
2712:../Generated_Code/tasks.c ****                 if( pcName[ x ] == 0x00 )
 3484              		.loc 1 2712 0
 3485 0028 BA68     		ldr	r2, [r7, #8]
 3486 002a 7B69     		ldr	r3, [r7, #20]
 3487 002c D318     		add	r3, r2, r3
 3488 002e 1B78     		ldrb	r3, [r3]
 3489 0030 002B     		cmp	r3, #0
 3490 0032 0BD0     		beq	.L257
 3491              	.L253:
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3492              		.loc 1 2705 0
 3493 0034 7B69     		ldr	r3, [r7, #20]
 3494 0036 0133     		add	r3, r3, #1
 3495 0038 7B61     		str	r3, [r7, #20]
 3496              	.L252:
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3497              		.loc 1 2705 0 is_stmt 0
 3498 003a 7A69     		ldr	r2, [r7, #20]
 3499 003c 1821     		mov	r1, #24
 3500 003e 0023     		mov	r3, #0
 3501 0040 9142     		cmp	r1, r2
 3502 0042 5B41     		adc	r3, r3, r3
 3503 0044 DBB2     		uxtb	r3, r3
 3504 0046 002B     		cmp	r3, #0
 3505 0048 E4D1     		bne	.L255
 3506 004a 00E0     		b	.L254
 3507              	.L257:
2713:../Generated_Code/tasks.c ****                 {
2714:../Generated_Code/tasks.c ****                         break;
 3508              		.loc 1 2714 0 is_stmt 1
 3509 004c C046     		mov	r8, r8
 3510              	.L254:
2715:../Generated_Code/tasks.c ****                 }
2716:../Generated_Code/tasks.c ****                 else
2717:../Generated_Code/tasks.c ****                 {
2718:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2719:../Generated_Code/tasks.c ****                 }
2720:../Generated_Code/tasks.c ****         }
2721:../Generated_Code/tasks.c **** 
2722:../Generated_Code/tasks.c ****         /* Ensure the name string is terminated in the case that the string length
2723:../Generated_Code/tasks.c ****         was greater or equal to configMAX_TASK_NAME_LEN. */
2724:../Generated_Code/tasks.c ****         pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 3511              		.loc 1 2724 0
 3512 004e FA68     		ldr	r2, [r7, #12]
 3513 0050 4C23     		mov	r3, #76
 3514 0052 0021     		mov	r1, #0
 3515 0054 D154     		strb	r1, [r2, r3]
2725:../Generated_Code/tasks.c **** 
2726:../Generated_Code/tasks.c ****         /* This is used as an array index so must ensure it's not too large.  First
2727:../Generated_Code/tasks.c ****         remove the privilege bit if one is present. */
2728:../Generated_Code/tasks.c ****         if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 3516              		.loc 1 2728 0
 3517 0056 7B68     		ldr	r3, [r7, #4]
 3518 0058 052B     		cmp	r3, #5
 3519 005a 01D9     		bls	.L256
2729:../Generated_Code/tasks.c ****         {
2730:../Generated_Code/tasks.c ****                 uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 3520              		.loc 1 2730 0
 3521 005c 0523     		mov	r3, #5
 3522 005e 7B60     		str	r3, [r7, #4]
 3523              	.L256:
2731:../Generated_Code/tasks.c ****         }
2732:../Generated_Code/tasks.c ****         else
2733:../Generated_Code/tasks.c ****         {
2734:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2735:../Generated_Code/tasks.c ****         }
2736:../Generated_Code/tasks.c **** 
2737:../Generated_Code/tasks.c ****         pxTCB->uxPriority = uxPriority;
 3524              		.loc 1 2737 0
 3525 0060 FB68     		ldr	r3, [r7, #12]
 3526 0062 7A68     		ldr	r2, [r7, #4]
 3527 0064 DA62     		str	r2, [r3, #44]
2738:../Generated_Code/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
2739:../Generated_Code/tasks.c ****         {
2740:../Generated_Code/tasks.c ****                 pxTCB->uxBasePriority = uxPriority;
 3528              		.loc 1 2740 0
 3529 0066 FB68     		ldr	r3, [r7, #12]
 3530 0068 7A68     		ldr	r2, [r7, #4]
 3531 006a 1A65     		str	r2, [r3, #80]
2741:../Generated_Code/tasks.c ****         }
2742:../Generated_Code/tasks.c ****         #endif /* configUSE_MUTEXES */
2743:../Generated_Code/tasks.c **** 
2744:../Generated_Code/tasks.c ****         vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3532              		.loc 1 2744 0
 3533 006c FB68     		ldr	r3, [r7, #12]
 3534 006e 0433     		add	r3, r3, #4
 3535 0070 181C     		mov	r0, r3
 3536 0072 FFF7FEFF 		bl	vListInitialiseItem
2745:../Generated_Code/tasks.c ****         vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3537              		.loc 1 2745 0
 3538 0076 FB68     		ldr	r3, [r7, #12]
 3539 0078 1833     		add	r3, r3, #24
 3540 007a 181C     		mov	r0, r3
 3541 007c FFF7FEFF 		bl	vListInitialiseItem
2746:../Generated_Code/tasks.c **** 
2747:../Generated_Code/tasks.c ****         /* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2748:../Generated_Code/tasks.c ****         back to the containing TCB from a generic item in a list. */
2749:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3542              		.loc 1 2749 0
 3543 0080 FB68     		ldr	r3, [r7, #12]
 3544 0082 FA68     		ldr	r2, [r7, #12]
 3545 0084 1A61     		str	r2, [r3, #16]
2750:../Generated_Code/tasks.c **** 
2751:../Generated_Code/tasks.c ****         /* Event lists are always in priority order. */
2752:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - 
 3546              		.loc 1 2752 0
 3547 0086 7B68     		ldr	r3, [r7, #4]
 3548 0088 0622     		mov	r2, #6
 3549 008a D21A     		sub	r2, r2, r3
 3550 008c FB68     		ldr	r3, [r7, #12]
 3551 008e 9A61     		str	r2, [r3, #24]
2753:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3552              		.loc 1 2753 0
 3553 0090 FB68     		ldr	r3, [r7, #12]
 3554 0092 FA68     		ldr	r2, [r7, #12]
 3555 0094 5A62     		str	r2, [r3, #36]
 3556              	.LBE40:
2754:../Generated_Code/tasks.c **** 
2755:../Generated_Code/tasks.c ****         #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2756:../Generated_Code/tasks.c ****         {
2757:../Generated_Code/tasks.c ****                 pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2758:../Generated_Code/tasks.c ****         }
2759:../Generated_Code/tasks.c ****         #endif /* portCRITICAL_NESTING_IN_TCB */
2760:../Generated_Code/tasks.c **** 
2761:../Generated_Code/tasks.c ****         #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2762:../Generated_Code/tasks.c ****         {
2763:../Generated_Code/tasks.c ****                 pxTCB->pxTaskTag = NULL;
2764:../Generated_Code/tasks.c ****         }
2765:../Generated_Code/tasks.c ****         #endif /* configUSE_APPLICATION_TASK_TAG */
2766:../Generated_Code/tasks.c **** 
2767:../Generated_Code/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
2768:../Generated_Code/tasks.c ****         {
2769:../Generated_Code/tasks.c ****                 pxTCB->ulRunTimeCounter = 0UL;
2770:../Generated_Code/tasks.c ****         }
2771:../Generated_Code/tasks.c ****         #endif /* configGENERATE_RUN_TIME_STATS */
2772:../Generated_Code/tasks.c **** 
2773:../Generated_Code/tasks.c ****         #if ( portUSING_MPU_WRAPPERS == 1 )
2774:../Generated_Code/tasks.c ****         {
2775:../Generated_Code/tasks.c ****                 vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usSt
2776:../Generated_Code/tasks.c ****         }
2777:../Generated_Code/tasks.c ****         #else /* portUSING_MPU_WRAPPERS */
2778:../Generated_Code/tasks.c ****         {
2779:../Generated_Code/tasks.c ****                 ( void ) xRegions;
2780:../Generated_Code/tasks.c ****                 ( void ) usStackDepth;
2781:../Generated_Code/tasks.c ****         }
2782:../Generated_Code/tasks.c ****         #endif /* portUSING_MPU_WRAPPERS */
2783:../Generated_Code/tasks.c **** 
2784:../Generated_Code/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
2785:../Generated_Code/tasks.c ****         {
2786:../Generated_Code/tasks.c ****                 /* Initialise this task's Newlib reent structure. */
2787:../Generated_Code/tasks.c ****                 _REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2788:../Generated_Code/tasks.c ****         }
2789:../Generated_Code/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
2790:../Generated_Code/tasks.c **** }
 3557              		.loc 1 2790 0
 3558 0096 BD46     		mov	sp, r7
 3559 0098 06B0     		add	sp, sp, #24
 3560              		@ sp needed for prologue
 3561 009a 80BD     		pop	{r7, pc}
 3562              		.cfi_endproc
 3563              	.LFE36:
 3565              		.section	.text._ZL22prvInitialiseTaskListsv,"ax",%progbits
 3566              		.align	2
 3567              		.code	16
 3568              		.thumb_func
 3570              	_ZL22prvInitialiseTaskListsv:
 3571              	.LFB37:
2791:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2792:../Generated_Code/tasks.c **** 
2793:../Generated_Code/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2794:../Generated_Code/tasks.c **** 
2795:../Generated_Code/tasks.c ****         void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xReg
2796:../Generated_Code/tasks.c ****         {
2797:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2798:../Generated_Code/tasks.c **** 
2799:../Generated_Code/tasks.c ****                 /* If null is passed in here then we are deleting ourselves. */
2800:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTaskToModify );
2801:../Generated_Code/tasks.c **** 
2802:../Generated_Code/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2803:../Generated_Code/tasks.c ****         }
2804:../Generated_Code/tasks.c **** 
2805:../Generated_Code/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2806:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2807:../Generated_Code/tasks.c **** 
2808:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void )
2809:../Generated_Code/tasks.c **** {
 3572              		.loc 1 2809 0
 3573              		.cfi_startproc
 3574 0000 80B5     		push	{r7, lr}
 3575              	.LCFI80:
 3576              		.cfi_def_cfa_offset 8
 3577              		.cfi_offset 7, -8
 3578              		.cfi_offset 14, -4
 3579 0002 82B0     		sub	sp, sp, #8
 3580              	.LCFI81:
 3581              		.cfi_def_cfa_offset 16
 3582 0004 00AF     		add	r7, sp, #0
 3583              	.LCFI82:
 3584              		.cfi_def_cfa_register 7
 3585              	.LBB41:
2810:../Generated_Code/tasks.c **** UBaseType_t uxPriority;
2811:../Generated_Code/tasks.c **** 
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3586              		.loc 1 2812 0
 3587 0006 0023     		mov	r3, #0
 3588 0008 7B60     		str	r3, [r7, #4]
 3589 000a 0CE0     		b	.L259
 3590              	.L260:
2813:../Generated_Code/tasks.c ****         {
2814:../Generated_Code/tasks.c ****                 vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3591              		.loc 1 2814 0
 3592 000c 7A68     		ldr	r2, [r7, #4]
 3593 000e 131C     		mov	r3, r2
 3594 0010 9B00     		lsl	r3, r3, #2
 3595 0012 9B18     		add	r3, r3, r2
 3596 0014 9B00     		lsl	r3, r3, #2
 3597 0016 164A     		ldr	r2, .L261
 3598 0018 9B18     		add	r3, r3, r2
 3599 001a 181C     		mov	r0, r3
 3600 001c FFF7FEFF 		bl	vListInitialise
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3601              		.loc 1 2812 0
 3602 0020 7B68     		ldr	r3, [r7, #4]
 3603 0022 0133     		add	r3, r3, #1
 3604 0024 7B60     		str	r3, [r7, #4]
 3605              	.L259:
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3606              		.loc 1 2812 0 is_stmt 0
 3607 0026 7A68     		ldr	r2, [r7, #4]
 3608 0028 0521     		mov	r1, #5
 3609 002a 0023     		mov	r3, #0
 3610 002c 9142     		cmp	r1, r2
 3611 002e 5B41     		adc	r3, r3, r3
 3612 0030 DBB2     		uxtb	r3, r3
 3613 0032 002B     		cmp	r3, #0
 3614 0034 EAD1     		bne	.L260
2815:../Generated_Code/tasks.c ****         }
2816:../Generated_Code/tasks.c **** 
2817:../Generated_Code/tasks.c ****         vListInitialise( &xDelayedTaskList1 );
 3615              		.loc 1 2817 0 is_stmt 1
 3616 0036 0F4B     		ldr	r3, .L261+4
 3617 0038 181C     		mov	r0, r3
 3618 003a FFF7FEFF 		bl	vListInitialise
2818:../Generated_Code/tasks.c ****         vListInitialise( &xDelayedTaskList2 );
 3619              		.loc 1 2818 0
 3620 003e 0E4B     		ldr	r3, .L261+8
 3621 0040 181C     		mov	r0, r3
 3622 0042 FFF7FEFF 		bl	vListInitialise
2819:../Generated_Code/tasks.c ****         vListInitialise( &xPendingReadyList );
 3623              		.loc 1 2819 0
 3624 0046 0D4B     		ldr	r3, .L261+12
 3625 0048 181C     		mov	r0, r3
 3626 004a FFF7FEFF 		bl	vListInitialise
2820:../Generated_Code/tasks.c **** 
2821:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskDelete == 1 )
2822:../Generated_Code/tasks.c ****         {
2823:../Generated_Code/tasks.c ****                 vListInitialise( &xTasksWaitingTermination );
 3627              		.loc 1 2823 0
 3628 004e 0C4B     		ldr	r3, .L261+16
 3629 0050 181C     		mov	r0, r3
 3630 0052 FFF7FEFF 		bl	vListInitialise
2824:../Generated_Code/tasks.c ****         }
2825:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskDelete */
2826:../Generated_Code/tasks.c **** 
2827:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2828:../Generated_Code/tasks.c ****         {
2829:../Generated_Code/tasks.c ****                 vListInitialise( &xSuspendedTaskList );
 3631              		.loc 1 2829 0
 3632 0056 0B4B     		ldr	r3, .L261+20
 3633 0058 181C     		mov	r0, r3
 3634 005a FFF7FEFF 		bl	vListInitialise
2830:../Generated_Code/tasks.c ****         }
2831:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2832:../Generated_Code/tasks.c **** 
2833:../Generated_Code/tasks.c ****         /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2834:../Generated_Code/tasks.c ****         using list2. */
2835:../Generated_Code/tasks.c ****         pxDelayedTaskList = &xDelayedTaskList1;
 3635              		.loc 1 2835 0
 3636 005e 0A4B     		ldr	r3, .L261+24
 3637 0060 044A     		ldr	r2, .L261+4
 3638 0062 1A60     		str	r2, [r3]
2836:../Generated_Code/tasks.c ****         pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3639              		.loc 1 2836 0
 3640 0064 094B     		ldr	r3, .L261+28
 3641 0066 044A     		ldr	r2, .L261+8
 3642 0068 1A60     		str	r2, [r3]
 3643              	.LBE41:
2837:../Generated_Code/tasks.c **** }
 3644              		.loc 1 2837 0
 3645 006a BD46     		mov	sp, r7
 3646 006c 02B0     		add	sp, sp, #8
 3647              		@ sp needed for prologue
 3648 006e 80BD     		pop	{r7, pc}
 3649              	.L262:
 3650              		.align	2
 3651              	.L261:
 3652 0070 00000000 		.word	_ZL17pxReadyTasksLists
 3653 0074 00000000 		.word	_ZL17xDelayedTaskList1
 3654 0078 00000000 		.word	_ZL17xDelayedTaskList2
 3655 007c 00000000 		.word	_ZL17xPendingReadyList
 3656 0080 00000000 		.word	_ZL24xTasksWaitingTermination
 3657 0084 00000000 		.word	_ZL18xSuspendedTaskList
 3658 0088 00000000 		.word	_ZL17pxDelayedTaskList
 3659 008c 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 3660              		.cfi_endproc
 3661              	.LFE37:
 3663              		.section	.text._ZL31prvCheckTasksWaitingTerminationv,"ax",%progbits
 3664              		.align	2
 3665              		.code	16
 3666              		.thumb_func
 3668              	_ZL31prvCheckTasksWaitingTerminationv:
 3669              	.LFB38:
2838:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2839:../Generated_Code/tasks.c **** 
2840:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2841:../Generated_Code/tasks.c **** {
 3670              		.loc 1 2841 0
 3671              		.cfi_startproc
 3672 0000 80B5     		push	{r7, lr}
 3673              	.LCFI83:
 3674              		.cfi_def_cfa_offset 8
 3675              		.cfi_offset 7, -8
 3676              		.cfi_offset 14, -4
 3677 0002 82B0     		sub	sp, sp, #8
 3678              	.LCFI84:
 3679              		.cfi_def_cfa_offset 16
 3680 0004 00AF     		add	r7, sp, #0
 3681              	.LCFI85:
 3682              		.cfi_def_cfa_register 7
 3683              	.LBB42:
 3684              	.LBB43:
2842:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskDelete == 1 )
2843:../Generated_Code/tasks.c ****         {
2844:../Generated_Code/tasks.c ****                 BaseType_t xListIsEmpty;
2845:../Generated_Code/tasks.c **** 
2846:../Generated_Code/tasks.c ****                 /* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2847:../Generated_Code/tasks.c ****                 too often in the idle task. */
2848:../Generated_Code/tasks.c ****                 while( uxTasksDeleted > ( UBaseType_t ) 0U )
 3685              		.loc 1 2848 0
 3686 0006 27E0     		b	.L264
 3687              	.L265:
 3688              	.LBB44:
2849:../Generated_Code/tasks.c ****                 {
2850:../Generated_Code/tasks.c ****                         vTaskSuspendAll();
 3689              		.loc 1 2850 0
 3690 0008 FFF7FEFF 		bl	vTaskSuspendAll
2851:../Generated_Code/tasks.c ****                         {
2852:../Generated_Code/tasks.c ****                                 xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3691              		.loc 1 2852 0
 3692 000c 174B     		ldr	r3, .L266
 3693 000e 1B68     		ldr	r3, [r3]
 3694 0010 5A42     		neg	r2, r3
 3695 0012 5341     		adc	r3, r3, r2
 3696 0014 DBB2     		uxtb	r3, r3
 3697 0016 7B60     		str	r3, [r7, #4]
2853:../Generated_Code/tasks.c ****                         }
2854:../Generated_Code/tasks.c ****                         ( void ) xTaskResumeAll();
 3698              		.loc 1 2854 0
 3699 0018 FFF7FEFF 		bl	xTaskResumeAll
 3700              	.LBB45:
2855:../Generated_Code/tasks.c **** 
2856:../Generated_Code/tasks.c ****                         if( xListIsEmpty == pdFALSE )
 3701              		.loc 1 2856 0
 3702 001c 7B68     		ldr	r3, [r7, #4]
 3703 001e 002B     		cmp	r3, #0
 3704 0020 1AD1     		bne	.L264
 3705              	.LBB46:
2857:../Generated_Code/tasks.c ****                         {
2858:../Generated_Code/tasks.c ****                                 TCB_t *pxTCB;
2859:../Generated_Code/tasks.c **** 
2860:../Generated_Code/tasks.c ****                                 taskENTER_CRITICAL();
 3706              		.loc 1 2860 0
 3707 0022 FFF7FEFF 		bl	vPortEnterCritical
2861:../Generated_Code/tasks.c ****                                 {
2862:../Generated_Code/tasks.c ****                                         pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksW
 3708              		.loc 1 2862 0
 3709 0026 114B     		ldr	r3, .L266
 3710 0028 DB68     		ldr	r3, [r3, #12]
 3711 002a DB68     		ldr	r3, [r3, #12]
 3712 002c 3B60     		str	r3, [r7]
2863:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3713              		.loc 1 2863 0
 3714 002e 3B68     		ldr	r3, [r7]
 3715 0030 0433     		add	r3, r3, #4
 3716 0032 181C     		mov	r0, r3
 3717 0034 FFF7FEFF 		bl	uxListRemove
2864:../Generated_Code/tasks.c ****                                         --uxCurrentNumberOfTasks;
 3718              		.loc 1 2864 0
 3719 0038 0D4B     		ldr	r3, .L266+4
 3720 003a 1B68     		ldr	r3, [r3]
 3721 003c 5A1E     		sub	r2, r3, #1
 3722 003e 0C4B     		ldr	r3, .L266+4
 3723 0040 1A60     		str	r2, [r3]
2865:../Generated_Code/tasks.c ****                                         --uxTasksDeleted;
 3724              		.loc 1 2865 0
 3725 0042 0C4B     		ldr	r3, .L266+8
 3726 0044 1B68     		ldr	r3, [r3]
 3727 0046 5A1E     		sub	r2, r3, #1
 3728 0048 0A4B     		ldr	r3, .L266+8
 3729 004a 1A60     		str	r2, [r3]
2866:../Generated_Code/tasks.c ****                                 }
2867:../Generated_Code/tasks.c ****                                 taskEXIT_CRITICAL();
 3730              		.loc 1 2867 0
 3731 004c FFF7FEFF 		bl	vPortExitCritical
2868:../Generated_Code/tasks.c **** 
2869:../Generated_Code/tasks.c ****                                 prvDeleteTCB( pxTCB );
 3732              		.loc 1 2869 0
 3733 0050 3B68     		ldr	r3, [r7]
 3734 0052 181C     		mov	r0, r3
 3735 0054 FFF7FEFF 		bl	_ZL12prvDeleteTCBP19tskTaskControlBlock
 3736              	.L264:
 3737              	.LBE46:
 3738              	.LBE45:
 3739              	.LBE44:
2848:../Generated_Code/tasks.c ****                 while( uxTasksDeleted > ( UBaseType_t ) 0U )
 3740              		.loc 1 2848 0
 3741 0058 064B     		ldr	r3, .L266+8
 3742 005a 1B68     		ldr	r3, [r3]
 3743 005c 5A1E     		sub	r2, r3, #1
 3744 005e 9341     		sbc	r3, r3, r2
 3745 0060 DBB2     		uxtb	r3, r3
 3746 0062 002B     		cmp	r3, #0
 3747 0064 D0D1     		bne	.L265
 3748              	.LBE43:
 3749              	.LBE42:
2870:../Generated_Code/tasks.c ****                         }
2871:../Generated_Code/tasks.c ****                         else
2872:../Generated_Code/tasks.c ****                         {
2873:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2874:../Generated_Code/tasks.c ****                         }
2875:../Generated_Code/tasks.c ****                 }
2876:../Generated_Code/tasks.c ****         }
2877:../Generated_Code/tasks.c ****         #endif /* vTaskDelete */
2878:../Generated_Code/tasks.c **** }
 3750              		.loc 1 2878 0
 3751 0066 BD46     		mov	sp, r7
 3752 0068 02B0     		add	sp, sp, #8
 3753              		@ sp needed for prologue
 3754 006a 80BD     		pop	{r7, pc}
 3755              	.L267:
 3756              		.align	2
 3757              	.L266:
 3758 006c 00000000 		.word	_ZL24xTasksWaitingTermination
 3759 0070 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 3760 0074 00000000 		.word	_ZL14uxTasksDeleted
 3761              		.cfi_endproc
 3762              	.LFE38:
 3764              		.section	.text._ZL30prvAddCurrentTaskToDelayedListm,"ax",%progbits
 3765              		.align	2
 3766              		.code	16
 3767              		.thumb_func
 3769              	_ZL30prvAddCurrentTaskToDelayedListm:
 3770              	.LFB39:
2879:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2880:../Generated_Code/tasks.c **** 
2881:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2882:../Generated_Code/tasks.c **** {
 3771              		.loc 1 2882 0
 3772              		.cfi_startproc
 3773 0000 80B5     		push	{r7, lr}
 3774              	.LCFI86:
 3775              		.cfi_def_cfa_offset 8
 3776              		.cfi_offset 7, -8
 3777              		.cfi_offset 14, -4
 3778 0002 82B0     		sub	sp, sp, #8
 3779              	.LCFI87:
 3780              		.cfi_def_cfa_offset 16
 3781 0004 00AF     		add	r7, sp, #0
 3782              	.LCFI88:
 3783              		.cfi_def_cfa_register 7
 3784 0006 7860     		str	r0, [r7, #4]
2883:../Generated_Code/tasks.c ****         /* The list item will be inserted in wake time order. */
2884:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3785              		.loc 1 2884 0
 3786 0008 174B     		ldr	r3, .L271
 3787 000a 1B68     		ldr	r3, [r3]
 3788 000c 7A68     		ldr	r2, [r7, #4]
 3789 000e 5A60     		str	r2, [r3, #4]
2885:../Generated_Code/tasks.c **** 
2886:../Generated_Code/tasks.c ****         if( xTimeToWake < xTickCount )
 3790              		.loc 1 2886 0
 3791 0010 164B     		ldr	r3, .L271+4
 3792 0012 1B68     		ldr	r3, [r3]
 3793 0014 7A68     		ldr	r2, [r7, #4]
 3794 0016 9A42     		cmp	r2, r3
 3795 0018 9B41     		sbc	r3, r3, r3
 3796 001a 5B42     		neg	r3, r3
 3797 001c DBB2     		uxtb	r3, r3
 3798 001e 002B     		cmp	r3, #0
 3799 0020 09D0     		beq	.L269
2887:../Generated_Code/tasks.c ****         {
2888:../Generated_Code/tasks.c ****                 /* Wake time has overflowed.  Place this item in the overflow list. */
2889:../Generated_Code/tasks.c ****                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3800              		.loc 1 2889 0
 3801 0022 134B     		ldr	r3, .L271+8
 3802 0024 1A68     		ldr	r2, [r3]
 3803 0026 104B     		ldr	r3, .L271
 3804 0028 1B68     		ldr	r3, [r3]
 3805 002a 0433     		add	r3, r3, #4
 3806 002c 101C     		mov	r0, r2
 3807 002e 191C     		mov	r1, r3
 3808 0030 FFF7FEFF 		bl	vListInsert
 3809 0034 14E0     		b	.L268
 3810              	.L269:
2890:../Generated_Code/tasks.c ****         }
2891:../Generated_Code/tasks.c ****         else
2892:../Generated_Code/tasks.c ****         {
2893:../Generated_Code/tasks.c ****                 /* The wake time has not overflowed, so the current block list is used. */
2894:../Generated_Code/tasks.c ****                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3811              		.loc 1 2894 0
 3812 0036 0F4B     		ldr	r3, .L271+12
 3813 0038 1A68     		ldr	r2, [r3]
 3814 003a 0B4B     		ldr	r3, .L271
 3815 003c 1B68     		ldr	r3, [r3]
 3816 003e 0433     		add	r3, r3, #4
 3817 0040 101C     		mov	r0, r2
 3818 0042 191C     		mov	r1, r3
 3819 0044 FFF7FEFF 		bl	vListInsert
2895:../Generated_Code/tasks.c **** 
2896:../Generated_Code/tasks.c ****                 /* If the task entering the blocked state was placed at the head of the
2897:../Generated_Code/tasks.c ****                 list of blocked tasks then xNextTaskUnblockTime needs to be updated
2898:../Generated_Code/tasks.c ****                 too. */
2899:../Generated_Code/tasks.c ****                 if( xTimeToWake < xNextTaskUnblockTime )
 3820              		.loc 1 2899 0
 3821 0048 0B4B     		ldr	r3, .L271+16
 3822 004a 1B68     		ldr	r3, [r3]
 3823 004c 7A68     		ldr	r2, [r7, #4]
 3824 004e 9A42     		cmp	r2, r3
 3825 0050 9B41     		sbc	r3, r3, r3
 3826 0052 5B42     		neg	r3, r3
 3827 0054 DBB2     		uxtb	r3, r3
 3828 0056 002B     		cmp	r3, #0
 3829 0058 02D0     		beq	.L268
2900:../Generated_Code/tasks.c ****                 {
2901:../Generated_Code/tasks.c ****                         xNextTaskUnblockTime = xTimeToWake;
 3830              		.loc 1 2901 0
 3831 005a 074B     		ldr	r3, .L271+16
 3832 005c 7A68     		ldr	r2, [r7, #4]
 3833 005e 1A60     		str	r2, [r3]
 3834              	.L268:
2902:../Generated_Code/tasks.c ****                 }
2903:../Generated_Code/tasks.c ****                 else
2904:../Generated_Code/tasks.c ****                 {
2905:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2906:../Generated_Code/tasks.c ****                 }
2907:../Generated_Code/tasks.c ****         }
2908:../Generated_Code/tasks.c **** }
 3835              		.loc 1 2908 0
 3836 0060 BD46     		mov	sp, r7
 3837 0062 02B0     		add	sp, sp, #8
 3838              		@ sp needed for prologue
 3839 0064 80BD     		pop	{r7, pc}
 3840              	.L272:
 3841 0066 C046     		.align	2
 3842              	.L271:
 3843 0068 00000000 		.word	pxCurrentTCB
 3844 006c 00000000 		.word	_ZL10xTickCount
 3845 0070 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 3846 0074 00000000 		.word	_ZL17pxDelayedTaskList
 3847 0078 00000000 		.word	_ZL20xNextTaskUnblockTime
 3848              		.cfi_endproc
 3849              	.LFE39:
 3851              		.section	.text._ZL22prvAllocateTCBAndStacktPm,"ax",%progbits
 3852              		.align	2
 3853              		.code	16
 3854              		.thumb_func
 3856              	_ZL22prvAllocateTCBAndStacktPm:
 3857              	.LFB40:
2909:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2910:../Generated_Code/tasks.c **** 
2911:../Generated_Code/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
2912:../Generated_Code/tasks.c **** {
 3858              		.loc 1 2912 0
 3859              		.cfi_startproc
 3860 0000 80B5     		push	{r7, lr}
 3861              	.LCFI89:
 3862              		.cfi_def_cfa_offset 8
 3863              		.cfi_offset 7, -8
 3864              		.cfi_offset 14, -4
 3865 0002 84B0     		sub	sp, sp, #16
 3866              	.LCFI90:
 3867              		.cfi_def_cfa_offset 24
 3868 0004 00AF     		add	r7, sp, #0
 3869              	.LCFI91:
 3870              		.cfi_def_cfa_register 7
 3871 0006 021C     		mov	r2, r0
 3872 0008 3960     		str	r1, [r7]
 3873 000a BB1D     		add	r3, r7, #6
 3874 000c 1A80     		strh	r2, [r3]
 3875              	.LBB47:
2913:../Generated_Code/tasks.c **** TCB_t *pxNewTCB;
2914:../Generated_Code/tasks.c **** 
2915:../Generated_Code/tasks.c ****         /* Allocate space for the TCB.  Where the memory comes from depends on
2916:../Generated_Code/tasks.c ****         the implementation of the port malloc function. */
2917:../Generated_Code/tasks.c ****         pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 3876              		.loc 1 2917 0
 3877 000e 5420     		mov	r0, #84
 3878 0010 FFF7FEFF 		bl	pvPortMalloc
 3879 0014 031C     		mov	r3, r0
 3880 0016 FB60     		str	r3, [r7, #12]
2918:../Generated_Code/tasks.c **** 
2919:../Generated_Code/tasks.c ****         if( pxNewTCB != NULL )
 3881              		.loc 1 2919 0
 3882 0018 FB68     		ldr	r3, [r7, #12]
 3883 001a 002B     		cmp	r3, #0
 3884 001c 22D0     		beq	.L274
2920:../Generated_Code/tasks.c ****         {
2921:../Generated_Code/tasks.c ****                 /* Allocate space for the stack used by the task being created.
2922:../Generated_Code/tasks.c ****                 The base of the stack memory stored in the TCB so the task can
2923:../Generated_Code/tasks.c ****                 be deleted later if required. */
2924:../Generated_Code/tasks.c ****                 pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDe
 3885              		.loc 1 2924 0
 3886 001e 3B68     		ldr	r3, [r7]
 3887 0020 002B     		cmp	r3, #0
 3888 0022 07D1     		bne	.L275
 3889              		.loc 1 2924 0 is_stmt 0
 3890 0024 BB1D     		add	r3, r7, #6
 3891 0026 1B88     		ldrh	r3, [r3]
 3892 0028 9B00     		lsl	r3, r3, #2
 3893 002a 181C     		mov	r0, r3
 3894 002c FFF7FEFF 		bl	pvPortMalloc
 3895 0030 021C     		mov	r2, r0
 3896 0032 00E0     		b	.L276
 3897              	.L275:
 3898              		.loc 1 2924 0
 3899 0034 3A68     		ldr	r2, [r7]
 3900              	.L276:
 3901              		.loc 1 2924 0
 3902 0036 FB68     		ldr	r3, [r7, #12]
 3903 0038 1A63     		str	r2, [r3, #48]
2925:../Generated_Code/tasks.c **** 
2926:../Generated_Code/tasks.c ****                 if( pxNewTCB->pxStack == NULL )
 3904              		.loc 1 2926 0 is_stmt 1
 3905 003a FB68     		ldr	r3, [r7, #12]
 3906 003c 1B6B     		ldr	r3, [r3, #48]
 3907 003e 002B     		cmp	r3, #0
 3908 0040 06D1     		bne	.L277
2927:../Generated_Code/tasks.c ****                 {
2928:../Generated_Code/tasks.c ****                         /* Could not allocate the stack.  Delete the allocated TCB. */
2929:../Generated_Code/tasks.c ****                         vPortFree( pxNewTCB );
 3909              		.loc 1 2929 0
 3910 0042 FB68     		ldr	r3, [r7, #12]
 3911 0044 181C     		mov	r0, r3
 3912 0046 FFF7FEFF 		bl	vPortFree
2930:../Generated_Code/tasks.c ****                         pxNewTCB = NULL;
 3913              		.loc 1 2930 0
 3914 004a 0023     		mov	r3, #0
 3915 004c FB60     		str	r3, [r7, #12]
 3916 004e 09E0     		b	.L274
 3917              	.L277:
2931:../Generated_Code/tasks.c ****                 }
2932:../Generated_Code/tasks.c ****                 else
2933:../Generated_Code/tasks.c ****                 {
2934:../Generated_Code/tasks.c ****                         /* Avoid dependency on memset() if it is not required. */
2935:../Generated_Code/tasks.c ****                         #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY =
2936:../Generated_Code/tasks.c ****                         {
2937:../Generated_Code/tasks.c ****                                 /* Just to help debugging. */
2938:../Generated_Code/tasks.c ****                                 ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( s
 3918              		.loc 1 2938 0
 3919 0050 FB68     		ldr	r3, [r7, #12]
 3920 0052 1A6B     		ldr	r2, [r3, #48]
 3921 0054 BB1D     		add	r3, r7, #6
 3922 0056 1B88     		ldrh	r3, [r3]
 3923 0058 9B00     		lsl	r3, r3, #2
 3924 005a 101C     		mov	r0, r2
 3925 005c A521     		mov	r1, #165
 3926 005e 1A1C     		mov	r2, r3
 3927 0060 FFF7FEFF 		bl	memset
 3928              	.L274:
2939:../Generated_Code/tasks.c ****                         }
2940:../Generated_Code/tasks.c ****                         #endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_F
2941:../Generated_Code/tasks.c ****                 }
2942:../Generated_Code/tasks.c ****         }
2943:../Generated_Code/tasks.c **** 
2944:../Generated_Code/tasks.c ****         return pxNewTCB;
 3929              		.loc 1 2944 0
 3930 0064 FB68     		ldr	r3, [r7, #12]
 3931              	.LBE47:
2945:../Generated_Code/tasks.c **** }
 3932              		.loc 1 2945 0
 3933 0066 181C     		mov	r0, r3
 3934 0068 BD46     		mov	sp, r7
 3935 006a 04B0     		add	sp, sp, #16
 3936              		@ sp needed for prologue
 3937 006c 80BD     		pop	{r7, pc}
 3938              		.cfi_endproc
 3939              	.LFE40:
 3941 006e C046     		.section	.text._ZL26prvTaskCheckFreeStackSpacePKh,"ax",%progbits
 3942              		.align	2
 3943              		.code	16
 3944              		.thumb_func
 3946              	_ZL26prvTaskCheckFreeStackSpacePKh:
 3947              	.LFB41:
2946:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2947:../Generated_Code/tasks.c **** 
2948:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2949:../Generated_Code/tasks.c **** 
2950:../Generated_Code/tasks.c ****         static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *px
2951:../Generated_Code/tasks.c ****         {
2952:../Generated_Code/tasks.c ****         volatile TCB_t *pxNextTCB, *pxFirstTCB;
2953:../Generated_Code/tasks.c ****         UBaseType_t uxTask = 0;
2954:../Generated_Code/tasks.c **** 
2955:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2956:../Generated_Code/tasks.c ****                 {
2957:../Generated_Code/tasks.c ****                         listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2958:../Generated_Code/tasks.c **** 
2959:../Generated_Code/tasks.c ****                         /* Populate an TaskStatus_t structure within the
2960:../Generated_Code/tasks.c ****                         pxTaskStatusArray array for each task that is referenced from
2961:../Generated_Code/tasks.c ****                         pxList.  See the definition of TaskStatus_t in task.h for the
2962:../Generated_Code/tasks.c ****                         meaning of each TaskStatus_t structure member. */
2963:../Generated_Code/tasks.c ****                         do
2964:../Generated_Code/tasks.c ****                         {
2965:../Generated_Code/tasks.c ****                                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2966:../Generated_Code/tasks.c **** 
2967:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
2968:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNext
2969:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2970:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2971:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriori
2972:../Generated_Code/tasks.c **** 
2973:../Generated_Code/tasks.c ****                                 #if ( INCLUDE_vTaskSuspend == 1 )
2974:../Generated_Code/tasks.c ****                                 {
2975:../Generated_Code/tasks.c ****                                         /* If the task is in the suspended list then there is a cha
2976:../Generated_Code/tasks.c ****                                         it is actually just blocked indefinitely - so really it sho
2977:../Generated_Code/tasks.c ****                                         be reported as being in the Blocked state. */
2978:../Generated_Code/tasks.c ****                                         if( eState == eSuspended )
2979:../Generated_Code/tasks.c ****                                         {
2980:../Generated_Code/tasks.c ****                                                 if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventLi
2981:../Generated_Code/tasks.c ****                                                 {
2982:../Generated_Code/tasks.c ****                                                         pxTaskStatusArray[ uxTask ].eCurrentState =
2983:../Generated_Code/tasks.c ****                                                 }
2984:../Generated_Code/tasks.c ****                                         }
2985:../Generated_Code/tasks.c ****                                 }
2986:../Generated_Code/tasks.c ****                                 #endif /* INCLUDE_vTaskSuspend */
2987:../Generated_Code/tasks.c **** 
2988:../Generated_Code/tasks.c ****                                 #if ( configUSE_MUTEXES == 1 )
2989:../Generated_Code/tasks.c ****                                 {
2990:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxB
2991:../Generated_Code/tasks.c ****                                 }
2992:../Generated_Code/tasks.c ****                                 #else
2993:../Generated_Code/tasks.c ****                                 {
2994:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2995:../Generated_Code/tasks.c ****                                 }
2996:../Generated_Code/tasks.c ****                                 #endif
2997:../Generated_Code/tasks.c **** 
2998:../Generated_Code/tasks.c ****                                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2999:../Generated_Code/tasks.c ****                                 {
3000:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->u
3001:../Generated_Code/tasks.c ****                                 }
3002:../Generated_Code/tasks.c ****                                 #else
3003:../Generated_Code/tasks.c ****                                 {
3004:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3005:../Generated_Code/tasks.c ****                                 }
3006:../Generated_Code/tasks.c ****                                 #endif
3007:../Generated_Code/tasks.c **** 
3008:../Generated_Code/tasks.c ****                                 #if ( portSTACK_GROWTH > 0 )
3009:../Generated_Code/tasks.c ****                                 {
3010:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskC
3011:../Generated_Code/tasks.c ****                                 }
3012:../Generated_Code/tasks.c ****                                 #else
3013:../Generated_Code/tasks.c ****                                 {
3014:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskC
3015:../Generated_Code/tasks.c ****                                 }
3016:../Generated_Code/tasks.c ****                                 #endif
3017:../Generated_Code/tasks.c **** 
3018:../Generated_Code/tasks.c ****                                 uxTask++;
3019:../Generated_Code/tasks.c **** 
3020:../Generated_Code/tasks.c ****                         } while( pxNextTCB != pxFirstTCB );
3021:../Generated_Code/tasks.c ****                 }
3022:../Generated_Code/tasks.c ****                 else
3023:../Generated_Code/tasks.c ****                 {
3024:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3025:../Generated_Code/tasks.c ****                 }
3026:../Generated_Code/tasks.c **** 
3027:../Generated_Code/tasks.c ****                 return uxTask;
3028:../Generated_Code/tasks.c ****         }
3029:../Generated_Code/tasks.c **** 
3030:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3031:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3032:../Generated_Code/tasks.c **** 
3033:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3034:../Generated_Code/tasks.c **** 
3035:../Generated_Code/tasks.c ****         static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3036:../Generated_Code/tasks.c ****         {
 3948              		.loc 1 3036 0
 3949              		.cfi_startproc
 3950 0000 80B5     		push	{r7, lr}
 3951              	.LCFI92:
 3952              		.cfi_def_cfa_offset 8
 3953              		.cfi_offset 7, -8
 3954              		.cfi_offset 14, -4
 3955 0002 84B0     		sub	sp, sp, #16
 3956              	.LCFI93:
 3957              		.cfi_def_cfa_offset 24
 3958 0004 00AF     		add	r7, sp, #0
 3959              	.LCFI94:
 3960              		.cfi_def_cfa_register 7
 3961 0006 7860     		str	r0, [r7, #4]
 3962              	.LBB48:
3037:../Generated_Code/tasks.c ****         uint32_t ulCount = 0U;
 3963              		.loc 1 3037 0
 3964 0008 0023     		mov	r3, #0
 3965 000a FB60     		str	r3, [r7, #12]
3038:../Generated_Code/tasks.c **** 
3039:../Generated_Code/tasks.c ****                 while( *pucStackByte == tskSTACK_FILL_BYTE )
 3966              		.loc 1 3039 0
 3967 000c 05E0     		b	.L280
 3968              	.L281:
3040:../Generated_Code/tasks.c ****                 {
3041:../Generated_Code/tasks.c ****                         pucStackByte -= portSTACK_GROWTH;
 3969              		.loc 1 3041 0
 3970 000e 7B68     		ldr	r3, [r7, #4]
 3971 0010 0133     		add	r3, r3, #1
 3972 0012 7B60     		str	r3, [r7, #4]
3042:../Generated_Code/tasks.c ****                         ulCount++;
 3973              		.loc 1 3042 0
 3974 0014 FB68     		ldr	r3, [r7, #12]
 3975 0016 0133     		add	r3, r3, #1
 3976 0018 FB60     		str	r3, [r7, #12]
 3977              	.L280:
3039:../Generated_Code/tasks.c ****                 while( *pucStackByte == tskSTACK_FILL_BYTE )
 3978              		.loc 1 3039 0
 3979 001a 7B68     		ldr	r3, [r7, #4]
 3980 001c 1B78     		ldrb	r3, [r3]
 3981 001e A53B     		sub	r3, r3, #165
 3982 0020 5A42     		neg	r2, r3
 3983 0022 5341     		adc	r3, r3, r2
 3984 0024 DBB2     		uxtb	r3, r3
 3985 0026 002B     		cmp	r3, #0
 3986 0028 F1D1     		bne	.L281
3043:../Generated_Code/tasks.c ****                 }
3044:../Generated_Code/tasks.c **** 
3045:../Generated_Code/tasks.c ****                 ulCount /= ( uint32_t ) sizeof( StackType_t );
 3987              		.loc 1 3045 0
 3988 002a FB68     		ldr	r3, [r7, #12]
 3989 002c 9B08     		lsr	r3, r3, #2
 3990 002e FB60     		str	r3, [r7, #12]
3046:../Generated_Code/tasks.c **** 
3047:../Generated_Code/tasks.c ****                 return ( uint16_t ) ulCount;
 3991              		.loc 1 3047 0
 3992 0030 FB68     		ldr	r3, [r7, #12]
 3993 0032 9BB2     		uxth	r3, r3
 3994              	.LBE48:
3048:../Generated_Code/tasks.c ****         }
 3995              		.loc 1 3048 0
 3996 0034 181C     		mov	r0, r3
 3997 0036 BD46     		mov	sp, r7
 3998 0038 04B0     		add	sp, sp, #16
 3999              		@ sp needed for prologue
 4000 003a 80BD     		pop	{r7, pc}
 4001              		.cfi_endproc
 4002              	.LFE41:
 4004              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 4005              		.align	2
 4006              		.global	uxTaskGetStackHighWaterMark
 4007              		.code	16
 4008              		.thumb_func
 4010              	uxTaskGetStackHighWaterMark:
 4011              	.LFB42:
3049:../Generated_Code/tasks.c **** 
3050:../Generated_Code/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3051:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3052:../Generated_Code/tasks.c **** 
3053:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3054:../Generated_Code/tasks.c **** 
3055:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3056:../Generated_Code/tasks.c ****         {
 4012              		.loc 1 3056 0
 4013              		.cfi_startproc
 4014 0000 80B5     		push	{r7, lr}
 4015              	.LCFI95:
 4016              		.cfi_def_cfa_offset 8
 4017              		.cfi_offset 7, -8
 4018              		.cfi_offset 14, -4
 4019 0002 86B0     		sub	sp, sp, #24
 4020              	.LCFI96:
 4021              		.cfi_def_cfa_offset 32
 4022 0004 00AF     		add	r7, sp, #0
 4023              	.LCFI97:
 4024              		.cfi_def_cfa_register 7
 4025 0006 7860     		str	r0, [r7, #4]
 4026              	.LBB49:
3057:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
3058:../Generated_Code/tasks.c ****         uint8_t *pucEndOfStack;
3059:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
3060:../Generated_Code/tasks.c **** 
3061:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTask );
 4027              		.loc 1 3061 0
 4028 0008 7B68     		ldr	r3, [r7, #4]
 4029 000a 002B     		cmp	r3, #0
 4030 000c 02D1     		bne	.L284
 4031              		.loc 1 3061 0 is_stmt 0
 4032 000e 094B     		ldr	r3, .L287
 4033 0010 1B68     		ldr	r3, [r3]
 4034 0012 00E0     		b	.L285
 4035              	.L284:
 4036              		.loc 1 3061 0
 4037 0014 7B68     		ldr	r3, [r7, #4]
 4038              	.L285:
 4039              		.loc 1 3061 0
 4040 0016 7B61     		str	r3, [r7, #20]
3062:../Generated_Code/tasks.c **** 
3063:../Generated_Code/tasks.c ****                 #if portSTACK_GROWTH < 0
3064:../Generated_Code/tasks.c ****                 {
3065:../Generated_Code/tasks.c ****                         pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 4041              		.loc 1 3065 0 is_stmt 1
 4042 0018 7B69     		ldr	r3, [r7, #20]
 4043 001a 1B6B     		ldr	r3, [r3, #48]
 4044 001c 3B61     		str	r3, [r7, #16]
3066:../Generated_Code/tasks.c ****                 }
3067:../Generated_Code/tasks.c ****                 #else
3068:../Generated_Code/tasks.c ****                 {
3069:../Generated_Code/tasks.c ****                         pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3070:../Generated_Code/tasks.c ****                 }
3071:../Generated_Code/tasks.c ****                 #endif
3072:../Generated_Code/tasks.c **** 
3073:../Generated_Code/tasks.c ****                 uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 4045              		.loc 1 3073 0
 4046 001e 3B69     		ldr	r3, [r7, #16]
 4047 0020 181C     		mov	r0, r3
 4048 0022 FFF7FEFF 		bl	_ZL26prvTaskCheckFreeStackSpacePKh
 4049 0026 031C     		mov	r3, r0
 4050 0028 FB60     		str	r3, [r7, #12]
3074:../Generated_Code/tasks.c **** 
3075:../Generated_Code/tasks.c ****                 return uxReturn;
 4051              		.loc 1 3075 0
 4052 002a FB68     		ldr	r3, [r7, #12]
 4053              	.LBE49:
3076:../Generated_Code/tasks.c ****         }
 4054              		.loc 1 3076 0
 4055 002c 181C     		mov	r0, r3
 4056 002e BD46     		mov	sp, r7
 4057 0030 06B0     		add	sp, sp, #24
 4058              		@ sp needed for prologue
 4059 0032 80BD     		pop	{r7, pc}
 4060              	.L288:
 4061              		.align	2
 4062              	.L287:
 4063 0034 00000000 		.word	pxCurrentTCB
 4064              		.cfi_endproc
 4065              	.LFE42:
 4067              		.section	.text._ZL12prvDeleteTCBP19tskTaskControlBlock,"ax",%progbits
 4068              		.align	2
 4069              		.code	16
 4070              		.thumb_func
 4072              	_ZL12prvDeleteTCBP19tskTaskControlBlock:
 4073              	.LFB43:
3077:../Generated_Code/tasks.c **** 
3078:../Generated_Code/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3079:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3080:../Generated_Code/tasks.c **** 
3081:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3082:../Generated_Code/tasks.c **** 
3083:../Generated_Code/tasks.c ****         static void prvDeleteTCB( TCB_t *pxTCB )
3084:../Generated_Code/tasks.c ****         {
 4074              		.loc 1 3084 0
 4075              		.cfi_startproc
 4076 0000 80B5     		push	{r7, lr}
 4077              	.LCFI98:
 4078              		.cfi_def_cfa_offset 8
 4079              		.cfi_offset 7, -8
 4080              		.cfi_offset 14, -4
 4081 0002 82B0     		sub	sp, sp, #8
 4082              	.LCFI99:
 4083              		.cfi_def_cfa_offset 16
 4084 0004 00AF     		add	r7, sp, #0
 4085              	.LCFI100:
 4086              		.cfi_def_cfa_register 7
 4087 0006 7860     		str	r0, [r7, #4]
3085:../Generated_Code/tasks.c ****                 /* This call is required specifically for the TriCore port.  It must be
3086:../Generated_Code/tasks.c ****                 above the vPortFree() calls.  The call is also used by ports/demos that
3087:../Generated_Code/tasks.c ****                 want to allocate and clean RAM statically. */
3088:../Generated_Code/tasks.c ****                 portCLEAN_UP_TCB( pxTCB );
3089:../Generated_Code/tasks.c **** 
3090:../Generated_Code/tasks.c ****                 /* Free up the memory allocated by the scheduler for the task.  It is up to
3091:../Generated_Code/tasks.c ****                 the task to free any memory allocated at the application level. */
3092:../Generated_Code/tasks.c ****                 vPortFreeAligned( pxTCB->pxStack );
 4088              		.loc 1 3092 0
 4089 0008 7B68     		ldr	r3, [r7, #4]
 4090 000a 1B6B     		ldr	r3, [r3, #48]
 4091 000c 181C     		mov	r0, r3
 4092 000e FFF7FEFF 		bl	vPortFree
3093:../Generated_Code/tasks.c ****                 vPortFree( pxTCB );
 4093              		.loc 1 3093 0
 4094 0012 7B68     		ldr	r3, [r7, #4]
 4095 0014 181C     		mov	r0, r3
 4096 0016 FFF7FEFF 		bl	vPortFree
3094:../Generated_Code/tasks.c ****         }
 4097              		.loc 1 3094 0
 4098 001a BD46     		mov	sp, r7
 4099 001c 02B0     		add	sp, sp, #8
 4100              		@ sp needed for prologue
 4101 001e 80BD     		pop	{r7, pc}
 4102              		.cfi_endproc
 4103              	.LFE43:
 4105              		.section	.text._ZL27prvResetNextTaskUnblockTimev,"ax",%progbits
 4106              		.align	2
 4107              		.code	16
 4108              		.thumb_func
 4110              	_ZL27prvResetNextTaskUnblockTimev:
 4111              	.LFB44:
3095:../Generated_Code/tasks.c **** 
3096:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3097:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3098:../Generated_Code/tasks.c **** 
3099:../Generated_Code/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3100:../Generated_Code/tasks.c **** {
 4112              		.loc 1 3100 0
 4113              		.cfi_startproc
 4114 0000 80B5     		push	{r7, lr}
 4115              	.LCFI101:
 4116              		.cfi_def_cfa_offset 8
 4117              		.cfi_offset 7, -8
 4118              		.cfi_offset 14, -4
 4119 0002 82B0     		sub	sp, sp, #8
 4120              	.LCFI102:
 4121              		.cfi_def_cfa_offset 16
 4122 0004 00AF     		add	r7, sp, #0
 4123              	.LCFI103:
 4124              		.cfi_def_cfa_register 7
 4125              	.LBB50:
3101:../Generated_Code/tasks.c **** TCB_t *pxTCB;
3102:../Generated_Code/tasks.c **** 
3103:../Generated_Code/tasks.c ****         if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4126              		.loc 1 3103 0
 4127 0006 0D4B     		ldr	r3, .L295
 4128 0008 1B68     		ldr	r3, [r3]
 4129 000a 1B68     		ldr	r3, [r3]
 4130 000c 002B     		cmp	r3, #0
 4131 000e 01D1     		bne	.L291
 4132              		.loc 1 3103 0 is_stmt 0
 4133 0010 0123     		mov	r3, #1
 4134 0012 00E0     		b	.L292
 4135              	.L291:
 4136              		.loc 1 3103 0
 4137 0014 0023     		mov	r3, #0
 4138              	.L292:
 4139              		.loc 1 3103 0
 4140 0016 002B     		cmp	r3, #0
 4141 0018 04D0     		beq	.L293
3104:../Generated_Code/tasks.c ****         {
3105:../Generated_Code/tasks.c ****                 /* The new current delayed list is empty.  Set
3106:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime to the maximum possible value so it is
3107:../Generated_Code/tasks.c ****                 extremely unlikely that the
3108:../Generated_Code/tasks.c ****                 if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3109:../Generated_Code/tasks.c ****                 there is an item in the delayed list. */
3110:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime = portMAX_DELAY;
 4142              		.loc 1 3110 0 is_stmt 1
 4143 001a 094B     		ldr	r3, .L295+4
 4144 001c 0122     		mov	r2, #1
 4145 001e 5242     		neg	r2, r2
 4146 0020 1A60     		str	r2, [r3]
 4147 0022 08E0     		b	.L290
 4148              	.L293:
3111:../Generated_Code/tasks.c ****         }
3112:../Generated_Code/tasks.c ****         else
3113:../Generated_Code/tasks.c ****         {
3114:../Generated_Code/tasks.c ****                 /* The new current delayed list is not empty, get the value of
3115:../Generated_Code/tasks.c ****                 the item at the head of the delayed list.  This is the time at
3116:../Generated_Code/tasks.c ****                 which the task at the head of the delayed list should be removed
3117:../Generated_Code/tasks.c ****                 from the Blocked state. */
3118:../Generated_Code/tasks.c ****                 ( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 4149              		.loc 1 3118 0
 4150 0024 054B     		ldr	r3, .L295
 4151 0026 1B68     		ldr	r3, [r3]
 4152 0028 DB68     		ldr	r3, [r3, #12]
 4153 002a DB68     		ldr	r3, [r3, #12]
 4154 002c 7B60     		str	r3, [r7, #4]
3119:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 4155              		.loc 1 3119 0
 4156 002e 7B68     		ldr	r3, [r7, #4]
 4157 0030 5A68     		ldr	r2, [r3, #4]
 4158 0032 034B     		ldr	r3, .L295+4
 4159 0034 1A60     		str	r2, [r3]
 4160              	.L290:
 4161              	.LBE50:
3120:../Generated_Code/tasks.c ****         }
3121:../Generated_Code/tasks.c **** }
 4162              		.loc 1 3121 0
 4163 0036 BD46     		mov	sp, r7
 4164 0038 02B0     		add	sp, sp, #8
 4165              		@ sp needed for prologue
 4166 003a 80BD     		pop	{r7, pc}
 4167              	.L296:
 4168              		.align	2
 4169              	.L295:
 4170 003c 00000000 		.word	_ZL17pxDelayedTaskList
 4171 0040 00000000 		.word	_ZL20xNextTaskUnblockTime
 4172              		.cfi_endproc
 4173              	.LFE44:
 4175              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4176              		.align	2
 4177              		.global	xTaskGetCurrentTaskHandle
 4178              		.code	16
 4179              		.thumb_func
 4181              	xTaskGetCurrentTaskHandle:
 4182              	.LFB45:
3122:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3123:../Generated_Code/tasks.c **** 
3124:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3125:../Generated_Code/tasks.c **** 
3126:../Generated_Code/tasks.c ****         TaskHandle_t xTaskGetCurrentTaskHandle( void )
3127:../Generated_Code/tasks.c ****         {
 4183              		.loc 1 3127 0
 4184              		.cfi_startproc
 4185 0000 80B5     		push	{r7, lr}
 4186              	.LCFI104:
 4187              		.cfi_def_cfa_offset 8
 4188              		.cfi_offset 7, -8
 4189              		.cfi_offset 14, -4
 4190 0002 82B0     		sub	sp, sp, #8
 4191              	.LCFI105:
 4192              		.cfi_def_cfa_offset 16
 4193 0004 00AF     		add	r7, sp, #0
 4194              	.LCFI106:
 4195              		.cfi_def_cfa_register 7
 4196              	.LBB51:
3128:../Generated_Code/tasks.c ****         TaskHandle_t xReturn;
3129:../Generated_Code/tasks.c **** 
3130:../Generated_Code/tasks.c ****                 /* A critical section is not required as this is not called from
3131:../Generated_Code/tasks.c ****                 an interrupt and the current TCB will always be the same for any
3132:../Generated_Code/tasks.c ****                 individual execution thread. */
3133:../Generated_Code/tasks.c ****                 xReturn = pxCurrentTCB;
 4197              		.loc 1 3133 0
 4198 0006 044B     		ldr	r3, .L299
 4199 0008 1B68     		ldr	r3, [r3]
 4200 000a 7B60     		str	r3, [r7, #4]
3134:../Generated_Code/tasks.c **** 
3135:../Generated_Code/tasks.c ****                 return xReturn;
 4201              		.loc 1 3135 0
 4202 000c 7B68     		ldr	r3, [r7, #4]
 4203              	.LBE51:
3136:../Generated_Code/tasks.c ****         }
 4204              		.loc 1 3136 0
 4205 000e 181C     		mov	r0, r3
 4206 0010 BD46     		mov	sp, r7
 4207 0012 02B0     		add	sp, sp, #8
 4208              		@ sp needed for prologue
 4209 0014 80BD     		pop	{r7, pc}
 4210              	.L300:
 4211 0016 C046     		.align	2
 4212              	.L299:
 4213 0018 00000000 		.word	pxCurrentTCB
 4214              		.cfi_endproc
 4215              	.LFE45:
 4217              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4218              		.align	2
 4219              		.global	xTaskGetSchedulerState
 4220              		.code	16
 4221              		.thumb_func
 4223              	xTaskGetSchedulerState:
 4224              	.LFB46:
3137:../Generated_Code/tasks.c **** 
3138:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3139:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3140:../Generated_Code/tasks.c **** 
3141:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3142:../Generated_Code/tasks.c **** 
3143:../Generated_Code/tasks.c ****         BaseType_t xTaskGetSchedulerState( void )
3144:../Generated_Code/tasks.c ****         {
 4225              		.loc 1 3144 0
 4226              		.cfi_startproc
 4227 0000 80B5     		push	{r7, lr}
 4228              	.LCFI107:
 4229              		.cfi_def_cfa_offset 8
 4230              		.cfi_offset 7, -8
 4231              		.cfi_offset 14, -4
 4232 0002 82B0     		sub	sp, sp, #8
 4233              	.LCFI108:
 4234              		.cfi_def_cfa_offset 16
 4235 0004 00AF     		add	r7, sp, #0
 4236              	.LCFI109:
 4237              		.cfi_def_cfa_register 7
 4238              	.LBB52:
3145:../Generated_Code/tasks.c ****         BaseType_t xReturn;
3146:../Generated_Code/tasks.c **** 
3147:../Generated_Code/tasks.c ****                 if( xSchedulerRunning == pdFALSE )
 4239              		.loc 1 3147 0
 4240 0006 0D4B     		ldr	r3, .L306
 4241 0008 1B68     		ldr	r3, [r3]
 4242 000a 5A42     		neg	r2, r3
 4243 000c 5341     		adc	r3, r3, r2
 4244 000e DBB2     		uxtb	r3, r3
 4245 0010 002B     		cmp	r3, #0
 4246 0012 02D0     		beq	.L302
3148:../Generated_Code/tasks.c ****                 {
3149:../Generated_Code/tasks.c ****                         xReturn = taskSCHEDULER_NOT_STARTED;
 4247              		.loc 1 3149 0
 4248 0014 0123     		mov	r3, #1
 4249 0016 7B60     		str	r3, [r7, #4]
 4250 0018 0BE0     		b	.L303
 4251              	.L302:
3150:../Generated_Code/tasks.c ****                 }
3151:../Generated_Code/tasks.c ****                 else
3152:../Generated_Code/tasks.c ****                 {
3153:../Generated_Code/tasks.c ****                         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4252              		.loc 1 3153 0
 4253 001a 094B     		ldr	r3, .L306+4
 4254 001c 1B68     		ldr	r3, [r3]
 4255 001e 5A42     		neg	r2, r3
 4256 0020 5341     		adc	r3, r3, r2
 4257 0022 DBB2     		uxtb	r3, r3
 4258 0024 002B     		cmp	r3, #0
 4259 0026 02D0     		beq	.L304
3154:../Generated_Code/tasks.c ****                         {
3155:../Generated_Code/tasks.c ****                                 xReturn = taskSCHEDULER_RUNNING;
 4260              		.loc 1 3155 0
 4261 0028 0223     		mov	r3, #2
 4262 002a 7B60     		str	r3, [r7, #4]
 4263 002c 01E0     		b	.L303
 4264              	.L304:
3156:../Generated_Code/tasks.c ****                         }
3157:../Generated_Code/tasks.c ****                         else
3158:../Generated_Code/tasks.c ****                         {
3159:../Generated_Code/tasks.c ****                                 xReturn = taskSCHEDULER_SUSPENDED;
 4265              		.loc 1 3159 0
 4266 002e 0023     		mov	r3, #0
 4267 0030 7B60     		str	r3, [r7, #4]
 4268              	.L303:
3160:../Generated_Code/tasks.c ****                         }
3161:../Generated_Code/tasks.c ****                 }
3162:../Generated_Code/tasks.c **** 
3163:../Generated_Code/tasks.c ****                 return xReturn;
 4269              		.loc 1 3163 0
 4270 0032 7B68     		ldr	r3, [r7, #4]
 4271              	.LBE52:
3164:../Generated_Code/tasks.c ****         }
 4272              		.loc 1 3164 0
 4273 0034 181C     		mov	r0, r3
 4274 0036 BD46     		mov	sp, r7
 4275 0038 02B0     		add	sp, sp, #8
 4276              		@ sp needed for prologue
 4277 003a 80BD     		pop	{r7, pc}
 4278              	.L307:
 4279              		.align	2
 4280              	.L306:
 4281 003c 00000000 		.word	_ZL17xSchedulerRunning
 4282 0040 00000000 		.word	_ZL20uxSchedulerSuspended
 4283              		.cfi_endproc
 4284              	.LFE46:
 4286              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 4287              		.align	2
 4288              		.global	vTaskPriorityInherit
 4289              		.code	16
 4290              		.thumb_func
 4292              	vTaskPriorityInherit:
 4293              	.LFB47:
3165:../Generated_Code/tasks.c **** 
3166:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3167:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3168:../Generated_Code/tasks.c **** 
3169:../Generated_Code/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3170:../Generated_Code/tasks.c **** 
3171:../Generated_Code/tasks.c ****         void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3172:../Generated_Code/tasks.c ****         {
 4294              		.loc 1 3172 0
 4295              		.cfi_startproc
 4296 0000 80B5     		push	{r7, lr}
 4297              	.LCFI110:
 4298              		.cfi_def_cfa_offset 8
 4299              		.cfi_offset 7, -8
 4300              		.cfi_offset 14, -4
 4301 0002 84B0     		sub	sp, sp, #16
 4302              	.LCFI111:
 4303              		.cfi_def_cfa_offset 24
 4304 0004 00AF     		add	r7, sp, #0
 4305              	.LCFI112:
 4306              		.cfi_def_cfa_register 7
 4307 0006 7860     		str	r0, [r7, #4]
 4308              	.LBB53:
3173:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4309              		.loc 1 3173 0
 4310 0008 7B68     		ldr	r3, [r7, #4]
 4311 000a FB60     		str	r3, [r7, #12]
3174:../Generated_Code/tasks.c **** 
3175:../Generated_Code/tasks.c ****                 /* If the mutex was given back by an interrupt while the queue was
3176:../Generated_Code/tasks.c ****                 locked then the mutex holder might now be NULL. */
3177:../Generated_Code/tasks.c ****                 if( pxMutexHolder != NULL )
 4312              		.loc 1 3177 0
 4313 000c 7B68     		ldr	r3, [r7, #4]
 4314 000e 002B     		cmp	r3, #0
 4315 0010 52D0     		beq	.L308
3178:../Generated_Code/tasks.c ****                 {
3179:../Generated_Code/tasks.c ****                         if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4316              		.loc 1 3179 0
 4317 0012 FB68     		ldr	r3, [r7, #12]
 4318 0014 DA6A     		ldr	r2, [r3, #44]
 4319 0016 2A4B     		ldr	r3, .L315
 4320 0018 1B68     		ldr	r3, [r3]
 4321 001a DB6A     		ldr	r3, [r3, #44]
 4322 001c 9A42     		cmp	r2, r3
 4323 001e 9B41     		sbc	r3, r3, r3
 4324 0020 5B42     		neg	r3, r3
 4325 0022 DBB2     		uxtb	r3, r3
 4326 0024 002B     		cmp	r3, #0
 4327 0026 47D0     		beq	.L308
3180:../Generated_Code/tasks.c ****                         {
3181:../Generated_Code/tasks.c ****                                 /* Adjust the mutex holder state to account for its new
3182:../Generated_Code/tasks.c ****                                 priority.  Only reset the event list item value if the value is
3183:../Generated_Code/tasks.c ****                                 not     being used for anything else. */
3184:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 4328              		.loc 1 3184 0
 4329 0028 FB68     		ldr	r3, [r7, #12]
 4330 002a 9B69     		ldr	r3, [r3, #24]
 4331 002c 002B     		cmp	r3, #0
 4332 002e 06DB     		blt	.L310
3185:../Generated_Code/tasks.c ****                                 {
3186:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( Tick
 4333              		.loc 1 3186 0
 4334 0030 234B     		ldr	r3, .L315
 4335 0032 1B68     		ldr	r3, [r3]
 4336 0034 DB6A     		ldr	r3, [r3, #44]
 4337 0036 0622     		mov	r2, #6
 4338 0038 D21A     		sub	r2, r2, r3
 4339 003a FB68     		ldr	r3, [r7, #12]
 4340 003c 9A61     		str	r2, [r3, #24]
 4341              	.L310:
3187:../Generated_Code/tasks.c ****                                 }
3188:../Generated_Code/tasks.c ****                                 else
3189:../Generated_Code/tasks.c ****                                 {
3190:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3191:../Generated_Code/tasks.c ****                                 }
3192:../Generated_Code/tasks.c **** 
3193:../Generated_Code/tasks.c ****                                 /* If the task being modified is in the ready state it will need to
3194:../Generated_Code/tasks.c ****                                 be moved into a new list. */
3195:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriorit
 4342              		.loc 1 3195 0
 4343 003e FB68     		ldr	r3, [r7, #12]
 4344 0040 5969     		ldr	r1, [r3, #20]
 4345 0042 FB68     		ldr	r3, [r7, #12]
 4346 0044 DA6A     		ldr	r2, [r3, #44]
 4347 0046 131C     		mov	r3, r2
 4348 0048 9B00     		lsl	r3, r3, #2
 4349 004a 9B18     		add	r3, r3, r2
 4350 004c 9B00     		lsl	r3, r3, #2
 4351 004e 1D4A     		ldr	r2, .L315+4
 4352 0050 9B18     		add	r3, r3, r2
 4353 0052 9942     		cmp	r1, r3
 4354 0054 01D1     		bne	.L311
 4355              		.loc 1 3195 0 is_stmt 0
 4356 0056 0123     		mov	r3, #1
 4357 0058 00E0     		b	.L312
 4358              	.L311:
 4359              		.loc 1 3195 0
 4360 005a 0023     		mov	r3, #0
 4361              	.L312:
 4362              		.loc 1 3195 0
 4363 005c 002B     		cmp	r3, #0
 4364 005e 26D0     		beq	.L313
3196:../Generated_Code/tasks.c ****                                 {
3197:../Generated_Code/tasks.c ****                                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBase
 4365              		.loc 1 3197 0 is_stmt 1
 4366 0060 FB68     		ldr	r3, [r7, #12]
 4367 0062 0433     		add	r3, r3, #4
 4368 0064 181C     		mov	r0, r3
 4369 0066 FFF7FEFF 		bl	uxListRemove
3198:../Generated_Code/tasks.c ****                                         {
3199:../Generated_Code/tasks.c ****                                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3200:../Generated_Code/tasks.c ****                                         }
3201:../Generated_Code/tasks.c ****                                         else
3202:../Generated_Code/tasks.c ****                                         {
3203:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
3204:../Generated_Code/tasks.c ****                                         }
3205:../Generated_Code/tasks.c **** 
3206:../Generated_Code/tasks.c ****                                         /* Inherit the priority before being moved into the new lis
3207:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4370              		.loc 1 3207 0
 4371 006a 154B     		ldr	r3, .L315
 4372 006c 1B68     		ldr	r3, [r3]
 4373 006e DA6A     		ldr	r2, [r3, #44]
 4374 0070 FB68     		ldr	r3, [r7, #12]
 4375 0072 DA62     		str	r2, [r3, #44]
3208:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 4376              		.loc 1 3208 0
 4377 0074 FB68     		ldr	r3, [r7, #12]
 4378 0076 DA6A     		ldr	r2, [r3, #44]
 4379 0078 134B     		ldr	r3, .L315+8
 4380 007a 1B68     		ldr	r3, [r3]
 4381 007c 9342     		cmp	r3, r2
 4382 007e 9B41     		sbc	r3, r3, r3
 4383 0080 5B42     		neg	r3, r3
 4384 0082 DBB2     		uxtb	r3, r3
 4385 0084 002B     		cmp	r3, #0
 4386 0086 03D0     		beq	.L314
 4387              		.loc 1 3208 0 is_stmt 0
 4388 0088 FB68     		ldr	r3, [r7, #12]
 4389 008a DA6A     		ldr	r2, [r3, #44]
 4390 008c 0E4B     		ldr	r3, .L315+8
 4391 008e 1A60     		str	r2, [r3]
 4392              	.L314:
 4393              		.loc 1 3208 0
 4394 0090 FB68     		ldr	r3, [r7, #12]
 4395 0092 DA6A     		ldr	r2, [r3, #44]
 4396 0094 131C     		mov	r3, r2
 4397 0096 9B00     		lsl	r3, r3, #2
 4398 0098 9B18     		add	r3, r3, r2
 4399 009a 9B00     		lsl	r3, r3, #2
 4400 009c 094A     		ldr	r2, .L315+4
 4401 009e 9A18     		add	r2, r3, r2
 4402 00a0 FB68     		ldr	r3, [r7, #12]
 4403 00a2 0433     		add	r3, r3, #4
 4404 00a4 101C     		mov	r0, r2
 4405 00a6 191C     		mov	r1, r3
 4406 00a8 FFF7FEFF 		bl	vListInsertEnd
 4407 00ac 04E0     		b	.L308
 4408              	.L313:
3209:../Generated_Code/tasks.c ****                                 }
3210:../Generated_Code/tasks.c ****                                 else
3211:../Generated_Code/tasks.c ****                                 {
3212:../Generated_Code/tasks.c ****                                         /* Just inherit the priority. */
3213:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4409              		.loc 1 3213 0 is_stmt 1
 4410 00ae 044B     		ldr	r3, .L315
 4411 00b0 1B68     		ldr	r3, [r3]
 4412 00b2 DA6A     		ldr	r2, [r3, #44]
 4413 00b4 FB68     		ldr	r3, [r7, #12]
 4414 00b6 DA62     		str	r2, [r3, #44]
 4415              	.L308:
 4416              	.LBE53:
3214:../Generated_Code/tasks.c ****                                 }
3215:../Generated_Code/tasks.c **** 
3216:../Generated_Code/tasks.c ****                                 traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3217:../Generated_Code/tasks.c ****                         }
3218:../Generated_Code/tasks.c ****                         else
3219:../Generated_Code/tasks.c ****                         {
3220:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3221:../Generated_Code/tasks.c ****                         }
3222:../Generated_Code/tasks.c ****                 }
3223:../Generated_Code/tasks.c ****                 else
3224:../Generated_Code/tasks.c ****                 {
3225:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3226:../Generated_Code/tasks.c ****                 }
3227:../Generated_Code/tasks.c ****         }
 4417              		.loc 1 3227 0
 4418 00b8 BD46     		mov	sp, r7
 4419 00ba 04B0     		add	sp, sp, #16
 4420              		@ sp needed for prologue
 4421 00bc 80BD     		pop	{r7, pc}
 4422              	.L316:
 4423 00be C046     		.align	2
 4424              	.L315:
 4425 00c0 00000000 		.word	pxCurrentTCB
 4426 00c4 00000000 		.word	_ZL17pxReadyTasksLists
 4427 00c8 00000000 		.word	_ZL18uxTopReadyPriority
 4428              		.cfi_endproc
 4429              	.LFE47:
 4431              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 4432              		.align	2
 4433              		.global	vTaskPriorityDisinherit
 4434              		.code	16
 4435              		.thumb_func
 4437              	vTaskPriorityDisinherit:
 4438              	.LFB48:
3228:../Generated_Code/tasks.c **** 
3229:../Generated_Code/tasks.c **** #endif /* configUSE_MUTEXES */
3230:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3231:../Generated_Code/tasks.c **** 
3232:../Generated_Code/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3233:../Generated_Code/tasks.c **** 
3234:../Generated_Code/tasks.c ****         void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3235:../Generated_Code/tasks.c ****         {
 4439              		.loc 1 3235 0
 4440              		.cfi_startproc
 4441 0000 80B5     		push	{r7, lr}
 4442              	.LCFI113:
 4443              		.cfi_def_cfa_offset 8
 4444              		.cfi_offset 7, -8
 4445              		.cfi_offset 14, -4
 4446 0002 84B0     		sub	sp, sp, #16
 4447              	.LCFI114:
 4448              		.cfi_def_cfa_offset 24
 4449 0004 00AF     		add	r7, sp, #0
 4450              	.LCFI115:
 4451              		.cfi_def_cfa_register 7
 4452 0006 7860     		str	r0, [r7, #4]
 4453              	.LBB54:
3236:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4454              		.loc 1 3236 0
 4455 0008 7B68     		ldr	r3, [r7, #4]
 4456 000a FB60     		str	r3, [r7, #12]
3237:../Generated_Code/tasks.c **** 
3238:../Generated_Code/tasks.c ****                 if( pxMutexHolder != NULL )
 4457              		.loc 1 3238 0
 4458 000c 7B68     		ldr	r3, [r7, #4]
 4459 000e 002B     		cmp	r3, #0
 4460 0010 34D0     		beq	.L317
3239:../Generated_Code/tasks.c ****                 {
3240:../Generated_Code/tasks.c ****                         if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4461              		.loc 1 3240 0
 4462 0012 FB68     		ldr	r3, [r7, #12]
 4463 0014 DA6A     		ldr	r2, [r3, #44]
 4464 0016 FB68     		ldr	r3, [r7, #12]
 4465 0018 1B6D     		ldr	r3, [r3, #80]
 4466 001a 9A42     		cmp	r2, r3
 4467 001c 2ED0     		beq	.L317
3241:../Generated_Code/tasks.c ****                         {
3242:../Generated_Code/tasks.c ****                                 /* We must be the running task to be able to give the mutex back.
3243:../Generated_Code/tasks.c ****                                 Remove ourselves from the ready list we currently appear in. */
3244:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t )
 4468              		.loc 1 3244 0
 4469 001e FB68     		ldr	r3, [r7, #12]
 4470 0020 0433     		add	r3, r3, #4
 4471 0022 181C     		mov	r0, r3
 4472 0024 FFF7FEFF 		bl	uxListRemove
3245:../Generated_Code/tasks.c ****                                 {
3246:../Generated_Code/tasks.c ****                                         taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3247:../Generated_Code/tasks.c ****                                 }
3248:../Generated_Code/tasks.c ****                                 else
3249:../Generated_Code/tasks.c ****                                 {
3250:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3251:../Generated_Code/tasks.c ****                                 }
3252:../Generated_Code/tasks.c **** 
3253:../Generated_Code/tasks.c ****                                 /* Disinherit the priority before adding the task into the new
3254:../Generated_Code/tasks.c ****                                 ready list. */
3255:../Generated_Code/tasks.c ****                                 traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3256:../Generated_Code/tasks.c ****                                 pxTCB->uxPriority = pxTCB->uxBasePriority;
 4473              		.loc 1 3256 0
 4474 0028 FB68     		ldr	r3, [r7, #12]
 4475 002a 1A6D     		ldr	r2, [r3, #80]
 4476 002c FB68     		ldr	r3, [r7, #12]
 4477 002e DA62     		str	r2, [r3, #44]
3257:../Generated_Code/tasks.c **** 
3258:../Generated_Code/tasks.c ****                                 /* Only reset the event list item value if the value is not
3259:../Generated_Code/tasks.c ****                                 being used for anything else. */
3260:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 4478              		.loc 1 3260 0
 4479 0030 FB68     		ldr	r3, [r7, #12]
 4480 0032 9B69     		ldr	r3, [r3, #24]
 4481 0034 002B     		cmp	r3, #0
 4482 0036 05DB     		blt	.L319
3261:../Generated_Code/tasks.c ****                                 {
3262:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( Tick
 4483              		.loc 1 3262 0
 4484 0038 FB68     		ldr	r3, [r7, #12]
 4485 003a DB6A     		ldr	r3, [r3, #44]
 4486 003c 0622     		mov	r2, #6
 4487 003e D21A     		sub	r2, r2, r3
 4488 0040 FB68     		ldr	r3, [r7, #12]
 4489 0042 9A61     		str	r2, [r3, #24]
 4490              	.L319:
3263:../Generated_Code/tasks.c ****                                 }
3264:../Generated_Code/tasks.c ****                                 else
3265:../Generated_Code/tasks.c ****                                 {
3266:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3267:../Generated_Code/tasks.c ****                                 }
3268:../Generated_Code/tasks.c ****                                 prvAddTaskToReadyList( pxTCB );
 4491              		.loc 1 3268 0
 4492 0044 FB68     		ldr	r3, [r7, #12]
 4493 0046 DA6A     		ldr	r2, [r3, #44]
 4494 0048 0E4B     		ldr	r3, .L321
 4495 004a 1B68     		ldr	r3, [r3]
 4496 004c 9342     		cmp	r3, r2
 4497 004e 9B41     		sbc	r3, r3, r3
 4498 0050 5B42     		neg	r3, r3
 4499 0052 DBB2     		uxtb	r3, r3
 4500 0054 002B     		cmp	r3, #0
 4501 0056 03D0     		beq	.L320
 4502              		.loc 1 3268 0 is_stmt 0
 4503 0058 FB68     		ldr	r3, [r7, #12]
 4504 005a DA6A     		ldr	r2, [r3, #44]
 4505 005c 094B     		ldr	r3, .L321
 4506 005e 1A60     		str	r2, [r3]
 4507              	.L320:
 4508              		.loc 1 3268 0
 4509 0060 FB68     		ldr	r3, [r7, #12]
 4510 0062 DA6A     		ldr	r2, [r3, #44]
 4511 0064 131C     		mov	r3, r2
 4512 0066 9B00     		lsl	r3, r3, #2
 4513 0068 9B18     		add	r3, r3, r2
 4514 006a 9B00     		lsl	r3, r3, #2
 4515 006c 064A     		ldr	r2, .L321+4
 4516 006e 9A18     		add	r2, r3, r2
 4517 0070 FB68     		ldr	r3, [r7, #12]
 4518 0072 0433     		add	r3, r3, #4
 4519 0074 101C     		mov	r0, r2
 4520 0076 191C     		mov	r1, r3
 4521 0078 FFF7FEFF 		bl	vListInsertEnd
 4522              	.L317:
 4523              	.LBE54:
3269:../Generated_Code/tasks.c ****                         }
3270:../Generated_Code/tasks.c ****                         else
3271:../Generated_Code/tasks.c ****                         {
3272:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3273:../Generated_Code/tasks.c ****                         }
3274:../Generated_Code/tasks.c ****                 }
3275:../Generated_Code/tasks.c ****                 else
3276:../Generated_Code/tasks.c ****                 {
3277:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3278:../Generated_Code/tasks.c ****                 }
3279:../Generated_Code/tasks.c ****         }
 4524              		.loc 1 3279 0 is_stmt 1
 4525 007c BD46     		mov	sp, r7
 4526 007e 04B0     		add	sp, sp, #16
 4527              		@ sp needed for prologue
 4528 0080 80BD     		pop	{r7, pc}
 4529              	.L322:
 4530 0082 C046     		.align	2
 4531              	.L321:
 4532 0084 00000000 		.word	_ZL18uxTopReadyPriority
 4533 0088 00000000 		.word	_ZL17pxReadyTasksLists
 4534              		.cfi_endproc
 4535              	.LFE48:
 4537              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4538              		.align	2
 4539              		.global	uxTaskResetEventItemValue
 4540              		.code	16
 4541              		.thumb_func
 4543              	uxTaskResetEventItemValue:
 4544              	.LFB49:
3280:../Generated_Code/tasks.c **** 
3281:../Generated_Code/tasks.c **** #endif /* configUSE_MUTEXES */
3282:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3283:../Generated_Code/tasks.c **** 
3284:../Generated_Code/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3285:../Generated_Code/tasks.c **** 
3286:../Generated_Code/tasks.c ****         void vTaskEnterCritical( void )
3287:../Generated_Code/tasks.c ****         {
3288:../Generated_Code/tasks.c ****                 portDISABLE_INTERRUPTS();
3289:../Generated_Code/tasks.c **** 
3290:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
3291:../Generated_Code/tasks.c ****                 {
3292:../Generated_Code/tasks.c ****                         ( pxCurrentTCB->uxCriticalNesting )++;
3293:../Generated_Code/tasks.c ****                 }
3294:../Generated_Code/tasks.c ****                 else
3295:../Generated_Code/tasks.c ****                 {
3296:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3297:../Generated_Code/tasks.c ****                 }
3298:../Generated_Code/tasks.c ****         }
3299:../Generated_Code/tasks.c **** 
3300:../Generated_Code/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3301:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3302:../Generated_Code/tasks.c **** 
3303:../Generated_Code/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3304:../Generated_Code/tasks.c **** 
3305:../Generated_Code/tasks.c ****         void vTaskExitCritical( void )
3306:../Generated_Code/tasks.c ****         {
3307:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
3308:../Generated_Code/tasks.c ****                 {
3309:../Generated_Code/tasks.c ****                         if( pxCurrentTCB->uxCriticalNesting > 0U )
3310:../Generated_Code/tasks.c ****                         {
3311:../Generated_Code/tasks.c ****                                 ( pxCurrentTCB->uxCriticalNesting )--;
3312:../Generated_Code/tasks.c **** 
3313:../Generated_Code/tasks.c ****                                 if( pxCurrentTCB->uxCriticalNesting == 0U )
3314:../Generated_Code/tasks.c ****                                 {
3315:../Generated_Code/tasks.c ****                                         portENABLE_INTERRUPTS();
3316:../Generated_Code/tasks.c ****                                 }
3317:../Generated_Code/tasks.c ****                                 else
3318:../Generated_Code/tasks.c ****                                 {
3319:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3320:../Generated_Code/tasks.c ****                                 }
3321:../Generated_Code/tasks.c ****                         }
3322:../Generated_Code/tasks.c ****                         else
3323:../Generated_Code/tasks.c ****                         {
3324:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3325:../Generated_Code/tasks.c ****                         }
3326:../Generated_Code/tasks.c ****                 }
3327:../Generated_Code/tasks.c ****                 else
3328:../Generated_Code/tasks.c ****                 {
3329:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3330:../Generated_Code/tasks.c ****                 }
3331:../Generated_Code/tasks.c ****         }
3332:../Generated_Code/tasks.c **** 
3333:../Generated_Code/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3334:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3335:../Generated_Code/tasks.c **** 
3336:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3337:../Generated_Code/tasks.c **** 
3338:../Generated_Code/tasks.c ****         void vTaskList( char * pcWriteBuffer, size_t bufSize)
3339:../Generated_Code/tasks.c ****         {
3340:../Generated_Code/tasks.c ****         TaskStatus_t *pxTaskStatusArray;
3341:../Generated_Code/tasks.c ****         volatile UBaseType_t uxArraySize, x;
3342:../Generated_Code/tasks.c ****         char cStatus;
3343:../Generated_Code/tasks.c **** 
3344:../Generated_Code/tasks.c ****                 /*
3345:../Generated_Code/tasks.c ****                  * PLEASE NOTE:
3346:../Generated_Code/tasks.c ****                  *
3347:../Generated_Code/tasks.c ****                  * This function is provided for convenience only, and is used by many
3348:../Generated_Code/tasks.c ****                  * of the demo applications.  Do not consider it to be part of the
3349:../Generated_Code/tasks.c ****                  * scheduler.
3350:../Generated_Code/tasks.c ****                  *
3351:../Generated_Code/tasks.c ****                  * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3352:../Generated_Code/tasks.c ****                  * uxTaskGetSystemState() output into a human readable table that
3353:../Generated_Code/tasks.c ****                  * displays task names, states and stack usage.
3354:../Generated_Code/tasks.c ****                  *
3355:../Generated_Code/tasks.c ****                  * vTaskList() has a dependency on the sprintf() C library function that
3356:../Generated_Code/tasks.c ****                  * might bloat the code size, use a lot of stack, and provide different
3357:../Generated_Code/tasks.c ****                  * results on different platforms.  An alternative, tiny, third party,
3358:../Generated_Code/tasks.c ****                  * and limited functionality implementation of sprintf() is provided in
3359:../Generated_Code/tasks.c ****                  * many of the FreeRTOS/Demo sub-directories in a file called
3360:../Generated_Code/tasks.c ****                  * printf-stdarg.c (note printf-stdarg.c does not provide a full
3361:../Generated_Code/tasks.c ****                  * snprintf() implementation!).
3362:../Generated_Code/tasks.c ****                  *
3363:../Generated_Code/tasks.c ****                  * It is recommended that production systems call uxTaskGetSystemState()
3364:../Generated_Code/tasks.c ****                  * directly to get access to raw stats data, rather than indirectly
3365:../Generated_Code/tasks.c ****                  * through a call to vTaskList().
3366:../Generated_Code/tasks.c ****                  */
3367:../Generated_Code/tasks.c **** 
3368:../Generated_Code/tasks.c **** 
3369:../Generated_Code/tasks.c ****                 /* Make sure the write buffer does not contain a string. */
3370:../Generated_Code/tasks.c ****                 *pcWriteBuffer = 0x00;
3371:../Generated_Code/tasks.c **** 
3372:../Generated_Code/tasks.c ****                 /* Take a snapshot of the number of tasks in case it changes while this
3373:../Generated_Code/tasks.c ****                 function is executing. */
3374:../Generated_Code/tasks.c ****                 uxArraySize = uxCurrentNumberOfTasks;
3375:../Generated_Code/tasks.c **** 
3376:../Generated_Code/tasks.c ****                 /* Allocate an array index for each task. */
3377:../Generated_Code/tasks.c ****                 pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) )
3378:../Generated_Code/tasks.c **** 
3379:../Generated_Code/tasks.c ****                 if( pxTaskStatusArray != NULL )
3380:../Generated_Code/tasks.c ****                 {
3381:../Generated_Code/tasks.c ****                         /* Generate the (binary) data. */
3382:../Generated_Code/tasks.c ****                         uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3383:../Generated_Code/tasks.c **** 
3384:../Generated_Code/tasks.c ****                         /* Create a human readable table from the binary data. */
3385:../Generated_Code/tasks.c ****                         for( x = 0; x < uxArraySize; x++ )
3386:../Generated_Code/tasks.c ****                         {
3387:../Generated_Code/tasks.c ****                                 switch( pxTaskStatusArray[ x ].eCurrentState )
3388:../Generated_Code/tasks.c ****                                 {
3389:../Generated_Code/tasks.c ****                                 case eReady:            cStatus = tskREADY_CHAR;
3390:../Generated_Code/tasks.c ****                                                                         break;
3391:../Generated_Code/tasks.c **** 
3392:../Generated_Code/tasks.c ****                                 case eBlocked:          cStatus = tskBLOCKED_CHAR;
3393:../Generated_Code/tasks.c ****                                                                         break;
3394:../Generated_Code/tasks.c **** 
3395:../Generated_Code/tasks.c ****                                 case eSuspended:        cStatus = tskSUSPENDED_CHAR;
3396:../Generated_Code/tasks.c ****                                                                         break;
3397:../Generated_Code/tasks.c **** 
3398:../Generated_Code/tasks.c ****                                 case eDeleted:          cStatus = tskDELETED_CHAR;
3399:../Generated_Code/tasks.c ****                                                                         break;
3400:../Generated_Code/tasks.c **** 
3401:../Generated_Code/tasks.c ****                                 default:                        /* Should not get here, but it is i
3402:../Generated_Code/tasks.c ****                                                                         to prevent static checking 
3403:../Generated_Code/tasks.c ****                                                                         cStatus = 0x00;
3404:../Generated_Code/tasks.c ****                                                                         break;
3405:../Generated_Code/tasks.c ****                                 }
3406:../Generated_Code/tasks.c **** #if 0
3407:../Generated_Code/tasks.c ****                                 sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%c\t%u\t%u\t%u
3408:../Generated_Code/tasks.c **** #else /* << EST */
3409:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3410:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3411:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)cStatus);
3412:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3413:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].uxCurrent
3414:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3415:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].usStackHi
3416:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3417:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].xTaskNumb
3418:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
3419:../Generated_Code/tasks.c **** #endif
3420:../Generated_Code/tasks.c ****                         }
3421:../Generated_Code/tasks.c **** 
3422:../Generated_Code/tasks.c ****                         /* Free the array again. */
3423:../Generated_Code/tasks.c ****                         vPortFree( pxTaskStatusArray );
3424:../Generated_Code/tasks.c ****                 }
3425:../Generated_Code/tasks.c ****                 else
3426:../Generated_Code/tasks.c ****                 {
3427:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3428:../Generated_Code/tasks.c ****                 }
3429:../Generated_Code/tasks.c ****         }
3430:../Generated_Code/tasks.c **** 
3431:../Generated_Code/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3432:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
3433:../Generated_Code/tasks.c **** 
3434:../Generated_Code/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3435:../Generated_Code/tasks.c **** 
3436:../Generated_Code/tasks.c ****         void vTaskGetRunTimeStats( char *pcWriteBuffer, size_t bufSize)
3437:../Generated_Code/tasks.c ****         {
3438:../Generated_Code/tasks.c ****         TaskStatus_t *pxTaskStatusArray;
3439:../Generated_Code/tasks.c ****         volatile UBaseType_t uxArraySize, x;
3440:../Generated_Code/tasks.c ****         uint32_t ulTotalTime, ulStatsAsPercentage;
3441:../Generated_Code/tasks.c **** 
3442:../Generated_Code/tasks.c ****                 #if( configUSE_TRACE_FACILITY != 1 )
3443:../Generated_Code/tasks.c ****                 {
3444:../Generated_Code/tasks.c ****                         #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h t
3445:../Generated_Code/tasks.c ****                 }
3446:../Generated_Code/tasks.c ****                 #endif
3447:../Generated_Code/tasks.c **** 
3448:../Generated_Code/tasks.c ****                 /*
3449:../Generated_Code/tasks.c ****                  * PLEASE NOTE:
3450:../Generated_Code/tasks.c ****                  *
3451:../Generated_Code/tasks.c ****                  * This function is provided for convenience only, and is used by many
3452:../Generated_Code/tasks.c ****                  * of the demo applications.  Do not consider it to be part of the
3453:../Generated_Code/tasks.c ****                  * scheduler.
3454:../Generated_Code/tasks.c ****                  *
3455:../Generated_Code/tasks.c ****                  * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3456:../Generated_Code/tasks.c ****                  * of the uxTaskGetSystemState() output into a human readable table that
3457:../Generated_Code/tasks.c ****                  * displays the amount of time each task has spent in the Running state
3458:../Generated_Code/tasks.c ****                  * in both absolute and percentage terms.
3459:../Generated_Code/tasks.c ****                  *
3460:../Generated_Code/tasks.c ****                  * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3461:../Generated_Code/tasks.c ****                  * function that might bloat the code size, use a lot of stack, and
3462:../Generated_Code/tasks.c ****                  * provide different results on different platforms.  An alternative,
3463:../Generated_Code/tasks.c ****                  * tiny, third party, and limited functionality implementation of
3464:../Generated_Code/tasks.c ****                  * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3465:../Generated_Code/tasks.c ****                  * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3466:../Generated_Code/tasks.c ****                  * a full snprintf() implementation!).
3467:../Generated_Code/tasks.c ****                  *
3468:../Generated_Code/tasks.c ****                  * It is recommended that production systems call uxTaskGetSystemState()
3469:../Generated_Code/tasks.c ****                  * directly to get access to raw stats data, rather than indirectly
3470:../Generated_Code/tasks.c ****                  * through a call to vTaskGetRunTimeStats().
3471:../Generated_Code/tasks.c ****                  */
3472:../Generated_Code/tasks.c **** 
3473:../Generated_Code/tasks.c ****                 /* Make sure the write buffer does not contain a string. */
3474:../Generated_Code/tasks.c ****                 *pcWriteBuffer = 0x00;
3475:../Generated_Code/tasks.c **** 
3476:../Generated_Code/tasks.c ****                 /* Take a snapshot of the number of tasks in case it changes while this
3477:../Generated_Code/tasks.c ****                 function is executing. */
3478:../Generated_Code/tasks.c ****                 uxArraySize = uxCurrentNumberOfTasks;
3479:../Generated_Code/tasks.c **** 
3480:../Generated_Code/tasks.c ****                 /* Allocate an array index for each task. */
3481:../Generated_Code/tasks.c ****                 pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) )
3482:../Generated_Code/tasks.c **** 
3483:../Generated_Code/tasks.c ****                 if( pxTaskStatusArray != NULL )
3484:../Generated_Code/tasks.c ****                 {
3485:../Generated_Code/tasks.c ****                         /* Generate the (binary) data. */
3486:../Generated_Code/tasks.c ****                         uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTota
3487:../Generated_Code/tasks.c **** 
3488:../Generated_Code/tasks.c ****                         /* For percentage calculations. */
3489:../Generated_Code/tasks.c ****                         ulTotalTime /= 100UL;
3490:../Generated_Code/tasks.c **** 
3491:../Generated_Code/tasks.c ****                         /* Avoid divide by zero errors. */
3492:../Generated_Code/tasks.c ****                         if( ulTotalTime > 0 )
3493:../Generated_Code/tasks.c ****                         {
3494:../Generated_Code/tasks.c ****                                 /* Create a human readable table from the binary data. */
3495:../Generated_Code/tasks.c ****                                 for( x = 0; x < uxArraySize; x++ )
3496:../Generated_Code/tasks.c ****                                 {
3497:../Generated_Code/tasks.c ****                                         /* What percentage of the total run time has the task used?
3498:../Generated_Code/tasks.c ****                                         This will always be rounded down to the nearest integer.
3499:../Generated_Code/tasks.c ****                                         ulTotalRunTimeDiv100 has already been divided by 100. */
3500:../Generated_Code/tasks.c ****                                         ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCount
3501:../Generated_Code/tasks.c **** 
3502:../Generated_Code/tasks.c ****                                         if( ulStatsAsPercentage > 0UL )
3503:../Generated_Code/tasks.c ****                                         {
3504:../Generated_Code/tasks.c ****                                                 #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3505:../Generated_Code/tasks.c ****                                                 {
3506:../Generated_Code/tasks.c ****                                                   sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s
3507:../Generated_Code/tasks.c ****                                                 }
3508:../Generated_Code/tasks.c ****                                                 #else
3509:../Generated_Code/tasks.c ****                                                 {
3510:../Generated_Code/tasks.c ****                                                         /* sizeof( int ) == sizeof( long ) so a sma
3511:../Generated_Code/tasks.c ****                                                         printf() library can be used. */
3512:../Generated_Code/tasks.c **** #if 0
3513:../Generated_Code/tasks.c ****                                                         sprintf( ( char * ) pcWriteBuffer, ( char *
3514:../Generated_Code/tasks.c **** #else /* << EST */
3515:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3516:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3517:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTime
3518:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3519:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, ulStatsAsPercentage);
3520:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"%\r\n");
3521:../Generated_Code/tasks.c **** #endif
3522:../Generated_Code/tasks.c ****                                                 }
3523:../Generated_Code/tasks.c ****                                                 #endif
3524:../Generated_Code/tasks.c ****                                         }
3525:../Generated_Code/tasks.c ****                                         else
3526:../Generated_Code/tasks.c ****                                         {
3527:../Generated_Code/tasks.c ****                                                 /* If the percentage is zero here then the task has
3528:../Generated_Code/tasks.c ****                                                 consumed less than 1% of the total run time. */
3529:../Generated_Code/tasks.c ****                                                 #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3530:../Generated_Code/tasks.c ****                                                 {
3531:../Generated_Code/tasks.c ****                                                         sprintf( ( char * ) pcWriteBuffer, ( char *
3532:../Generated_Code/tasks.c ****                                                 }
3533:../Generated_Code/tasks.c ****                                                 #else
3534:../Generated_Code/tasks.c ****                                                 {
3535:../Generated_Code/tasks.c ****                                                         /* sizeof( int ) == sizeof( long ) so a sma
3536:../Generated_Code/tasks.c ****                                                         printf() library can be used. */
3537:../Generated_Code/tasks.c **** #if 0
3538:../Generated_Code/tasks.c ****               sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArr
3539:../Generated_Code/tasks.c **** #else /* << EST */
3540:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3541:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3542:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTime
3543:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t<1%\r\n");
3544:../Generated_Code/tasks.c **** #endif
3545:../Generated_Code/tasks.c ****                                                 }
3546:../Generated_Code/tasks.c ****                                                 #endif
3547:../Generated_Code/tasks.c ****                                         }
3548:../Generated_Code/tasks.c **** 
3549:../Generated_Code/tasks.c ****                                         pcWriteBuffer += strlen( pcWriteBuffer );
3550:../Generated_Code/tasks.c ****                                 }
3551:../Generated_Code/tasks.c ****                         }
3552:../Generated_Code/tasks.c ****                         else
3553:../Generated_Code/tasks.c ****                         {
3554:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3555:../Generated_Code/tasks.c ****                         }
3556:../Generated_Code/tasks.c **** 
3557:../Generated_Code/tasks.c ****                         /* Free the array again. */
3558:../Generated_Code/tasks.c ****                         vPortFree( pxTaskStatusArray );
3559:../Generated_Code/tasks.c ****                 }
3560:../Generated_Code/tasks.c ****                 else
3561:../Generated_Code/tasks.c ****                 {
3562:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3563:../Generated_Code/tasks.c ****                 }
3564:../Generated_Code/tasks.c ****         }
3565:../Generated_Code/tasks.c **** 
3566:../Generated_Code/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
3567:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3568:../Generated_Code/tasks.c **** 
3569:../Generated_Code/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3570:../Generated_Code/tasks.c **** {
 4545              		.loc 1 3570 0
 4546              		.cfi_startproc
 4547 0000 80B5     		push	{r7, lr}
 4548              	.LCFI116:
 4549              		.cfi_def_cfa_offset 8
 4550              		.cfi_offset 7, -8
 4551              		.cfi_offset 14, -4
 4552 0002 82B0     		sub	sp, sp, #8
 4553              	.LCFI117:
 4554              		.cfi_def_cfa_offset 16
 4555 0004 00AF     		add	r7, sp, #0
 4556              	.LCFI118:
 4557              		.cfi_def_cfa_register 7
 4558              	.LBB55:
3571:../Generated_Code/tasks.c **** TickType_t uxReturn;
3572:../Generated_Code/tasks.c **** 
3573:../Generated_Code/tasks.c ****         uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4559              		.loc 1 3573 0
 4560 0006 084B     		ldr	r3, .L325
 4561 0008 1B68     		ldr	r3, [r3]
 4562 000a 9B69     		ldr	r3, [r3, #24]
 4563 000c 7B60     		str	r3, [r7, #4]
3574:../Generated_Code/tasks.c **** 
3575:../Generated_Code/tasks.c ****         /* Reset the event list item to its normal value - so it can be used with
3576:../Generated_Code/tasks.c ****         queues and semaphores. */
3577:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIO
 4564              		.loc 1 3577 0
 4565 000e 064B     		ldr	r3, .L325
 4566 0010 1B68     		ldr	r3, [r3]
 4567 0012 054A     		ldr	r2, .L325
 4568 0014 1268     		ldr	r2, [r2]
 4569 0016 D26A     		ldr	r2, [r2, #44]
 4570 0018 0621     		mov	r1, #6
 4571 001a 8A1A     		sub	r2, r1, r2
 4572 001c 9A61     		str	r2, [r3, #24]
3578:../Generated_Code/tasks.c **** 
3579:../Generated_Code/tasks.c ****         return uxReturn;
 4573              		.loc 1 3579 0
 4574 001e 7B68     		ldr	r3, [r7, #4]
 4575              	.LBE55:
3580:../Generated_Code/tasks.c **** }
 4576              		.loc 1 3580 0
 4577 0020 181C     		mov	r0, r3
 4578 0022 BD46     		mov	sp, r7
 4579 0024 02B0     		add	sp, sp, #8
 4580              		@ sp needed for prologue
 4581 0026 80BD     		pop	{r7, pc}
 4582              	.L326:
 4583              		.align	2
 4584              	.L325:
 4585 0028 00000000 		.word	pxCurrentTCB
 4586              		.cfi_endproc
 4587              	.LFE49:
 4589              		.text
 4590              	.Letext0:
 4591              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 4592              		.file 3 "../Generated_Code/projdefs.h"
 4593              		.file 4 "../Generated_Code/portmacro.h"
 4594              		.file 5 "../Generated_Code/list.h"
 4595              		.file 6 "../Generated_Code/task.h"
 4596              		.file 7 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:22     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:19     .bss.pxCurrentTCB:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:25     .bss._ZL17pxReadyTasksLists:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:28     .bss._ZL17pxReadyTasksLists:00000000 _ZL17pxReadyTasksLists
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:31     .bss._ZL17xDelayedTaskList1:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:34     .bss._ZL17xDelayedTaskList1:00000000 _ZL17xDelayedTaskList1
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:37     .bss._ZL17xDelayedTaskList2:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:40     .bss._ZL17xDelayedTaskList2:00000000 _ZL17xDelayedTaskList2
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:43     .bss._ZL17pxDelayedTaskList:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:46     .bss._ZL17pxDelayedTaskList:00000000 _ZL17pxDelayedTaskList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:49     .bss._ZL25pxOverflowDelayedTaskList:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:52     .bss._ZL25pxOverflowDelayedTaskList:00000000 _ZL25pxOverflowDelayedTaskList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:55     .bss._ZL17xPendingReadyList:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:58     .bss._ZL17xPendingReadyList:00000000 _ZL17xPendingReadyList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:61     .bss._ZL24xTasksWaitingTermination:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:64     .bss._ZL24xTasksWaitingTermination:00000000 _ZL24xTasksWaitingTermination
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:67     .bss._ZL14uxTasksDeleted:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:70     .bss._ZL14uxTasksDeleted:00000000 _ZL14uxTasksDeleted
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:73     .bss._ZL18xSuspendedTaskList:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:76     .bss._ZL18xSuspendedTaskList:00000000 _ZL18xSuspendedTaskList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:79     .bss._ZL22uxCurrentNumberOfTasks:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:82     .bss._ZL22uxCurrentNumberOfTasks:00000000 _ZL22uxCurrentNumberOfTasks
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:85     .bss._ZL10xTickCount:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:88     .bss._ZL10xTickCount:00000000 _ZL10xTickCount
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:91     .bss._ZL18uxTopReadyPriority:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:94     .bss._ZL18uxTopReadyPriority:00000000 _ZL18uxTopReadyPriority
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:97     .bss._ZL17xSchedulerRunning:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:100    .bss._ZL17xSchedulerRunning:00000000 _ZL17xSchedulerRunning
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:103    .bss._ZL13uxPendedTicks:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:106    .bss._ZL13uxPendedTicks:00000000 _ZL13uxPendedTicks
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:109    .bss._ZL13xYieldPending:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:112    .bss._ZL13xYieldPending:00000000 _ZL13xYieldPending
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:115    .bss._ZL15xNumOfOverflows:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:118    .bss._ZL15xNumOfOverflows:00000000 _ZL15xNumOfOverflows
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:121    .bss._ZL12uxTaskNumber:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:124    .bss._ZL12uxTaskNumber:00000000 _ZL12uxTaskNumber
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:127    .data._ZL20xNextTaskUnblockTime:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:130    .data._ZL20xNextTaskUnblockTime:00000000 _ZL20xNextTaskUnblockTime
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:133    .bss._ZL20uxSchedulerSuspended:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:136    .bss._ZL20uxSchedulerSuspended:00000000 _ZL20uxSchedulerSuspended
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:139    .text.xTaskGenericCreate:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:144    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3856   .text._ZL22prvAllocateTCBAndStacktPm:00000000 _ZL22prvAllocateTCBAndStacktPm
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3448   .text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:00000000 _ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3570   .text._ZL22prvInitialiseTaskListsv:00000000 _ZL22prvInitialiseTaskListsv
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:413    .text.xTaskGenericCreate:00000180 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:423    .text.vTaskDelete:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:428    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4110   .text._ZL27prvResetNextTaskUnblockTimev:00000000 _ZL27prvResetNextTaskUnblockTimev
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:549    .text.vTaskDelete:000000a0 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:559    .text.vTaskDelayUntil:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:564    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1800   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3769   .text._ZL30prvAddCurrentTaskToDelayedListm:00000000 _ZL30prvAddCurrentTaskToDelayedListm
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1835   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:719    .text.vTaskDelayUntil:000000b8 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:726    .text.vTaskDelay:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:731    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:811    .text.vTaskDelay:00000060 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:818    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:823    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:874    .text.uxTaskPriorityGet:00000030 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:879    .text.vTaskPrioritySet:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:884    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1107   .text.vTaskPrioritySet:00000138 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1114   .text.vTaskSuspend:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1119   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2500   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1257   .text.vTaskSuspend:000000bc $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1266   .text._ZL22prvTaskIsTaskSuspendedPv:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1270   .text._ZL22prvTaskIsTaskSuspendedPv:00000000 _ZL22prvTaskIsTaskSuspendedPv
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1359   .text._ZL22prvTaskIsTaskSuspendedPv:00000058 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1365   .text.vTaskResume:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1370   .text.vTaskResume:00000000 vTaskResume
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1499   .text.vTaskResume:000000b0 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1506   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1511   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1652   .text.xTaskResumeFromISR:000000bc $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1661   .rodata:00000000 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1665   .text.vTaskStartScheduler:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1670   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1747   .text.vTaskStartScheduler:00000054 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3405   .text._ZL11prvIdleTaskPv:00000000 _ZL11prvIdleTaskPv
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1755   .text.vTaskEndScheduler:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1760   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1790   .text.vTaskEndScheduler:00000014 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1795   .text.vTaskSuspendAll:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1825   .text.vTaskSuspendAll:00000014 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:1830   .text.xTaskResumeAll:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2190   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2040   .text.xTaskResumeAll:0000012c $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2052   .text.xTaskGetTickCount:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2057   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2093   .text.xTaskGetTickCount:00000020 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2098   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2103   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2147   .text.xTaskGetTickCountFromISR:00000020 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2152   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2157   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2180   .text.uxTaskGetNumberOfTasks:00000010 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2185   .text.xTaskIncrementTick:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2480   .text.xTaskIncrementTick:00000190 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2495   .text.vTaskSwitchContext:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2649   .text.vTaskSwitchContext:000000c8 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2658   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2663   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2742   .text.vTaskPlaceOnEventList:00000060 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2749   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2754   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2859   .text.vTaskPlaceOnUnorderedEventList:00000084 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2867   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:2872   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3003   .text.xTaskRemoveFromEventList:000000b4 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3013   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3018   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3154   .text.xTaskRemoveFromUnorderedEventList:000000b4 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3163   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3168   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3215   .text.vTaskSetTimeOutState:00000028 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3221   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3226   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3362   .text.xTaskCheckForTimeOut:000000a0 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3368   .text.vTaskMissedYield:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3373   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3396   .text.vTaskMissedYield:00000010 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3401   .text._ZL11prvIdleTaskPv:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3668   .text._ZL31prvCheckTasksWaitingTerminationv:00000000 _ZL31prvCheckTasksWaitingTerminationv
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3439   .text._ZL11prvIdleTaskPv:00000020 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3444   .text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3566   .text._ZL22prvInitialiseTaskListsv:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3652   .text._ZL22prvInitialiseTaskListsv:00000070 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3664   .text._ZL31prvCheckTasksWaitingTerminationv:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4072   .text._ZL12prvDeleteTCBP19tskTaskControlBlock:00000000 _ZL12prvDeleteTCBP19tskTaskControlBlock
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3758   .text._ZL31prvCheckTasksWaitingTerminationv:0000006c $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3765   .text._ZL30prvAddCurrentTaskToDelayedListm:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3843   .text._ZL30prvAddCurrentTaskToDelayedListm:00000068 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3852   .text._ZL22prvAllocateTCBAndStacktPm:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3942   .text._ZL26prvTaskCheckFreeStackSpacePKh:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:3946   .text._ZL26prvTaskCheckFreeStackSpacePKh:00000000 _ZL26prvTaskCheckFreeStackSpacePKh
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4005   .text.uxTaskGetStackHighWaterMark:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4010   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4063   .text.uxTaskGetStackHighWaterMark:00000034 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4068   .text._ZL12prvDeleteTCBP19tskTaskControlBlock:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4106   .text._ZL27prvResetNextTaskUnblockTimev:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4170   .text._ZL27prvResetNextTaskUnblockTimev:0000003c $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4176   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4181   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4213   .text.xTaskGetCurrentTaskHandle:00000018 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4218   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4223   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4281   .text.xTaskGetSchedulerState:0000003c $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4287   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4292   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4425   .text.vTaskPriorityInherit:000000c0 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4432   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4437   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4532   .text.vTaskPriorityDisinherit:00000084 $d
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4538   .text.uxTaskResetEventItemValue:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4543   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\Judah\AppData\Local\Temp\ccwgRQv2.s:4585   .text.uxTaskResetEventItemValue:00000028 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
uxListRemove
xPortStartScheduler
vPortEndScheduler
_Z30FreeRTOS0_vApplicationTickHookv
_Z39FreeRTOS0_vApplicationStackOverflowHookPvPc
vListInsert
_Z30FreeRTOS0_vApplicationIdleHookv
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
