   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	pxCurrentTCB
  18              		.section	.bss.pxCurrentTCB,"aw",%nobits
  19              		.align	2
  22              	pxCurrentTCB:
  23 0000 00000000 		.space	4
  24              		.section	.bss._ZL17pxReadyTasksLists,"aw",%nobits
  25              		.align	2
  28              	_ZL17pxReadyTasksLists:
  29 0000 00000000 		.space	120
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.section	.bss._ZL17xDelayedTaskList1,"aw",%nobits
  31              		.align	2
  34              	_ZL17xDelayedTaskList1:
  35 0000 00000000 		.space	20
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              		.section	.bss._ZL17xDelayedTaskList2,"aw",%nobits
  37              		.align	2
  40              	_ZL17xDelayedTaskList2:
  41 0000 00000000 		.space	20
  41      00000000 
  41      00000000 
  41      00000000 
  41      00000000 
  42              		.section	.bss._ZL17pxDelayedTaskList,"aw",%nobits
  43              		.align	2
  46              	_ZL17pxDelayedTaskList:
  47 0000 00000000 		.space	4
  48              		.section	.bss._ZL25pxOverflowDelayedTaskList,"aw",%nobits
  49              		.align	2
  52              	_ZL25pxOverflowDelayedTaskList:
  53 0000 00000000 		.space	4
  54              		.section	.bss._ZL17xPendingReadyList,"aw",%nobits
  55              		.align	2
  58              	_ZL17xPendingReadyList:
  59 0000 00000000 		.space	20
  59      00000000 
  59      00000000 
  59      00000000 
  59      00000000 
  60              		.section	.bss._ZL18xSuspendedTaskList,"aw",%nobits
  61              		.align	2
  64              	_ZL18xSuspendedTaskList:
  65 0000 00000000 		.space	20
  65      00000000 
  65      00000000 
  65      00000000 
  65      00000000 
  66              		.section	.bss._ZL22uxCurrentNumberOfTasks,"aw",%nobits
  67              		.align	2
  70              	_ZL22uxCurrentNumberOfTasks:
  71 0000 00000000 		.space	4
  72              		.section	.bss._ZL10xTickCount,"aw",%nobits
  73              		.align	2
  76              	_ZL10xTickCount:
  77 0000 00000000 		.space	4
  78              		.section	.bss._ZL18uxTopReadyPriority,"aw",%nobits
  79              		.align	2
  82              	_ZL18uxTopReadyPriority:
  83 0000 00000000 		.space	4
  84              		.section	.bss._ZL17xSchedulerRunning,"aw",%nobits
  85              		.align	2
  88              	_ZL17xSchedulerRunning:
  89 0000 00000000 		.space	4
  90              		.section	.bss._ZL13uxPendedTicks,"aw",%nobits
  91              		.align	2
  94              	_ZL13uxPendedTicks:
  95 0000 00000000 		.space	4
  96              		.section	.bss._ZL13xYieldPending,"aw",%nobits
  97              		.align	2
 100              	_ZL13xYieldPending:
 101 0000 00000000 		.space	4
 102              		.section	.bss._ZL15xNumOfOverflows,"aw",%nobits
 103              		.align	2
 106              	_ZL15xNumOfOverflows:
 107 0000 00000000 		.space	4
 108              		.section	.bss._ZL12uxTaskNumber,"aw",%nobits
 109              		.align	2
 112              	_ZL12uxTaskNumber:
 113 0000 00000000 		.space	4
 114              		.section	.data._ZL20xNextTaskUnblockTime,"aw",%progbits
 115              		.align	2
 118              	_ZL20xNextTaskUnblockTime:
 119 0000 FFFFFFFF 		.word	-1
 120              		.section	.bss._ZL20uxSchedulerSuspended,"aw",%nobits
 121              		.align	2
 124              	_ZL20uxSchedulerSuspended:
 125 0000 00000000 		.space	4
 126              		.section	.text.xTaskGenericCreate,"ax",%progbits
 127              		.align	2
 128              		.global	xTaskGenericCreate
 129              		.code	16
 130              		.thumb_func
 132              	xTaskGenericCreate:
 133              	.LFB9:
 134              		.file 1 "../Generated_Code/tasks.c"
   1:../Generated_Code/tasks.c **** /*
   2:../Generated_Code/tasks.c ****     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:../Generated_Code/tasks.c ****     All rights reserved
   4:../Generated_Code/tasks.c **** 
   5:../Generated_Code/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Generated_Code/tasks.c **** 
   7:../Generated_Code/tasks.c ****     ***************************************************************************
   8:../Generated_Code/tasks.c ****      *                                                                       *
   9:../Generated_Code/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Generated_Code/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Generated_Code/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:../Generated_Code/tasks.c ****      *                                                                       *
  13:../Generated_Code/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Generated_Code/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Generated_Code/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Generated_Code/tasks.c ****      *                                                                       *
  17:../Generated_Code/tasks.c ****      *    Thank you!                                                         *
  18:../Generated_Code/tasks.c ****      *                                                                       *
  19:../Generated_Code/tasks.c ****     ***************************************************************************
  20:../Generated_Code/tasks.c **** 
  21:../Generated_Code/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:../Generated_Code/tasks.c **** 
  23:../Generated_Code/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Generated_Code/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Generated_Code/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Generated_Code/tasks.c **** 
  27:../Generated_Code/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Generated_Code/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Generated_Code/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Generated_Code/tasks.c ****     >>! kernel.
  31:../Generated_Code/tasks.c **** 
  32:../Generated_Code/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Generated_Code/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Generated_Code/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Generated_Code/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:../Generated_Code/tasks.c **** 
  37:../Generated_Code/tasks.c ****     1 tab == 4 spaces!
  38:../Generated_Code/tasks.c **** 
  39:../Generated_Code/tasks.c ****     ***************************************************************************
  40:../Generated_Code/tasks.c ****      *                                                                       *
  41:../Generated_Code/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Generated_Code/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:../Generated_Code/tasks.c ****      *                                                                       *
  44:../Generated_Code/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Generated_Code/tasks.c ****      *                                                                       *
  46:../Generated_Code/tasks.c ****     ***************************************************************************
  47:../Generated_Code/tasks.c **** 
  48:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Generated_Code/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Generated_Code/tasks.c **** 
  51:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Generated_Code/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Generated_Code/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Generated_Code/tasks.c **** 
  55:../Generated_Code/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Generated_Code/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Generated_Code/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Generated_Code/tasks.c **** 
  59:../Generated_Code/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Generated_Code/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Generated_Code/tasks.c ****     mission critical applications that require provable dependability.
  62:../Generated_Code/tasks.c **** 
  63:../Generated_Code/tasks.c ****     1 tab == 4 spaces!
  64:../Generated_Code/tasks.c **** */
  65:../Generated_Code/tasks.c **** 
  66:../Generated_Code/tasks.c **** /* Standard includes. */
  67:../Generated_Code/tasks.c **** #include <stdlib.h>
  68:../Generated_Code/tasks.c **** #include <string.h>
  69:../Generated_Code/tasks.c **** 
  70:../Generated_Code/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:../Generated_Code/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:../Generated_Code/tasks.c **** task.h is included from an application file. */
  73:../Generated_Code/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:../Generated_Code/tasks.c **** 
  75:../Generated_Code/tasks.c **** /* FreeRTOS includes. */
  76:../Generated_Code/tasks.c **** #include "FreeRTOS.h"
  77:../Generated_Code/tasks.c **** #include "task.h"
  78:../Generated_Code/tasks.c **** #include "timers.h"
  79:../Generated_Code/tasks.c **** #include "StackMacros.h"
  80:../Generated_Code/tasks.c **** 
  81:../Generated_Code/tasks.c **** #include "Events.h"
  82:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
  83:../Generated_Code/tasks.c **** #include "UTIL0.h" /* interface to utility because used for safe string routines */ /* << EST */
  84:../Generated_Code/tasks.c **** #endif
  85:../Generated_Code/tasks.c **** 
  86:../Generated_Code/tasks.c **** #if (configCOMPILER == configCOMPILER_ARM_IAR) /* << EST: suppress warnings for IAR */
  87:../Generated_Code/tasks.c **** #pragma diag_suppress=pa082 /* Warning[Pa082]: undefined behavior: the order of volatile accesses i
  88:../Generated_Code/tasks.c **** #endif
  89:../Generated_Code/tasks.c **** 
  90:../Generated_Code/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  91:../Generated_Code/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  92:../Generated_Code/tasks.c **** header files above, but not in this file, in order to generate the correct
  93:../Generated_Code/tasks.c **** privileged Vs unprivileged linkage and placement. */
  94:../Generated_Code/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  95:../Generated_Code/tasks.c **** 
  96:../Generated_Code/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  97:../Generated_Code/tasks.c ****         /* At the bottom of this file are two optional functions that can be used
  98:../Generated_Code/tasks.c ****         to generate human readable text from the raw data generated by the
  99:../Generated_Code/tasks.c ****         uxTaskGetSystemState() function.  Note the formatting functions are provided
 100:../Generated_Code/tasks.c ****         for convenience only, and are NOT considered part of the kernel. */
 101:../Generated_Code/tasks.c ****         #include <stdio.h>
 102:../Generated_Code/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 103:../Generated_Code/tasks.c **** 
 104:../Generated_Code/tasks.c **** /* Sanity check the configuration. */
 105:../Generated_Code/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
 106:../Generated_Code/tasks.c ****         #if INCLUDE_vTaskSuspend != 1
 107:../Generated_Code/tasks.c ****                 #error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set 
 108:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
 109:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 110:../Generated_Code/tasks.c **** 
 111:../Generated_Code/tasks.c **** /*
 112:../Generated_Code/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 113:../Generated_Code/tasks.c ****  */
 114:../Generated_Code/tasks.c **** #define tskIDLE_STACK_SIZE      configMINIMAL_STACK_SIZE
 115:../Generated_Code/tasks.c **** 
 116:../Generated_Code/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 117:../Generated_Code/tasks.c ****         /* If the cooperative scheduler is being used then a yield should not be
 118:../Generated_Code/tasks.c ****         performed just because a higher priority task has been woken. */
 119:../Generated_Code/tasks.c ****         #define taskYIELD_IF_USING_PREEMPTION()
 120:../Generated_Code/tasks.c **** #else
 121:../Generated_Code/tasks.c ****         #define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 122:../Generated_Code/tasks.c **** #endif
 123:../Generated_Code/tasks.c **** 
 124:../Generated_Code/tasks.c **** /*
 125:../Generated_Code/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 126:../Generated_Code/tasks.c ****  * and stores task state information, including a pointer to the task's context
 127:../Generated_Code/tasks.c ****  * (the task's run time environment, including register values)
 128:../Generated_Code/tasks.c ****  */
 129:../Generated_Code/tasks.c **** typedef struct tskTaskControlBlock
 130:../Generated_Code/tasks.c **** {
 131:../Generated_Code/tasks.c ****         volatile StackType_t    *pxTopOfStack;  /*< Points to the location of the last item placed 
 132:../Generated_Code/tasks.c **** 
 133:../Generated_Code/tasks.c ****         #if ( portUSING_MPU_WRAPPERS == 1 )
 134:../Generated_Code/tasks.c ****                 xMPU_SETTINGS   xMPUSettings;           /*< The MPU settings are defined as part of
 135:../Generated_Code/tasks.c ****         #endif
 136:../Generated_Code/tasks.c **** 
 137:../Generated_Code/tasks.c ****         ListItem_t                      xGenericListItem;       /*< The list that the state list it
 138:../Generated_Code/tasks.c ****         ListItem_t                      xEventListItem;         /*< Used to reference a task from a
 139:../Generated_Code/tasks.c ****         UBaseType_t                     uxPriority;                     /*< The priority of the tas
 140:../Generated_Code/tasks.c ****         StackType_t                     *pxStack;                       /*< Points to the start of 
 141:../Generated_Code/tasks.c ****         char                            pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name 
 142:../Generated_Code/tasks.c **** 
 143:../Generated_Code/tasks.c ****         #if ( portSTACK_GROWTH > 0 )
 144:../Generated_Code/tasks.c ****                 StackType_t             *pxEndOfStack;          /*< Points to the end of the stack 
 145:../Generated_Code/tasks.c ****         #endif
 146:../Generated_Code/tasks.c **** 
 147:../Generated_Code/tasks.c ****         #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 148:../Generated_Code/tasks.c ****                 UBaseType_t     uxCriticalNesting;      /*< Holds the critical section nesting dept
 149:../Generated_Code/tasks.c ****         #endif
 150:../Generated_Code/tasks.c **** 
 151:../Generated_Code/tasks.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
 152:../Generated_Code/tasks.c ****                 UBaseType_t             uxTCBNumber;            /*< Stores a number that increments
 153:../Generated_Code/tasks.c ****                 UBaseType_t     uxTaskNumber;           /*< Stores a number specifically for use by
 154:../Generated_Code/tasks.c ****         #endif
 155:../Generated_Code/tasks.c **** 
 156:../Generated_Code/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
 157:../Generated_Code/tasks.c ****                 UBaseType_t     uxBasePriority;         /*< The priority last assigned to the task 
 158:../Generated_Code/tasks.c ****         #endif
 159:../Generated_Code/tasks.c **** 
 160:../Generated_Code/tasks.c ****         #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 161:../Generated_Code/tasks.c ****                 TaskHookFunction_t pxTaskTag;
 162:../Generated_Code/tasks.c ****         #endif
 163:../Generated_Code/tasks.c **** 
 164:../Generated_Code/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
 165:../Generated_Code/tasks.c ****                 uint32_t                ulRunTimeCounter;       /*< Stores the amount of time the t
 166:../Generated_Code/tasks.c ****         #endif
 167:../Generated_Code/tasks.c **** 
 168:../Generated_Code/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
 169:../Generated_Code/tasks.c ****                 /* Allocate a Newlib reent structure that is specific to this task.
 170:../Generated_Code/tasks.c ****                 Note Newlib support has been included by popular demand, but is not
 171:../Generated_Code/tasks.c ****                 used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 172:../Generated_Code/tasks.c ****                 responsible for resulting newlib operation.  User must be familiar with
 173:../Generated_Code/tasks.c ****                 newlib and must provide system-wide implementations of the necessary
 174:../Generated_Code/tasks.c ****                 stubs. Be warned that (at the time of writing) the current newlib design
 175:../Generated_Code/tasks.c ****                 implements a system-wide malloc() that must be provided with locks. */
 176:../Generated_Code/tasks.c ****                 struct  _reent xNewLib_reent;
 177:../Generated_Code/tasks.c ****         #endif
 178:../Generated_Code/tasks.c **** 
 179:../Generated_Code/tasks.c **** } tskTCB;
 180:../Generated_Code/tasks.c **** 
 181:../Generated_Code/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 182:../Generated_Code/tasks.c **** below to enable the use of older kernel aware debuggers. */
 183:../Generated_Code/tasks.c **** typedef tskTCB TCB_t;
 184:../Generated_Code/tasks.c **** 
 185:../Generated_Code/tasks.c **** /*
 186:../Generated_Code/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 187:../Generated_Code/tasks.c ****  * be global, rather than file scope.
 188:../Generated_Code/tasks.c ****  */
 189:../Generated_Code/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 190:../Generated_Code/tasks.c ****         #define static
 191:../Generated_Code/tasks.c **** #endif
 192:../Generated_Code/tasks.c **** 
 193:../Generated_Code/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 194:../Generated_Code/tasks.c **** static variables must be declared volatile. */
 195:../Generated_Code/tasks.c **** 
 196:../Generated_Code/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 197:../Generated_Code/tasks.c **** 
 198:../Generated_Code/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 199:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 200:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;                                                /*<
 201:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;                                                /*<
 202:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;                             /*< Points 
 203:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;             /*< Points to the d
 204:../Generated_Code/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;                                                /*<
 205:../Generated_Code/tasks.c **** 
 206:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 207:../Generated_Code/tasks.c **** 
 208:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static List_t xTasksWaitingTermination;                         /*< Tasks t
 209:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 210:../Generated_Code/tasks.c **** 
 211:../Generated_Code/tasks.c **** #endif
 212:../Generated_Code/tasks.c **** 
 213:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 214:../Generated_Code/tasks.c **** 
 215:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static List_t xSuspendedTaskList;                                       /*<
 216:../Generated_Code/tasks.c **** 
 217:../Generated_Code/tasks.c **** #endif
 218:../Generated_Code/tasks.c **** 
 219:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 220:../Generated_Code/tasks.c **** 
 221:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                     /*< Holds t
 222:../Generated_Code/tasks.c **** 
 223:../Generated_Code/tasks.c **** #endif
 224:../Generated_Code/tasks.c **** 
 225:../Generated_Code/tasks.c **** /* Other file private variables. --------------------------------*/
 226:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks      = ( UBaseType_t ) 0U;
 227:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount                           = ( TickType_t ) 0U
 228:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority          = tskIDLE_PRIORITY;
 229:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning            = pdFALSE;
 230:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks                       = ( UBaseType_t ) 0
 231:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending                        = pdFALSE;
 232:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows                      = ( BaseType_t ) 0;
 233:../Generated_Code/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber                                         = ( UBaseTy
 234:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime         = portMAX_DELAY;
 235:../Generated_Code/tasks.c **** 
 236:../Generated_Code/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 237:../Generated_Code/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 238:../Generated_Code/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 239:../Generated_Code/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 240:../Generated_Code/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 241:../Generated_Code/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 242:../Generated_Code/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 243:../Generated_Code/tasks.c **** accessed from a critical section. */
 244:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended        = ( UBaseType_t ) pdFALSE;
 245:../Generated_Code/tasks.c **** 
 246:../Generated_Code/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 247:../Generated_Code/tasks.c **** 
 248:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;     /*< Holds the value of a ti
 249:../Generated_Code/tasks.c ****         PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;           /*< Holds the total amount 
 250:../Generated_Code/tasks.c **** 
 251:../Generated_Code/tasks.c **** #endif
 252:../Generated_Code/tasks.c **** 
 253:../Generated_Code/tasks.c **** /*lint +e956 */
 254:../Generated_Code/tasks.c **** 
 255:../Generated_Code/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 256:../Generated_Code/tasks.c **** 
 257:../Generated_Code/tasks.c **** /*
 258:../Generated_Code/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 259:../Generated_Code/tasks.c ****  * is used purely for checking the high water mark for tasks.
 260:../Generated_Code/tasks.c ****  */
 261:../Generated_Code/tasks.c **** #define tskSTACK_FILL_BYTE      ( 0xa5U )
 262:../Generated_Code/tasks.c **** 
 263:../Generated_Code/tasks.c **** /*
 264:../Generated_Code/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 265:../Generated_Code/tasks.c ****  */
 266:../Generated_Code/tasks.c **** #define tskBLOCKED_CHAR         ( 'B' )
 267:../Generated_Code/tasks.c **** #define tskREADY_CHAR           ( 'R' )
 268:../Generated_Code/tasks.c **** #define tskDELETED_CHAR         ( 'D' )
 269:../Generated_Code/tasks.c **** #define tskSUSPENDED_CHAR       ( 'S' )
 270:../Generated_Code/tasks.c **** 
 271:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 272:../Generated_Code/tasks.c **** 
 273:../Generated_Code/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 274:../Generated_Code/tasks.c **** 
 275:../Generated_Code/tasks.c ****         /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 276:../Generated_Code/tasks.c ****         performed in a generic way that is not optimised to any particular
 277:../Generated_Code/tasks.c ****         microcontroller architecture. */
 278:../Generated_Code/tasks.c **** 
 279:../Generated_Code/tasks.c ****         /* uxTopReadyPriority holds the priority of the highest priority ready
 280:../Generated_Code/tasks.c ****         state task. */
 281:../Generated_Code/tasks.c ****         #define taskRECORD_READY_PRIORITY( uxPriority )                                            
 282:../Generated_Code/tasks.c ****         {                                                                                          
 283:../Generated_Code/tasks.c ****                 if( ( uxPriority ) > uxTopReadyPriority )                                          
 284:../Generated_Code/tasks.c ****                 {                                                                                  
 285:../Generated_Code/tasks.c ****                         uxTopReadyPriority = ( uxPriority );                                       
 286:../Generated_Code/tasks.c ****                 }                                                                                  
 287:../Generated_Code/tasks.c ****         } /* taskRECORD_READY_PRIORITY */
 288:../Generated_Code/tasks.c **** 
 289:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 290:../Generated_Code/tasks.c **** 
 291:../Generated_Code/tasks.c ****         #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                 
 292:../Generated_Code/tasks.c ****         {                                                                                          
 293:../Generated_Code/tasks.c ****                 /* Find the highest priority queue that contains ready tasks. */                   
 294:../Generated_Code/tasks.c ****                 while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )         
 295:../Generated_Code/tasks.c ****                 {                                                                                  
 296:../Generated_Code/tasks.c ****                         configASSERT( uxTopReadyPriority );                                        
 297:../Generated_Code/tasks.c ****                         --uxTopReadyPriority;                                                      
 298:../Generated_Code/tasks.c ****                 }                                                                                  
 299:../Generated_Code/tasks.c ****                                                                                                    
 300:../Generated_Code/tasks.c ****                 /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of           
 301:../Generated_Code/tasks.c ****                 the     same priority get an equal share of the processor time. */                 
 302:../Generated_Code/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority
 303:../Generated_Code/tasks.c ****         } /* taskSELECT_HIGHEST_PRIORITY_TASK */
 304:../Generated_Code/tasks.c **** 
 305:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 306:../Generated_Code/tasks.c **** 
 307:../Generated_Code/tasks.c ****         /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 308:../Generated_Code/tasks.c ****         they are only required when a port optimised method of task selection is
 309:../Generated_Code/tasks.c ****         being used. */
 310:../Generated_Code/tasks.c ****         #define taskRESET_READY_PRIORITY( uxPriority )
 311:../Generated_Code/tasks.c ****         #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 312:../Generated_Code/tasks.c **** 
 313:../Generated_Code/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 314:../Generated_Code/tasks.c **** 
 315:../Generated_Code/tasks.c ****         /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 316:../Generated_Code/tasks.c ****         performed in a way that is tailored to the particular microcontroller
 317:../Generated_Code/tasks.c ****         architecture being used. */
 318:../Generated_Code/tasks.c **** 
 319:../Generated_Code/tasks.c ****         /* A port optimised version is provided.  Call the port defined macros. */
 320:../Generated_Code/tasks.c ****         #define taskRECORD_READY_PRIORITY( uxPriority ) portRECORD_READY_PRIORITY( uxPriority, uxTo
 321:../Generated_Code/tasks.c **** 
 322:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 323:../Generated_Code/tasks.c **** 
 324:../Generated_Code/tasks.c ****         #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                 
 325:../Generated_Code/tasks.c ****         {                                                                                          
 326:../Generated_Code/tasks.c ****         UBaseType_t uxTopPriority;                                                                 
 327:../Generated_Code/tasks.c ****                                                                                                    
 328:../Generated_Code/tasks.c ****                 /* Find the highest priority queue that contains ready tasks. */                   
 329:../Generated_Code/tasks.c ****                 portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                     
 330:../Generated_Code/tasks.c ****                 configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 
 331:../Generated_Code/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) 
 332:../Generated_Code/tasks.c ****         } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 333:../Generated_Code/tasks.c **** 
 334:../Generated_Code/tasks.c ****         /*-----------------------------------------------------------*/
 335:../Generated_Code/tasks.c **** 
 336:../Generated_Code/tasks.c ****         /* A port optimised version is provided, call it only if the TCB being reset
 337:../Generated_Code/tasks.c ****         is being referenced from a ready list.  If it is referenced from a delayed
 338:../Generated_Code/tasks.c ****         or suspended list then it won't be in a ready list. */
 339:../Generated_Code/tasks.c ****         #define taskRESET_READY_PRIORITY( uxPriority )                                             
 340:../Generated_Code/tasks.c ****         {                                                                                          
 341:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )     
 342:../Generated_Code/tasks.c ****                 {                                                                                  
 343:../Generated_Code/tasks.c ****                         portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );        
 344:../Generated_Code/tasks.c ****                 }                                                                                  
 345:../Generated_Code/tasks.c ****         }
 346:../Generated_Code/tasks.c **** 
 347:../Generated_Code/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 348:../Generated_Code/tasks.c **** 
 349:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 350:../Generated_Code/tasks.c **** 
 351:../Generated_Code/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 352:../Generated_Code/tasks.c **** count overflows. */
 353:../Generated_Code/tasks.c **** #define taskSWITCH_DELAYED_LISTS()                                                                 
 354:../Generated_Code/tasks.c **** {                                                                                                  
 355:../Generated_Code/tasks.c ****         List_t *pxTemp;                                                                            
 356:../Generated_Code/tasks.c ****                                                                                                    
 357:../Generated_Code/tasks.c ****         /* The delayed tasks list should be empty when the lists are switched. */                  
 358:../Generated_Code/tasks.c ****         configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );                                
 359:../Generated_Code/tasks.c ****                                                                                                    
 360:../Generated_Code/tasks.c ****         pxTemp = pxDelayedTaskList;                                                                
 361:../Generated_Code/tasks.c ****         pxDelayedTaskList = pxOverflowDelayedTaskList;                                             
 362:../Generated_Code/tasks.c ****         pxOverflowDelayedTaskList = pxTemp;                                                        
 363:../Generated_Code/tasks.c ****         xNumOfOverflows++;                                                                         
 364:../Generated_Code/tasks.c ****         prvResetNextTaskUnblockTime();                                                             
 365:../Generated_Code/tasks.c **** }
 366:../Generated_Code/tasks.c **** 
 367:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 368:../Generated_Code/tasks.c **** 
 369:../Generated_Code/tasks.c **** /*
 370:../Generated_Code/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 371:../Generated_Code/tasks.c ****  * the task.  It is inserted at the end of the list.
 372:../Generated_Code/tasks.c ****  */
 373:../Generated_Code/tasks.c **** #define prvAddTaskToReadyList( pxTCB )                                                             
 374:../Generated_Code/tasks.c ****         traceMOVED_TASK_TO_READY_STATE( pxTCB )                                                    
 375:../Generated_Code/tasks.c ****         taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                        
 376:../Generated_Code/tasks.c ****         vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericList
 377:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 378:../Generated_Code/tasks.c **** 
 379:../Generated_Code/tasks.c **** /*
 380:../Generated_Code/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 381:../Generated_Code/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 382:../Generated_Code/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 383:../Generated_Code/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 384:../Generated_Code/tasks.c ****  */
 385:../Generated_Code/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 386:../Generated_Code/tasks.c **** 
 387:../Generated_Code/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 388:../Generated_Code/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 389:../Generated_Code/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 390:../Generated_Code/tasks.c **** is important its value is not updated due to a task priority change while it is
 391:../Generated_Code/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 392:../Generated_Code/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 393:../Generated_Code/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 394:../Generated_Code/tasks.c **** to its original value when it is released. */
 395:../Generated_Code/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 396:../Generated_Code/tasks.c ****         #define taskEVENT_LIST_ITEM_VALUE_IN_USE        0x8000U
 397:../Generated_Code/tasks.c **** #else
 398:../Generated_Code/tasks.c ****         #define taskEVENT_LIST_ITEM_VALUE_IN_USE        0x80000000UL
 399:../Generated_Code/tasks.c **** #endif
 400:../Generated_Code/tasks.c **** 
 401:../Generated_Code/tasks.c **** /* Callback function prototypes. --------------------------*/
 402:../Generated_Code/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 403:../Generated_Code/tasks.c ****         extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 404:../Generated_Code/tasks.c **** #endif
 405:../Generated_Code/tasks.c **** 
 406:../Generated_Code/tasks.c **** #if configUSE_TICK_HOOK > 0
 407:../Generated_Code/tasks.c ****         extern void vApplicationTickHook( void );
 408:../Generated_Code/tasks.c **** #endif
 409:../Generated_Code/tasks.c **** 
 410:../Generated_Code/tasks.c **** /* File private functions. --------------------------------*/
 411:../Generated_Code/tasks.c **** 
 412:../Generated_Code/tasks.c **** /*
 413:../Generated_Code/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 414:../Generated_Code/tasks.c ****  * into the TCB structure.
 415:../Generated_Code/tasks.c ****  */
 416:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 417:../Generated_Code/tasks.c **** 
 418:../Generated_Code/tasks.c **** /**
 419:../Generated_Code/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 420:../Generated_Code/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 421:../Generated_Code/tasks.c ****  * is in any other state.
 422:../Generated_Code/tasks.c ****  */
 423:../Generated_Code/tasks.c **** static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 424:../Generated_Code/tasks.c **** 
 425:../Generated_Code/tasks.c **** /*
 426:../Generated_Code/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 427:../Generated_Code/tasks.c ****  * automatically upon the creation of the first task.
 428:../Generated_Code/tasks.c ****  */
 429:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 430:../Generated_Code/tasks.c **** 
 431:../Generated_Code/tasks.c **** /*
 432:../Generated_Code/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 433:../Generated_Code/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 434:../Generated_Code/tasks.c ****  * creation of the first user task.
 435:../Generated_Code/tasks.c ****  *
 436:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 437:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 438:../Generated_Code/tasks.c ****  *
 439:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
 440:../Generated_Code/tasks.c ****  *
 441:../Generated_Code/tasks.c ****  */
 442:../Generated_Code/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 443:../Generated_Code/tasks.c **** 
 444:../Generated_Code/tasks.c **** /*
 445:../Generated_Code/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 446:../Generated_Code/tasks.c ****  * including the stack pointed to by the TCB.
 447:../Generated_Code/tasks.c ****  *
 448:../Generated_Code/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 449:../Generated_Code/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 450:../Generated_Code/tasks.c ****  */
 451:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 452:../Generated_Code/tasks.c **** 
 453:../Generated_Code/tasks.c ****         static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 454:../Generated_Code/tasks.c **** 
 455:../Generated_Code/tasks.c **** #endif
 456:../Generated_Code/tasks.c **** 
 457:../Generated_Code/tasks.c **** /*
 458:../Generated_Code/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 459:../Generated_Code/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 460:../Generated_Code/tasks.c ****  * and its TCB deleted.
 461:../Generated_Code/tasks.c ****  */
 462:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 463:../Generated_Code/tasks.c **** 
 464:../Generated_Code/tasks.c **** /*
 465:../Generated_Code/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 466:../Generated_Code/tasks.c ****  * either the current or the overflow delayed task list.
 467:../Generated_Code/tasks.c ****  */
 468:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 469:../Generated_Code/tasks.c **** 
 470:../Generated_Code/tasks.c **** /*
 471:../Generated_Code/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 472:../Generated_Code/tasks.c ****  * allocation was successful.
 473:../Generated_Code/tasks.c ****  */
 474:../Generated_Code/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 475:../Generated_Code/tasks.c **** 
 476:../Generated_Code/tasks.c **** /*
 477:../Generated_Code/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 478:../Generated_Code/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 479:../Generated_Code/tasks.c ****  * a suspended list, etc.).
 480:../Generated_Code/tasks.c ****  *
 481:../Generated_Code/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 482:../Generated_Code/tasks.c ****  * NORMAL APPLICATION CODE.
 483:../Generated_Code/tasks.c ****  */
 484:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 485:../Generated_Code/tasks.c **** 
 486:../Generated_Code/tasks.c ****         static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *px
 487:../Generated_Code/tasks.c **** 
 488:../Generated_Code/tasks.c **** #endif
 489:../Generated_Code/tasks.c **** 
 490:../Generated_Code/tasks.c **** /*
 491:../Generated_Code/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 492:../Generated_Code/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 493:../Generated_Code/tasks.c ****  * determining how much of the stack remains at the original preset value.
 494:../Generated_Code/tasks.c ****  */
 495:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 496:../Generated_Code/tasks.c **** 
 497:../Generated_Code/tasks.c ****         static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCT
 498:../Generated_Code/tasks.c **** 
 499:../Generated_Code/tasks.c **** #endif
 500:../Generated_Code/tasks.c **** 
 501:../Generated_Code/tasks.c **** /*
 502:../Generated_Code/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 503:../Generated_Code/tasks.c ****  * next move a task from the Blocked state to the Running state.
 504:../Generated_Code/tasks.c ****  *
 505:../Generated_Code/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 506:../Generated_Code/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 507:../Generated_Code/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 508:../Generated_Code/tasks.c ****  * set to a value other than 1.
 509:../Generated_Code/tasks.c ****  */
 510:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 511:../Generated_Code/tasks.c **** 
 512:../Generated_Code/tasks.c ****         static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 513:../Generated_Code/tasks.c **** 
 514:../Generated_Code/tasks.c **** #endif
 515:../Generated_Code/tasks.c **** 
 516:../Generated_Code/tasks.c **** /*
 517:../Generated_Code/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 518:../Generated_Code/tasks.c ****  * will exit the Blocked state.
 519:../Generated_Code/tasks.c ****  */
 520:../Generated_Code/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 521:../Generated_Code/tasks.c **** 
 522:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 523:../Generated_Code/tasks.c **** 
 524:../Generated_Code/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 525:../Generated_Code/tasks.c **** {
 135              		.loc 1 525 0
 136              		.cfi_startproc
 137 0000 90B5     		push	{r4, r7, lr}
 138              	.LCFI0:
 139              		.cfi_def_cfa_offset 12
 140              		.cfi_offset 4, -12
 141              		.cfi_offset 7, -8
 142              		.cfi_offset 14, -4
 143 0002 8BB0     		sub	sp, sp, #44
 144              	.LCFI1:
 145              		.cfi_def_cfa_offset 56
 146 0004 02AF     		add	r7, sp, #8
 147              	.LCFI2:
 148              		.cfi_def_cfa 7, 48
 149 0006 F860     		str	r0, [r7, #12]
 150 0008 B960     		str	r1, [r7, #8]
 151 000a 3B60     		str	r3, [r7]
 152 000c BB1D     		add	r3, r7, #6
 153 000e 1A80     		strh	r2, [r3]
 154              	.LBB2:
 526:../Generated_Code/tasks.c **** BaseType_t xReturn;
 527:../Generated_Code/tasks.c **** TCB_t * pxNewTCB;
 528:../Generated_Code/tasks.c **** 
 529:../Generated_Code/tasks.c ****         configASSERT( pxTaskCode );
 155              		.loc 1 529 0
 156 0010 FB68     		ldr	r3, [r7, #12]
 157 0012 002B     		cmp	r3, #0
 158 0014 01D1     		bne	.L2
 159              		.loc 1 529 0 is_stmt 0
 160              	@ 529 "../Generated_Code/tasks.c" 1
 161 0016 72B6     		cpsid i
 162              	@ 0 "" 2
 163              		.code	16
 164              	.L3:
 165              		.loc 1 529 0
 166 0018 FEE7     		b	.L3
 167              	.L2:
 530:../Generated_Code/tasks.c ****         configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 168              		.loc 1 530 0 is_stmt 1
 169 001a 3B6B     		ldr	r3, [r7, #48]
 170 001c 052B     		cmp	r3, #5
 171 001e 01D9     		bls	.L4
 172              		.loc 1 530 0 is_stmt 0
 173              	@ 530 "../Generated_Code/tasks.c" 1
 174 0020 72B6     		cpsid i
 175              	@ 0 "" 2
 176              		.code	16
 177              	.L5:
 178              		.loc 1 530 0
 179 0022 FEE7     		b	.L5
 180              	.L4:
 531:../Generated_Code/tasks.c **** 
 532:../Generated_Code/tasks.c ****         /* Allocate the memory required by the TCB and stack for the new task,
 533:../Generated_Code/tasks.c ****         checking that the allocation was successful. */
 534:../Generated_Code/tasks.c ****         pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 181              		.loc 1 534 0 is_stmt 1
 182 0024 BB1D     		add	r3, r7, #6
 183 0026 1A88     		ldrh	r2, [r3]
 184 0028 BB6B     		ldr	r3, [r7, #56]
 185 002a 101C     		mov	r0, r2
 186 002c 191C     		mov	r1, r3
 187 002e FFF7FEFF 		bl	_ZL22prvAllocateTCBAndStacktPm
 188 0032 031C     		mov	r3, r0
 189 0034 BB61     		str	r3, [r7, #24]
 190              	.LBB3:
 535:../Generated_Code/tasks.c **** 
 536:../Generated_Code/tasks.c ****         if( pxNewTCB != NULL )
 191              		.loc 1 536 0
 192 0036 BB69     		ldr	r3, [r7, #24]
 193 0038 002B     		cmp	r3, #0
 194 003a 00D1     		bne	.LCB53
 195 003c 81E0     		b	.L6	@long jump
 196              	.LCB53:
 197              	.LBB4:
 537:../Generated_Code/tasks.c ****         {
 538:../Generated_Code/tasks.c ****                 StackType_t *pxTopOfStack;
 539:../Generated_Code/tasks.c **** 
 540:../Generated_Code/tasks.c ****                 #if( portUSING_MPU_WRAPPERS == 1 )
 541:../Generated_Code/tasks.c ****                         /* Should the task be created in privileged mode? */
 542:../Generated_Code/tasks.c ****                         BaseType_t xRunPrivileged;
 543:../Generated_Code/tasks.c ****                         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 544:../Generated_Code/tasks.c ****                         {
 545:../Generated_Code/tasks.c ****                                 xRunPrivileged = pdTRUE;
 546:../Generated_Code/tasks.c ****                         }
 547:../Generated_Code/tasks.c ****                         else
 548:../Generated_Code/tasks.c ****                         {
 549:../Generated_Code/tasks.c ****                                 xRunPrivileged = pdFALSE;
 550:../Generated_Code/tasks.c ****                         }
 551:../Generated_Code/tasks.c ****                         uxPriority &= ~portPRIVILEGE_BIT;
 552:../Generated_Code/tasks.c ****                 #endif /* portUSING_MPU_WRAPPERS == 1 */
 553:../Generated_Code/tasks.c **** 
 554:../Generated_Code/tasks.c ****                 /* Calculate the top of stack address.  This depends on whether the
 555:../Generated_Code/tasks.c ****                 stack grows from high memory to low (as per the 80x86) or vice versa.
 556:../Generated_Code/tasks.c ****                 portSTACK_GROWTH is used to make the result positive or negative as
 557:../Generated_Code/tasks.c ****                 required by the port. */
 558:../Generated_Code/tasks.c ****                 #if( portSTACK_GROWTH < 0 )
 559:../Generated_Code/tasks.c ****                 {
 560:../Generated_Code/tasks.c ****                         pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 198              		.loc 1 560 0
 199 003e BB69     		ldr	r3, [r7, #24]
 200 0040 1A6B     		ldr	r2, [r3, #48]
 201 0042 BB1D     		add	r3, r7, #6
 202 0044 1B88     		ldrh	r3, [r3]
 203 0046 013B     		sub	r3, r3, #1
 204 0048 9B00     		lsl	r3, r3, #2
 205 004a D318     		add	r3, r2, r3
 206 004c 7B61     		str	r3, [r7, #20]
 561:../Generated_Code/tasks.c ****                         pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack
 207              		.loc 1 561 0
 208 004e 7B69     		ldr	r3, [r7, #20]
 209 0050 0722     		mov	r2, #7
 210 0052 9343     		bic	r3, r2
 211 0054 7B61     		str	r3, [r7, #20]
 562:../Generated_Code/tasks.c **** 
 563:../Generated_Code/tasks.c ****                         /* Check the alignment of the calculated top of stack is correct. */
 564:../Generated_Code/tasks.c ****                         configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNME
 212              		.loc 1 564 0
 213 0056 7A69     		ldr	r2, [r7, #20]
 214 0058 0723     		mov	r3, #7
 215 005a 1340     		and	r3, r2
 216 005c 01D0     		beq	.L7
 217              		.loc 1 564 0 is_stmt 0
 218              	@ 564 "../Generated_Code/tasks.c" 1
 219 005e 72B6     		cpsid i
 220              	@ 0 "" 2
 221              		.code	16
 222              	.L8:
 223              		.loc 1 564 0
 224 0060 FEE7     		b	.L8
 225              	.L7:
 565:../Generated_Code/tasks.c ****                 }
 566:../Generated_Code/tasks.c ****                 #else /* portSTACK_GROWTH */
 567:../Generated_Code/tasks.c ****                 {
 568:../Generated_Code/tasks.c ****                         pxTopOfStack = pxNewTCB->pxStack;
 569:../Generated_Code/tasks.c **** 
 570:../Generated_Code/tasks.c ****                         /* Check the alignment of the stack buffer is correct. */
 571:../Generated_Code/tasks.c ****                         configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_AL
 572:../Generated_Code/tasks.c **** 
 573:../Generated_Code/tasks.c ****                         /* If we want to use stack checking on architectures that use
 574:../Generated_Code/tasks.c ****                         a positive stack growth direction then we also need to store the
 575:../Generated_Code/tasks.c ****                         other extreme of the stack space. */
 576:../Generated_Code/tasks.c ****                         pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 577:../Generated_Code/tasks.c ****                 }
 578:../Generated_Code/tasks.c ****                 #endif /* portSTACK_GROWTH */
 579:../Generated_Code/tasks.c **** 
 580:../Generated_Code/tasks.c ****                 /* Setup the newly allocated TCB with the initial state of the task. */
 581:../Generated_Code/tasks.c ****                 prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 226              		.loc 1 581 0 is_stmt 1
 227 0062 B869     		ldr	r0, [r7, #24]
 228 0064 B968     		ldr	r1, [r7, #8]
 229 0066 3A6B     		ldr	r2, [r7, #48]
 230 0068 FB6B     		ldr	r3, [r7, #60]
 231 006a BC1D     		add	r4, r7, #6
 232 006c 2488     		ldrh	r4, [r4]
 233 006e 0094     		str	r4, [sp]
 234 0070 FFF7FEFF 		bl	_ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt
 582:../Generated_Code/tasks.c **** 
 583:../Generated_Code/tasks.c ****                 /* Initialize the TCB stack to look as if the task was already running,
 584:../Generated_Code/tasks.c ****                 but had been interrupted by the scheduler.  The return address is set
 585:../Generated_Code/tasks.c ****                 to the start of the task function. Once the stack has been initialised
 586:../Generated_Code/tasks.c ****                 the     top of stack variable is updated. */
 587:../Generated_Code/tasks.c ****                 #if( portUSING_MPU_WRAPPERS == 1 )
 588:../Generated_Code/tasks.c ****                 {
 589:../Generated_Code/tasks.c ****                         pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, p
 590:../Generated_Code/tasks.c ****                 }
 591:../Generated_Code/tasks.c ****                 #else /* portUSING_MPU_WRAPPERS */
 592:../Generated_Code/tasks.c ****                 {
 593:../Generated_Code/tasks.c ****                         pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, p
 235              		.loc 1 593 0
 236 0074 7969     		ldr	r1, [r7, #20]
 237 0076 FA68     		ldr	r2, [r7, #12]
 238 0078 3B68     		ldr	r3, [r7]
 239 007a 081C     		mov	r0, r1
 240 007c 111C     		mov	r1, r2
 241 007e 1A1C     		mov	r2, r3
 242 0080 FFF7FEFF 		bl	pxPortInitialiseStack
 243 0084 021C     		mov	r2, r0
 244 0086 BB69     		ldr	r3, [r7, #24]
 245 0088 1A60     		str	r2, [r3]
 594:../Generated_Code/tasks.c ****                 }
 595:../Generated_Code/tasks.c ****                 #endif /* portUSING_MPU_WRAPPERS */
 596:../Generated_Code/tasks.c **** 
 597:../Generated_Code/tasks.c ****                 if( ( void * ) pxCreatedTask != NULL )
 246              		.loc 1 597 0
 247 008a 7B6B     		ldr	r3, [r7, #52]
 248 008c 002B     		cmp	r3, #0
 249 008e 02D0     		beq	.L9
 598:../Generated_Code/tasks.c ****                 {
 599:../Generated_Code/tasks.c ****                         /* Pass the TCB out - in an anonymous way.  The calling function/
 600:../Generated_Code/tasks.c ****                         task can use this as a handle to delete the task later if
 601:../Generated_Code/tasks.c ****                         required.*/
 602:../Generated_Code/tasks.c ****                         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 250              		.loc 1 602 0
 251 0090 7B6B     		ldr	r3, [r7, #52]
 252 0092 BA69     		ldr	r2, [r7, #24]
 253 0094 1A60     		str	r2, [r3]
 254              	.L9:
 603:../Generated_Code/tasks.c ****                 }
 604:../Generated_Code/tasks.c ****                 else
 605:../Generated_Code/tasks.c ****                 {
 606:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 607:../Generated_Code/tasks.c ****                 }
 608:../Generated_Code/tasks.c **** 
 609:../Generated_Code/tasks.c ****                 /* Ensure interrupts don't access the task lists while they are being
 610:../Generated_Code/tasks.c ****                 updated. */
 611:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 255              		.loc 1 611 0
 256 0096 FFF7FEFF 		bl	vPortEnterCritical
 612:../Generated_Code/tasks.c ****                 {
 613:../Generated_Code/tasks.c ****                         uxCurrentNumberOfTasks++;
 257              		.loc 1 613 0
 258 009a 394B     		ldr	r3, .L16
 259 009c 1B68     		ldr	r3, [r3]
 260 009e 5A1C     		add	r2, r3, #1
 261 00a0 374B     		ldr	r3, .L16
 262 00a2 1A60     		str	r2, [r3]
 614:../Generated_Code/tasks.c ****                         if( pxCurrentTCB == NULL )
 263              		.loc 1 614 0
 264 00a4 374B     		ldr	r3, .L16+4
 265 00a6 1B68     		ldr	r3, [r3]
 266 00a8 5A42     		neg	r2, r3
 267 00aa 5341     		adc	r3, r3, r2
 268 00ac DBB2     		uxtb	r3, r3
 269 00ae 002B     		cmp	r3, #0
 270 00b0 0DD0     		beq	.L10
 615:../Generated_Code/tasks.c ****                         {
 616:../Generated_Code/tasks.c ****                                 /* There are no other tasks, or all the other tasks are in
 617:../Generated_Code/tasks.c ****                                 the suspended state - make this the current task. */
 618:../Generated_Code/tasks.c ****                                 pxCurrentTCB =  pxNewTCB;
 271              		.loc 1 618 0
 272 00b2 344B     		ldr	r3, .L16+4
 273 00b4 BA69     		ldr	r2, [r7, #24]
 274 00b6 1A60     		str	r2, [r3]
 619:../Generated_Code/tasks.c **** 
 620:../Generated_Code/tasks.c ****                                 if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 275              		.loc 1 620 0
 276 00b8 314B     		ldr	r3, .L16
 277 00ba 1B68     		ldr	r3, [r3]
 278 00bc 013B     		sub	r3, r3, #1
 279 00be 5A42     		neg	r2, r3
 280 00c0 5341     		adc	r3, r3, r2
 281 00c2 DBB2     		uxtb	r3, r3
 282 00c4 002B     		cmp	r3, #0
 283 00c6 16D0     		beq	.L11
 621:../Generated_Code/tasks.c ****                                 {
 622:../Generated_Code/tasks.c ****                                         /* This is the first task to be created so do the prelimina
 623:../Generated_Code/tasks.c ****                                         initialisation required.  We will not recover if this call
 624:../Generated_Code/tasks.c ****                                         fails, but we will report the failure. */
 625:../Generated_Code/tasks.c ****                                         prvInitialiseTaskLists();
 284              		.loc 1 625 0
 285 00c8 FFF7FEFF 		bl	_ZL22prvInitialiseTaskListsv
 286 00cc 13E0     		b	.L11
 287              	.L10:
 626:../Generated_Code/tasks.c ****                                 }
 627:../Generated_Code/tasks.c ****                                 else
 628:../Generated_Code/tasks.c ****                                 {
 629:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 630:../Generated_Code/tasks.c ****                                 }
 631:../Generated_Code/tasks.c ****                         }
 632:../Generated_Code/tasks.c ****                         else
 633:../Generated_Code/tasks.c ****                         {
 634:../Generated_Code/tasks.c ****                                 /* If the scheduler is not already running, make this task the
 635:../Generated_Code/tasks.c ****                                 current task if it is the highest priority task to be created
 636:../Generated_Code/tasks.c ****                                 so far. */
 637:../Generated_Code/tasks.c ****                                 if( xSchedulerRunning == pdFALSE )
 288              		.loc 1 637 0
 289 00ce 2E4B     		ldr	r3, .L16+8
 290 00d0 1B68     		ldr	r3, [r3]
 291 00d2 5A42     		neg	r2, r3
 292 00d4 5341     		adc	r3, r3, r2
 293 00d6 DBB2     		uxtb	r3, r3
 294 00d8 002B     		cmp	r3, #0
 295 00da 0CD0     		beq	.L11
 638:../Generated_Code/tasks.c ****                                 {
 639:../Generated_Code/tasks.c ****                                         if( pxCurrentTCB->uxPriority <= uxPriority )
 296              		.loc 1 639 0
 297 00dc 294B     		ldr	r3, .L16+4
 298 00de 1B68     		ldr	r3, [r3]
 299 00e0 DA6A     		ldr	r2, [r3, #44]
 300 00e2 396B     		ldr	r1, [r7, #48]
 301 00e4 0023     		mov	r3, #0
 302 00e6 9142     		cmp	r1, r2
 303 00e8 5B41     		adc	r3, r3, r3
 304 00ea DBB2     		uxtb	r3, r3
 305 00ec 002B     		cmp	r3, #0
 306 00ee 02D0     		beq	.L11
 640:../Generated_Code/tasks.c ****                                         {
 641:../Generated_Code/tasks.c ****                                                 pxCurrentTCB = pxNewTCB;
 307              		.loc 1 641 0
 308 00f0 244B     		ldr	r3, .L16+4
 309 00f2 BA69     		ldr	r2, [r7, #24]
 310 00f4 1A60     		str	r2, [r3]
 311              	.L11:
 642:../Generated_Code/tasks.c ****                                         }
 643:../Generated_Code/tasks.c ****                                         else
 644:../Generated_Code/tasks.c ****                                         {
 645:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
 646:../Generated_Code/tasks.c ****                                         }
 647:../Generated_Code/tasks.c ****                                 }
 648:../Generated_Code/tasks.c ****                                 else
 649:../Generated_Code/tasks.c ****                                 {
 650:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 651:../Generated_Code/tasks.c ****                                 }
 652:../Generated_Code/tasks.c ****                         }
 653:../Generated_Code/tasks.c **** 
 654:../Generated_Code/tasks.c ****                         uxTaskNumber++;
 312              		.loc 1 654 0
 313 00f6 254B     		ldr	r3, .L16+12
 314 00f8 1B68     		ldr	r3, [r3]
 315 00fa 5A1C     		add	r2, r3, #1
 316 00fc 234B     		ldr	r3, .L16+12
 317 00fe 1A60     		str	r2, [r3]
 655:../Generated_Code/tasks.c **** 
 656:../Generated_Code/tasks.c ****                         #if ( configUSE_TRACE_FACILITY == 1 )
 657:../Generated_Code/tasks.c ****                         {
 658:../Generated_Code/tasks.c ****                                 /* Add a counter into the TCB for tracing only. */
 659:../Generated_Code/tasks.c ****                                 pxNewTCB->uxTCBNumber = uxTaskNumber;
 660:../Generated_Code/tasks.c ****                         }
 661:../Generated_Code/tasks.c ****                         #endif /* configUSE_TRACE_FACILITY */
 662:../Generated_Code/tasks.c ****                         traceTASK_CREATE( pxNewTCB );
 663:../Generated_Code/tasks.c **** 
 664:../Generated_Code/tasks.c ****                         prvAddTaskToReadyList( pxNewTCB );
 318              		.loc 1 664 0
 319 0100 BB69     		ldr	r3, [r7, #24]
 320 0102 DA6A     		ldr	r2, [r3, #44]
 321 0104 224B     		ldr	r3, .L16+16
 322 0106 1B68     		ldr	r3, [r3]
 323 0108 9342     		cmp	r3, r2
 324 010a 9B41     		sbc	r3, r3, r3
 325 010c 5B42     		neg	r3, r3
 326 010e DBB2     		uxtb	r3, r3
 327 0110 002B     		cmp	r3, #0
 328 0112 03D0     		beq	.L12
 329              		.loc 1 664 0 is_stmt 0
 330 0114 BB69     		ldr	r3, [r7, #24]
 331 0116 DA6A     		ldr	r2, [r3, #44]
 332 0118 1D4B     		ldr	r3, .L16+16
 333 011a 1A60     		str	r2, [r3]
 334              	.L12:
 335              		.loc 1 664 0
 336 011c BB69     		ldr	r3, [r7, #24]
 337 011e DA6A     		ldr	r2, [r3, #44]
 338 0120 131C     		mov	r3, r2
 339 0122 9B00     		lsl	r3, r3, #2
 340 0124 9B18     		add	r3, r3, r2
 341 0126 9B00     		lsl	r3, r3, #2
 342 0128 1A4A     		ldr	r2, .L16+20
 343 012a 9A18     		add	r2, r3, r2
 344 012c BB69     		ldr	r3, [r7, #24]
 345 012e 0433     		add	r3, r3, #4
 346 0130 101C     		mov	r0, r2
 347 0132 191C     		mov	r1, r3
 348 0134 FFF7FEFF 		bl	vListInsertEnd
 665:../Generated_Code/tasks.c **** 
 666:../Generated_Code/tasks.c ****                         xReturn = pdPASS;
 349              		.loc 1 666 0 is_stmt 1
 350 0138 0123     		mov	r3, #1
 351 013a FB61     		str	r3, [r7, #28]
 667:../Generated_Code/tasks.c ****                         portSETUP_TCB( pxNewTCB );
 668:../Generated_Code/tasks.c ****                 }
 669:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 352              		.loc 1 669 0
 353 013c FFF7FEFF 		bl	vPortExitCritical
 354 0140 02E0     		b	.L13
 355              	.L6:
 356              	.LBE4:
 670:../Generated_Code/tasks.c ****         }
 671:../Generated_Code/tasks.c ****         else
 672:../Generated_Code/tasks.c ****         {
 673:../Generated_Code/tasks.c ****                 xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 357              		.loc 1 673 0
 358 0142 0123     		mov	r3, #1
 359 0144 5B42     		neg	r3, r3
 360 0146 FB61     		str	r3, [r7, #28]
 361              	.L13:
 362              	.LBE3:
 674:../Generated_Code/tasks.c ****                 traceTASK_CREATE_FAILED();
 675:../Generated_Code/tasks.c ****         }
 676:../Generated_Code/tasks.c **** 
 677:../Generated_Code/tasks.c ****         if( xReturn == pdPASS )
 363              		.loc 1 677 0
 364 0148 FB69     		ldr	r3, [r7, #28]
 365 014a 012B     		cmp	r3, #1
 366 014c 12D1     		bne	.L14
 678:../Generated_Code/tasks.c ****         {
 679:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
 367              		.loc 1 679 0
 368 014e 0E4B     		ldr	r3, .L16+8
 369 0150 1B68     		ldr	r3, [r3]
 370 0152 5A1E     		sub	r2, r3, #1
 371 0154 9341     		sbc	r3, r3, r2
 372 0156 DBB2     		uxtb	r3, r3
 373 0158 002B     		cmp	r3, #0
 374 015a 0BD0     		beq	.L14
 680:../Generated_Code/tasks.c ****                 {
 681:../Generated_Code/tasks.c ****                         /* If the created task is of a higher priority than the current task
 682:../Generated_Code/tasks.c ****                         then it should run now. */
 683:../Generated_Code/tasks.c ****                         if( pxCurrentTCB->uxPriority < uxPriority )
 375              		.loc 1 683 0
 376 015c 094B     		ldr	r3, .L16+4
 377 015e 1B68     		ldr	r3, [r3]
 378 0160 DA6A     		ldr	r2, [r3, #44]
 379 0162 3B6B     		ldr	r3, [r7, #48]
 380 0164 9A42     		cmp	r2, r3
 381 0166 9B41     		sbc	r3, r3, r3
 382 0168 5B42     		neg	r3, r3
 383 016a DBB2     		uxtb	r3, r3
 384 016c 002B     		cmp	r3, #0
 385 016e 01D0     		beq	.L14
 684:../Generated_Code/tasks.c ****                         {
 685:../Generated_Code/tasks.c ****                                 taskYIELD_IF_USING_PREEMPTION();
 386              		.loc 1 685 0
 387 0170 FFF7FEFF 		bl	vPortYieldFromISR
 388              	.L14:
 686:../Generated_Code/tasks.c ****                         }
 687:../Generated_Code/tasks.c ****                         else
 688:../Generated_Code/tasks.c ****                         {
 689:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 690:../Generated_Code/tasks.c ****                         }
 691:../Generated_Code/tasks.c ****                 }
 692:../Generated_Code/tasks.c ****                 else
 693:../Generated_Code/tasks.c ****                 {
 694:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 695:../Generated_Code/tasks.c ****                 }
 696:../Generated_Code/tasks.c ****         }
 697:../Generated_Code/tasks.c **** 
 698:../Generated_Code/tasks.c ****         return xReturn;
 389              		.loc 1 698 0
 390 0174 FB69     		ldr	r3, [r7, #28]
 391              	.LBE2:
 699:../Generated_Code/tasks.c **** }
 392              		.loc 1 699 0
 393 0176 181C     		mov	r0, r3
 394 0178 BD46     		mov	sp, r7
 395 017a 09B0     		add	sp, sp, #36
 396              		@ sp needed for prologue
 397 017c 90BD     		pop	{r4, r7, pc}
 398              	.L17:
 399 017e C046     		.align	2
 400              	.L16:
 401 0180 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 402 0184 00000000 		.word	pxCurrentTCB
 403 0188 00000000 		.word	_ZL17xSchedulerRunning
 404 018c 00000000 		.word	_ZL12uxTaskNumber
 405 0190 00000000 		.word	_ZL18uxTopReadyPriority
 406 0194 00000000 		.word	_ZL17pxReadyTasksLists
 407              		.cfi_endproc
 408              	.LFE9:
 410              		.section	.text.vTaskDelayUntil,"ax",%progbits
 411              		.align	2
 412              		.global	vTaskDelayUntil
 413              		.code	16
 414              		.thumb_func
 416              	vTaskDelayUntil:
 417              	.LFB10:
 700:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 701:../Generated_Code/tasks.c **** 
 702:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 703:../Generated_Code/tasks.c **** 
 704:../Generated_Code/tasks.c ****         void vTaskDelete( TaskHandle_t xTaskToDelete )
 705:../Generated_Code/tasks.c ****         {
 706:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
 707:../Generated_Code/tasks.c **** 
 708:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 709:../Generated_Code/tasks.c ****                 {
 710:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the calling task that is
 711:../Generated_Code/tasks.c ****                         being deleted. */
 712:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 713:../Generated_Code/tasks.c **** 
 714:../Generated_Code/tasks.c ****                         /* Remove task from the ready list and place in the     termination list.
 715:../Generated_Code/tasks.c ****                         This will stop the task from be scheduled.  The idle task will check
 716:../Generated_Code/tasks.c ****                         the termination list and free up any memory allocated by the
 717:../Generated_Code/tasks.c ****                         scheduler for the TCB and stack. */
 718:../Generated_Code/tasks.c ****                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 719:../Generated_Code/tasks.c ****                         {
 720:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 721:../Generated_Code/tasks.c ****                         }
 722:../Generated_Code/tasks.c ****                         else
 723:../Generated_Code/tasks.c ****                         {
 724:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 725:../Generated_Code/tasks.c ****                         }
 726:../Generated_Code/tasks.c **** 
 727:../Generated_Code/tasks.c ****                         /* Is the task waiting on an event also? */
 728:../Generated_Code/tasks.c ****                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 729:../Generated_Code/tasks.c ****                         {
 730:../Generated_Code/tasks.c ****                                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 731:../Generated_Code/tasks.c ****                         }
 732:../Generated_Code/tasks.c ****                         else
 733:../Generated_Code/tasks.c ****                         {
 734:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 735:../Generated_Code/tasks.c ****                         }
 736:../Generated_Code/tasks.c **** 
 737:../Generated_Code/tasks.c ****                         vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 738:../Generated_Code/tasks.c **** 
 739:../Generated_Code/tasks.c ****                         /* Increment the ucTasksDeleted variable so the idle task knows
 740:../Generated_Code/tasks.c ****                         there is a task that has been deleted and that it should therefore
 741:../Generated_Code/tasks.c ****                         check the xTasksWaitingTermination list. */
 742:../Generated_Code/tasks.c ****                         ++uxTasksDeleted;
 743:../Generated_Code/tasks.c **** 
 744:../Generated_Code/tasks.c ****                         /* Increment the uxTaskNumberVariable also so kernel aware debuggers
 745:../Generated_Code/tasks.c ****                         can detect that the task lists need re-generating. */
 746:../Generated_Code/tasks.c ****                         uxTaskNumber++;
 747:../Generated_Code/tasks.c **** 
 748:../Generated_Code/tasks.c ****                         traceTASK_DELETE( pxTCB );
 749:../Generated_Code/tasks.c ****                 }
 750:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 751:../Generated_Code/tasks.c **** 
 752:../Generated_Code/tasks.c ****                 /* Force a reschedule if it is the currently running task that has just
 753:../Generated_Code/tasks.c ****                 been deleted. */
 754:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
 755:../Generated_Code/tasks.c ****                 {
 756:../Generated_Code/tasks.c ****                         if( pxTCB == pxCurrentTCB )
 757:../Generated_Code/tasks.c ****                         {
 758:../Generated_Code/tasks.c ****                                 configASSERT( uxSchedulerSuspended == 0 );
 759:../Generated_Code/tasks.c **** 
 760:../Generated_Code/tasks.c ****                                 /* The pre-delete hook is primarily for the Windows simulator,
 761:../Generated_Code/tasks.c ****                                 in which Windows specific clean up operations are performed,
 762:../Generated_Code/tasks.c ****                                 after which it is not possible to yield away from this task -
 763:../Generated_Code/tasks.c ****                                 hence xYieldPending is used to latch that a context switch is
 764:../Generated_Code/tasks.c ****                                 required. */
 765:../Generated_Code/tasks.c ****                                 portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 766:../Generated_Code/tasks.c ****                                 portYIELD_WITHIN_API();
 767:../Generated_Code/tasks.c ****                         }
 768:../Generated_Code/tasks.c ****                         else
 769:../Generated_Code/tasks.c ****                         {
 770:../Generated_Code/tasks.c ****                                 /* Reset the next expected unblock time in case it referred to
 771:../Generated_Code/tasks.c ****                                 the task that has just been deleted. */
 772:../Generated_Code/tasks.c ****                                 prvResetNextTaskUnblockTime();
 773:../Generated_Code/tasks.c ****                         }
 774:../Generated_Code/tasks.c ****                 }
 775:../Generated_Code/tasks.c ****         }
 776:../Generated_Code/tasks.c **** 
 777:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 778:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 779:../Generated_Code/tasks.c **** 
 780:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 781:../Generated_Code/tasks.c **** 
 782:../Generated_Code/tasks.c ****         void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncremen
 783:../Generated_Code/tasks.c ****         {
 418              		.loc 1 783 0
 419              		.cfi_startproc
 420 0000 80B5     		push	{r7, lr}
 421              	.LCFI3:
 422              		.cfi_def_cfa_offset 8
 423              		.cfi_offset 7, -8
 424              		.cfi_offset 14, -4
 425 0002 86B0     		sub	sp, sp, #24
 426              	.LCFI4:
 427              		.cfi_def_cfa_offset 32
 428 0004 00AF     		add	r7, sp, #0
 429              	.LCFI5:
 430              		.cfi_def_cfa_register 7
 431 0006 7860     		str	r0, [r7, #4]
 432 0008 3960     		str	r1, [r7]
 433              	.LBB5:
 784:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
 785:../Generated_Code/tasks.c ****         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 434              		.loc 1 785 0
 435 000a 0023     		mov	r3, #0
 436 000c 7B61     		str	r3, [r7, #20]
 786:../Generated_Code/tasks.c **** 
 787:../Generated_Code/tasks.c ****                 configASSERT( pxPreviousWakeTime );
 437              		.loc 1 787 0
 438 000e 7B68     		ldr	r3, [r7, #4]
 439 0010 002B     		cmp	r3, #0
 440 0012 01D1     		bne	.L19
 441              		.loc 1 787 0 is_stmt 0
 442              	@ 787 "../Generated_Code/tasks.c" 1
 443 0014 72B6     		cpsid i
 444              	@ 0 "" 2
 445              		.code	16
 446              	.L20:
 447              		.loc 1 787 0
 448 0016 FEE7     		b	.L20
 449              	.L19:
 788:../Generated_Code/tasks.c ****                 configASSERT( ( xTimeIncrement > 0U ) );
 450              		.loc 1 788 0 is_stmt 1
 451 0018 3B68     		ldr	r3, [r7]
 452 001a 002B     		cmp	r3, #0
 453 001c 01D1     		bne	.L21
 454              		.loc 1 788 0 is_stmt 0
 455              	@ 788 "../Generated_Code/tasks.c" 1
 456 001e 72B6     		cpsid i
 457              	@ 0 "" 2
 458              		.code	16
 459              	.L22:
 460              		.loc 1 788 0
 461 0020 FEE7     		b	.L22
 462              	.L21:
 789:../Generated_Code/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
 463              		.loc 1 789 0 is_stmt 1
 464 0022 254B     		ldr	r3, .L30
 465 0024 1B68     		ldr	r3, [r3]
 466 0026 5A1E     		sub	r2, r3, #1
 467 0028 9341     		sbc	r3, r3, r2
 468 002a DBB2     		uxtb	r3, r3
 469 002c 002B     		cmp	r3, #0
 470 002e 01D0     		beq	.L23
 471              		.loc 1 789 0 is_stmt 0
 472              	@ 789 "../Generated_Code/tasks.c" 1
 473 0030 72B6     		cpsid i
 474              	@ 0 "" 2
 475              		.code	16
 476              	.L24:
 477              		.loc 1 789 0
 478 0032 FEE7     		b	.L24
 479              	.L23:
 790:../Generated_Code/tasks.c **** 
 791:../Generated_Code/tasks.c ****                 vTaskSuspendAll();
 480              		.loc 1 791 0 is_stmt 1
 481 0034 FFF7FEFF 		bl	vTaskSuspendAll
 482              	.LBB6:
 792:../Generated_Code/tasks.c ****                 {
 793:../Generated_Code/tasks.c ****                         /* Minor optimisation.  The tick count cannot change in this
 794:../Generated_Code/tasks.c ****                         block. */
 795:../Generated_Code/tasks.c ****                         const TickType_t xConstTickCount = xTickCount;
 483              		.loc 1 795 0
 484 0038 204B     		ldr	r3, .L30+4
 485 003a 1B68     		ldr	r3, [r3]
 486 003c 3B61     		str	r3, [r7, #16]
 796:../Generated_Code/tasks.c **** 
 797:../Generated_Code/tasks.c ****                         /* Generate the tick time at which the task wants to wake. */
 798:../Generated_Code/tasks.c ****                         xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 487              		.loc 1 798 0
 488 003e 7B68     		ldr	r3, [r7, #4]
 489 0040 1A68     		ldr	r2, [r3]
 490 0042 3B68     		ldr	r3, [r7]
 491 0044 D318     		add	r3, r2, r3
 492 0046 FB60     		str	r3, [r7, #12]
 799:../Generated_Code/tasks.c **** 
 800:../Generated_Code/tasks.c ****                         if( xConstTickCount < *pxPreviousWakeTime )
 493              		.loc 1 800 0
 494 0048 7B68     		ldr	r3, [r7, #4]
 495 004a 1A68     		ldr	r2, [r3]
 496 004c 3B69     		ldr	r3, [r7, #16]
 497 004e 9A42     		cmp	r2, r3
 498 0050 0BD9     		bls	.L25
 801:../Generated_Code/tasks.c ****                         {
 802:../Generated_Code/tasks.c ****                                 /* The tick count has overflowed since this function was
 803:../Generated_Code/tasks.c ****                                 lasted called.  In this case the only time we should ever
 804:../Generated_Code/tasks.c ****                                 actually delay is if the wake time has also     overflowed,
 805:../Generated_Code/tasks.c ****                                 and the wake time is greater than the tick time.  When this
 806:../Generated_Code/tasks.c ****                                 is the case it is as if neither time had overflowed. */
 807:../Generated_Code/tasks.c ****                                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConst
 499              		.loc 1 807 0
 500 0052 7B68     		ldr	r3, [r7, #4]
 501 0054 1A68     		ldr	r2, [r3]
 502 0056 FB68     		ldr	r3, [r7, #12]
 503 0058 9A42     		cmp	r2, r3
 504 005a 11D9     		bls	.L26
 505              		.loc 1 807 0 is_stmt 0
 506 005c FA68     		ldr	r2, [r7, #12]
 507 005e 3B69     		ldr	r3, [r7, #16]
 508 0060 9A42     		cmp	r2, r3
 509 0062 0DD9     		bls	.L26
 808:../Generated_Code/tasks.c ****                                 {
 809:../Generated_Code/tasks.c ****                                         xShouldDelay = pdTRUE;
 510              		.loc 1 809 0 is_stmt 1
 511 0064 0123     		mov	r3, #1
 512 0066 7B61     		str	r3, [r7, #20]
 513 0068 0AE0     		b	.L26
 514              	.L25:
 810:../Generated_Code/tasks.c ****                                 }
 811:../Generated_Code/tasks.c ****                                 else
 812:../Generated_Code/tasks.c ****                                 {
 813:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 814:../Generated_Code/tasks.c ****                                 }
 815:../Generated_Code/tasks.c ****                         }
 816:../Generated_Code/tasks.c ****                         else
 817:../Generated_Code/tasks.c ****                         {
 818:../Generated_Code/tasks.c ****                                 /* The tick time has not overflowed.  In this case we will
 819:../Generated_Code/tasks.c ****                                 delay if either the wake time has overflowed, and/or the
 820:../Generated_Code/tasks.c ****                                 tick time is less than the wake time. */
 821:../Generated_Code/tasks.c ****                                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConst
 515              		.loc 1 821 0
 516 006a 7B68     		ldr	r3, [r7, #4]
 517 006c 1A68     		ldr	r2, [r3]
 518 006e FB68     		ldr	r3, [r7, #12]
 519 0070 9A42     		cmp	r2, r3
 520 0072 03D8     		bhi	.L27
 521              		.loc 1 821 0 is_stmt 0
 522 0074 FA68     		ldr	r2, [r7, #12]
 523 0076 3B69     		ldr	r3, [r7, #16]
 524 0078 9A42     		cmp	r2, r3
 525 007a 01D9     		bls	.L26
 526              	.L27:
 822:../Generated_Code/tasks.c ****                                 {
 823:../Generated_Code/tasks.c ****                                         xShouldDelay = pdTRUE;
 527              		.loc 1 823 0 is_stmt 1
 528 007c 0123     		mov	r3, #1
 529 007e 7B61     		str	r3, [r7, #20]
 530              	.L26:
 824:../Generated_Code/tasks.c ****                                 }
 825:../Generated_Code/tasks.c ****                                 else
 826:../Generated_Code/tasks.c ****                                 {
 827:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 828:../Generated_Code/tasks.c ****                                 }
 829:../Generated_Code/tasks.c ****                         }
 830:../Generated_Code/tasks.c **** 
 831:../Generated_Code/tasks.c ****                         /* Update the wake time ready for the next call. */
 832:../Generated_Code/tasks.c ****                         *pxPreviousWakeTime = xTimeToWake;
 531              		.loc 1 832 0
 532 0080 7B68     		ldr	r3, [r7, #4]
 533 0082 FA68     		ldr	r2, [r7, #12]
 534 0084 1A60     		str	r2, [r3]
 833:../Generated_Code/tasks.c **** 
 834:../Generated_Code/tasks.c ****                         if( xShouldDelay != pdFALSE )
 535              		.loc 1 834 0
 536 0086 7B69     		ldr	r3, [r7, #20]
 537 0088 002B     		cmp	r3, #0
 538 008a 09D0     		beq	.L28
 835:../Generated_Code/tasks.c ****                         {
 836:../Generated_Code/tasks.c ****                                 traceTASK_DELAY_UNTIL();
 837:../Generated_Code/tasks.c **** 
 838:../Generated_Code/tasks.c ****                                 /* Remove the task from the ready list before adding it to the
 839:../Generated_Code/tasks.c ****                                 blocked list as the same list item is used for both lists. */
 840:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseT
 539              		.loc 1 840 0
 540 008c 0C4B     		ldr	r3, .L30+8
 541 008e 1B68     		ldr	r3, [r3]
 542 0090 0433     		add	r3, r3, #4
 543 0092 181C     		mov	r0, r3
 544 0094 FFF7FEFF 		bl	uxListRemove
 841:../Generated_Code/tasks.c ****                                 {
 842:../Generated_Code/tasks.c ****                                         /* The current task must be in a ready list, so there is
 843:../Generated_Code/tasks.c ****                                         no need to check, and the port reset macro can be called
 844:../Generated_Code/tasks.c ****                                         directly. */
 845:../Generated_Code/tasks.c ****                                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopRe
 846:../Generated_Code/tasks.c ****                                 }
 847:../Generated_Code/tasks.c ****                                 else
 848:../Generated_Code/tasks.c ****                                 {
 849:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 850:../Generated_Code/tasks.c ****                                 }
 851:../Generated_Code/tasks.c **** 
 852:../Generated_Code/tasks.c ****                                 prvAddCurrentTaskToDelayedList( xTimeToWake );
 545              		.loc 1 852 0
 546 0098 FB68     		ldr	r3, [r7, #12]
 547 009a 181C     		mov	r0, r3
 548 009c FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 549              	.L28:
 550              	.LBE6:
 853:../Generated_Code/tasks.c ****                         }
 854:../Generated_Code/tasks.c ****                         else
 855:../Generated_Code/tasks.c ****                         {
 856:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
 857:../Generated_Code/tasks.c ****                         }
 858:../Generated_Code/tasks.c ****                 }
 859:../Generated_Code/tasks.c ****                 xAlreadyYielded = xTaskResumeAll();
 551              		.loc 1 859 0
 552 00a0 FFF7FEFF 		bl	xTaskResumeAll
 553 00a4 031C     		mov	r3, r0
 554 00a6 BB60     		str	r3, [r7, #8]
 860:../Generated_Code/tasks.c **** 
 861:../Generated_Code/tasks.c ****                 /* Force a reschedule if xTaskResumeAll has not already done so, we may
 862:../Generated_Code/tasks.c ****                 have put ourselves to sleep. */
 863:../Generated_Code/tasks.c ****                 if( xAlreadyYielded == pdFALSE )
 555              		.loc 1 863 0
 556 00a8 BB68     		ldr	r3, [r7, #8]
 557 00aa 002B     		cmp	r3, #0
 558 00ac 01D1     		bne	.L18
 864:../Generated_Code/tasks.c ****                 {
 865:../Generated_Code/tasks.c ****                         portYIELD_WITHIN_API();
 559              		.loc 1 865 0
 560 00ae FFF7FEFF 		bl	vPortYieldFromISR
 561              	.L18:
 562              	.LBE5:
 866:../Generated_Code/tasks.c ****                 }
 867:../Generated_Code/tasks.c ****                 else
 868:../Generated_Code/tasks.c ****                 {
 869:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 870:../Generated_Code/tasks.c ****                 }
 871:../Generated_Code/tasks.c ****         }
 563              		.loc 1 871 0
 564 00b2 BD46     		mov	sp, r7
 565 00b4 06B0     		add	sp, sp, #24
 566              		@ sp needed for prologue
 567 00b6 80BD     		pop	{r7, pc}
 568              	.L31:
 569              		.align	2
 570              	.L30:
 571 00b8 00000000 		.word	_ZL20uxSchedulerSuspended
 572 00bc 00000000 		.word	_ZL10xTickCount
 573 00c0 00000000 		.word	pxCurrentTCB
 574              		.cfi_endproc
 575              	.LFE10:
 577              		.section	.text.vTaskDelay,"ax",%progbits
 578              		.align	2
 579              		.global	vTaskDelay
 580              		.code	16
 581              		.thumb_func
 583              	vTaskDelay:
 584              	.LFB11:
 872:../Generated_Code/tasks.c **** 
 873:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 874:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 875:../Generated_Code/tasks.c **** 
 876:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 877:../Generated_Code/tasks.c **** 
 878:../Generated_Code/tasks.c ****         void vTaskDelay( const TickType_t xTicksToDelay )
 879:../Generated_Code/tasks.c ****         {
 585              		.loc 1 879 0
 586              		.cfi_startproc
 587 0000 80B5     		push	{r7, lr}
 588              	.LCFI6:
 589              		.cfi_def_cfa_offset 8
 590              		.cfi_offset 7, -8
 591              		.cfi_offset 14, -4
 592 0002 84B0     		sub	sp, sp, #16
 593              	.LCFI7:
 594              		.cfi_def_cfa_offset 24
 595 0004 00AF     		add	r7, sp, #0
 596              	.LCFI8:
 597              		.cfi_def_cfa_register 7
 598 0006 7860     		str	r0, [r7, #4]
 599              	.LBB7:
 880:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
 881:../Generated_Code/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
 600              		.loc 1 881 0
 601 0008 0023     		mov	r3, #0
 602 000a FB60     		str	r3, [r7, #12]
 882:../Generated_Code/tasks.c **** 
 883:../Generated_Code/tasks.c **** 
 884:../Generated_Code/tasks.c ****                 /* A delay time of zero just forces a reschedule. */
 885:../Generated_Code/tasks.c ****                 if( xTicksToDelay > ( TickType_t ) 0U )
 603              		.loc 1 885 0
 604 000c 7B68     		ldr	r3, [r7, #4]
 605 000e 002B     		cmp	r3, #0
 606 0010 1DD0     		beq	.L33
 886:../Generated_Code/tasks.c ****                 {
 887:../Generated_Code/tasks.c ****                         configASSERT( uxSchedulerSuspended == 0 );
 607              		.loc 1 887 0
 608 0012 134B     		ldr	r3, .L37
 609 0014 1B68     		ldr	r3, [r3]
 610 0016 5A1E     		sub	r2, r3, #1
 611 0018 9341     		sbc	r3, r3, r2
 612 001a DBB2     		uxtb	r3, r3
 613 001c 002B     		cmp	r3, #0
 614 001e 01D0     		beq	.L34
 615              		.loc 1 887 0 is_stmt 0
 616              	@ 887 "../Generated_Code/tasks.c" 1
 617 0020 72B6     		cpsid i
 618              	@ 0 "" 2
 619              		.code	16
 620              	.L35:
 621              		.loc 1 887 0
 622 0022 FEE7     		b	.L35
 623              	.L34:
 888:../Generated_Code/tasks.c ****                         vTaskSuspendAll();
 624              		.loc 1 888 0 is_stmt 1
 625 0024 FFF7FEFF 		bl	vTaskSuspendAll
 889:../Generated_Code/tasks.c ****                         {
 890:../Generated_Code/tasks.c ****                                 traceTASK_DELAY();
 891:../Generated_Code/tasks.c **** 
 892:../Generated_Code/tasks.c ****                                 /* A task that is removed from the event list while the
 893:../Generated_Code/tasks.c ****                                 scheduler is suspended will not get placed in the ready
 894:../Generated_Code/tasks.c ****                                 list or removed from the blocked list until the scheduler
 895:../Generated_Code/tasks.c ****                                 is resumed.
 896:../Generated_Code/tasks.c **** 
 897:../Generated_Code/tasks.c ****                                 This task cannot be in an event list as it is the currently
 898:../Generated_Code/tasks.c ****                                 executing task. */
 899:../Generated_Code/tasks.c **** 
 900:../Generated_Code/tasks.c ****                                 /* Calculate the time to wake - this may overflow but this is
 901:../Generated_Code/tasks.c ****                                 not a problem. */
 902:../Generated_Code/tasks.c ****                                 xTimeToWake = xTickCount + xTicksToDelay;
 626              		.loc 1 902 0
 627 0028 0E4B     		ldr	r3, .L37+4
 628 002a 1A68     		ldr	r2, [r3]
 629 002c 7B68     		ldr	r3, [r7, #4]
 630 002e D318     		add	r3, r2, r3
 631 0030 BB60     		str	r3, [r7, #8]
 903:../Generated_Code/tasks.c **** 
 904:../Generated_Code/tasks.c ****                                 /* We must remove ourselves from the ready list before adding
 905:../Generated_Code/tasks.c ****                                 ourselves to the blocked list as the same list item is used for
 906:../Generated_Code/tasks.c ****                                 both lists. */
 907:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseT
 632              		.loc 1 907 0
 633 0032 0D4B     		ldr	r3, .L37+8
 634 0034 1B68     		ldr	r3, [r3]
 635 0036 0433     		add	r3, r3, #4
 636 0038 181C     		mov	r0, r3
 637 003a FFF7FEFF 		bl	uxListRemove
 908:../Generated_Code/tasks.c ****                                 {
 909:../Generated_Code/tasks.c ****                                         /* The current task must be in a ready list, so there is
 910:../Generated_Code/tasks.c ****                                         no need to check, and the port reset macro can be called
 911:../Generated_Code/tasks.c ****                                         directly. */
 912:../Generated_Code/tasks.c ****                                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopRe
 913:../Generated_Code/tasks.c ****                                 }
 914:../Generated_Code/tasks.c ****                                 else
 915:../Generated_Code/tasks.c ****                                 {
 916:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
 917:../Generated_Code/tasks.c ****                                 }
 918:../Generated_Code/tasks.c ****                                 prvAddCurrentTaskToDelayedList( xTimeToWake );
 638              		.loc 1 918 0
 639 003e BB68     		ldr	r3, [r7, #8]
 640 0040 181C     		mov	r0, r3
 641 0042 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 919:../Generated_Code/tasks.c ****                         }
 920:../Generated_Code/tasks.c ****                         xAlreadyYielded = xTaskResumeAll();
 642              		.loc 1 920 0
 643 0046 FFF7FEFF 		bl	xTaskResumeAll
 644 004a 031C     		mov	r3, r0
 645 004c FB60     		str	r3, [r7, #12]
 646              	.L33:
 921:../Generated_Code/tasks.c ****                 }
 922:../Generated_Code/tasks.c ****                 else
 923:../Generated_Code/tasks.c ****                 {
 924:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 925:../Generated_Code/tasks.c ****                 }
 926:../Generated_Code/tasks.c **** 
 927:../Generated_Code/tasks.c ****                 /* Force a reschedule if xTaskResumeAll has not already done so, we may
 928:../Generated_Code/tasks.c ****                 have put ourselves to sleep. */
 929:../Generated_Code/tasks.c ****                 if( xAlreadyYielded == pdFALSE )
 647              		.loc 1 929 0
 648 004e FB68     		ldr	r3, [r7, #12]
 649 0050 002B     		cmp	r3, #0
 650 0052 01D1     		bne	.L32
 930:../Generated_Code/tasks.c ****                 {
 931:../Generated_Code/tasks.c ****                         portYIELD_WITHIN_API();
 651              		.loc 1 931 0
 652 0054 FFF7FEFF 		bl	vPortYieldFromISR
 653              	.L32:
 654              	.LBE7:
 932:../Generated_Code/tasks.c ****                 }
 933:../Generated_Code/tasks.c ****                 else
 934:../Generated_Code/tasks.c ****                 {
 935:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
 936:../Generated_Code/tasks.c ****                 }
 937:../Generated_Code/tasks.c ****         }
 655              		.loc 1 937 0
 656 0058 BD46     		mov	sp, r7
 657 005a 04B0     		add	sp, sp, #16
 658              		@ sp needed for prologue
 659 005c 80BD     		pop	{r7, pc}
 660              	.L38:
 661 005e C046     		.align	2
 662              	.L37:
 663 0060 00000000 		.word	_ZL20uxSchedulerSuspended
 664 0064 00000000 		.word	_ZL10xTickCount
 665 0068 00000000 		.word	pxCurrentTCB
 666              		.cfi_endproc
 667              	.LFE11:
 669              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 670              		.align	2
 671              		.global	uxTaskPriorityGet
 672              		.code	16
 673              		.thumb_func
 675              	uxTaskPriorityGet:
 676              	.LFB12:
 938:../Generated_Code/tasks.c **** 
 939:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 940:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 941:../Generated_Code/tasks.c **** 
 942:../Generated_Code/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 943:../Generated_Code/tasks.c **** 
 944:../Generated_Code/tasks.c ****         eTaskState eTaskGetState( TaskHandle_t xTask )
 945:../Generated_Code/tasks.c ****         {
 946:../Generated_Code/tasks.c ****         eTaskState eReturn;
 947:../Generated_Code/tasks.c ****         List_t *pxStateList;
 948:../Generated_Code/tasks.c ****         const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 949:../Generated_Code/tasks.c **** 
 950:../Generated_Code/tasks.c ****                 configASSERT( pxTCB );
 951:../Generated_Code/tasks.c **** 
 952:../Generated_Code/tasks.c ****                 if( pxTCB == pxCurrentTCB )
 953:../Generated_Code/tasks.c ****                 {
 954:../Generated_Code/tasks.c ****                         /* The task calling this function is querying its own state. */
 955:../Generated_Code/tasks.c ****                         eReturn = eRunning;
 956:../Generated_Code/tasks.c ****                 }
 957:../Generated_Code/tasks.c ****                 else
 958:../Generated_Code/tasks.c ****                 {
 959:../Generated_Code/tasks.c ****                         taskENTER_CRITICAL();
 960:../Generated_Code/tasks.c ****                         {
 961:../Generated_Code/tasks.c ****                                 pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGene
 962:../Generated_Code/tasks.c ****                         }
 963:../Generated_Code/tasks.c ****                         taskEXIT_CRITICAL();
 964:../Generated_Code/tasks.c **** 
 965:../Generated_Code/tasks.c ****                         if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDela
 966:../Generated_Code/tasks.c ****                         {
 967:../Generated_Code/tasks.c ****                                 /* The task being queried is referenced from one of the Blocked
 968:../Generated_Code/tasks.c ****                                 lists. */
 969:../Generated_Code/tasks.c ****                                 eReturn = eBlocked;
 970:../Generated_Code/tasks.c ****                         }
 971:../Generated_Code/tasks.c **** 
 972:../Generated_Code/tasks.c ****                         #if ( INCLUDE_vTaskSuspend == 1 )
 973:../Generated_Code/tasks.c ****                                 else if( pxStateList == &xSuspendedTaskList )
 974:../Generated_Code/tasks.c ****                                 {
 975:../Generated_Code/tasks.c ****                                         /* The task being queried is referenced from the suspended
 976:../Generated_Code/tasks.c ****                                         list.  Is it genuinely suspended or is it block
 977:../Generated_Code/tasks.c ****                                         indefinitely? */
 978:../Generated_Code/tasks.c ****                                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) =
 979:../Generated_Code/tasks.c ****                                         {
 980:../Generated_Code/tasks.c ****                                                 eReturn = eSuspended;
 981:../Generated_Code/tasks.c ****                                         }
 982:../Generated_Code/tasks.c ****                                         else
 983:../Generated_Code/tasks.c ****                                         {
 984:../Generated_Code/tasks.c ****                                                 eReturn = eBlocked;
 985:../Generated_Code/tasks.c ****                                         }
 986:../Generated_Code/tasks.c ****                                 }
 987:../Generated_Code/tasks.c ****                         #endif
 988:../Generated_Code/tasks.c **** 
 989:../Generated_Code/tasks.c ****                         #if ( INCLUDE_vTaskDelete == 1 )
 990:../Generated_Code/tasks.c ****                                 else if( pxStateList == &xTasksWaitingTermination )
 991:../Generated_Code/tasks.c ****                                 {
 992:../Generated_Code/tasks.c ****                                         /* The task being queried is referenced from the deleted
 993:../Generated_Code/tasks.c ****                                         tasks list. */
 994:../Generated_Code/tasks.c ****                                         eReturn = eDeleted;
 995:../Generated_Code/tasks.c ****                                 }
 996:../Generated_Code/tasks.c ****                         #endif
 997:../Generated_Code/tasks.c **** 
 998:../Generated_Code/tasks.c ****                         else
 999:../Generated_Code/tasks.c ****                         {
1000:../Generated_Code/tasks.c ****                                 /* If the task is not in any other state, it must be in the
1001:../Generated_Code/tasks.c ****                                 Ready (including pending ready) state. */
1002:../Generated_Code/tasks.c ****                                 eReturn = eReady;
1003:../Generated_Code/tasks.c ****                         }
1004:../Generated_Code/tasks.c ****                 }
1005:../Generated_Code/tasks.c **** 
1006:../Generated_Code/tasks.c ****                 return eReturn;
1007:../Generated_Code/tasks.c ****         }
1008:../Generated_Code/tasks.c **** 
1009:../Generated_Code/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1010:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1011:../Generated_Code/tasks.c **** 
1012:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1013:../Generated_Code/tasks.c **** 
1014:../Generated_Code/tasks.c ****         UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1015:../Generated_Code/tasks.c ****         {
 677              		.loc 1 1015 0
 678              		.cfi_startproc
 679 0000 80B5     		push	{r7, lr}
 680              	.LCFI9:
 681              		.cfi_def_cfa_offset 8
 682              		.cfi_offset 7, -8
 683              		.cfi_offset 14, -4
 684 0002 84B0     		sub	sp, sp, #16
 685              	.LCFI10:
 686              		.cfi_def_cfa_offset 24
 687 0004 00AF     		add	r7, sp, #0
 688              	.LCFI11:
 689              		.cfi_def_cfa_register 7
 690 0006 7860     		str	r0, [r7, #4]
 691              	.LBB8:
1016:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1017:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
1018:../Generated_Code/tasks.c **** 
1019:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 692              		.loc 1 1019 0
 693 0008 FFF7FEFF 		bl	vPortEnterCritical
1020:../Generated_Code/tasks.c ****                 {
1021:../Generated_Code/tasks.c ****                         /* If null is passed in here then we are changing the
1022:../Generated_Code/tasks.c ****                         priority of the calling function. */
1023:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTask );
 694              		.loc 1 1023 0
 695 000c 7B68     		ldr	r3, [r7, #4]
 696 000e 002B     		cmp	r3, #0
 697 0010 02D1     		bne	.L40
 698              		.loc 1 1023 0 is_stmt 0
 699 0012 074B     		ldr	r3, .L43
 700 0014 1B68     		ldr	r3, [r3]
 701 0016 00E0     		b	.L41
 702              	.L40:
 703              		.loc 1 1023 0
 704 0018 7B68     		ldr	r3, [r7, #4]
 705              	.L41:
 706              		.loc 1 1023 0
 707 001a FB60     		str	r3, [r7, #12]
1024:../Generated_Code/tasks.c ****                         uxReturn = pxTCB->uxPriority;
 708              		.loc 1 1024 0 is_stmt 1
 709 001c FB68     		ldr	r3, [r7, #12]
 710 001e DB6A     		ldr	r3, [r3, #44]
 711 0020 BB60     		str	r3, [r7, #8]
1025:../Generated_Code/tasks.c ****                 }
1026:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 712              		.loc 1 1026 0
 713 0022 FFF7FEFF 		bl	vPortExitCritical
1027:../Generated_Code/tasks.c **** 
1028:../Generated_Code/tasks.c ****                 return uxReturn;
 714              		.loc 1 1028 0
 715 0026 BB68     		ldr	r3, [r7, #8]
 716              	.LBE8:
1029:../Generated_Code/tasks.c ****         }
 717              		.loc 1 1029 0
 718 0028 181C     		mov	r0, r3
 719 002a BD46     		mov	sp, r7
 720 002c 04B0     		add	sp, sp, #16
 721              		@ sp needed for prologue
 722 002e 80BD     		pop	{r7, pc}
 723              	.L44:
 724              		.align	2
 725              	.L43:
 726 0030 00000000 		.word	pxCurrentTCB
 727              		.cfi_endproc
 728              	.LFE12:
 730              		.section	.text.vTaskPrioritySet,"ax",%progbits
 731              		.align	2
 732              		.global	vTaskPrioritySet
 733              		.code	16
 734              		.thumb_func
 736              	vTaskPrioritySet:
 737              	.LFB13:
1030:../Generated_Code/tasks.c **** 
1031:../Generated_Code/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1032:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1033:../Generated_Code/tasks.c **** 
1034:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1035:../Generated_Code/tasks.c **** 
1036:../Generated_Code/tasks.c ****         void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1037:../Generated_Code/tasks.c ****         {
 738              		.loc 1 1037 0
 739              		.cfi_startproc
 740 0000 80B5     		push	{r7, lr}
 741              	.LCFI12:
 742              		.cfi_def_cfa_offset 8
 743              		.cfi_offset 7, -8
 744              		.cfi_offset 14, -4
 745 0002 86B0     		sub	sp, sp, #24
 746              	.LCFI13:
 747              		.cfi_def_cfa_offset 32
 748 0004 00AF     		add	r7, sp, #0
 749              	.LCFI14:
 750              		.cfi_def_cfa_register 7
 751 0006 7860     		str	r0, [r7, #4]
 752 0008 3960     		str	r1, [r7]
 753              	.LBB9:
1038:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1039:../Generated_Code/tasks.c ****         UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1040:../Generated_Code/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 754              		.loc 1 1040 0
 755 000a 0023     		mov	r3, #0
 756 000c 7B61     		str	r3, [r7, #20]
1041:../Generated_Code/tasks.c **** 
1042:../Generated_Code/tasks.c ****                 configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 757              		.loc 1 1042 0
 758 000e 3B68     		ldr	r3, [r7]
 759 0010 052B     		cmp	r3, #5
 760 0012 01D9     		bls	.L46
 761              		.loc 1 1042 0 is_stmt 0
 762              	@ 1042 "../Generated_Code/tasks.c" 1
 763 0014 72B6     		cpsid i
 764              	@ 0 "" 2
 765              		.code	16
 766              	.L47:
 767              		.loc 1 1042 0
 768 0016 FEE7     		b	.L47
 769              	.L46:
1043:../Generated_Code/tasks.c **** 
1044:../Generated_Code/tasks.c ****                 /* Ensure the new priority is valid. */
1045:../Generated_Code/tasks.c ****                 if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 770              		.loc 1 1045 0 is_stmt 1
 771 0018 3B68     		ldr	r3, [r7]
 772 001a 052B     		cmp	r3, #5
 773 001c 01D9     		bls	.L48
1046:../Generated_Code/tasks.c ****                 {
1047:../Generated_Code/tasks.c ****                         uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 774              		.loc 1 1047 0
 775 001e 0523     		mov	r3, #5
 776 0020 3B60     		str	r3, [r7]
 777              	.L48:
1048:../Generated_Code/tasks.c ****                 }
1049:../Generated_Code/tasks.c ****                 else
1050:../Generated_Code/tasks.c ****                 {
1051:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1052:../Generated_Code/tasks.c ****                 }
1053:../Generated_Code/tasks.c **** 
1054:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 778              		.loc 1 1054 0
 779 0022 FFF7FEFF 		bl	vPortEnterCritical
1055:../Generated_Code/tasks.c ****                 {
1056:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the priority of the calling
1057:../Generated_Code/tasks.c ****                         task that is being changed. */
1058:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTask );
 780              		.loc 1 1058 0
 781 0026 7B68     		ldr	r3, [r7, #4]
 782 0028 002B     		cmp	r3, #0
 783 002a 02D1     		bne	.L49
 784              		.loc 1 1058 0 is_stmt 0
 785 002c 424B     		ldr	r3, .L60
 786 002e 1B68     		ldr	r3, [r3]
 787 0030 00E0     		b	.L50
 788              	.L49:
 789              		.loc 1 1058 0
 790 0032 7B68     		ldr	r3, [r7, #4]
 791              	.L50:
 792              		.loc 1 1058 0
 793 0034 3B61     		str	r3, [r7, #16]
1059:../Generated_Code/tasks.c **** 
1060:../Generated_Code/tasks.c ****                         traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1061:../Generated_Code/tasks.c **** 
1062:../Generated_Code/tasks.c ****                         #if ( configUSE_MUTEXES == 1 )
1063:../Generated_Code/tasks.c ****                         {
1064:../Generated_Code/tasks.c ****                                 uxCurrentBasePriority = pxTCB->uxBasePriority;
 794              		.loc 1 1064 0 is_stmt 1
 795 0036 3B69     		ldr	r3, [r7, #16]
 796 0038 1B6D     		ldr	r3, [r3, #80]
 797 003a FB60     		str	r3, [r7, #12]
1065:../Generated_Code/tasks.c ****                         }
1066:../Generated_Code/tasks.c ****                         #else
1067:../Generated_Code/tasks.c ****                         {
1068:../Generated_Code/tasks.c ****                                 uxCurrentBasePriority = pxTCB->uxPriority;
1069:../Generated_Code/tasks.c ****                         }
1070:../Generated_Code/tasks.c ****                         #endif
1071:../Generated_Code/tasks.c **** 
1072:../Generated_Code/tasks.c ****                         if( uxCurrentBasePriority != uxNewPriority )
 798              		.loc 1 1072 0
 799 003c FA68     		ldr	r2, [r7, #12]
 800 003e 3B68     		ldr	r3, [r7]
 801 0040 9A42     		cmp	r2, r3
 802 0042 00D1     		bne	.LCB575
 803 0044 72E0     		b	.L51	@long jump
 804              	.LCB575:
1073:../Generated_Code/tasks.c ****                         {
1074:../Generated_Code/tasks.c ****                                 /* The priority change may have readied a task of higher
1075:../Generated_Code/tasks.c ****                                 priority than the calling task. */
1076:../Generated_Code/tasks.c ****                                 if( uxNewPriority > uxCurrentBasePriority )
 805              		.loc 1 1076 0
 806 0046 3A68     		ldr	r2, [r7]
 807 0048 FB68     		ldr	r3, [r7, #12]
 808 004a 9A42     		cmp	r2, r3
 809 004c 15D9     		bls	.L52
1077:../Generated_Code/tasks.c ****                                 {
1078:../Generated_Code/tasks.c ****                                         if( pxTCB != pxCurrentTCB )
 810              		.loc 1 1078 0
 811 004e 3A4B     		ldr	r3, .L60
 812 0050 1B68     		ldr	r3, [r3]
 813 0052 3A69     		ldr	r2, [r7, #16]
 814 0054 D31A     		sub	r3, r2, r3
 815 0056 5A1E     		sub	r2, r3, #1
 816 0058 9341     		sbc	r3, r3, r2
 817 005a DBB2     		uxtb	r3, r3
 818 005c 002B     		cmp	r3, #0
 819 005e 17D0     		beq	.L53
1079:../Generated_Code/tasks.c ****                                         {
1080:../Generated_Code/tasks.c ****                                                 /* The priority of a task other than the currently
1081:../Generated_Code/tasks.c ****                                                 running task is being raised.  Is the priority bein
1082:../Generated_Code/tasks.c ****                                                 raised above that of the running task? */
1083:../Generated_Code/tasks.c ****                                                 if( uxNewPriority >= pxCurrentTCB->uxPriority )
 820              		.loc 1 1083 0
 821 0060 354B     		ldr	r3, .L60
 822 0062 1B68     		ldr	r3, [r3]
 823 0064 DA6A     		ldr	r2, [r3, #44]
 824 0066 3968     		ldr	r1, [r7]
 825 0068 0023     		mov	r3, #0
 826 006a 9142     		cmp	r1, r2
 827 006c 5B41     		adc	r3, r3, r3
 828 006e DBB2     		uxtb	r3, r3
 829 0070 002B     		cmp	r3, #0
 830 0072 0DD0     		beq	.L53
1084:../Generated_Code/tasks.c ****                                                 {
1085:../Generated_Code/tasks.c ****                                                         xYieldRequired = pdTRUE;
 831              		.loc 1 1085 0
 832 0074 0123     		mov	r3, #1
 833 0076 7B61     		str	r3, [r7, #20]
 834 0078 0AE0     		b	.L53
 835              	.L52:
1086:../Generated_Code/tasks.c ****                                                 }
1087:../Generated_Code/tasks.c ****                                                 else
1088:../Generated_Code/tasks.c ****                                                 {
1089:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1090:../Generated_Code/tasks.c ****                                                 }
1091:../Generated_Code/tasks.c ****                                         }
1092:../Generated_Code/tasks.c ****                                         else
1093:../Generated_Code/tasks.c ****                                         {
1094:../Generated_Code/tasks.c ****                                                 /* The priority of the running task is being raised
1095:../Generated_Code/tasks.c ****                                                 but the running task must already be the highest
1096:../Generated_Code/tasks.c ****                                                 priority task able to run so no yield is required. 
1097:../Generated_Code/tasks.c ****                                         }
1098:../Generated_Code/tasks.c ****                                 }
1099:../Generated_Code/tasks.c ****                                 else if( pxTCB == pxCurrentTCB )
 836              		.loc 1 1099 0
 837 007a 2F4B     		ldr	r3, .L60
 838 007c 1B68     		ldr	r3, [r3]
 839 007e 3A69     		ldr	r2, [r7, #16]
 840 0080 D31A     		sub	r3, r2, r3
 841 0082 5A42     		neg	r2, r3
 842 0084 5341     		adc	r3, r3, r2
 843 0086 DBB2     		uxtb	r3, r3
 844 0088 002B     		cmp	r3, #0
 845 008a 01D0     		beq	.L53
1100:../Generated_Code/tasks.c ****                                 {
1101:../Generated_Code/tasks.c ****                                         /* Setting the priority of the running task down means
1102:../Generated_Code/tasks.c ****                                         there may now be another task of higher priority that
1103:../Generated_Code/tasks.c ****                                         is ready to execute. */
1104:../Generated_Code/tasks.c ****                                         xYieldRequired = pdTRUE;
 846              		.loc 1 1104 0
 847 008c 0123     		mov	r3, #1
 848 008e 7B61     		str	r3, [r7, #20]
 849              	.L53:
1105:../Generated_Code/tasks.c ****                                 }
1106:../Generated_Code/tasks.c ****                                 else
1107:../Generated_Code/tasks.c ****                                 {
1108:../Generated_Code/tasks.c ****                                         /* Setting the priority of any other task down does not
1109:../Generated_Code/tasks.c ****                                         require a yield as the running task must be above the
1110:../Generated_Code/tasks.c ****                                         new priority of the task being modified. */
1111:../Generated_Code/tasks.c ****                                 }
1112:../Generated_Code/tasks.c **** 
1113:../Generated_Code/tasks.c ****                                 /* Remember the ready list the task might be referenced from
1114:../Generated_Code/tasks.c ****                                 before its uxPriority member is changed so the
1115:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY() macro can function correctly. */
1116:../Generated_Code/tasks.c ****                                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
 850              		.loc 1 1116 0
 851 0090 3B69     		ldr	r3, [r7, #16]
 852 0092 DB6A     		ldr	r3, [r3, #44]
 853 0094 BB60     		str	r3, [r7, #8]
1117:../Generated_Code/tasks.c **** 
1118:../Generated_Code/tasks.c ****                                 #if ( configUSE_MUTEXES == 1 )
1119:../Generated_Code/tasks.c ****                                 {
1120:../Generated_Code/tasks.c ****                                         /* Only change the priority being used if the task is not
1121:../Generated_Code/tasks.c ****                                         currently using an inherited priority. */
1122:../Generated_Code/tasks.c ****                                         if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 854              		.loc 1 1122 0
 855 0096 3B69     		ldr	r3, [r7, #16]
 856 0098 1A6D     		ldr	r2, [r3, #80]
 857 009a 3B69     		ldr	r3, [r7, #16]
 858 009c DB6A     		ldr	r3, [r3, #44]
 859 009e 9A42     		cmp	r2, r3
 860 00a0 02D1     		bne	.L54
1123:../Generated_Code/tasks.c ****                                         {
1124:../Generated_Code/tasks.c ****                                                 pxTCB->uxPriority = uxNewPriority;
 861              		.loc 1 1124 0
 862 00a2 3B69     		ldr	r3, [r7, #16]
 863 00a4 3A68     		ldr	r2, [r7]
 864 00a6 DA62     		str	r2, [r3, #44]
 865              	.L54:
1125:../Generated_Code/tasks.c ****                                         }
1126:../Generated_Code/tasks.c ****                                         else
1127:../Generated_Code/tasks.c ****                                         {
1128:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1129:../Generated_Code/tasks.c ****                                         }
1130:../Generated_Code/tasks.c **** 
1131:../Generated_Code/tasks.c ****                                         /* The base priority gets set whatever. */
1132:../Generated_Code/tasks.c ****                                         pxTCB->uxBasePriority = uxNewPriority;
 866              		.loc 1 1132 0
 867 00a8 3B69     		ldr	r3, [r7, #16]
 868 00aa 3A68     		ldr	r2, [r7]
 869 00ac 1A65     		str	r2, [r3, #80]
1133:../Generated_Code/tasks.c ****                                 }
1134:../Generated_Code/tasks.c ****                                 #else
1135:../Generated_Code/tasks.c ****                                 {
1136:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = uxNewPriority;
1137:../Generated_Code/tasks.c ****                                 }
1138:../Generated_Code/tasks.c ****                                 #endif
1139:../Generated_Code/tasks.c **** 
1140:../Generated_Code/tasks.c ****                                 /* Only reset the event list item value if the value is not
1141:../Generated_Code/tasks.c ****                                 being used for anything else. */
1142:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 870              		.loc 1 1142 0
 871 00ae 3B69     		ldr	r3, [r7, #16]
 872 00b0 9B69     		ldr	r3, [r3, #24]
 873 00b2 002B     		cmp	r3, #0
 874 00b4 04DB     		blt	.L55
1143:../Generated_Code/tasks.c ****                                 {
1144:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( Ti
 875              		.loc 1 1144 0
 876 00b6 3B68     		ldr	r3, [r7]
 877 00b8 0622     		mov	r2, #6
 878 00ba D21A     		sub	r2, r2, r3
 879 00bc 3B69     		ldr	r3, [r7, #16]
 880 00be 9A61     		str	r2, [r3, #24]
 881              	.L55:
1145:../Generated_Code/tasks.c ****                                 }
1146:../Generated_Code/tasks.c ****                                 else
1147:../Generated_Code/tasks.c ****                                 {
1148:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1149:../Generated_Code/tasks.c ****                                 }
1150:../Generated_Code/tasks.c **** 
1151:../Generated_Code/tasks.c ****                                 /* If the task is in the blocked or suspended list we need do
1152:../Generated_Code/tasks.c ****                                 nothing more than change it's priority variable. However, if
1153:../Generated_Code/tasks.c ****                                 the task is in a ready list it needs to be removed and placed
1154:../Generated_Code/tasks.c ****                                 in the list appropriate to its new priority. */
1155:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOn
 882              		.loc 1 1155 0
 883 00c0 3B69     		ldr	r3, [r7, #16]
 884 00c2 5969     		ldr	r1, [r3, #20]
 885 00c4 BA68     		ldr	r2, [r7, #8]
 886 00c6 131C     		mov	r3, r2
 887 00c8 9B00     		lsl	r3, r3, #2
 888 00ca 9B18     		add	r3, r3, r2
 889 00cc 9B00     		lsl	r3, r3, #2
 890 00ce 1B4A     		ldr	r2, .L60+4
 891 00d0 9B18     		add	r3, r3, r2
 892 00d2 9942     		cmp	r1, r3
 893 00d4 01D1     		bne	.L56
 894              		.loc 1 1155 0 is_stmt 0
 895 00d6 0123     		mov	r3, #1
 896 00d8 00E0     		b	.L57
 897              	.L56:
 898              		.loc 1 1155 0
 899 00da 0023     		mov	r3, #0
 900              	.L57:
 901              		.loc 1 1155 0
 902 00dc 002B     		cmp	r3, #0
 903 00de 20D0     		beq	.L58
1156:../Generated_Code/tasks.c ****                                 {
1157:../Generated_Code/tasks.c ****                                         /* The task is currently in its ready list - remove before 
1158:../Generated_Code/tasks.c ****                                         it to it's new ready list.  As we are in a critical section
1159:../Generated_Code/tasks.c ****                                         can do this even if the scheduler is suspended. */
1160:../Generated_Code/tasks.c ****                                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBase
 904              		.loc 1 1160 0 is_stmt 1
 905 00e0 3B69     		ldr	r3, [r7, #16]
 906 00e2 0433     		add	r3, r3, #4
 907 00e4 181C     		mov	r0, r3
 908 00e6 FFF7FEFF 		bl	uxListRemove
1161:../Generated_Code/tasks.c ****                                         {
1162:../Generated_Code/tasks.c ****                                                 /* It is known that the task is in its ready list s
1163:../Generated_Code/tasks.c ****                                                 there is no need to check again and the port level
1164:../Generated_Code/tasks.c ****                                                 reset macro can be called directly. */
1165:../Generated_Code/tasks.c ****                                                 portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, ux
1166:../Generated_Code/tasks.c ****                                         }
1167:../Generated_Code/tasks.c ****                                         else
1168:../Generated_Code/tasks.c ****                                         {
1169:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1170:../Generated_Code/tasks.c ****                                         }
1171:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 909              		.loc 1 1171 0
 910 00ea 3B69     		ldr	r3, [r7, #16]
 911 00ec DA6A     		ldr	r2, [r3, #44]
 912 00ee 144B     		ldr	r3, .L60+8
 913 00f0 1B68     		ldr	r3, [r3]
 914 00f2 9342     		cmp	r3, r2
 915 00f4 9B41     		sbc	r3, r3, r3
 916 00f6 5B42     		neg	r3, r3
 917 00f8 DBB2     		uxtb	r3, r3
 918 00fa 002B     		cmp	r3, #0
 919 00fc 03D0     		beq	.L59
 920              		.loc 1 1171 0 is_stmt 0
 921 00fe 3B69     		ldr	r3, [r7, #16]
 922 0100 DA6A     		ldr	r2, [r3, #44]
 923 0102 0F4B     		ldr	r3, .L60+8
 924 0104 1A60     		str	r2, [r3]
 925              	.L59:
 926              		.loc 1 1171 0
 927 0106 3B69     		ldr	r3, [r7, #16]
 928 0108 DA6A     		ldr	r2, [r3, #44]
 929 010a 131C     		mov	r3, r2
 930 010c 9B00     		lsl	r3, r3, #2
 931 010e 9B18     		add	r3, r3, r2
 932 0110 9B00     		lsl	r3, r3, #2
 933 0112 0A4A     		ldr	r2, .L60+4
 934 0114 9A18     		add	r2, r3, r2
 935 0116 3B69     		ldr	r3, [r7, #16]
 936 0118 0433     		add	r3, r3, #4
 937 011a 101C     		mov	r0, r2
 938 011c 191C     		mov	r1, r3
 939 011e FFF7FEFF 		bl	vListInsertEnd
 940              	.L58:
1172:../Generated_Code/tasks.c ****                                 }
1173:../Generated_Code/tasks.c ****                                 else
1174:../Generated_Code/tasks.c ****                                 {
1175:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1176:../Generated_Code/tasks.c ****                                 }
1177:../Generated_Code/tasks.c **** 
1178:../Generated_Code/tasks.c ****                                 if( xYieldRequired == pdTRUE )
 941              		.loc 1 1178 0 is_stmt 1
 942 0122 7B69     		ldr	r3, [r7, #20]
 943 0124 012B     		cmp	r3, #1
 944 0126 01D1     		bne	.L51
1179:../Generated_Code/tasks.c ****                                 {
1180:../Generated_Code/tasks.c ****                                         taskYIELD_IF_USING_PREEMPTION();
 945              		.loc 1 1180 0
 946 0128 FFF7FEFF 		bl	vPortYieldFromISR
 947              	.L51:
1181:../Generated_Code/tasks.c ****                                 }
1182:../Generated_Code/tasks.c ****                                 else
1183:../Generated_Code/tasks.c ****                                 {
1184:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1185:../Generated_Code/tasks.c ****                                 }
1186:../Generated_Code/tasks.c **** 
1187:../Generated_Code/tasks.c ****                                 /* Remove compiler warning about unused variables when the port
1188:../Generated_Code/tasks.c ****                                 optimised task selection is not being used. */
1189:../Generated_Code/tasks.c ****                                 ( void ) uxPriorityUsedOnEntry;
1190:../Generated_Code/tasks.c ****                         }
1191:../Generated_Code/tasks.c ****                 }
1192:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 948              		.loc 1 1192 0
 949 012c FFF7FEFF 		bl	vPortExitCritical
 950              	.LBE9:
1193:../Generated_Code/tasks.c ****         }
 951              		.loc 1 1193 0
 952 0130 BD46     		mov	sp, r7
 953 0132 06B0     		add	sp, sp, #24
 954              		@ sp needed for prologue
 955 0134 80BD     		pop	{r7, pc}
 956              	.L61:
 957 0136 C046     		.align	2
 958              	.L60:
 959 0138 00000000 		.word	pxCurrentTCB
 960 013c 00000000 		.word	_ZL17pxReadyTasksLists
 961 0140 00000000 		.word	_ZL18uxTopReadyPriority
 962              		.cfi_endproc
 963              	.LFE13:
 965              		.section	.text.vTaskSuspend,"ax",%progbits
 966              		.align	2
 967              		.global	vTaskSuspend
 968              		.code	16
 969              		.thumb_func
 971              	vTaskSuspend:
 972              	.LFB14:
1194:../Generated_Code/tasks.c **** 
1195:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1196:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1197:../Generated_Code/tasks.c **** 
1198:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1199:../Generated_Code/tasks.c **** 
1200:../Generated_Code/tasks.c ****         void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1201:../Generated_Code/tasks.c ****         {
 973              		.loc 1 1201 0
 974              		.cfi_startproc
 975 0000 80B5     		push	{r7, lr}
 976              	.LCFI15:
 977              		.cfi_def_cfa_offset 8
 978              		.cfi_offset 7, -8
 979              		.cfi_offset 14, -4
 980 0002 84B0     		sub	sp, sp, #16
 981              	.LCFI16:
 982              		.cfi_def_cfa_offset 24
 983 0004 00AF     		add	r7, sp, #0
 984              	.LCFI17:
 985              		.cfi_def_cfa_register 7
 986 0006 7860     		str	r0, [r7, #4]
 987              	.LBB10:
1202:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1203:../Generated_Code/tasks.c **** 
1204:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
 988              		.loc 1 1204 0
 989 0008 FFF7FEFF 		bl	vPortEnterCritical
1205:../Generated_Code/tasks.c ****                 {
1206:../Generated_Code/tasks.c ****                         /* If null is passed in here then it is the running task that is
1207:../Generated_Code/tasks.c ****                         being suspended. */
1208:../Generated_Code/tasks.c ****                         pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 990              		.loc 1 1208 0
 991 000c 7B68     		ldr	r3, [r7, #4]
 992 000e 002B     		cmp	r3, #0
 993 0010 02D1     		bne	.L63
 994              		.loc 1 1208 0 is_stmt 0
 995 0012 2A4B     		ldr	r3, .L72
 996 0014 1B68     		ldr	r3, [r3]
 997 0016 00E0     		b	.L64
 998              	.L63:
 999              		.loc 1 1208 0
 1000 0018 7B68     		ldr	r3, [r7, #4]
 1001              	.L64:
 1002              		.loc 1 1208 0
 1003 001a FB60     		str	r3, [r7, #12]
1209:../Generated_Code/tasks.c **** 
1210:../Generated_Code/tasks.c ****                         traceTASK_SUSPEND( pxTCB );
1211:../Generated_Code/tasks.c **** 
1212:../Generated_Code/tasks.c ****                         /* Remove task from the ready/delayed list and place in the
1213:../Generated_Code/tasks.c ****                         suspended list. */
1214:../Generated_Code/tasks.c ****                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1004              		.loc 1 1214 0 is_stmt 1
 1005 001c FB68     		ldr	r3, [r7, #12]
 1006 001e 0433     		add	r3, r3, #4
 1007 0020 181C     		mov	r0, r3
 1008 0022 FFF7FEFF 		bl	uxListRemove
1215:../Generated_Code/tasks.c ****                         {
1216:../Generated_Code/tasks.c ****                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1217:../Generated_Code/tasks.c ****                         }
1218:../Generated_Code/tasks.c ****                         else
1219:../Generated_Code/tasks.c ****                         {
1220:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1221:../Generated_Code/tasks.c ****                         }
1222:../Generated_Code/tasks.c **** 
1223:../Generated_Code/tasks.c ****                         /* Is the task waiting on an event also? */
1224:../Generated_Code/tasks.c ****                         if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1009              		.loc 1 1224 0
 1010 0026 FB68     		ldr	r3, [r7, #12]
 1011 0028 9B6A     		ldr	r3, [r3, #40]
 1012 002a 002B     		cmp	r3, #0
 1013 002c 04D0     		beq	.L65
1225:../Generated_Code/tasks.c ****                         {
1226:../Generated_Code/tasks.c ****                                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1014              		.loc 1 1226 0
 1015 002e FB68     		ldr	r3, [r7, #12]
 1016 0030 1833     		add	r3, r3, #24
 1017 0032 181C     		mov	r0, r3
 1018 0034 FFF7FEFF 		bl	uxListRemove
 1019              	.L65:
1227:../Generated_Code/tasks.c ****                         }
1228:../Generated_Code/tasks.c ****                         else
1229:../Generated_Code/tasks.c ****                         {
1230:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1231:../Generated_Code/tasks.c ****                         }
1232:../Generated_Code/tasks.c **** 
1233:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1020              		.loc 1 1233 0
 1021 0038 FB68     		ldr	r3, [r7, #12]
 1022 003a 0433     		add	r3, r3, #4
 1023 003c 204A     		ldr	r2, .L72+4
 1024 003e 101C     		mov	r0, r2
 1025 0040 191C     		mov	r1, r3
 1026 0042 FFF7FEFF 		bl	vListInsertEnd
1234:../Generated_Code/tasks.c ****                 }
1235:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
 1027              		.loc 1 1235 0
 1028 0046 FFF7FEFF 		bl	vPortExitCritical
1236:../Generated_Code/tasks.c **** 
1237:../Generated_Code/tasks.c ****                 if( pxTCB == pxCurrentTCB )
 1029              		.loc 1 1237 0
 1030 004a 1C4B     		ldr	r3, .L72
 1031 004c 1B68     		ldr	r3, [r3]
 1032 004e FA68     		ldr	r2, [r7, #12]
 1033 0050 D31A     		sub	r3, r2, r3
 1034 0052 5A42     		neg	r2, r3
 1035 0054 5341     		adc	r3, r3, r2
 1036 0056 DBB2     		uxtb	r3, r3
 1037 0058 002B     		cmp	r3, #0
 1038 005a 23D0     		beq	.L66
1238:../Generated_Code/tasks.c ****                 {
1239:../Generated_Code/tasks.c ****                         if( xSchedulerRunning != pdFALSE )
 1039              		.loc 1 1239 0
 1040 005c 194B     		ldr	r3, .L72+8
 1041 005e 1B68     		ldr	r3, [r3]
 1042 0060 5A1E     		sub	r2, r3, #1
 1043 0062 9341     		sbc	r3, r3, r2
 1044 0064 DBB2     		uxtb	r3, r3
 1045 0066 002B     		cmp	r3, #0
 1046 0068 0BD0     		beq	.L67
1240:../Generated_Code/tasks.c ****                         {
1241:../Generated_Code/tasks.c ****                                 /* The current task has just been suspended. */
1242:../Generated_Code/tasks.c ****                                 configASSERT( uxSchedulerSuspended == 0 );
 1047              		.loc 1 1242 0
 1048 006a 174B     		ldr	r3, .L72+12
 1049 006c 1B68     		ldr	r3, [r3]
 1050 006e 5A1E     		sub	r2, r3, #1
 1051 0070 9341     		sbc	r3, r3, r2
 1052 0072 DBB2     		uxtb	r3, r3
 1053 0074 002B     		cmp	r3, #0
 1054 0076 01D0     		beq	.L68
 1055              		.loc 1 1242 0 is_stmt 0
 1056              	@ 1242 "../Generated_Code/tasks.c" 1
 1057 0078 72B6     		cpsid i
 1058              	@ 0 "" 2
 1059              		.code	16
 1060              	.L69:
 1061              		.loc 1 1242 0
 1062 007a FEE7     		b	.L69
 1063              	.L68:
1243:../Generated_Code/tasks.c ****                                 portYIELD_WITHIN_API();
 1064              		.loc 1 1243 0 is_stmt 1
 1065 007c FFF7FEFF 		bl	vPortYieldFromISR
 1066 0080 19E0     		b	.L62
 1067              	.L67:
1244:../Generated_Code/tasks.c ****                         }
1245:../Generated_Code/tasks.c ****                         else
1246:../Generated_Code/tasks.c ****                         {
1247:../Generated_Code/tasks.c ****                                 /* The scheduler is not running, but the task that was pointed
1248:../Generated_Code/tasks.c ****                                 to by pxCurrentTCB has just been suspended and pxCurrentTCB
1249:../Generated_Code/tasks.c ****                                 must be adjusted to point to a different task. */
1250:../Generated_Code/tasks.c ****                                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumb
 1068              		.loc 1 1250 0
 1069 0082 0F4B     		ldr	r3, .L72+4
 1070 0084 1A68     		ldr	r2, [r3]
 1071 0086 114B     		ldr	r3, .L72+16
 1072 0088 1B68     		ldr	r3, [r3]
 1073 008a D31A     		sub	r3, r2, r3
 1074 008c 5A42     		neg	r2, r3
 1075 008e 5341     		adc	r3, r3, r2
 1076 0090 DBB2     		uxtb	r3, r3
 1077 0092 002B     		cmp	r3, #0
 1078 0094 03D0     		beq	.L71
1251:../Generated_Code/tasks.c ****                                 {
1252:../Generated_Code/tasks.c ****                                         /* No other tasks are ready, so set pxCurrentTCB back to
1253:../Generated_Code/tasks.c ****                                         NULL so when the next task is created pxCurrentTCB will
1254:../Generated_Code/tasks.c ****                                         be set to point to it no matter what its relative priority
1255:../Generated_Code/tasks.c ****                                         is. */
1256:../Generated_Code/tasks.c ****                                         pxCurrentTCB = NULL;
 1079              		.loc 1 1256 0
 1080 0096 094B     		ldr	r3, .L72
 1081 0098 0022     		mov	r2, #0
 1082 009a 1A60     		str	r2, [r3]
 1083 009c 0BE0     		b	.L62
 1084              	.L71:
1257:../Generated_Code/tasks.c ****                                 }
1258:../Generated_Code/tasks.c ****                                 else
1259:../Generated_Code/tasks.c ****                                 {
1260:../Generated_Code/tasks.c ****                                         vTaskSwitchContext();
 1085              		.loc 1 1260 0
 1086 009e FFF7FEFF 		bl	vTaskSwitchContext
 1087 00a2 08E0     		b	.L62
 1088              	.L66:
1261:../Generated_Code/tasks.c ****                                 }
1262:../Generated_Code/tasks.c ****                         }
1263:../Generated_Code/tasks.c ****                 }
1264:../Generated_Code/tasks.c ****                 else
1265:../Generated_Code/tasks.c ****                 {
1266:../Generated_Code/tasks.c ****                         if( xSchedulerRunning != pdFALSE )
 1089              		.loc 1 1266 0
 1090 00a4 074B     		ldr	r3, .L72+8
 1091 00a6 1B68     		ldr	r3, [r3]
 1092 00a8 5A1E     		sub	r2, r3, #1
 1093 00aa 9341     		sbc	r3, r3, r2
 1094 00ac DBB2     		uxtb	r3, r3
 1095 00ae 002B     		cmp	r3, #0
 1096 00b0 01D0     		beq	.L62
1267:../Generated_Code/tasks.c ****                         {
1268:../Generated_Code/tasks.c ****                                 /* A task other than the currently running task was suspended,
1269:../Generated_Code/tasks.c ****                                 reset the next expected unblock time in case it referred to the
1270:../Generated_Code/tasks.c ****                                 task that is now in the Suspended state. */
1271:../Generated_Code/tasks.c ****                                 prvResetNextTaskUnblockTime();
 1097              		.loc 1 1271 0
 1098 00b2 FFF7FEFF 		bl	_ZL27prvResetNextTaskUnblockTimev
 1099              	.L62:
 1100              	.LBE10:
1272:../Generated_Code/tasks.c ****                         }
1273:../Generated_Code/tasks.c ****                         else
1274:../Generated_Code/tasks.c ****                         {
1275:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1276:../Generated_Code/tasks.c ****                         }
1277:../Generated_Code/tasks.c ****                 }
1278:../Generated_Code/tasks.c ****         }
 1101              		.loc 1 1278 0
 1102 00b6 BD46     		mov	sp, r7
 1103 00b8 04B0     		add	sp, sp, #16
 1104              		@ sp needed for prologue
 1105 00ba 80BD     		pop	{r7, pc}
 1106              	.L73:
 1107              		.align	2
 1108              	.L72:
 1109 00bc 00000000 		.word	pxCurrentTCB
 1110 00c0 00000000 		.word	_ZL18xSuspendedTaskList
 1111 00c4 00000000 		.word	_ZL17xSchedulerRunning
 1112 00c8 00000000 		.word	_ZL20uxSchedulerSuspended
 1113 00cc 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 1114              		.cfi_endproc
 1115              	.LFE14:
 1117              		.section	.text._ZL22prvTaskIsTaskSuspendedPv,"ax",%progbits
 1118              		.align	2
 1119              		.code	16
 1120              		.thumb_func
 1122              	_ZL22prvTaskIsTaskSuspendedPv:
 1123              	.LFB15:
1279:../Generated_Code/tasks.c **** 
1280:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1281:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1282:../Generated_Code/tasks.c **** 
1283:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1284:../Generated_Code/tasks.c **** 
1285:../Generated_Code/tasks.c ****         static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1286:../Generated_Code/tasks.c ****         {
 1124              		.loc 1 1286 0
 1125              		.cfi_startproc
 1126 0000 80B5     		push	{r7, lr}
 1127              	.LCFI18:
 1128              		.cfi_def_cfa_offset 8
 1129              		.cfi_offset 7, -8
 1130              		.cfi_offset 14, -4
 1131 0002 84B0     		sub	sp, sp, #16
 1132              	.LCFI19:
 1133              		.cfi_def_cfa_offset 24
 1134 0004 00AF     		add	r7, sp, #0
 1135              	.LCFI20:
 1136              		.cfi_def_cfa_register 7
 1137 0006 7860     		str	r0, [r7, #4]
 1138              	.LBB11:
1287:../Generated_Code/tasks.c ****         BaseType_t xReturn = pdFALSE;
 1139              		.loc 1 1287 0
 1140 0008 0023     		mov	r3, #0
 1141 000a FB60     		str	r3, [r7, #12]
1288:../Generated_Code/tasks.c ****         const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1142              		.loc 1 1288 0
 1143 000c 7B68     		ldr	r3, [r7, #4]
 1144 000e BB60     		str	r3, [r7, #8]
1289:../Generated_Code/tasks.c **** 
1290:../Generated_Code/tasks.c ****                 /* Accesses xPendingReadyList so must be called from a critical
1291:../Generated_Code/tasks.c ****                 section. */
1292:../Generated_Code/tasks.c **** 
1293:../Generated_Code/tasks.c ****                 /* It does not make sense to check if the calling task is suspended. */
1294:../Generated_Code/tasks.c ****                 configASSERT( xTask );
 1145              		.loc 1 1294 0
 1146 0010 7B68     		ldr	r3, [r7, #4]
 1147 0012 002B     		cmp	r3, #0
 1148 0014 01D1     		bne	.L75
 1149              		.loc 1 1294 0 is_stmt 0
 1150              	@ 1294 "../Generated_Code/tasks.c" 1
 1151 0016 72B6     		cpsid i
 1152              	@ 0 "" 2
 1153              		.code	16
 1154              	.L76:
 1155              		.loc 1 1294 0
 1156 0018 FEE7     		b	.L76
 1157              	.L75:
1295:../Generated_Code/tasks.c **** 
1296:../Generated_Code/tasks.c ****                 /* Is the task being resumed actually in the suspended list? */
1297:../Generated_Code/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) !=
 1158              		.loc 1 1297 0 is_stmt 1
 1159 001a BB68     		ldr	r3, [r7, #8]
 1160 001c 5A69     		ldr	r2, [r3, #20]
 1161 001e 0E4B     		ldr	r3, .L83
 1162 0020 9A42     		cmp	r2, r3
 1163 0022 01D1     		bne	.L77
 1164              		.loc 1 1297 0 is_stmt 0
 1165 0024 0123     		mov	r3, #1
 1166 0026 00E0     		b	.L78
 1167              	.L77:
 1168              		.loc 1 1297 0
 1169 0028 0023     		mov	r3, #0
 1170              	.L78:
 1171              		.loc 1 1297 0
 1172 002a 002B     		cmp	r3, #0
 1173 002c 0FD0     		beq	.L79
1298:../Generated_Code/tasks.c ****                 {
1299:../Generated_Code/tasks.c ****                         /* Has the task already been resumed from within an ISR? */
1300:../Generated_Code/tasks.c ****                         if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem )
 1174              		.loc 1 1300 0 is_stmt 1
 1175 002e BB68     		ldr	r3, [r7, #8]
 1176 0030 9A6A     		ldr	r2, [r3, #40]
 1177 0032 0A4B     		ldr	r3, .L83+4
 1178 0034 9A42     		cmp	r2, r3
 1179 0036 0AD0     		beq	.L79
1301:../Generated_Code/tasks.c ****                         {
1302:../Generated_Code/tasks.c ****                                 /* Is it in the suspended list because it is in the     Suspended
1303:../Generated_Code/tasks.c ****                                 state, or because is is blocked with no timeout? */
1304:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != 
 1180              		.loc 1 1304 0
 1181 0038 BB68     		ldr	r3, [r7, #8]
 1182 003a 9B6A     		ldr	r3, [r3, #40]
 1183 003c 002B     		cmp	r3, #0
 1184 003e 01D1     		bne	.L80
 1185              		.loc 1 1304 0 is_stmt 0
 1186 0040 0123     		mov	r3, #1
 1187 0042 00E0     		b	.L81
 1188              	.L80:
 1189              		.loc 1 1304 0
 1190 0044 0023     		mov	r3, #0
 1191              	.L81:
 1192              		.loc 1 1304 0
 1193 0046 002B     		cmp	r3, #0
 1194 0048 01D0     		beq	.L79
1305:../Generated_Code/tasks.c ****                                 {
1306:../Generated_Code/tasks.c ****                                         xReturn = pdTRUE;
 1195              		.loc 1 1306 0 is_stmt 1
 1196 004a 0123     		mov	r3, #1
 1197 004c FB60     		str	r3, [r7, #12]
 1198              	.L79:
1307:../Generated_Code/tasks.c ****                                 }
1308:../Generated_Code/tasks.c ****                                 else
1309:../Generated_Code/tasks.c ****                                 {
1310:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1311:../Generated_Code/tasks.c ****                                 }
1312:../Generated_Code/tasks.c ****                         }
1313:../Generated_Code/tasks.c ****                         else
1314:../Generated_Code/tasks.c ****                         {
1315:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1316:../Generated_Code/tasks.c ****                         }
1317:../Generated_Code/tasks.c ****                 }
1318:../Generated_Code/tasks.c ****                 else
1319:../Generated_Code/tasks.c ****                 {
1320:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1321:../Generated_Code/tasks.c ****                 }
1322:../Generated_Code/tasks.c **** 
1323:../Generated_Code/tasks.c ****                 return xReturn;
 1199              		.loc 1 1323 0
 1200 004e FB68     		ldr	r3, [r7, #12]
 1201              	.LBE11:
1324:../Generated_Code/tasks.c ****         } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1202              		.loc 1 1324 0
 1203 0050 181C     		mov	r0, r3
 1204 0052 BD46     		mov	sp, r7
 1205 0054 04B0     		add	sp, sp, #16
 1206              		@ sp needed for prologue
 1207 0056 80BD     		pop	{r7, pc}
 1208              	.L84:
 1209              		.align	2
 1210              	.L83:
 1211 0058 00000000 		.word	_ZL18xSuspendedTaskList
 1212 005c 00000000 		.word	_ZL17xPendingReadyList
 1213              		.cfi_endproc
 1214              	.LFE15:
 1216              		.section	.text.vTaskResume,"ax",%progbits
 1217              		.align	2
 1218              		.global	vTaskResume
 1219              		.code	16
 1220              		.thumb_func
 1222              	vTaskResume:
 1223              	.LFB16:
1325:../Generated_Code/tasks.c **** 
1326:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1327:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1328:../Generated_Code/tasks.c **** 
1329:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1330:../Generated_Code/tasks.c **** 
1331:../Generated_Code/tasks.c ****         void vTaskResume( TaskHandle_t xTaskToResume )
1332:../Generated_Code/tasks.c ****         {
 1224              		.loc 1 1332 0
 1225              		.cfi_startproc
 1226 0000 80B5     		push	{r7, lr}
 1227              	.LCFI21:
 1228              		.cfi_def_cfa_offset 8
 1229              		.cfi_offset 7, -8
 1230              		.cfi_offset 14, -4
 1231 0002 84B0     		sub	sp, sp, #16
 1232              	.LCFI22:
 1233              		.cfi_def_cfa_offset 24
 1234 0004 00AF     		add	r7, sp, #0
 1235              	.LCFI23:
 1236              		.cfi_def_cfa_register 7
 1237 0006 7860     		str	r0, [r7, #4]
 1238              	.LBB12:
1333:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1239              		.loc 1 1333 0
 1240 0008 7B68     		ldr	r3, [r7, #4]
 1241 000a FB60     		str	r3, [r7, #12]
1334:../Generated_Code/tasks.c **** 
1335:../Generated_Code/tasks.c ****                 /* It does not make sense to resume the calling task. */
1336:../Generated_Code/tasks.c ****                 configASSERT( xTaskToResume );
 1242              		.loc 1 1336 0
 1243 000c 7B68     		ldr	r3, [r7, #4]
 1244 000e 002B     		cmp	r3, #0
 1245 0010 01D1     		bne	.L86
 1246              		.loc 1 1336 0 is_stmt 0
 1247              	@ 1336 "../Generated_Code/tasks.c" 1
 1248 0012 72B6     		cpsid i
 1249              	@ 0 "" 2
 1250              		.code	16
 1251              	.L87:
 1252              		.loc 1 1336 0
 1253 0014 FEE7     		b	.L87
 1254              	.L86:
1337:../Generated_Code/tasks.c **** 
1338:../Generated_Code/tasks.c ****                 /* The parameter cannot be NULL as it is impossible to resume the
1339:../Generated_Code/tasks.c ****                 currently executing task. */
1340:../Generated_Code/tasks.c ****                 if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1255              		.loc 1 1340 0 is_stmt 1
 1256 0016 FB68     		ldr	r3, [r7, #12]
 1257 0018 002B     		cmp	r3, #0
 1258 001a 06D0     		beq	.L88
 1259              		.loc 1 1340 0 is_stmt 0
 1260 001c 244B     		ldr	r3, .L93
 1261 001e 1B68     		ldr	r3, [r3]
 1262 0020 FA68     		ldr	r2, [r7, #12]
 1263 0022 9A42     		cmp	r2, r3
 1264 0024 01D0     		beq	.L88
 1265              		.loc 1 1340 0
 1266 0026 0123     		mov	r3, #1
 1267 0028 00E0     		b	.L89
 1268              	.L88:
 1269              		.loc 1 1340 0
 1270 002a 0023     		mov	r3, #0
 1271              	.L89:
 1272              		.loc 1 1340 0
 1273 002c 002B     		cmp	r3, #0
 1274 002e 3CD0     		beq	.L85
1341:../Generated_Code/tasks.c ****                 {
1342:../Generated_Code/tasks.c ****                         taskENTER_CRITICAL();
 1275              		.loc 1 1342 0 is_stmt 1
 1276 0030 FFF7FEFF 		bl	vPortEnterCritical
1343:../Generated_Code/tasks.c ****                         {
1344:../Generated_Code/tasks.c ****                                 if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1277              		.loc 1 1344 0
 1278 0034 FB68     		ldr	r3, [r7, #12]
 1279 0036 181C     		mov	r0, r3
 1280 0038 FFF7FEFF 		bl	_ZL22prvTaskIsTaskSuspendedPv
 1281 003c 031C     		mov	r3, r0
 1282 003e 013B     		sub	r3, r3, #1
 1283 0040 5A42     		neg	r2, r3
 1284 0042 5341     		adc	r3, r3, r2
 1285 0044 DBB2     		uxtb	r3, r3
 1286 0046 002B     		cmp	r3, #0
 1287 0048 2DD0     		beq	.L91
1345:../Generated_Code/tasks.c ****                                 {
1346:../Generated_Code/tasks.c ****                                         traceTASK_RESUME( pxTCB );
1347:../Generated_Code/tasks.c **** 
1348:../Generated_Code/tasks.c ****                                         /* As we are in a critical section we can access the ready
1349:../Generated_Code/tasks.c ****                                         lists even if the scheduler is suspended. */
1350:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1288              		.loc 1 1350 0
 1289 004a FB68     		ldr	r3, [r7, #12]
 1290 004c 0433     		add	r3, r3, #4
 1291 004e 181C     		mov	r0, r3
 1292 0050 FFF7FEFF 		bl	uxListRemove
1351:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1293              		.loc 1 1351 0
 1294 0054 FB68     		ldr	r3, [r7, #12]
 1295 0056 DA6A     		ldr	r2, [r3, #44]
 1296 0058 164B     		ldr	r3, .L93+4
 1297 005a 1B68     		ldr	r3, [r3]
 1298 005c 9342     		cmp	r3, r2
 1299 005e 9B41     		sbc	r3, r3, r3
 1300 0060 5B42     		neg	r3, r3
 1301 0062 DBB2     		uxtb	r3, r3
 1302 0064 002B     		cmp	r3, #0
 1303 0066 03D0     		beq	.L92
 1304              		.loc 1 1351 0 is_stmt 0
 1305 0068 FB68     		ldr	r3, [r7, #12]
 1306 006a DA6A     		ldr	r2, [r3, #44]
 1307 006c 114B     		ldr	r3, .L93+4
 1308 006e 1A60     		str	r2, [r3]
 1309              	.L92:
 1310              		.loc 1 1351 0
 1311 0070 FB68     		ldr	r3, [r7, #12]
 1312 0072 DA6A     		ldr	r2, [r3, #44]
 1313 0074 131C     		mov	r3, r2
 1314 0076 9B00     		lsl	r3, r3, #2
 1315 0078 9B18     		add	r3, r3, r2
 1316 007a 9B00     		lsl	r3, r3, #2
 1317 007c 0E4A     		ldr	r2, .L93+8
 1318 007e 9A18     		add	r2, r3, r2
 1319 0080 FB68     		ldr	r3, [r7, #12]
 1320 0082 0433     		add	r3, r3, #4
 1321 0084 101C     		mov	r0, r2
 1322 0086 191C     		mov	r1, r3
 1323 0088 FFF7FEFF 		bl	vListInsertEnd
1352:../Generated_Code/tasks.c **** 
1353:../Generated_Code/tasks.c ****                                         /* We may have just resumed a higher priority task. */
1354:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1324              		.loc 1 1354 0 is_stmt 1
 1325 008c FB68     		ldr	r3, [r7, #12]
 1326 008e D96A     		ldr	r1, [r3, #44]
 1327 0090 074B     		ldr	r3, .L93
 1328 0092 1B68     		ldr	r3, [r3]
 1329 0094 DA6A     		ldr	r2, [r3, #44]
 1330 0096 0023     		mov	r3, #0
 1331 0098 9142     		cmp	r1, r2
 1332 009a 5B41     		adc	r3, r3, r3
 1333 009c DBB2     		uxtb	r3, r3
 1334 009e 002B     		cmp	r3, #0
 1335 00a0 01D0     		beq	.L91
1355:../Generated_Code/tasks.c ****                                         {
1356:../Generated_Code/tasks.c ****                                                 /* This yield may not cause the task just resumed t
1357:../Generated_Code/tasks.c ****                                                 but will leave the lists in the correct state for t
1358:../Generated_Code/tasks.c ****                                                 next yield. */
1359:../Generated_Code/tasks.c ****                                                 taskYIELD_IF_USING_PREEMPTION();
 1336              		.loc 1 1359 0
 1337 00a2 FFF7FEFF 		bl	vPortYieldFromISR
 1338              	.L91:
1360:../Generated_Code/tasks.c ****                                         }
1361:../Generated_Code/tasks.c ****                                         else
1362:../Generated_Code/tasks.c ****                                         {
1363:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1364:../Generated_Code/tasks.c ****                                         }
1365:../Generated_Code/tasks.c ****                                 }
1366:../Generated_Code/tasks.c ****                                 else
1367:../Generated_Code/tasks.c ****                                 {
1368:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1369:../Generated_Code/tasks.c ****                                 }
1370:../Generated_Code/tasks.c ****                         }
1371:../Generated_Code/tasks.c ****                         taskEXIT_CRITICAL();
 1339              		.loc 1 1371 0
 1340 00a6 FFF7FEFF 		bl	vPortExitCritical
 1341              	.L85:
 1342              	.LBE12:
1372:../Generated_Code/tasks.c ****                 }
1373:../Generated_Code/tasks.c ****                 else
1374:../Generated_Code/tasks.c ****                 {
1375:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1376:../Generated_Code/tasks.c ****                 }
1377:../Generated_Code/tasks.c ****         }
 1343              		.loc 1 1377 0
 1344 00aa BD46     		mov	sp, r7
 1345 00ac 04B0     		add	sp, sp, #16
 1346              		@ sp needed for prologue
 1347 00ae 80BD     		pop	{r7, pc}
 1348              	.L94:
 1349              		.align	2
 1350              	.L93:
 1351 00b0 00000000 		.word	pxCurrentTCB
 1352 00b4 00000000 		.word	_ZL18uxTopReadyPriority
 1353 00b8 00000000 		.word	_ZL17pxReadyTasksLists
 1354              		.cfi_endproc
 1355              	.LFE16:
 1357              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1358              		.align	2
 1359              		.global	xTaskResumeFromISR
 1360              		.code	16
 1361              		.thumb_func
 1363              	xTaskResumeFromISR:
 1364              	.LFB17:
1378:../Generated_Code/tasks.c **** 
1379:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1380:../Generated_Code/tasks.c **** 
1381:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1382:../Generated_Code/tasks.c **** 
1383:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1384:../Generated_Code/tasks.c **** 
1385:../Generated_Code/tasks.c ****         BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1386:../Generated_Code/tasks.c ****         {
 1365              		.loc 1 1386 0
 1366              		.cfi_startproc
 1367 0000 80B5     		push	{r7, lr}
 1368              	.LCFI24:
 1369              		.cfi_def_cfa_offset 8
 1370              		.cfi_offset 7, -8
 1371              		.cfi_offset 14, -4
 1372 0002 86B0     		sub	sp, sp, #24
 1373              	.LCFI25:
 1374              		.cfi_def_cfa_offset 32
 1375 0004 00AF     		add	r7, sp, #0
 1376              	.LCFI26:
 1377              		.cfi_def_cfa_register 7
 1378 0006 7860     		str	r0, [r7, #4]
 1379              	.LBB13:
1387:../Generated_Code/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 1380              		.loc 1 1387 0
 1381 0008 0023     		mov	r3, #0
 1382 000a 7B61     		str	r3, [r7, #20]
1388:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1383              		.loc 1 1388 0
 1384 000c 7B68     		ldr	r3, [r7, #4]
 1385 000e 3B61     		str	r3, [r7, #16]
1389:../Generated_Code/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
1390:../Generated_Code/tasks.c **** 
1391:../Generated_Code/tasks.c ****                 configASSERT( xTaskToResume );
 1386              		.loc 1 1391 0
 1387 0010 7B68     		ldr	r3, [r7, #4]
 1388 0012 002B     		cmp	r3, #0
 1389 0014 01D1     		bne	.L96
 1390              		.loc 1 1391 0 is_stmt 0
 1391              	@ 1391 "../Generated_Code/tasks.c" 1
 1392 0016 72B6     		cpsid i
 1393              	@ 0 "" 2
 1394              		.code	16
 1395              	.L97:
 1396              		.loc 1 1391 0
 1397 0018 FEE7     		b	.L97
 1398              	.L96:
1392:../Generated_Code/tasks.c **** 
1393:../Generated_Code/tasks.c ****                 /* RTOS ports that support interrupt nesting have the concept of a
1394:../Generated_Code/tasks.c ****                 maximum system call (or maximum API call) interrupt priority.
1395:../Generated_Code/tasks.c ****                 Interrupts that are     above the maximum system call priority are keep
1396:../Generated_Code/tasks.c ****                 permanently enabled, even when the RTOS kernel is in a critical section,
1397:../Generated_Code/tasks.c ****                 but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1398:../Generated_Code/tasks.c ****                 is defined in FreeRTOSConfig.h then
1399:../Generated_Code/tasks.c ****                 portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1400:../Generated_Code/tasks.c ****                 failure if a FreeRTOS API function is called from an interrupt that has
1401:../Generated_Code/tasks.c ****                 been assigned a priority above the configured maximum system call
1402:../Generated_Code/tasks.c ****                 priority.  Only FreeRTOS functions that end in FromISR can be called
1403:../Generated_Code/tasks.c ****                 from interrupts that have been assigned a priority at or (logically)
1404:../Generated_Code/tasks.c ****                 below the maximum system call interrupt priority.  FreeRTOS maintains a
1405:../Generated_Code/tasks.c ****                 separate interrupt safe API to ensure interrupt entry is as fast and as
1406:../Generated_Code/tasks.c ****                 simple as possible.  More information (albeit Cortex-M specific) is
1407:../Generated_Code/tasks.c ****                 provided on the following link:
1408:../Generated_Code/tasks.c ****                 http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1409:../Generated_Code/tasks.c ****                 portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1410:../Generated_Code/tasks.c **** 
1411:../Generated_Code/tasks.c ****                 uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1399              		.loc 1 1411 0 is_stmt 1
 1400 001a 0023     		mov	r3, #0
 1401 001c FB60     		str	r3, [r7, #12]
 1402              	@ 1411 "../Generated_Code/tasks.c" 1
 1403 001e 72B6     		cpsid i
 1404              	@ 0 "" 2
1412:../Generated_Code/tasks.c ****                 {
1413:../Generated_Code/tasks.c ****                         if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1405              		.loc 1 1413 0
 1406              		.code	16
 1407 0020 3B69     		ldr	r3, [r7, #16]
 1408 0022 181C     		mov	r0, r3
 1409 0024 FFF7FEFF 		bl	_ZL22prvTaskIsTaskSuspendedPv
 1410 0028 031C     		mov	r3, r0
 1411 002a 013B     		sub	r3, r3, #1
 1412 002c 5A42     		neg	r2, r3
 1413 002e 5341     		adc	r3, r3, r2
 1414 0030 DBB2     		uxtb	r3, r3
 1415 0032 002B     		cmp	r3, #0
 1416 0034 3CD0     		beq	.L98
1414:../Generated_Code/tasks.c ****                         {
1415:../Generated_Code/tasks.c ****                                 traceTASK_RESUME_FROM_ISR( pxTCB );
1416:../Generated_Code/tasks.c **** 
1417:../Generated_Code/tasks.c ****                                 /* Check the ready lists can be accessed. */
1418:../Generated_Code/tasks.c ****                                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1417              		.loc 1 1418 0
 1418 0036 214B     		ldr	r3, .L103
 1419 0038 1B68     		ldr	r3, [r3]
 1420 003a 5A42     		neg	r2, r3
 1421 003c 5341     		adc	r3, r3, r2
 1422 003e DBB2     		uxtb	r3, r3
 1423 0040 002B     		cmp	r3, #0
 1424 0042 2ED0     		beq	.L99
1419:../Generated_Code/tasks.c ****                                 {
1420:../Generated_Code/tasks.c ****                                         /* Ready lists can be accessed so move the task from the
1421:../Generated_Code/tasks.c ****                                         suspended list to the ready list directly. */
1422:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1425              		.loc 1 1422 0
 1426 0044 3B69     		ldr	r3, [r7, #16]
 1427 0046 D96A     		ldr	r1, [r3, #44]
 1428 0048 1D4B     		ldr	r3, .L103+4
 1429 004a 1B68     		ldr	r3, [r3]
 1430 004c DA6A     		ldr	r2, [r3, #44]
 1431 004e 0023     		mov	r3, #0
 1432 0050 9142     		cmp	r1, r2
 1433 0052 5B41     		adc	r3, r3, r3
 1434 0054 DBB2     		uxtb	r3, r3
 1435 0056 002B     		cmp	r3, #0
 1436 0058 01D0     		beq	.L100
1423:../Generated_Code/tasks.c ****                                         {
1424:../Generated_Code/tasks.c ****                                                 xYieldRequired = pdTRUE;
 1437              		.loc 1 1424 0
 1438 005a 0123     		mov	r3, #1
 1439 005c 7B61     		str	r3, [r7, #20]
 1440              	.L100:
1425:../Generated_Code/tasks.c ****                                         }
1426:../Generated_Code/tasks.c ****                                         else
1427:../Generated_Code/tasks.c ****                                         {
1428:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1429:../Generated_Code/tasks.c ****                                         }
1430:../Generated_Code/tasks.c **** 
1431:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1441              		.loc 1 1431 0
 1442 005e 3B69     		ldr	r3, [r7, #16]
 1443 0060 0433     		add	r3, r3, #4
 1444 0062 181C     		mov	r0, r3
 1445 0064 FFF7FEFF 		bl	uxListRemove
1432:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1446              		.loc 1 1432 0
 1447 0068 3B69     		ldr	r3, [r7, #16]
 1448 006a DA6A     		ldr	r2, [r3, #44]
 1449 006c 154B     		ldr	r3, .L103+8
 1450 006e 1B68     		ldr	r3, [r3]
 1451 0070 9342     		cmp	r3, r2
 1452 0072 9B41     		sbc	r3, r3, r3
 1453 0074 5B42     		neg	r3, r3
 1454 0076 DBB2     		uxtb	r3, r3
 1455 0078 002B     		cmp	r3, #0
 1456 007a 03D0     		beq	.L101
 1457              		.loc 1 1432 0 is_stmt 0
 1458 007c 3B69     		ldr	r3, [r7, #16]
 1459 007e DA6A     		ldr	r2, [r3, #44]
 1460 0080 104B     		ldr	r3, .L103+8
 1461 0082 1A60     		str	r2, [r3]
 1462              	.L101:
 1463              		.loc 1 1432 0
 1464 0084 3B69     		ldr	r3, [r7, #16]
 1465 0086 DA6A     		ldr	r2, [r3, #44]
 1466 0088 131C     		mov	r3, r2
 1467 008a 9B00     		lsl	r3, r3, #2
 1468 008c 9B18     		add	r3, r3, r2
 1469 008e 9B00     		lsl	r3, r3, #2
 1470 0090 0D4A     		ldr	r2, .L103+12
 1471 0092 9A18     		add	r2, r3, r2
 1472 0094 3B69     		ldr	r3, [r7, #16]
 1473 0096 0433     		add	r3, r3, #4
 1474 0098 101C     		mov	r0, r2
 1475 009a 191C     		mov	r1, r3
 1476 009c FFF7FEFF 		bl	vListInsertEnd
 1477 00a0 06E0     		b	.L98
 1478              	.L99:
1433:../Generated_Code/tasks.c ****                                 }
1434:../Generated_Code/tasks.c ****                                 else
1435:../Generated_Code/tasks.c ****                                 {
1436:../Generated_Code/tasks.c ****                                         /* The delayed or ready lists cannot be accessed so the tas
1437:../Generated_Code/tasks.c ****                                         is held in the pending ready list until the scheduler is
1438:../Generated_Code/tasks.c ****                                         unsuspended. */
1439:../Generated_Code/tasks.c ****                                         vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventLis
 1479              		.loc 1 1439 0 is_stmt 1
 1480 00a2 3B69     		ldr	r3, [r7, #16]
 1481 00a4 1833     		add	r3, r3, #24
 1482 00a6 094A     		ldr	r2, .L103+16
 1483 00a8 101C     		mov	r0, r2
 1484 00aa 191C     		mov	r1, r3
 1485 00ac FFF7FEFF 		bl	vListInsertEnd
 1486              	.L98:
1440:../Generated_Code/tasks.c ****                                 }
1441:../Generated_Code/tasks.c ****                         }
1442:../Generated_Code/tasks.c ****                         else
1443:../Generated_Code/tasks.c ****                         {
1444:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1445:../Generated_Code/tasks.c ****                         }
1446:../Generated_Code/tasks.c ****                 }
1447:../Generated_Code/tasks.c ****                 portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1487              		.loc 1 1447 0
 1488              	@ 1447 "../Generated_Code/tasks.c" 1
 1489 00b0 62B6     		cpsie i
 1490              	@ 0 "" 2
1448:../Generated_Code/tasks.c **** 
1449:../Generated_Code/tasks.c ****                 return xYieldRequired;
 1491              		.loc 1 1449 0
 1492              		.code	16
 1493 00b2 7B69     		ldr	r3, [r7, #20]
 1494              	.LBE13:
1450:../Generated_Code/tasks.c ****         }
 1495              		.loc 1 1450 0
 1496 00b4 181C     		mov	r0, r3
 1497 00b6 BD46     		mov	sp, r7
 1498 00b8 06B0     		add	sp, sp, #24
 1499              		@ sp needed for prologue
 1500 00ba 80BD     		pop	{r7, pc}
 1501              	.L104:
 1502              		.align	2
 1503              	.L103:
 1504 00bc 00000000 		.word	_ZL20uxSchedulerSuspended
 1505 00c0 00000000 		.word	pxCurrentTCB
 1506 00c4 00000000 		.word	_ZL18uxTopReadyPriority
 1507 00c8 00000000 		.word	_ZL17pxReadyTasksLists
 1508 00cc 00000000 		.word	_ZL17xPendingReadyList
 1509              		.cfi_endproc
 1510              	.LFE17:
 1512              		.section	.rodata
 1513              		.align	2
 1514              	.LC32:
 1515 0000 49444C45 		.ascii	"IDLE\000"
 1515      00
 1516 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1517              		.align	2
 1518              		.global	vTaskStartScheduler
 1519              		.code	16
 1520              		.thumb_func
 1522              	vTaskStartScheduler:
 1523              	.LFB18:
1451:../Generated_Code/tasks.c **** 
1452:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1453:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1454:../Generated_Code/tasks.c **** 
1455:../Generated_Code/tasks.c **** void vTaskStartScheduler( void )
1456:../Generated_Code/tasks.c **** {
 1524              		.loc 1 1456 0
 1525              		.cfi_startproc
 1526 0000 80B5     		push	{r7, lr}
 1527              	.LCFI27:
 1528              		.cfi_def_cfa_offset 8
 1529              		.cfi_offset 7, -8
 1530              		.cfi_offset 14, -4
 1531 0002 86B0     		sub	sp, sp, #24
 1532              	.LCFI28:
 1533              		.cfi_def_cfa_offset 32
 1534 0004 04AF     		add	r7, sp, #16
 1535              	.LCFI29:
 1536              		.cfi_def_cfa 7, 16
 1537              	.LBB14:
1457:../Generated_Code/tasks.c **** BaseType_t xReturn;
1458:../Generated_Code/tasks.c **** 
1459:../Generated_Code/tasks.c ****         /* Add the idle task at the lowest priority. */
1460:../Generated_Code/tasks.c ****         #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1461:../Generated_Code/tasks.c ****         {
1462:../Generated_Code/tasks.c ****                 /* Create the idle task, storing its handle in xIdleTaskHandle so it can
1463:../Generated_Code/tasks.c ****                 be returned by the xTaskGetIdleTaskHandle() function. */
1464:../Generated_Code/tasks.c ****                 xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( 
1465:../Generated_Code/tasks.c ****         }
1466:../Generated_Code/tasks.c ****         #else
1467:../Generated_Code/tasks.c ****         {
1468:../Generated_Code/tasks.c ****                 /* Create the idle task without storing its handle. */
1469:../Generated_Code/tasks.c ****                 xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( 
 1538              		.loc 1 1469 0
 1539 0006 134A     		ldr	r2, .L109
 1540 0008 134B     		ldr	r3, .L109+4
 1541 000a 0021     		mov	r1, #0
 1542 000c 0091     		str	r1, [sp]
 1543 000e 0021     		mov	r1, #0
 1544 0010 0191     		str	r1, [sp, #4]
 1545 0012 0021     		mov	r1, #0
 1546 0014 0291     		str	r1, [sp, #8]
 1547 0016 0021     		mov	r1, #0
 1548 0018 0391     		str	r1, [sp, #12]
 1549 001a 101C     		mov	r0, r2
 1550 001c 191C     		mov	r1, r3
 1551 001e C822     		mov	r2, #200
 1552 0020 0023     		mov	r3, #0
 1553 0022 FFF7FEFF 		bl	xTaskGenericCreate
 1554 0026 031C     		mov	r3, r0
 1555 0028 7B60     		str	r3, [r7, #4]
1470:../Generated_Code/tasks.c ****         }
1471:../Generated_Code/tasks.c ****         #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1472:../Generated_Code/tasks.c **** 
1473:../Generated_Code/tasks.c ****         #if ( configUSE_TIMERS == 1 )
1474:../Generated_Code/tasks.c ****         {
1475:../Generated_Code/tasks.c ****                 if( xReturn == pdPASS )
1476:../Generated_Code/tasks.c ****                 {
1477:../Generated_Code/tasks.c ****                         xReturn = xTimerCreateTimerTask();
1478:../Generated_Code/tasks.c ****                 }
1479:../Generated_Code/tasks.c ****                 else
1480:../Generated_Code/tasks.c ****                 {
1481:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1482:../Generated_Code/tasks.c ****                 }
1483:../Generated_Code/tasks.c ****         }
1484:../Generated_Code/tasks.c ****         #endif /* configUSE_TIMERS */
1485:../Generated_Code/tasks.c **** 
1486:../Generated_Code/tasks.c ****         if( xReturn == pdPASS )
 1556              		.loc 1 1486 0
 1557 002a 7B68     		ldr	r3, [r7, #4]
 1558 002c 012B     		cmp	r3, #1
 1559 002e 09D1     		bne	.L106
1487:../Generated_Code/tasks.c ****         {
1488:../Generated_Code/tasks.c ****                 /* Interrupts are turned off here, to ensure a tick does not occur
1489:../Generated_Code/tasks.c ****                 before or during the call to xPortStartScheduler().  The stacks of
1490:../Generated_Code/tasks.c ****                 the created tasks contain a status word with interrupts switched on
1491:../Generated_Code/tasks.c ****                 so interrupts will automatically get re-enabled when the first task
1492:../Generated_Code/tasks.c ****                 starts to run. */
1493:../Generated_Code/tasks.c ****                 portDISABLE_INTERRUPTS();
 1560              		.loc 1 1493 0
 1561              	@ 1493 "../Generated_Code/tasks.c" 1
 1562 0030 72B6     		cpsid i
 1563              	@ 0 "" 2
1494:../Generated_Code/tasks.c **** 
1495:../Generated_Code/tasks.c ****                 #if ( configUSE_NEWLIB_REENTRANT == 1 )
1496:../Generated_Code/tasks.c ****                 {
1497:../Generated_Code/tasks.c ****                         /* Switch Newlib's _impure_ptr variable to point to the _reent
1498:../Generated_Code/tasks.c ****                         structure specific to the task that will run first. */
1499:../Generated_Code/tasks.c ****                         _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1500:../Generated_Code/tasks.c ****                 }
1501:../Generated_Code/tasks.c ****                 #endif /* configUSE_NEWLIB_REENTRANT */
1502:../Generated_Code/tasks.c **** 
1503:../Generated_Code/tasks.c ****                 xSchedulerRunning = pdTRUE;
 1564              		.loc 1 1503 0
 1565              		.code	16
 1566 0032 0A4B     		ldr	r3, .L109+8
 1567 0034 0122     		mov	r2, #1
 1568 0036 1A60     		str	r2, [r3]
1504:../Generated_Code/tasks.c ****                 xTickCount = ( TickType_t ) 0U;
 1569              		.loc 1 1504 0
 1570 0038 094B     		ldr	r3, .L109+12
 1571 003a 0022     		mov	r2, #0
 1572 003c 1A60     		str	r2, [r3]
1505:../Generated_Code/tasks.c **** 
1506:../Generated_Code/tasks.c ****                 /* If configGENERATE_RUN_TIME_STATS is defined then the following
1507:../Generated_Code/tasks.c ****                 macro must be defined to configure the timer/counter used to generate
1508:../Generated_Code/tasks.c ****                 the run time counter time base. */
1509:../Generated_Code/tasks.c ****                 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1510:../Generated_Code/tasks.c **** 
1511:../Generated_Code/tasks.c ****                 /* Setting up the timer tick is hardware specific and thus in the
1512:../Generated_Code/tasks.c ****                 portable interface. */
1513:../Generated_Code/tasks.c ****                 if( xPortStartScheduler() != pdFALSE )
 1573              		.loc 1 1513 0
 1574 003e FFF7FEFF 		bl	xPortStartScheduler
 1575 0042 04E0     		b	.L105
 1576              	.L106:
1514:../Generated_Code/tasks.c ****                 {
1515:../Generated_Code/tasks.c ****                         /* Should not reach here as if the scheduler is running the
1516:../Generated_Code/tasks.c ****                         function will not return. */
1517:../Generated_Code/tasks.c ****                 }
1518:../Generated_Code/tasks.c ****                 else
1519:../Generated_Code/tasks.c ****                 {
1520:../Generated_Code/tasks.c ****                         /* Should only reach here if a task calls xTaskEndScheduler(). */
1521:../Generated_Code/tasks.c ****                 }
1522:../Generated_Code/tasks.c ****         }
1523:../Generated_Code/tasks.c ****         else
1524:../Generated_Code/tasks.c ****         {
1525:../Generated_Code/tasks.c ****                 /* This line will only be reached if the kernel could not be started,
1526:../Generated_Code/tasks.c ****                 because there was not enough FreeRTOS heap to create the idle task
1527:../Generated_Code/tasks.c ****                 or the timer task. */
1528:../Generated_Code/tasks.c ****                 configASSERT( xReturn );
 1577              		.loc 1 1528 0
 1578 0044 7B68     		ldr	r3, [r7, #4]
 1579 0046 002B     		cmp	r3, #0
 1580 0048 01D1     		bne	.L105
 1581              		.loc 1 1528 0 is_stmt 0
 1582              	@ 1528 "../Generated_Code/tasks.c" 1
 1583 004a 72B6     		cpsid i
 1584              	@ 0 "" 2
 1585              		.code	16
 1586              	.L108:
 1587              		.loc 1 1528 0
 1588 004c FEE7     		b	.L108
 1589              	.L105:
 1590              	.LBE14:
1529:../Generated_Code/tasks.c ****         }
1530:../Generated_Code/tasks.c **** }
 1591              		.loc 1 1530 0 is_stmt 1
 1592 004e BD46     		mov	sp, r7
 1593 0050 02B0     		add	sp, sp, #8
 1594              		@ sp needed for prologue
 1595 0052 80BD     		pop	{r7, pc}
 1596              	.L110:
 1597              		.align	2
 1598              	.L109:
 1599 0054 00000000 		.word	_ZL11prvIdleTaskPv
 1600 0058 00000000 		.word	.LC32
 1601 005c 00000000 		.word	_ZL17xSchedulerRunning
 1602 0060 00000000 		.word	_ZL10xTickCount
 1603              		.cfi_endproc
 1604              	.LFE18:
 1606              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1607              		.align	2
 1608              		.global	vTaskEndScheduler
 1609              		.code	16
 1610              		.thumb_func
 1612              	vTaskEndScheduler:
 1613              	.LFB19:
1531:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1532:../Generated_Code/tasks.c **** 
1533:../Generated_Code/tasks.c **** void vTaskEndScheduler( void )
1534:../Generated_Code/tasks.c **** {
 1614              		.loc 1 1534 0
 1615              		.cfi_startproc
 1616 0000 80B5     		push	{r7, lr}
 1617              	.LCFI30:
 1618              		.cfi_def_cfa_offset 8
 1619              		.cfi_offset 7, -8
 1620              		.cfi_offset 14, -4
 1621 0002 00AF     		add	r7, sp, #0
 1622              	.LCFI31:
 1623              		.cfi_def_cfa_register 7
1535:../Generated_Code/tasks.c ****         /* Stop the scheduler interrupts and call the portable scheduler end
1536:../Generated_Code/tasks.c ****         routine so the original ISRs can be restored if necessary.  The port
1537:../Generated_Code/tasks.c ****         layer must ensure interrupts enable     bit is left in the correct state. */
1538:../Generated_Code/tasks.c ****         portDISABLE_INTERRUPTS();
 1624              		.loc 1 1538 0
 1625              	@ 1538 "../Generated_Code/tasks.c" 1
 1626 0004 72B6     		cpsid i
 1627              	@ 0 "" 2
1539:../Generated_Code/tasks.c ****         xSchedulerRunning = pdFALSE;
 1628              		.loc 1 1539 0
 1629              		.code	16
 1630 0006 034B     		ldr	r3, .L112
 1631 0008 0022     		mov	r2, #0
 1632 000a 1A60     		str	r2, [r3]
1540:../Generated_Code/tasks.c ****         vPortEndScheduler();
 1633              		.loc 1 1540 0
 1634 000c FFF7FEFF 		bl	vPortEndScheduler
1541:../Generated_Code/tasks.c **** }
 1635              		.loc 1 1541 0
 1636 0010 BD46     		mov	sp, r7
 1637              		@ sp needed for prologue
 1638 0012 80BD     		pop	{r7, pc}
 1639              	.L113:
 1640              		.align	2
 1641              	.L112:
 1642 0014 00000000 		.word	_ZL17xSchedulerRunning
 1643              		.cfi_endproc
 1644              	.LFE19:
 1646              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1647              		.align	2
 1648              		.global	vTaskSuspendAll
 1649              		.code	16
 1650              		.thumb_func
 1652              	vTaskSuspendAll:
 1653              	.LFB20:
1542:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1543:../Generated_Code/tasks.c **** 
1544:../Generated_Code/tasks.c **** void vTaskSuspendAll( void )
1545:../Generated_Code/tasks.c **** {
 1654              		.loc 1 1545 0
 1655              		.cfi_startproc
 1656 0000 80B5     		push	{r7, lr}
 1657              	.LCFI32:
 1658              		.cfi_def_cfa_offset 8
 1659              		.cfi_offset 7, -8
 1660              		.cfi_offset 14, -4
 1661 0002 00AF     		add	r7, sp, #0
 1662              	.LCFI33:
 1663              		.cfi_def_cfa_register 7
1546:../Generated_Code/tasks.c ****         /* A critical section is not required as the variable is of type
1547:../Generated_Code/tasks.c ****         BaseType_t.  Please read Richard Barry's reply in the following link to a
1548:../Generated_Code/tasks.c ****         post in the FreeRTOS support forum before reporting this as a bug! -
1549:../Generated_Code/tasks.c ****         http://goo.gl/wu4acr */
1550:../Generated_Code/tasks.c ****         ++uxSchedulerSuspended;
 1664              		.loc 1 1550 0
 1665 0004 034B     		ldr	r3, .L115
 1666 0006 1B68     		ldr	r3, [r3]
 1667 0008 5A1C     		add	r2, r3, #1
 1668 000a 024B     		ldr	r3, .L115
 1669 000c 1A60     		str	r2, [r3]
1551:../Generated_Code/tasks.c **** }
 1670              		.loc 1 1551 0
 1671 000e BD46     		mov	sp, r7
 1672              		@ sp needed for prologue
 1673 0010 80BD     		pop	{r7, pc}
 1674              	.L116:
 1675 0012 C046     		.align	2
 1676              	.L115:
 1677 0014 00000000 		.word	_ZL20uxSchedulerSuspended
 1678              		.cfi_endproc
 1679              	.LFE20:
 1681              		.section	.text.xTaskResumeAll,"ax",%progbits
 1682              		.align	2
 1683              		.global	xTaskResumeAll
 1684              		.code	16
 1685              		.thumb_func
 1687              	xTaskResumeAll:
 1688              	.LFB21:
1552:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1553:../Generated_Code/tasks.c **** 
1554:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1555:../Generated_Code/tasks.c **** 
1556:../Generated_Code/tasks.c ****         static TickType_t prvGetExpectedIdleTime( void )
1557:../Generated_Code/tasks.c ****         {
1558:../Generated_Code/tasks.c ****         TickType_t xReturn;
1559:../Generated_Code/tasks.c **** 
1560:../Generated_Code/tasks.c ****                 if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1561:../Generated_Code/tasks.c ****                 {
1562:../Generated_Code/tasks.c ****                         xReturn = 0;
1563:../Generated_Code/tasks.c ****                 }
1564:../Generated_Code/tasks.c ****                 else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 
1565:../Generated_Code/tasks.c ****                 {
1566:../Generated_Code/tasks.c ****                         /* There are other idle priority tasks in the ready state.  If
1567:../Generated_Code/tasks.c ****                         time slicing is used then the very next tick interrupt must be
1568:../Generated_Code/tasks.c ****                         processed. */
1569:../Generated_Code/tasks.c ****                         xReturn = 0;
1570:../Generated_Code/tasks.c ****                 }
1571:../Generated_Code/tasks.c ****                 else
1572:../Generated_Code/tasks.c ****                 {
1573:../Generated_Code/tasks.c ****                         xReturn = xNextTaskUnblockTime - xTickCount;
1574:../Generated_Code/tasks.c ****                 }
1575:../Generated_Code/tasks.c **** 
1576:../Generated_Code/tasks.c ****                 return xReturn;
1577:../Generated_Code/tasks.c ****         }
1578:../Generated_Code/tasks.c **** 
1579:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1580:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1581:../Generated_Code/tasks.c **** 
1582:../Generated_Code/tasks.c **** BaseType_t xTaskResumeAll( void )
1583:../Generated_Code/tasks.c **** {
 1689              		.loc 1 1583 0
 1690              		.cfi_startproc
 1691 0000 80B5     		push	{r7, lr}
 1692              	.LCFI34:
 1693              		.cfi_def_cfa_offset 8
 1694              		.cfi_offset 7, -8
 1695              		.cfi_offset 14, -4
 1696 0002 82B0     		sub	sp, sp, #8
 1697              	.LCFI35:
 1698              		.cfi_def_cfa_offset 16
 1699 0004 00AF     		add	r7, sp, #0
 1700              	.LCFI36:
 1701              		.cfi_def_cfa_register 7
 1702              	.LBB15:
1584:../Generated_Code/tasks.c **** TCB_t *pxTCB;
1585:../Generated_Code/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1703              		.loc 1 1585 0
 1704 0006 0023     		mov	r3, #0
 1705 0008 7B60     		str	r3, [r7, #4]
1586:../Generated_Code/tasks.c **** 
1587:../Generated_Code/tasks.c ****         /* If uxSchedulerSuspended is zero then this function does not match a
1588:../Generated_Code/tasks.c ****         previous call to vTaskSuspendAll(). */
1589:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended );
 1706              		.loc 1 1589 0
 1707 000a 484B     		ldr	r3, .L129
 1708 000c 1B68     		ldr	r3, [r3]
 1709 000e 5A42     		neg	r2, r3
 1710 0010 5341     		adc	r3, r3, r2
 1711 0012 DBB2     		uxtb	r3, r3
 1712 0014 002B     		cmp	r3, #0
 1713 0016 01D0     		beq	.L118
 1714              		.loc 1 1589 0 is_stmt 0
 1715              	@ 1589 "../Generated_Code/tasks.c" 1
 1716 0018 72B6     		cpsid i
 1717              	@ 0 "" 2
 1718              		.code	16
 1719              	.L119:
 1720              		.loc 1 1589 0
 1721 001a FEE7     		b	.L119
 1722              	.L118:
1590:../Generated_Code/tasks.c **** 
1591:../Generated_Code/tasks.c ****         /* It is possible that an ISR caused a task to be removed from an event
1592:../Generated_Code/tasks.c ****         list while the scheduler was suspended.  If this was the case then the
1593:../Generated_Code/tasks.c ****         removed task will have been added to the xPendingReadyList.  Once the
1594:../Generated_Code/tasks.c ****         scheduler has been resumed it is safe to move all the pending ready
1595:../Generated_Code/tasks.c ****         tasks from this list into their appropriate ready list. */
1596:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 1723              		.loc 1 1596 0 is_stmt 1
 1724 001c FFF7FEFF 		bl	vPortEnterCritical
1597:../Generated_Code/tasks.c ****         {
1598:../Generated_Code/tasks.c ****                 --uxSchedulerSuspended;
 1725              		.loc 1 1598 0
 1726 0020 424B     		ldr	r3, .L129
 1727 0022 1B68     		ldr	r3, [r3]
 1728 0024 5A1E     		sub	r2, r3, #1
 1729 0026 414B     		ldr	r3, .L129
 1730 0028 1A60     		str	r2, [r3]
1599:../Generated_Code/tasks.c **** 
1600:../Generated_Code/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1731              		.loc 1 1600 0
 1732 002a 404B     		ldr	r3, .L129
 1733 002c 1B68     		ldr	r3, [r3]
 1734 002e 5A42     		neg	r2, r3
 1735 0030 5341     		adc	r3, r3, r2
 1736 0032 DBB2     		uxtb	r3, r3
 1737 0034 002B     		cmp	r3, #0
 1738 0036 00D1     		bne	.LCB1381
 1739 0038 71E0     		b	.L120	@long jump
 1740              	.LCB1381:
1601:../Generated_Code/tasks.c ****                 {
1602:../Generated_Code/tasks.c ****                         if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1741              		.loc 1 1602 0
 1742 003a 3D4B     		ldr	r3, .L129+4
 1743 003c 1B68     		ldr	r3, [r3]
 1744 003e 5A1E     		sub	r2, r3, #1
 1745 0040 9341     		sbc	r3, r3, r2
 1746 0042 DBB2     		uxtb	r3, r3
 1747 0044 002B     		cmp	r3, #0
 1748 0046 6AD0     		beq	.L120
1603:../Generated_Code/tasks.c ****                         {
1604:../Generated_Code/tasks.c ****                                 /* Move any readied tasks from the pending list into the
1605:../Generated_Code/tasks.c ****                                 appropriate ready list. */
1606:../Generated_Code/tasks.c ****                                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1749              		.loc 1 1606 0
 1750 0048 37E0     		b	.L121
 1751              	.L123:
1607:../Generated_Code/tasks.c ****                                 {
1608:../Generated_Code/tasks.c ****                                         pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendin
 1752              		.loc 1 1608 0
 1753 004a 3A4B     		ldr	r3, .L129+8
 1754 004c DB68     		ldr	r3, [r3, #12]
 1755 004e DB68     		ldr	r3, [r3, #12]
 1756 0050 3B60     		str	r3, [r7]
1609:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1757              		.loc 1 1609 0
 1758 0052 3B68     		ldr	r3, [r7]
 1759 0054 1833     		add	r3, r3, #24
 1760 0056 181C     		mov	r0, r3
 1761 0058 FFF7FEFF 		bl	uxListRemove
1610:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1762              		.loc 1 1610 0
 1763 005c 3B68     		ldr	r3, [r7]
 1764 005e 0433     		add	r3, r3, #4
 1765 0060 181C     		mov	r0, r3
 1766 0062 FFF7FEFF 		bl	uxListRemove
1611:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 1767              		.loc 1 1611 0
 1768 0066 3B68     		ldr	r3, [r7]
 1769 0068 DA6A     		ldr	r2, [r3, #44]
 1770 006a 334B     		ldr	r3, .L129+12
 1771 006c 1B68     		ldr	r3, [r3]
 1772 006e 9342     		cmp	r3, r2
 1773 0070 9B41     		sbc	r3, r3, r3
 1774 0072 5B42     		neg	r3, r3
 1775 0074 DBB2     		uxtb	r3, r3
 1776 0076 002B     		cmp	r3, #0
 1777 0078 03D0     		beq	.L122
 1778              		.loc 1 1611 0 is_stmt 0
 1779 007a 3B68     		ldr	r3, [r7]
 1780 007c DA6A     		ldr	r2, [r3, #44]
 1781 007e 2E4B     		ldr	r3, .L129+12
 1782 0080 1A60     		str	r2, [r3]
 1783              	.L122:
 1784              		.loc 1 1611 0
 1785 0082 3B68     		ldr	r3, [r7]
 1786 0084 DA6A     		ldr	r2, [r3, #44]
 1787 0086 131C     		mov	r3, r2
 1788 0088 9B00     		lsl	r3, r3, #2
 1789 008a 9B18     		add	r3, r3, r2
 1790 008c 9B00     		lsl	r3, r3, #2
 1791 008e 2B4A     		ldr	r2, .L129+16
 1792 0090 9A18     		add	r2, r3, r2
 1793 0092 3B68     		ldr	r3, [r7]
 1794 0094 0433     		add	r3, r3, #4
 1795 0096 101C     		mov	r0, r2
 1796 0098 191C     		mov	r1, r3
 1797 009a FFF7FEFF 		bl	vListInsertEnd
1612:../Generated_Code/tasks.c **** 
1613:../Generated_Code/tasks.c ****                                         /* If we have moved a task that has a priority higher than
1614:../Generated_Code/tasks.c ****                                         the current task then we should yield. */
1615:../Generated_Code/tasks.c ****                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1798              		.loc 1 1615 0 is_stmt 1
 1799 009e 3B68     		ldr	r3, [r7]
 1800 00a0 D96A     		ldr	r1, [r3, #44]
 1801 00a2 274B     		ldr	r3, .L129+20
 1802 00a4 1B68     		ldr	r3, [r3]
 1803 00a6 DA6A     		ldr	r2, [r3, #44]
 1804 00a8 0023     		mov	r3, #0
 1805 00aa 9142     		cmp	r1, r2
 1806 00ac 5B41     		adc	r3, r3, r3
 1807 00ae DBB2     		uxtb	r3, r3
 1808 00b0 002B     		cmp	r3, #0
 1809 00b2 02D0     		beq	.L121
1616:../Generated_Code/tasks.c ****                                         {
1617:../Generated_Code/tasks.c ****                                                 xYieldPending = pdTRUE;
 1810              		.loc 1 1617 0
 1811 00b4 234B     		ldr	r3, .L129+24
 1812 00b6 0122     		mov	r2, #1
 1813 00b8 1A60     		str	r2, [r3]
 1814              	.L121:
1606:../Generated_Code/tasks.c ****                                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1815              		.loc 1 1606 0
 1816 00ba 1E4B     		ldr	r3, .L129+8
 1817 00bc 1B68     		ldr	r3, [r3]
 1818 00be 5A1E     		sub	r2, r3, #1
 1819 00c0 9341     		sbc	r3, r3, r2
 1820 00c2 DBB2     		uxtb	r3, r3
 1821 00c4 002B     		cmp	r3, #0
 1822 00c6 C0D1     		bne	.L123
1618:../Generated_Code/tasks.c ****                                         }
1619:../Generated_Code/tasks.c ****                                         else
1620:../Generated_Code/tasks.c ****                                         {
1621:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
1622:../Generated_Code/tasks.c ****                                         }
1623:../Generated_Code/tasks.c ****                                 }
1624:../Generated_Code/tasks.c **** 
1625:../Generated_Code/tasks.c ****                                 /* If any ticks occurred while the scheduler was suspended then
1626:../Generated_Code/tasks.c ****                                 they should be processed now.  This ensures the tick count does
1627:../Generated_Code/tasks.c ****                                 not     slip, and that any delayed tasks are resumed at the correct
1628:../Generated_Code/tasks.c ****                                 time. */
1629:../Generated_Code/tasks.c ****                                 if( uxPendedTicks > ( UBaseType_t ) 0U )
 1823              		.loc 1 1629 0
 1824 00c8 1F4B     		ldr	r3, .L129+28
 1825 00ca 1B68     		ldr	r3, [r3]
 1826 00cc 5A1E     		sub	r2, r3, #1
 1827 00ce 9341     		sbc	r3, r3, r2
 1828 00d0 DBB2     		uxtb	r3, r3
 1829 00d2 002B     		cmp	r3, #0
 1830 00d4 17D0     		beq	.L124
1630:../Generated_Code/tasks.c ****                                 {
1631:../Generated_Code/tasks.c ****                                         while( uxPendedTicks > ( UBaseType_t ) 0U )
 1831              		.loc 1 1631 0
 1832 00d6 0FE0     		b	.L125
 1833              	.L127:
1632:../Generated_Code/tasks.c ****                                         {
1633:../Generated_Code/tasks.c ****                                                 if( xTaskIncrementTick() != pdFALSE )
 1834              		.loc 1 1633 0
 1835 00d8 FFF7FEFF 		bl	xTaskIncrementTick
 1836 00dc 031C     		mov	r3, r0
 1837 00de 5A1E     		sub	r2, r3, #1
 1838 00e0 9341     		sbc	r3, r3, r2
 1839 00e2 DBB2     		uxtb	r3, r3
 1840 00e4 002B     		cmp	r3, #0
 1841 00e6 02D0     		beq	.L126
1634:../Generated_Code/tasks.c ****                                                 {
1635:../Generated_Code/tasks.c ****                                                         xYieldPending = pdTRUE;
 1842              		.loc 1 1635 0
 1843 00e8 164B     		ldr	r3, .L129+24
 1844 00ea 0122     		mov	r2, #1
 1845 00ec 1A60     		str	r2, [r3]
 1846              	.L126:
1636:../Generated_Code/tasks.c ****                                                 }
1637:../Generated_Code/tasks.c ****                                                 else
1638:../Generated_Code/tasks.c ****                                                 {
1639:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1640:../Generated_Code/tasks.c ****                                                 }
1641:../Generated_Code/tasks.c ****                                                 --uxPendedTicks;
 1847              		.loc 1 1641 0
 1848 00ee 164B     		ldr	r3, .L129+28
 1849 00f0 1B68     		ldr	r3, [r3]
 1850 00f2 5A1E     		sub	r2, r3, #1
 1851 00f4 144B     		ldr	r3, .L129+28
 1852 00f6 1A60     		str	r2, [r3]
 1853              	.L125:
1631:../Generated_Code/tasks.c ****                                         while( uxPendedTicks > ( UBaseType_t ) 0U )
 1854              		.loc 1 1631 0
 1855 00f8 134B     		ldr	r3, .L129+28
 1856 00fa 1B68     		ldr	r3, [r3]
 1857 00fc 5A1E     		sub	r2, r3, #1
 1858 00fe 9341     		sbc	r3, r3, r2
 1859 0100 DBB2     		uxtb	r3, r3
 1860 0102 002B     		cmp	r3, #0
 1861 0104 E8D1     		bne	.L127
 1862              	.L124:
1642:../Generated_Code/tasks.c ****                                         }
1643:../Generated_Code/tasks.c ****                                 }
1644:../Generated_Code/tasks.c ****                                 else
1645:../Generated_Code/tasks.c ****                                 {
1646:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1647:../Generated_Code/tasks.c ****                                 }
1648:../Generated_Code/tasks.c **** 
1649:../Generated_Code/tasks.c ****                                 if( xYieldPending == pdTRUE )
 1863              		.loc 1 1649 0
 1864 0106 0F4B     		ldr	r3, .L129+24
 1865 0108 1B68     		ldr	r3, [r3]
 1866 010a 013B     		sub	r3, r3, #1
 1867 010c 5A42     		neg	r2, r3
 1868 010e 5341     		adc	r3, r3, r2
 1869 0110 DBB2     		uxtb	r3, r3
 1870 0112 002B     		cmp	r3, #0
 1871 0114 03D0     		beq	.L120
1650:../Generated_Code/tasks.c ****                                 {
1651:../Generated_Code/tasks.c ****                                         #if( configUSE_PREEMPTION != 0 )
1652:../Generated_Code/tasks.c ****                                         {
1653:../Generated_Code/tasks.c ****                                                 xAlreadyYielded = pdTRUE;
 1872              		.loc 1 1653 0
 1873 0116 0123     		mov	r3, #1
 1874 0118 7B60     		str	r3, [r7, #4]
1654:../Generated_Code/tasks.c ****                                         }
1655:../Generated_Code/tasks.c ****                                         #endif
1656:../Generated_Code/tasks.c ****                                         taskYIELD_IF_USING_PREEMPTION();
 1875              		.loc 1 1656 0
 1876 011a FFF7FEFF 		bl	vPortYieldFromISR
 1877              	.L120:
1657:../Generated_Code/tasks.c ****                                 }
1658:../Generated_Code/tasks.c ****                                 else
1659:../Generated_Code/tasks.c ****                                 {
1660:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
1661:../Generated_Code/tasks.c ****                                 }
1662:../Generated_Code/tasks.c ****                         }
1663:../Generated_Code/tasks.c ****                 }
1664:../Generated_Code/tasks.c ****                 else
1665:../Generated_Code/tasks.c ****                 {
1666:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1667:../Generated_Code/tasks.c ****                 }
1668:../Generated_Code/tasks.c ****         }
1669:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 1878              		.loc 1 1669 0
 1879 011e FFF7FEFF 		bl	vPortExitCritical
1670:../Generated_Code/tasks.c **** 
1671:../Generated_Code/tasks.c ****         return xAlreadyYielded;
 1880              		.loc 1 1671 0
 1881 0122 7B68     		ldr	r3, [r7, #4]
 1882              	.LBE15:
1672:../Generated_Code/tasks.c **** }
 1883              		.loc 1 1672 0
 1884 0124 181C     		mov	r0, r3
 1885 0126 BD46     		mov	sp, r7
 1886 0128 02B0     		add	sp, sp, #8
 1887              		@ sp needed for prologue
 1888 012a 80BD     		pop	{r7, pc}
 1889              	.L130:
 1890              		.align	2
 1891              	.L129:
 1892 012c 00000000 		.word	_ZL20uxSchedulerSuspended
 1893 0130 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 1894 0134 00000000 		.word	_ZL17xPendingReadyList
 1895 0138 00000000 		.word	_ZL18uxTopReadyPriority
 1896 013c 00000000 		.word	_ZL17pxReadyTasksLists
 1897 0140 00000000 		.word	pxCurrentTCB
 1898 0144 00000000 		.word	_ZL13xYieldPending
 1899 0148 00000000 		.word	_ZL13uxPendedTicks
 1900              		.cfi_endproc
 1901              	.LFE21:
 1903              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1904              		.align	2
 1905              		.global	xTaskGetTickCount
 1906              		.code	16
 1907              		.thumb_func
 1909              	xTaskGetTickCount:
 1910              	.LFB22:
1673:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1674:../Generated_Code/tasks.c **** 
1675:../Generated_Code/tasks.c **** TickType_t xTaskGetTickCount( void )
1676:../Generated_Code/tasks.c **** {
 1911              		.loc 1 1676 0
 1912              		.cfi_startproc
 1913 0000 80B5     		push	{r7, lr}
 1914              	.LCFI37:
 1915              		.cfi_def_cfa_offset 8
 1916              		.cfi_offset 7, -8
 1917              		.cfi_offset 14, -4
 1918 0002 82B0     		sub	sp, sp, #8
 1919              	.LCFI38:
 1920              		.cfi_def_cfa_offset 16
 1921 0004 00AF     		add	r7, sp, #0
 1922              	.LCFI39:
 1923              		.cfi_def_cfa_register 7
 1924              	.LBB16:
1677:../Generated_Code/tasks.c **** TickType_t xTicks;
1678:../Generated_Code/tasks.c **** 
1679:../Generated_Code/tasks.c ****         /* Critical section required if running on a 16 bit processor. */
1680:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 1925              		.loc 1 1680 0
 1926 0006 FFF7FEFF 		bl	vPortEnterCritical
1681:../Generated_Code/tasks.c ****         {
1682:../Generated_Code/tasks.c ****                 xTicks = xTickCount;
 1927              		.loc 1 1682 0
 1928 000a 054B     		ldr	r3, .L133
 1929 000c 1B68     		ldr	r3, [r3]
 1930 000e 7B60     		str	r3, [r7, #4]
1683:../Generated_Code/tasks.c ****         }
1684:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 1931              		.loc 1 1684 0
 1932 0010 FFF7FEFF 		bl	vPortExitCritical
1685:../Generated_Code/tasks.c **** 
1686:../Generated_Code/tasks.c ****         return xTicks;
 1933              		.loc 1 1686 0
 1934 0014 7B68     		ldr	r3, [r7, #4]
 1935              	.LBE16:
1687:../Generated_Code/tasks.c **** }
 1936              		.loc 1 1687 0
 1937 0016 181C     		mov	r0, r3
 1938 0018 BD46     		mov	sp, r7
 1939 001a 02B0     		add	sp, sp, #8
 1940              		@ sp needed for prologue
 1941 001c 80BD     		pop	{r7, pc}
 1942              	.L134:
 1943 001e C046     		.align	2
 1944              	.L133:
 1945 0020 00000000 		.word	_ZL10xTickCount
 1946              		.cfi_endproc
 1947              	.LFE22:
 1949              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1950              		.align	2
 1951              		.global	xTaskGetTickCountFromISR
 1952              		.code	16
 1953              		.thumb_func
 1955              	xTaskGetTickCountFromISR:
 1956              	.LFB23:
1688:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1689:../Generated_Code/tasks.c **** 
1690:../Generated_Code/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1691:../Generated_Code/tasks.c **** {
 1957              		.loc 1 1691 0
 1958              		.cfi_startproc
 1959 0000 80B5     		push	{r7, lr}
 1960              	.LCFI40:
 1961              		.cfi_def_cfa_offset 8
 1962              		.cfi_offset 7, -8
 1963              		.cfi_offset 14, -4
 1964 0002 82B0     		sub	sp, sp, #8
 1965              	.LCFI41:
 1966              		.cfi_def_cfa_offset 16
 1967 0004 00AF     		add	r7, sp, #0
 1968              	.LCFI42:
 1969              		.cfi_def_cfa_register 7
 1970              	.LBB17:
1692:../Generated_Code/tasks.c **** TickType_t xReturn;
1693:../Generated_Code/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1694:../Generated_Code/tasks.c **** 
1695:../Generated_Code/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a maximum
1696:../Generated_Code/tasks.c ****         system call (or maximum API call) interrupt priority.  Interrupts that are
1697:../Generated_Code/tasks.c ****         above the maximum system call priority are kept permanently enabled, even
1698:../Generated_Code/tasks.c ****         when the RTOS kernel is in a critical section, but cannot make any calls to
1699:../Generated_Code/tasks.c ****         FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1700:../Generated_Code/tasks.c ****         then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1701:../Generated_Code/tasks.c ****         failure if a FreeRTOS API function is called from an interrupt that has been
1702:../Generated_Code/tasks.c ****         assigned a priority above the configured maximum system call priority.
1703:../Generated_Code/tasks.c ****         Only FreeRTOS functions that end in FromISR can be called from interrupts
1704:../Generated_Code/tasks.c ****         that have been assigned a priority at or (logically) below the maximum
1705:../Generated_Code/tasks.c ****         system call     interrupt priority.  FreeRTOS maintains a separate interrupt
1706:../Generated_Code/tasks.c ****         safe API to ensure interrupt entry is as fast and as simple as possible.
1707:../Generated_Code/tasks.c ****         More information (albeit Cortex-M specific) is provided on the following
1708:../Generated_Code/tasks.c ****         link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1709:../Generated_Code/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1710:../Generated_Code/tasks.c **** 
1711:../Generated_Code/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1971              		.loc 1 1711 0
 1972 0006 0023     		mov	r3, #0
 1973 0008 7B60     		str	r3, [r7, #4]
 1974              	@ 1711 "../Generated_Code/tasks.c" 1
 1975 000a 72B6     		cpsid i
 1976              	@ 0 "" 2
1712:../Generated_Code/tasks.c ****         {
1713:../Generated_Code/tasks.c ****                 xReturn = xTickCount;
 1977              		.loc 1 1713 0
 1978              		.code	16
 1979 000c 044B     		ldr	r3, .L137
 1980 000e 1B68     		ldr	r3, [r3]
 1981 0010 3B60     		str	r3, [r7]
1714:../Generated_Code/tasks.c ****         }
1715:../Generated_Code/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1982              		.loc 1 1715 0
 1983              	@ 1715 "../Generated_Code/tasks.c" 1
 1984 0012 62B6     		cpsie i
 1985              	@ 0 "" 2
1716:../Generated_Code/tasks.c **** 
1717:../Generated_Code/tasks.c ****         return xReturn;
 1986              		.loc 1 1717 0
 1987              		.code	16
 1988 0014 3B68     		ldr	r3, [r7]
 1989              	.LBE17:
1718:../Generated_Code/tasks.c **** }
 1990              		.loc 1 1718 0
 1991 0016 181C     		mov	r0, r3
 1992 0018 BD46     		mov	sp, r7
 1993 001a 02B0     		add	sp, sp, #8
 1994              		@ sp needed for prologue
 1995 001c 80BD     		pop	{r7, pc}
 1996              	.L138:
 1997 001e C046     		.align	2
 1998              	.L137:
 1999 0020 00000000 		.word	_ZL10xTickCount
 2000              		.cfi_endproc
 2001              	.LFE23:
 2003              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2004              		.align	2
 2005              		.global	uxTaskGetNumberOfTasks
 2006              		.code	16
 2007              		.thumb_func
 2009              	uxTaskGetNumberOfTasks:
 2010              	.LFB24:
1719:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1720:../Generated_Code/tasks.c **** 
1721:../Generated_Code/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1722:../Generated_Code/tasks.c **** {
 2011              		.loc 1 1722 0
 2012              		.cfi_startproc
 2013 0000 80B5     		push	{r7, lr}
 2014              	.LCFI43:
 2015              		.cfi_def_cfa_offset 8
 2016              		.cfi_offset 7, -8
 2017              		.cfi_offset 14, -4
 2018 0002 00AF     		add	r7, sp, #0
 2019              	.LCFI44:
 2020              		.cfi_def_cfa_register 7
1723:../Generated_Code/tasks.c ****         /* A critical section is not required because the variables are of type
1724:../Generated_Code/tasks.c ****         BaseType_t. */
1725:../Generated_Code/tasks.c ****         return uxCurrentNumberOfTasks;
 2021              		.loc 1 1725 0
 2022 0004 024B     		ldr	r3, .L141
 2023 0006 1B68     		ldr	r3, [r3]
1726:../Generated_Code/tasks.c **** }
 2024              		.loc 1 1726 0
 2025 0008 181C     		mov	r0, r3
 2026 000a BD46     		mov	sp, r7
 2027              		@ sp needed for prologue
 2028 000c 80BD     		pop	{r7, pc}
 2029              	.L142:
 2030 000e C046     		.align	2
 2031              	.L141:
 2032 0010 00000000 		.word	_ZL22uxCurrentNumberOfTasks
 2033              		.cfi_endproc
 2034              	.LFE24:
 2036              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2037              		.align	2
 2038              		.global	xTaskIncrementTick
 2039              		.code	16
 2040              		.thumb_func
 2042              	xTaskIncrementTick:
 2043              	.LFB25:
1727:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1728:../Generated_Code/tasks.c **** 
1729:../Generated_Code/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1730:../Generated_Code/tasks.c **** 
1731:../Generated_Code/tasks.c ****         char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
1732:../Generated_Code/tasks.c ****         {
1733:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
1734:../Generated_Code/tasks.c **** 
1735:../Generated_Code/tasks.c ****                 /* If null is passed in here then the name of the calling task is being queried. */
1736:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1737:../Generated_Code/tasks.c ****                 configASSERT( pxTCB );
1738:../Generated_Code/tasks.c ****                 return &( pxTCB->pcTaskName[ 0 ] );
1739:../Generated_Code/tasks.c ****         }
1740:../Generated_Code/tasks.c **** 
1741:../Generated_Code/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1742:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1743:../Generated_Code/tasks.c **** 
1744:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1745:../Generated_Code/tasks.c **** 
1746:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t
1747:../Generated_Code/tasks.c ****         {
1748:../Generated_Code/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1749:../Generated_Code/tasks.c **** 
1750:../Generated_Code/tasks.c ****                 vTaskSuspendAll();
1751:../Generated_Code/tasks.c ****                 {
1752:../Generated_Code/tasks.c ****                         /* Is there a space in the array for each task in the system? */
1753:../Generated_Code/tasks.c ****                         if( uxArraySize >= uxCurrentNumberOfTasks )
1754:../Generated_Code/tasks.c ****                         {
1755:../Generated_Code/tasks.c ****                                 /* Fill in an TaskStatus_t structure with information on each
1756:../Generated_Code/tasks.c ****                                 task in the Ready state. */
1757:../Generated_Code/tasks.c ****                                 do
1758:../Generated_Code/tasks.c ****                                 {
1759:../Generated_Code/tasks.c ****                                         uxQueue--;
1760:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1761:../Generated_Code/tasks.c **** 
1762:../Generated_Code/tasks.c ****                                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961
1763:../Generated_Code/tasks.c **** 
1764:../Generated_Code/tasks.c ****                                 /* Fill in an TaskStatus_t structure with information on each
1765:../Generated_Code/tasks.c ****                                 task in the Blocked state. */
1766:../Generated_Code/tasks.c ****                                 uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask
1767:../Generated_Code/tasks.c ****                                 uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask
1768:../Generated_Code/tasks.c **** 
1769:../Generated_Code/tasks.c ****                                 #if( INCLUDE_vTaskDelete == 1 )
1770:../Generated_Code/tasks.c ****                                 {
1771:../Generated_Code/tasks.c ****                                         /* Fill in an TaskStatus_t structure with information on
1772:../Generated_Code/tasks.c ****                                         each task that has been deleted but not yet cleaned up. */
1773:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1774:../Generated_Code/tasks.c ****                                 }
1775:../Generated_Code/tasks.c ****                                 #endif
1776:../Generated_Code/tasks.c **** 
1777:../Generated_Code/tasks.c ****                                 #if ( INCLUDE_vTaskSuspend == 1 )
1778:../Generated_Code/tasks.c ****                                 {
1779:../Generated_Code/tasks.c ****                                         /* Fill in an TaskStatus_t structure with information on
1780:../Generated_Code/tasks.c ****                                         each task in the Suspended state. */
1781:../Generated_Code/tasks.c ****                                         uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray
1782:../Generated_Code/tasks.c ****                                 }
1783:../Generated_Code/tasks.c ****                                 #endif
1784:../Generated_Code/tasks.c **** 
1785:../Generated_Code/tasks.c ****                                 #if ( configGENERATE_RUN_TIME_STATS == 1)
1786:../Generated_Code/tasks.c ****                                 {
1787:../Generated_Code/tasks.c ****                                         if( pulTotalRunTime != NULL )
1788:../Generated_Code/tasks.c ****                                         {
1789:../Generated_Code/tasks.c ****                                                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1790:../Generated_Code/tasks.c ****                                                         portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulT
1791:../Generated_Code/tasks.c ****                                                 #else
1792:../Generated_Code/tasks.c ****                                                         *pulTotalRunTime = portGET_RUN_TIME_COUNTER
1793:../Generated_Code/tasks.c ****                                                 #endif
1794:../Generated_Code/tasks.c ****                                         }
1795:../Generated_Code/tasks.c ****                                 }
1796:../Generated_Code/tasks.c ****                                 #else
1797:../Generated_Code/tasks.c ****                                 {
1798:../Generated_Code/tasks.c ****                                         if( pulTotalRunTime != NULL )
1799:../Generated_Code/tasks.c ****                                         {
1800:../Generated_Code/tasks.c ****                                                 *pulTotalRunTime = 0;
1801:../Generated_Code/tasks.c ****                                         }
1802:../Generated_Code/tasks.c ****                                 }
1803:../Generated_Code/tasks.c ****                                 #endif
1804:../Generated_Code/tasks.c ****                         }
1805:../Generated_Code/tasks.c ****                         else
1806:../Generated_Code/tasks.c ****                         {
1807:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1808:../Generated_Code/tasks.c ****                         }
1809:../Generated_Code/tasks.c ****                 }
1810:../Generated_Code/tasks.c ****                 ( void ) xTaskResumeAll();
1811:../Generated_Code/tasks.c **** 
1812:../Generated_Code/tasks.c ****                 return uxTask;
1813:../Generated_Code/tasks.c ****         }
1814:../Generated_Code/tasks.c **** 
1815:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1816:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1817:../Generated_Code/tasks.c **** 
1818:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1819:../Generated_Code/tasks.c **** 
1820:../Generated_Code/tasks.c ****         TaskHandle_t xTaskGetIdleTaskHandle( void )
1821:../Generated_Code/tasks.c ****         {
1822:../Generated_Code/tasks.c ****                 /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1823:../Generated_Code/tasks.c ****                 started, then xIdleTaskHandle will be NULL. */
1824:../Generated_Code/tasks.c ****                 configASSERT( ( xIdleTaskHandle != NULL ) );
1825:../Generated_Code/tasks.c ****                 return xIdleTaskHandle;
1826:../Generated_Code/tasks.c ****         }
1827:../Generated_Code/tasks.c **** 
1828:../Generated_Code/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1829:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1830:../Generated_Code/tasks.c **** 
1831:../Generated_Code/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1832:../Generated_Code/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1833:../Generated_Code/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1834:../Generated_Code/tasks.c **** 1. */
1835:../Generated_Code/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1836:../Generated_Code/tasks.c **** 
1837:../Generated_Code/tasks.c ****         void vTaskStepTick( const TickType_t xTicksToJump )
1838:../Generated_Code/tasks.c ****         {
1839:../Generated_Code/tasks.c ****                 /* Correct the tick count value after a period during which the tick
1840:../Generated_Code/tasks.c ****                 was suppressed.  Note this does *not* call the tick hook function for
1841:../Generated_Code/tasks.c ****                 each stepped tick. */
1842:../Generated_Code/tasks.c ****                 configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1843:../Generated_Code/tasks.c ****                 xTickCount += xTicksToJump;
1844:../Generated_Code/tasks.c ****                 traceINCREASE_TICK_COUNT( xTicksToJump );
1845:../Generated_Code/tasks.c ****         }
1846:../Generated_Code/tasks.c **** 
1847:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1848:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1849:../Generated_Code/tasks.c **** 
1850:../Generated_Code/tasks.c **** BaseType_t xTaskIncrementTick( void )
1851:../Generated_Code/tasks.c **** {
 2044              		.loc 1 1851 0
 2045              		.cfi_startproc
 2046 0000 80B5     		push	{r7, lr}
 2047              	.LCFI45:
 2048              		.cfi_def_cfa_offset 8
 2049              		.cfi_offset 7, -8
 2050              		.cfi_offset 14, -4
 2051 0002 86B0     		sub	sp, sp, #24
 2052              	.LCFI46:
 2053              		.cfi_def_cfa_offset 32
 2054 0004 00AF     		add	r7, sp, #0
 2055              	.LCFI47:
 2056              		.cfi_def_cfa_register 7
 2057              	.LBB18:
1852:../Generated_Code/tasks.c **** TCB_t * pxTCB;
1853:../Generated_Code/tasks.c **** TickType_t xItemValue;
1854:../Generated_Code/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2058              		.loc 1 1854 0
 2059 0006 0023     		mov	r3, #0
 2060 0008 7B61     		str	r3, [r7, #20]
 2061              	.LBB19:
1855:../Generated_Code/tasks.c **** 
1856:../Generated_Code/tasks.c ****         /* Called by the portable layer each time a tick interrupt occurs.
1857:../Generated_Code/tasks.c ****         Increments the tick then checks to see if the new tick value will cause any
1858:../Generated_Code/tasks.c ****         tasks to be unblocked. */
1859:../Generated_Code/tasks.c ****         traceTASK_INCREMENT_TICK( xTickCount );
1860:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2062              		.loc 1 1860 0
 2063 000a 614B     		ldr	r3, .L163
 2064 000c 1B68     		ldr	r3, [r3]
 2065 000e 5A42     		neg	r2, r3
 2066 0010 5341     		adc	r3, r3, r2
 2067 0012 DBB2     		uxtb	r3, r3
 2068 0014 002B     		cmp	r3, #0
 2069 0016 00D1     		bne	.LCB1664
 2070 0018 A4E0     		b	.L144	@long jump
 2071              	.LCB1664:
 2072              	.LBB20:
1861:../Generated_Code/tasks.c ****         {
1862:../Generated_Code/tasks.c ****                 /* Increment the RTOS tick, switching the delayed and overflowed
1863:../Generated_Code/tasks.c ****                 delayed lists if it wraps to 0. */
1864:../Generated_Code/tasks.c ****                 ++xTickCount;
 2073              		.loc 1 1864 0
 2074 001a 5E4B     		ldr	r3, .L163+4
 2075 001c 1B68     		ldr	r3, [r3]
 2076 001e 5A1C     		add	r2, r3, #1
 2077 0020 5C4B     		ldr	r3, .L163+4
 2078 0022 1A60     		str	r2, [r3]
 2079              	.LBB21:
1865:../Generated_Code/tasks.c **** 
1866:../Generated_Code/tasks.c ****                 {
1867:../Generated_Code/tasks.c ****                         /* Minor optimisation.  The tick count cannot change in this
1868:../Generated_Code/tasks.c ****                         block. */
1869:../Generated_Code/tasks.c ****                         const TickType_t xConstTickCount = xTickCount;
 2080              		.loc 1 1869 0
 2081 0024 5B4B     		ldr	r3, .L163+4
 2082 0026 1B68     		ldr	r3, [r3]
 2083 0028 3B61     		str	r3, [r7, #16]
 2084              	.LBB22:
1870:../Generated_Code/tasks.c **** 
1871:../Generated_Code/tasks.c ****                         if( xConstTickCount == ( TickType_t ) 0U )
 2085              		.loc 1 1871 0
 2086 002a 3B69     		ldr	r3, [r7, #16]
 2087 002c 002B     		cmp	r3, #0
 2088 002e 1AD1     		bne	.L145
 2089              	.LBB23:
 2090              	.LBB24:
1872:../Generated_Code/tasks.c ****                         {
1873:../Generated_Code/tasks.c ****                                 taskSWITCH_DELAYED_LISTS();
 2091              		.loc 1 1873 0
 2092 0030 594B     		ldr	r3, .L163+8
 2093 0032 1B68     		ldr	r3, [r3]
 2094 0034 1B68     		ldr	r3, [r3]
 2095 0036 5A1E     		sub	r2, r3, #1
 2096 0038 9341     		sbc	r3, r3, r2
 2097 003a DBB2     		uxtb	r3, r3
 2098 003c 002B     		cmp	r3, #0
 2099 003e 01D0     		beq	.L146
 2100              		.loc 1 1873 0 is_stmt 0
 2101              	@ 1873 "../Generated_Code/tasks.c" 1
 2102 0040 72B6     		cpsid i
 2103              	@ 0 "" 2
 2104              		.code	16
 2105              	.L147:
 2106              		.loc 1 1873 0
 2107 0042 FEE7     		b	.L147
 2108              	.L146:
 2109              		.loc 1 1873 0
 2110 0044 544B     		ldr	r3, .L163+8
 2111 0046 1B68     		ldr	r3, [r3]
 2112 0048 FB60     		str	r3, [r7, #12]
 2113 004a 544B     		ldr	r3, .L163+12
 2114 004c 1A68     		ldr	r2, [r3]
 2115 004e 524B     		ldr	r3, .L163+8
 2116 0050 1A60     		str	r2, [r3]
 2117 0052 524B     		ldr	r3, .L163+12
 2118 0054 FA68     		ldr	r2, [r7, #12]
 2119 0056 1A60     		str	r2, [r3]
 2120 0058 514B     		ldr	r3, .L163+16
 2121 005a 1B68     		ldr	r3, [r3]
 2122 005c 5A1C     		add	r2, r3, #1
 2123 005e 504B     		ldr	r3, .L163+16
 2124 0060 1A60     		str	r2, [r3]
 2125 0062 FFF7FEFF 		bl	_ZL27prvResetNextTaskUnblockTimev
 2126              	.L145:
 2127              	.LBE24:
 2128              	.LBE23:
 2129              	.LBE22:
1874:../Generated_Code/tasks.c ****                         }
1875:../Generated_Code/tasks.c ****                         else
1876:../Generated_Code/tasks.c ****                         {
1877:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1878:../Generated_Code/tasks.c ****                         }
1879:../Generated_Code/tasks.c **** 
1880:../Generated_Code/tasks.c ****                         /* See if this tick has made a timeout expire.  Tasks are stored in
1881:../Generated_Code/tasks.c ****                         the     queue in the order of their wake time - meaning once one task
1882:../Generated_Code/tasks.c ****                         has been found whose block time has not expired there is no need to
1883:../Generated_Code/tasks.c ****                         look any further        down the list. */
1884:../Generated_Code/tasks.c ****                         if( xConstTickCount >= xNextTaskUnblockTime )
 2130              		.loc 1 1884 0 is_stmt 1
 2131 0066 4F4B     		ldr	r3, .L163+20
 2132 0068 1A68     		ldr	r2, [r3]
 2133 006a 3969     		ldr	r1, [r7, #16]
 2134 006c 0023     		mov	r3, #0
 2135 006e 9142     		cmp	r1, r2
 2136 0070 5B41     		adc	r3, r3, r3
 2137 0072 DBB2     		uxtb	r3, r3
 2138 0074 002B     		cmp	r3, #0
 2139 0076 59D0     		beq	.L148
 2140 0078 00E0     		b	.L157
 2141              	.L162:
1885:../Generated_Code/tasks.c ****                         {
1886:../Generated_Code/tasks.c ****                                 for( ;; )
 2142              		.loc 1 1886 0
 2143 007a C046     		mov	r8, r8
 2144              	.L157:
1887:../Generated_Code/tasks.c ****                                 {
1888:../Generated_Code/tasks.c ****                                         if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2145              		.loc 1 1888 0
 2146 007c 464B     		ldr	r3, .L163+8
 2147 007e 1B68     		ldr	r3, [r3]
 2148 0080 1B68     		ldr	r3, [r3]
 2149 0082 002B     		cmp	r3, #0
 2150 0084 01D1     		bne	.L149
 2151              		.loc 1 1888 0 is_stmt 0
 2152 0086 0123     		mov	r3, #1
 2153 0088 00E0     		b	.L150
 2154              	.L149:
 2155              		.loc 1 1888 0
 2156 008a 0023     		mov	r3, #0
 2157              	.L150:
 2158              		.loc 1 1888 0
 2159 008c 002B     		cmp	r3, #0
 2160 008e 04D0     		beq	.L151
1889:../Generated_Code/tasks.c ****                                         {
1890:../Generated_Code/tasks.c ****                                                 /* The delayed list is empty.  Set xNextTaskUnblock
1891:../Generated_Code/tasks.c ****                                                 to the maximum possible value so it is extremely
1892:../Generated_Code/tasks.c ****                                                 unlikely that the
1893:../Generated_Code/tasks.c ****                                                 if( xTickCount >= xNextTaskUnblockTime ) test will 
1894:../Generated_Code/tasks.c ****                                                 next time through. */
1895:../Generated_Code/tasks.c ****                                                 xNextTaskUnblockTime = portMAX_DELAY;
 2161              		.loc 1 1895 0 is_stmt 1
 2162 0090 444B     		ldr	r3, .L163+20
 2163 0092 0122     		mov	r2, #1
 2164 0094 5242     		neg	r2, r2
 2165 0096 1A60     		str	r2, [r3]
1896:../Generated_Code/tasks.c ****                                                 break;
 2166              		.loc 1 1896 0
 2167 0098 48E0     		b	.L148
 2168              	.L151:
1897:../Generated_Code/tasks.c ****                                         }
1898:../Generated_Code/tasks.c ****                                         else
1899:../Generated_Code/tasks.c ****                                         {
1900:../Generated_Code/tasks.c ****                                                 /* The delayed list is not empty, get the value of 
1901:../Generated_Code/tasks.c ****                                                 item at the head of the delayed list.  This is the 
1902:../Generated_Code/tasks.c ****                                                 at which the task at the head of the delayed list m
1903:../Generated_Code/tasks.c ****                                                 be removed from the Blocked state. */
1904:../Generated_Code/tasks.c ****                                                 pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( px
 2169              		.loc 1 1904 0
 2170 009a 3F4B     		ldr	r3, .L163+8
 2171 009c 1B68     		ldr	r3, [r3]
 2172 009e DB68     		ldr	r3, [r3, #12]
 2173 00a0 DB68     		ldr	r3, [r3, #12]
 2174 00a2 BB60     		str	r3, [r7, #8]
1905:../Generated_Code/tasks.c ****                                                 xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGe
 2175              		.loc 1 1905 0
 2176 00a4 BB68     		ldr	r3, [r7, #8]
 2177 00a6 5B68     		ldr	r3, [r3, #4]
 2178 00a8 7B60     		str	r3, [r7, #4]
1906:../Generated_Code/tasks.c **** 
1907:../Generated_Code/tasks.c ****                                                 if( xConstTickCount < xItemValue )
 2179              		.loc 1 1907 0
 2180 00aa 3A69     		ldr	r2, [r7, #16]
 2181 00ac 7B68     		ldr	r3, [r7, #4]
 2182 00ae 9A42     		cmp	r2, r3
 2183 00b0 04D2     		bcs	.L153
1908:../Generated_Code/tasks.c ****                                                 {
1909:../Generated_Code/tasks.c ****                                                         /* It is not time to unblock this item yet,
1910:../Generated_Code/tasks.c ****                                                         item value is the time at which the task at
1911:../Generated_Code/tasks.c ****                                                         of the blocked list must be removed from th
1912:../Generated_Code/tasks.c ****                                                         state - so record the item value in
1913:../Generated_Code/tasks.c ****                                                         xNextTaskUnblockTime. */
1914:../Generated_Code/tasks.c ****                                                         xNextTaskUnblockTime = xItemValue;
 2184              		.loc 1 1914 0
 2185 00b2 3C4B     		ldr	r3, .L163+20
 2186 00b4 7A68     		ldr	r2, [r7, #4]
 2187 00b6 1A60     		str	r2, [r3]
1915:../Generated_Code/tasks.c ****                                                         break;
 2188              		.loc 1 1915 0
 2189 00b8 C046     		mov	r8, r8
 2190 00ba 37E0     		b	.L148
 2191              	.L153:
1916:../Generated_Code/tasks.c ****                                                 }
1917:../Generated_Code/tasks.c ****                                                 else
1918:../Generated_Code/tasks.c ****                                                 {
1919:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1920:../Generated_Code/tasks.c ****                                                 }
1921:../Generated_Code/tasks.c **** 
1922:../Generated_Code/tasks.c ****                                                 /* It is time to remove the item from the Blocked s
1923:../Generated_Code/tasks.c ****                                                 ( void ) uxListRemove( &( pxTCB->xGenericListItem )
 2192              		.loc 1 1923 0
 2193 00bc BB68     		ldr	r3, [r7, #8]
 2194 00be 0433     		add	r3, r3, #4
 2195 00c0 181C     		mov	r0, r3
 2196 00c2 FFF7FEFF 		bl	uxListRemove
1924:../Generated_Code/tasks.c **** 
1925:../Generated_Code/tasks.c ****                                                 /* Is the task waiting on an event also?  If so rem
1926:../Generated_Code/tasks.c ****                                                 it from the event list. */
1927:../Generated_Code/tasks.c ****                                                 if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListIt
 2197              		.loc 1 1927 0
 2198 00c6 BB68     		ldr	r3, [r7, #8]
 2199 00c8 9B6A     		ldr	r3, [r3, #40]
 2200 00ca 002B     		cmp	r3, #0
 2201 00cc 04D0     		beq	.L154
1928:../Generated_Code/tasks.c ****                                                 {
1929:../Generated_Code/tasks.c ****                                                         ( void ) uxListRemove( &( pxTCB->xEventList
 2202              		.loc 1 1929 0
 2203 00ce BB68     		ldr	r3, [r7, #8]
 2204 00d0 1833     		add	r3, r3, #24
 2205 00d2 181C     		mov	r0, r3
 2206 00d4 FFF7FEFF 		bl	uxListRemove
 2207              	.L154:
1930:../Generated_Code/tasks.c ****                                                 }
1931:../Generated_Code/tasks.c ****                                                 else
1932:../Generated_Code/tasks.c ****                                                 {
1933:../Generated_Code/tasks.c ****                                                         mtCOVERAGE_TEST_MARKER();
1934:../Generated_Code/tasks.c ****                                                 }
1935:../Generated_Code/tasks.c **** 
1936:../Generated_Code/tasks.c ****                                                 /* Place the unblocked task into the appropriate re
1937:../Generated_Code/tasks.c ****                                                 list. */
1938:../Generated_Code/tasks.c ****                                                 prvAddTaskToReadyList( pxTCB );
 2208              		.loc 1 1938 0
 2209 00d8 BB68     		ldr	r3, [r7, #8]
 2210 00da DA6A     		ldr	r2, [r3, #44]
 2211 00dc 324B     		ldr	r3, .L163+24
 2212 00de 1B68     		ldr	r3, [r3]
 2213 00e0 9342     		cmp	r3, r2
 2214 00e2 9B41     		sbc	r3, r3, r3
 2215 00e4 5B42     		neg	r3, r3
 2216 00e6 DBB2     		uxtb	r3, r3
 2217 00e8 002B     		cmp	r3, #0
 2218 00ea 03D0     		beq	.L155
 2219              		.loc 1 1938 0 is_stmt 0
 2220 00ec BB68     		ldr	r3, [r7, #8]
 2221 00ee DA6A     		ldr	r2, [r3, #44]
 2222 00f0 2D4B     		ldr	r3, .L163+24
 2223 00f2 1A60     		str	r2, [r3]
 2224              	.L155:
 2225              		.loc 1 1938 0
 2226 00f4 BB68     		ldr	r3, [r7, #8]
 2227 00f6 DA6A     		ldr	r2, [r3, #44]
 2228 00f8 131C     		mov	r3, r2
 2229 00fa 9B00     		lsl	r3, r3, #2
 2230 00fc 9B18     		add	r3, r3, r2
 2231 00fe 9B00     		lsl	r3, r3, #2
 2232 0100 2A4A     		ldr	r2, .L163+28
 2233 0102 9A18     		add	r2, r3, r2
 2234 0104 BB68     		ldr	r3, [r7, #8]
 2235 0106 0433     		add	r3, r3, #4
 2236 0108 101C     		mov	r0, r2
 2237 010a 191C     		mov	r1, r3
 2238 010c FFF7FEFF 		bl	vListInsertEnd
1939:../Generated_Code/tasks.c **** 
1940:../Generated_Code/tasks.c ****                                                 /* A task being unblocked cannot cause an immediate
1941:../Generated_Code/tasks.c ****                                                 context switch if preemption is turned off. */
1942:../Generated_Code/tasks.c ****                                                 #if (  configUSE_PREEMPTION == 1 )
1943:../Generated_Code/tasks.c ****                                                 {
1944:../Generated_Code/tasks.c ****                                                         /* Preemption is on, but a context switch s
1945:../Generated_Code/tasks.c ****                                                         only be performed if the unblocked task has
1946:../Generated_Code/tasks.c ****                                                         priority that is equal to or higher than th
1947:../Generated_Code/tasks.c ****                                                         currently executing task. */
1948:../Generated_Code/tasks.c ****                                                         if( pxTCB->uxPriority >= pxCurrentTCB->uxPr
 2239              		.loc 1 1948 0 is_stmt 1
 2240 0110 BB68     		ldr	r3, [r7, #8]
 2241 0112 D96A     		ldr	r1, [r3, #44]
 2242 0114 264B     		ldr	r3, .L163+32
 2243 0116 1B68     		ldr	r3, [r3]
 2244 0118 DA6A     		ldr	r2, [r3, #44]
 2245 011a 0023     		mov	r3, #0
 2246 011c 9142     		cmp	r1, r2
 2247 011e 5B41     		adc	r3, r3, r3
 2248 0120 DBB2     		uxtb	r3, r3
 2249 0122 002B     		cmp	r3, #0
 2250 0124 A9D0     		beq	.L162
1949:../Generated_Code/tasks.c ****                                                         {
1950:../Generated_Code/tasks.c ****                                                                 xSwitchRequired = pdTRUE;
 2251              		.loc 1 1950 0
 2252 0126 0123     		mov	r3, #1
 2253 0128 7B61     		str	r3, [r7, #20]
1886:../Generated_Code/tasks.c ****                                 for( ;; )
 2254              		.loc 1 1886 0
 2255 012a A6E7     		b	.L162
 2256              	.L148:
 2257              	.LBE21:
1951:../Generated_Code/tasks.c ****                                                         }
1952:../Generated_Code/tasks.c ****                                                         else
1953:../Generated_Code/tasks.c ****                                                         {
1954:../Generated_Code/tasks.c ****                                                                 mtCOVERAGE_TEST_MARKER();
1955:../Generated_Code/tasks.c ****                                                         }
1956:../Generated_Code/tasks.c ****                                                 }
1957:../Generated_Code/tasks.c ****                                                 #endif /* configUSE_PREEMPTION */
1958:../Generated_Code/tasks.c ****                                         }
1959:../Generated_Code/tasks.c ****                                 }
1960:../Generated_Code/tasks.c ****                         }
1961:../Generated_Code/tasks.c ****                 }
1962:../Generated_Code/tasks.c **** 
1963:../Generated_Code/tasks.c ****                 /* Tasks of equal priority to the currently running task will share
1964:../Generated_Code/tasks.c ****                 processing time (time slice) if preemption is on, and the application
1965:../Generated_Code/tasks.c ****                 writer has not explicitly turned time slicing off. */
1966:../Generated_Code/tasks.c ****                 #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1967:../Generated_Code/tasks.c ****                 {
1968:../Generated_Code/tasks.c ****                         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority
 2258              		.loc 1 1968 0
 2259 012c 204B     		ldr	r3, .L163+32
 2260 012e 1B68     		ldr	r3, [r3]
 2261 0130 DA6A     		ldr	r2, [r3, #44]
 2262 0132 1E49     		ldr	r1, .L163+28
 2263 0134 131C     		mov	r3, r2
 2264 0136 9B00     		lsl	r3, r3, #2
 2265 0138 9B18     		add	r3, r3, r2
 2266 013a 9B00     		lsl	r3, r3, #2
 2267 013c 5B58     		ldr	r3, [r3, r1]
 2268 013e 0122     		mov	r2, #1
 2269 0140 9A42     		cmp	r2, r3
 2270 0142 9B41     		sbc	r3, r3, r3
 2271 0144 5B42     		neg	r3, r3
 2272 0146 DBB2     		uxtb	r3, r3
 2273 0148 002B     		cmp	r3, #0
 2274 014a 01D0     		beq	.L158
1969:../Generated_Code/tasks.c ****                         {
1970:../Generated_Code/tasks.c ****                                 xSwitchRequired = pdTRUE;
 2275              		.loc 1 1970 0
 2276 014c 0123     		mov	r3, #1
 2277 014e 7B61     		str	r3, [r7, #20]
 2278              	.L158:
 2279              	.LBB25:
 2280              	.LBB26:
1971:../Generated_Code/tasks.c ****                         }
1972:../Generated_Code/tasks.c ****                         else
1973:../Generated_Code/tasks.c ****                         {
1974:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1975:../Generated_Code/tasks.c ****                         }
1976:../Generated_Code/tasks.c ****                 }
1977:../Generated_Code/tasks.c ****                 #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1978:../Generated_Code/tasks.c **** 
1979:../Generated_Code/tasks.c ****                 #if ( configUSE_TICK_HOOK == 1 )
1980:../Generated_Code/tasks.c ****                 {
1981:../Generated_Code/tasks.c ****                         /* Guard against the tick hook being called when the pended tick
1982:../Generated_Code/tasks.c ****                         count is being unwound (when the scheduler is being unlocked). */
1983:../Generated_Code/tasks.c ****                         if( uxPendedTicks == ( UBaseType_t ) 0U )
 2281              		.loc 1 1983 0
 2282 0150 184B     		ldr	r3, .L163+36
 2283 0152 1B68     		ldr	r3, [r3]
 2284 0154 5A42     		neg	r2, r3
 2285 0156 5341     		adc	r3, r3, r2
 2286 0158 DBB2     		uxtb	r3, r3
 2287 015a 002B     		cmp	r3, #0
 2288 015c 09D0     		beq	.L159
 2289              	.LBB27:
1984:../Generated_Code/tasks.c ****                         {
1985:../Generated_Code/tasks.c ****       extern void vApplicationTickHook( void );
1986:../Generated_Code/tasks.c ****       FreeRTOS0_vApplicationTickHook();
 2290              		.loc 1 1986 0
 2291 015e FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationTickHookv
 2292 0162 06E0     		b	.L159
 2293              	.L144:
 2294              	.LBE27:
 2295              	.LBE26:
 2296              	.LBE25:
 2297              	.LBE20:
1987:../Generated_Code/tasks.c ****                         }
1988:../Generated_Code/tasks.c ****                         else
1989:../Generated_Code/tasks.c ****                         {
1990:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
1991:../Generated_Code/tasks.c ****                         }
1992:../Generated_Code/tasks.c ****                 }
1993:../Generated_Code/tasks.c ****                 #endif /* configUSE_TICK_HOOK */
1994:../Generated_Code/tasks.c ****         }
1995:../Generated_Code/tasks.c ****         else
1996:../Generated_Code/tasks.c ****         {
1997:../Generated_Code/tasks.c ****                 ++uxPendedTicks;
 2298              		.loc 1 1997 0
 2299 0164 134B     		ldr	r3, .L163+36
 2300 0166 1B68     		ldr	r3, [r3]
 2301 0168 5A1C     		add	r2, r3, #1
 2302 016a 124B     		ldr	r3, .L163+36
 2303 016c 1A60     		str	r2, [r3]
1998:../Generated_Code/tasks.c **** 
1999:../Generated_Code/tasks.c ****                 /* The tick hook gets called at regular intervals, even if the
2000:../Generated_Code/tasks.c ****                 scheduler is locked. */
2001:../Generated_Code/tasks.c ****                 #if ( configUSE_TICK_HOOK == 1 )
2002:../Generated_Code/tasks.c ****                 {
2003:../Generated_Code/tasks.c ****       FreeRTOS0_vApplicationTickHook();
 2304              		.loc 1 2003 0
 2305 016e FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationTickHookv
 2306              	.L159:
 2307              	.LBE19:
2004:../Generated_Code/tasks.c ****                 }
2005:../Generated_Code/tasks.c ****                 #endif
2006:../Generated_Code/tasks.c ****         }
2007:../Generated_Code/tasks.c **** 
2008:../Generated_Code/tasks.c ****         #if ( configUSE_PREEMPTION == 1 )
2009:../Generated_Code/tasks.c ****         {
2010:../Generated_Code/tasks.c ****                 if( xYieldPending != pdFALSE )
 2308              		.loc 1 2010 0
 2309 0172 114B     		ldr	r3, .L163+40
 2310 0174 1B68     		ldr	r3, [r3]
 2311 0176 5A1E     		sub	r2, r3, #1
 2312 0178 9341     		sbc	r3, r3, r2
 2313 017a DBB2     		uxtb	r3, r3
 2314 017c 002B     		cmp	r3, #0
 2315 017e 01D0     		beq	.L160
2011:../Generated_Code/tasks.c ****                 {
2012:../Generated_Code/tasks.c ****                         xSwitchRequired = pdTRUE;
 2316              		.loc 1 2012 0
 2317 0180 0123     		mov	r3, #1
 2318 0182 7B61     		str	r3, [r7, #20]
 2319              	.L160:
2013:../Generated_Code/tasks.c ****                 }
2014:../Generated_Code/tasks.c ****                 else
2015:../Generated_Code/tasks.c ****                 {
2016:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2017:../Generated_Code/tasks.c ****                 }
2018:../Generated_Code/tasks.c ****         }
2019:../Generated_Code/tasks.c ****         #endif /* configUSE_PREEMPTION */
2020:../Generated_Code/tasks.c **** 
2021:../Generated_Code/tasks.c ****         return xSwitchRequired;
 2320              		.loc 1 2021 0
 2321 0184 7B69     		ldr	r3, [r7, #20]
 2322              	.LBE18:
2022:../Generated_Code/tasks.c **** }
 2323              		.loc 1 2022 0
 2324 0186 181C     		mov	r0, r3
 2325 0188 BD46     		mov	sp, r7
 2326 018a 06B0     		add	sp, sp, #24
 2327              		@ sp needed for prologue
 2328 018c 80BD     		pop	{r7, pc}
 2329              	.L164:
 2330 018e C046     		.align	2
 2331              	.L163:
 2332 0190 00000000 		.word	_ZL20uxSchedulerSuspended
 2333 0194 00000000 		.word	_ZL10xTickCount
 2334 0198 00000000 		.word	_ZL17pxDelayedTaskList
 2335 019c 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 2336 01a0 00000000 		.word	_ZL15xNumOfOverflows
 2337 01a4 00000000 		.word	_ZL20xNextTaskUnblockTime
 2338 01a8 00000000 		.word	_ZL18uxTopReadyPriority
 2339 01ac 00000000 		.word	_ZL17pxReadyTasksLists
 2340 01b0 00000000 		.word	pxCurrentTCB
 2341 01b4 00000000 		.word	_ZL13uxPendedTicks
 2342 01b8 00000000 		.word	_ZL13xYieldPending
 2343              		.cfi_endproc
 2344              	.LFE25:
 2346              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2347              		.align	2
 2348              		.global	vTaskSwitchContext
 2349              		.code	16
 2350              		.thumb_func
 2352              	vTaskSwitchContext:
 2353              	.LFB26:
2023:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2024:../Generated_Code/tasks.c **** 
2025:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2026:../Generated_Code/tasks.c **** 
2027:../Generated_Code/tasks.c ****         void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2028:../Generated_Code/tasks.c ****         {
2029:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2030:../Generated_Code/tasks.c **** 
2031:../Generated_Code/tasks.c ****                 /* If xTask is NULL then it is the task hook of the calling task that is
2032:../Generated_Code/tasks.c ****                 getting set. */
2033:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2034:../Generated_Code/tasks.c ****                 {
2035:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2036:../Generated_Code/tasks.c ****                 }
2037:../Generated_Code/tasks.c ****                 else
2038:../Generated_Code/tasks.c ****                 {
2039:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2040:../Generated_Code/tasks.c ****                 }
2041:../Generated_Code/tasks.c **** 
2042:../Generated_Code/tasks.c ****                 /* Save the hook function in the TCB.  A critical section is required as
2043:../Generated_Code/tasks.c ****                 the value can be accessed from an interrupt. */
2044:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
2045:../Generated_Code/tasks.c ****                         xTCB->pxTaskTag = pxHookFunction;
2046:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
2047:../Generated_Code/tasks.c ****         }
2048:../Generated_Code/tasks.c **** 
2049:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2050:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2051:../Generated_Code/tasks.c **** 
2052:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2053:../Generated_Code/tasks.c **** 
2054:../Generated_Code/tasks.c ****         TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2055:../Generated_Code/tasks.c ****         {
2056:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2057:../Generated_Code/tasks.c ****         TaskHookFunction_t xReturn;
2058:../Generated_Code/tasks.c **** 
2059:../Generated_Code/tasks.c ****                 /* If xTask is NULL then we are setting our own task hook. */
2060:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2061:../Generated_Code/tasks.c ****                 {
2062:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2063:../Generated_Code/tasks.c ****                 }
2064:../Generated_Code/tasks.c ****                 else
2065:../Generated_Code/tasks.c ****                 {
2066:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2067:../Generated_Code/tasks.c ****                 }
2068:../Generated_Code/tasks.c **** 
2069:../Generated_Code/tasks.c ****                 /* Save the hook function in the TCB.  A critical section is required as
2070:../Generated_Code/tasks.c ****                 the value can be accessed from an interrupt. */
2071:../Generated_Code/tasks.c ****                 taskENTER_CRITICAL();
2072:../Generated_Code/tasks.c ****                 {
2073:../Generated_Code/tasks.c ****                         xReturn = xTCB->pxTaskTag;
2074:../Generated_Code/tasks.c ****                 }
2075:../Generated_Code/tasks.c ****                 taskEXIT_CRITICAL();
2076:../Generated_Code/tasks.c **** 
2077:../Generated_Code/tasks.c ****                 return xReturn;
2078:../Generated_Code/tasks.c ****         }
2079:../Generated_Code/tasks.c **** 
2080:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2081:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2082:../Generated_Code/tasks.c **** 
2083:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2084:../Generated_Code/tasks.c **** 
2085:../Generated_Code/tasks.c ****         BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2086:../Generated_Code/tasks.c ****         {
2087:../Generated_Code/tasks.c ****         TCB_t *xTCB;
2088:../Generated_Code/tasks.c ****         BaseType_t xReturn;
2089:../Generated_Code/tasks.c **** 
2090:../Generated_Code/tasks.c ****                 /* If xTask is NULL then we are calling our own task hook. */
2091:../Generated_Code/tasks.c ****                 if( xTask == NULL )
2092:../Generated_Code/tasks.c ****                 {
2093:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) pxCurrentTCB;
2094:../Generated_Code/tasks.c ****                 }
2095:../Generated_Code/tasks.c ****                 else
2096:../Generated_Code/tasks.c ****                 {
2097:../Generated_Code/tasks.c ****                         xTCB = ( TCB_t * ) xTask;
2098:../Generated_Code/tasks.c ****                 }
2099:../Generated_Code/tasks.c **** 
2100:../Generated_Code/tasks.c ****                 if( xTCB->pxTaskTag != NULL )
2101:../Generated_Code/tasks.c ****                 {
2102:../Generated_Code/tasks.c ****                         xReturn = xTCB->pxTaskTag( pvParameter );
2103:../Generated_Code/tasks.c ****                 }
2104:../Generated_Code/tasks.c ****                 else
2105:../Generated_Code/tasks.c ****                 {
2106:../Generated_Code/tasks.c ****                         xReturn = pdFAIL;
2107:../Generated_Code/tasks.c ****                 }
2108:../Generated_Code/tasks.c **** 
2109:../Generated_Code/tasks.c ****                 return xReturn;
2110:../Generated_Code/tasks.c ****         }
2111:../Generated_Code/tasks.c **** 
2112:../Generated_Code/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2113:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2114:../Generated_Code/tasks.c **** 
2115:../Generated_Code/tasks.c **** void vTaskSwitchContext( void )
2116:../Generated_Code/tasks.c **** {
 2354              		.loc 1 2116 0
 2355              		.cfi_startproc
 2356 0000 80B5     		push	{r7, lr}
 2357              	.LCFI48:
 2358              		.cfi_def_cfa_offset 8
 2359              		.cfi_offset 7, -8
 2360              		.cfi_offset 14, -4
 2361 0002 82B0     		sub	sp, sp, #8
 2362              	.LCFI49:
 2363              		.cfi_def_cfa_offset 16
 2364 0004 00AF     		add	r7, sp, #0
 2365              	.LCFI50:
 2366              		.cfi_def_cfa_register 7
 2367              	.LBB28:
 2368              	.LBB29:
2117:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2369              		.loc 1 2117 0
 2370 0006 304B     		ldr	r3, .L174
 2371 0008 1B68     		ldr	r3, [r3]
 2372 000a 5A1E     		sub	r2, r3, #1
 2373 000c 9341     		sbc	r3, r3, r2
 2374 000e DBB2     		uxtb	r3, r3
 2375 0010 002B     		cmp	r3, #0
 2376 0012 03D0     		beq	.L166
2118:../Generated_Code/tasks.c ****         {
2119:../Generated_Code/tasks.c ****                 /* The scheduler is currently suspended - do not allow a context
2120:../Generated_Code/tasks.c ****                 switch. */
2121:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 2377              		.loc 1 2121 0
 2378 0014 2D4B     		ldr	r3, .L174+4
 2379 0016 0122     		mov	r2, #1
 2380 0018 1A60     		str	r2, [r3]
 2381 001a 51E0     		b	.L165
 2382              	.L166:
 2383              	.LBB30:
2122:../Generated_Code/tasks.c ****         }
2123:../Generated_Code/tasks.c ****         else
2124:../Generated_Code/tasks.c ****         {
2125:../Generated_Code/tasks.c ****                 xYieldPending = pdFALSE;
 2384              		.loc 1 2125 0
 2385 001c 2B4B     		ldr	r3, .L174+4
 2386 001e 0022     		mov	r2, #0
 2387 0020 1A60     		str	r2, [r3]
2126:../Generated_Code/tasks.c ****                 traceTASK_SWITCHED_OUT();
2127:../Generated_Code/tasks.c **** 
2128:../Generated_Code/tasks.c ****                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2129:../Generated_Code/tasks.c ****                 {
2130:../Generated_Code/tasks.c ****                                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2131:../Generated_Code/tasks.c ****                                         portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2132:../Generated_Code/tasks.c ****                                 #else
2133:../Generated_Code/tasks.c ****                                         ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2134:../Generated_Code/tasks.c ****                                 #endif
2135:../Generated_Code/tasks.c **** 
2136:../Generated_Code/tasks.c ****                                 /* Add the amount of time the task has been running to the
2137:../Generated_Code/tasks.c ****                                 accumulated     time so far.  The time the task started running was
2138:../Generated_Code/tasks.c ****                                 stored in ulTaskSwitchedInTime.  Note that there is no overflow
2139:../Generated_Code/tasks.c ****                                 protection here so count values are only valid until the timer
2140:../Generated_Code/tasks.c ****                                 overflows.  The guard against negative values is to protect
2141:../Generated_Code/tasks.c ****                                 against suspect run time stat counter implementations - which
2142:../Generated_Code/tasks.c ****                                 are provided by the application, not the kernel. */
2143:../Generated_Code/tasks.c ****                                 if( ulTotalRunTime > ulTaskSwitchedInTime )
2144:../Generated_Code/tasks.c ****                                 {
2145:../Generated_Code/tasks.c ****                                         pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTask
2146:../Generated_Code/tasks.c ****                                 }
2147:../Generated_Code/tasks.c ****                                 else
2148:../Generated_Code/tasks.c ****                                 {
2149:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
2150:../Generated_Code/tasks.c ****                                 }
2151:../Generated_Code/tasks.c ****                                 ulTaskSwitchedInTime = ulTotalRunTime;
2152:../Generated_Code/tasks.c ****                 }
2153:../Generated_Code/tasks.c ****                 #endif /* configGENERATE_RUN_TIME_STATS */
2154:../Generated_Code/tasks.c **** 
2155:../Generated_Code/tasks.c ****                 taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2388              		.loc 1 2155 0
 2389 0022 2B4B     		ldr	r3, .L174+8
 2390 0024 1B68     		ldr	r3, [r3]
 2391 0026 1A68     		ldr	r2, [r3]
 2392 0028 294B     		ldr	r3, .L174+8
 2393 002a 1B68     		ldr	r3, [r3]
 2394 002c 196B     		ldr	r1, [r3, #48]
 2395 002e 0023     		mov	r3, #0
 2396 0030 9142     		cmp	r1, r2
 2397 0032 5B41     		adc	r3, r3, r3
 2398 0034 DBB2     		uxtb	r3, r3
 2399 0036 002B     		cmp	r3, #0
 2400 0038 17D0     		beq	.L169
 2401              		.loc 1 2155 0 is_stmt 0
 2402 003a 254B     		ldr	r3, .L174+8
 2403 003c 1A68     		ldr	r2, [r3]
 2404 003e 244B     		ldr	r3, .L174+8
 2405 0040 1B68     		ldr	r3, [r3]
 2406 0042 3433     		add	r3, r3, #52
 2407 0044 101C     		mov	r0, r2
 2408 0046 191C     		mov	r1, r3
 2409 0048 FFF7FEFF 		bl	_Z39FreeRTOS0_vApplicationStackOverflowHookPvPc
 2410              	.LBB31:
2156:../Generated_Code/tasks.c ****                 taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2157:../Generated_Code/tasks.c **** 
2158:../Generated_Code/tasks.c ****                 taskSELECT_HIGHEST_PRIORITY_TASK();
 2411              		.loc 1 2158 0 is_stmt 1
 2412 004c 0DE0     		b	.L169
 2413              	.L172:
 2414              		.loc 1 2158 0 is_stmt 0
 2415 004e 214B     		ldr	r3, .L174+12
 2416 0050 1B68     		ldr	r3, [r3]
 2417 0052 5A42     		neg	r2, r3
 2418 0054 5341     		adc	r3, r3, r2
 2419 0056 DBB2     		uxtb	r3, r3
 2420 0058 002B     		cmp	r3, #0
 2421 005a 01D0     		beq	.L170
 2422              		.loc 1 2158 0
 2423              	@ 2158 "../Generated_Code/tasks.c" 1
 2424 005c 72B6     		cpsid i
 2425              	@ 0 "" 2
 2426              		.code	16
 2427              	.L171:
 2428              		.loc 1 2158 0
 2429 005e FEE7     		b	.L171
 2430              	.L170:
 2431              		.loc 1 2158 0
 2432 0060 1C4B     		ldr	r3, .L174+12
 2433 0062 1B68     		ldr	r3, [r3]
 2434 0064 5A1E     		sub	r2, r3, #1
 2435 0066 1B4B     		ldr	r3, .L174+12
 2436 0068 1A60     		str	r2, [r3]
 2437              	.L169:
 2438              		.loc 1 2158 0
 2439 006a 1A4B     		ldr	r3, .L174+12
 2440 006c 1A68     		ldr	r2, [r3]
 2441 006e 1A49     		ldr	r1, .L174+16
 2442 0070 131C     		mov	r3, r2
 2443 0072 9B00     		lsl	r3, r3, #2
 2444 0074 9B18     		add	r3, r3, r2
 2445 0076 9B00     		lsl	r3, r3, #2
 2446 0078 5B58     		ldr	r3, [r3, r1]
 2447 007a 5A42     		neg	r2, r3
 2448 007c 5341     		adc	r3, r3, r2
 2449 007e DBB2     		uxtb	r3, r3
 2450 0080 002B     		cmp	r3, #0
 2451 0082 E4D1     		bne	.L172
 2452              	.LBB32:
 2453              		.loc 1 2158 0
 2454 0084 134B     		ldr	r3, .L174+12
 2455 0086 1A68     		ldr	r2, [r3]
 2456 0088 131C     		mov	r3, r2
 2457 008a 9B00     		lsl	r3, r3, #2
 2458 008c 9B18     		add	r3, r3, r2
 2459 008e 9B00     		lsl	r3, r3, #2
 2460 0090 114A     		ldr	r2, .L174+16
 2461 0092 9B18     		add	r3, r3, r2
 2462 0094 7B60     		str	r3, [r7, #4]
 2463 0096 7B68     		ldr	r3, [r7, #4]
 2464 0098 5B68     		ldr	r3, [r3, #4]
 2465 009a 5A68     		ldr	r2, [r3, #4]
 2466 009c 7B68     		ldr	r3, [r7, #4]
 2467 009e 5A60     		str	r2, [r3, #4]
 2468 00a0 7B68     		ldr	r3, [r7, #4]
 2469 00a2 5A68     		ldr	r2, [r3, #4]
 2470 00a4 7B68     		ldr	r3, [r7, #4]
 2471 00a6 0833     		add	r3, r3, #8
 2472 00a8 9A42     		cmp	r2, r3
 2473 00aa 04D1     		bne	.L173
 2474              		.loc 1 2158 0
 2475 00ac 7B68     		ldr	r3, [r7, #4]
 2476 00ae 5B68     		ldr	r3, [r3, #4]
 2477 00b0 5A68     		ldr	r2, [r3, #4]
 2478 00b2 7B68     		ldr	r3, [r7, #4]
 2479 00b4 5A60     		str	r2, [r3, #4]
 2480              	.L173:
 2481              		.loc 1 2158 0
 2482 00b6 7B68     		ldr	r3, [r7, #4]
 2483 00b8 5B68     		ldr	r3, [r3, #4]
 2484 00ba DA68     		ldr	r2, [r3, #12]
 2485 00bc 044B     		ldr	r3, .L174+8
 2486 00be 1A60     		str	r2, [r3]
 2487              	.L165:
 2488              	.LBE32:
 2489              	.LBE31:
 2490              	.LBE30:
 2491              	.LBE29:
 2492              	.LBE28:
2159:../Generated_Code/tasks.c **** 
2160:../Generated_Code/tasks.c ****                 traceTASK_SWITCHED_IN();
2161:../Generated_Code/tasks.c **** 
2162:../Generated_Code/tasks.c ****                 #if ( configUSE_NEWLIB_REENTRANT == 1 )
2163:../Generated_Code/tasks.c ****                 {
2164:../Generated_Code/tasks.c ****                         /* Switch Newlib's _impure_ptr variable to point to the _reent
2165:../Generated_Code/tasks.c ****                         structure specific to this task. */
2166:../Generated_Code/tasks.c ****                         _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2167:../Generated_Code/tasks.c ****                 }
2168:../Generated_Code/tasks.c ****                 #endif /* configUSE_NEWLIB_REENTRANT */
2169:../Generated_Code/tasks.c ****         }
2170:../Generated_Code/tasks.c **** }
 2493              		.loc 1 2170 0 is_stmt 1
 2494 00c0 BD46     		mov	sp, r7
 2495 00c2 02B0     		add	sp, sp, #8
 2496              		@ sp needed for prologue
 2497 00c4 80BD     		pop	{r7, pc}
 2498              	.L175:
 2499 00c6 C046     		.align	2
 2500              	.L174:
 2501 00c8 00000000 		.word	_ZL20uxSchedulerSuspended
 2502 00cc 00000000 		.word	_ZL13xYieldPending
 2503 00d0 00000000 		.word	pxCurrentTCB
 2504 00d4 00000000 		.word	_ZL18uxTopReadyPriority
 2505 00d8 00000000 		.word	_ZL17pxReadyTasksLists
 2506              		.cfi_endproc
 2507              	.LFE26:
 2509              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2510              		.align	2
 2511              		.global	vTaskPlaceOnEventList
 2512              		.code	16
 2513              		.thumb_func
 2515              	vTaskPlaceOnEventList:
 2516              	.LFB27:
2171:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2172:../Generated_Code/tasks.c **** 
2173:../Generated_Code/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2174:../Generated_Code/tasks.c **** {
 2517              		.loc 1 2174 0
 2518              		.cfi_startproc
 2519 0000 80B5     		push	{r7, lr}
 2520              	.LCFI51:
 2521              		.cfi_def_cfa_offset 8
 2522              		.cfi_offset 7, -8
 2523              		.cfi_offset 14, -4
 2524 0002 84B0     		sub	sp, sp, #16
 2525              	.LCFI52:
 2526              		.cfi_def_cfa_offset 24
 2527 0004 00AF     		add	r7, sp, #0
 2528              	.LCFI53:
 2529              		.cfi_def_cfa_register 7
 2530 0006 7860     		str	r0, [r7, #4]
 2531 0008 3960     		str	r1, [r7]
 2532              	.LBB33:
2175:../Generated_Code/tasks.c **** TickType_t xTimeToWake;
2176:../Generated_Code/tasks.c **** 
2177:../Generated_Code/tasks.c ****         configASSERT( pxEventList );
 2533              		.loc 1 2177 0
 2534 000a 7B68     		ldr	r3, [r7, #4]
 2535 000c 002B     		cmp	r3, #0
 2536 000e 01D1     		bne	.L177
 2537              		.loc 1 2177 0 is_stmt 0
 2538              	@ 2177 "../Generated_Code/tasks.c" 1
 2539 0010 72B6     		cpsid i
 2540              	@ 0 "" 2
 2541              		.code	16
 2542              	.L178:
 2543              		.loc 1 2177 0
 2544 0012 FEE7     		b	.L178
 2545              	.L177:
2178:../Generated_Code/tasks.c **** 
2179:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2180:../Generated_Code/tasks.c ****         SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2181:../Generated_Code/tasks.c **** 
2182:../Generated_Code/tasks.c ****         /* Place the event list item of the TCB in the appropriate event list.
2183:../Generated_Code/tasks.c ****         This is placed in the list in priority order so the highest priority task
2184:../Generated_Code/tasks.c ****         is the first to be woken by the event.  The queue that contains the event
2185:../Generated_Code/tasks.c ****         list is locked, preventing simultaneous access from interrupts. */
2186:../Generated_Code/tasks.c ****         vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2546              		.loc 1 2186 0 is_stmt 1
 2547 0014 124B     		ldr	r3, .L181
 2548 0016 1B68     		ldr	r3, [r3]
 2549 0018 1833     		add	r3, r3, #24
 2550 001a 7A68     		ldr	r2, [r7, #4]
 2551 001c 101C     		mov	r0, r2
 2552 001e 191C     		mov	r1, r3
 2553 0020 FFF7FEFF 		bl	vListInsert
2187:../Generated_Code/tasks.c **** 
2188:../Generated_Code/tasks.c ****         /* The task must be removed from from the ready list before it is added to
2189:../Generated_Code/tasks.c ****         the blocked list as the same list item is used for both lists.  Exclusive
2190:../Generated_Code/tasks.c ****         access to the ready lists guaranteed because the scheduler is locked. */
2191:../Generated_Code/tasks.c ****         if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2554              		.loc 1 2191 0
 2555 0024 0E4B     		ldr	r3, .L181
 2556 0026 1B68     		ldr	r3, [r3]
 2557 0028 0433     		add	r3, r3, #4
 2558 002a 181C     		mov	r0, r3
 2559 002c FFF7FEFF 		bl	uxListRemove
2192:../Generated_Code/tasks.c ****         {
2193:../Generated_Code/tasks.c ****                 /* The current task must be in a ready list, so there is no need to
2194:../Generated_Code/tasks.c ****                 check, and the port reset macro can be called directly. */
2195:../Generated_Code/tasks.c ****                 portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2196:../Generated_Code/tasks.c ****         }
2197:../Generated_Code/tasks.c ****         else
2198:../Generated_Code/tasks.c ****         {
2199:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2200:../Generated_Code/tasks.c ****         }
2201:../Generated_Code/tasks.c **** 
2202:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2203:../Generated_Code/tasks.c ****         {
2204:../Generated_Code/tasks.c ****                 if( xTicksToWait == portMAX_DELAY )
 2560              		.loc 1 2204 0
 2561 0030 3B68     		ldr	r3, [r7]
 2562 0032 0133     		add	r3, r3, #1
 2563 0034 08D1     		bne	.L179
2205:../Generated_Code/tasks.c ****                 {
2206:../Generated_Code/tasks.c ****                         /* Add the task to the suspended task list instead of a delayed task
2207:../Generated_Code/tasks.c ****                         list to ensure the task is not woken by a timing event.  It will
2208:../Generated_Code/tasks.c ****                         block indefinitely. */
2209:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2564              		.loc 1 2209 0
 2565 0036 0A4B     		ldr	r3, .L181
 2566 0038 1B68     		ldr	r3, [r3]
 2567 003a 0433     		add	r3, r3, #4
 2568 003c 094A     		ldr	r2, .L181+4
 2569 003e 101C     		mov	r0, r2
 2570 0040 191C     		mov	r1, r3
 2571 0042 FFF7FEFF 		bl	vListInsertEnd
 2572 0046 08E0     		b	.L176
 2573              	.L179:
2210:../Generated_Code/tasks.c ****                 }
2211:../Generated_Code/tasks.c ****                 else
2212:../Generated_Code/tasks.c ****                 {
2213:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event
2214:../Generated_Code/tasks.c ****                         does not occur.  This may overflow but this doesn't matter, the
2215:../Generated_Code/tasks.c ****                         scheduler will handle it. */
2216:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
 2574              		.loc 1 2216 0
 2575 0048 074B     		ldr	r3, .L181+8
 2576 004a 1A68     		ldr	r2, [r3]
 2577 004c 3B68     		ldr	r3, [r7]
 2578 004e D318     		add	r3, r2, r3
 2579 0050 FB60     		str	r3, [r7, #12]
2217:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
 2580              		.loc 1 2217 0
 2581 0052 FB68     		ldr	r3, [r7, #12]
 2582 0054 181C     		mov	r0, r3
 2583 0056 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 2584              	.L176:
 2585              	.LBE33:
2218:../Generated_Code/tasks.c ****                 }
2219:../Generated_Code/tasks.c ****         }
2220:../Generated_Code/tasks.c ****         #else /* INCLUDE_vTaskSuspend */
2221:../Generated_Code/tasks.c ****         {
2222:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event does
2223:../Generated_Code/tasks.c ****                         not occur.  This may overflow but this doesn't matter, the scheduler
2224:../Generated_Code/tasks.c ****                         will handle it. */
2225:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
2226:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
2227:../Generated_Code/tasks.c ****         }
2228:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2229:../Generated_Code/tasks.c **** }
 2586              		.loc 1 2229 0
 2587 005a BD46     		mov	sp, r7
 2588 005c 04B0     		add	sp, sp, #16
 2589              		@ sp needed for prologue
 2590 005e 80BD     		pop	{r7, pc}
 2591              	.L182:
 2592              		.align	2
 2593              	.L181:
 2594 0060 00000000 		.word	pxCurrentTCB
 2595 0064 00000000 		.word	_ZL18xSuspendedTaskList
 2596 0068 00000000 		.word	_ZL10xTickCount
 2597              		.cfi_endproc
 2598              	.LFE27:
 2600              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2601              		.align	2
 2602              		.global	vTaskPlaceOnUnorderedEventList
 2603              		.code	16
 2604              		.thumb_func
 2606              	vTaskPlaceOnUnorderedEventList:
 2607              	.LFB28:
2230:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2231:../Generated_Code/tasks.c **** 
2232:../Generated_Code/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2233:../Generated_Code/tasks.c **** {
 2608              		.loc 1 2233 0
 2609              		.cfi_startproc
 2610 0000 80B5     		push	{r7, lr}
 2611              	.LCFI54:
 2612              		.cfi_def_cfa_offset 8
 2613              		.cfi_offset 7, -8
 2614              		.cfi_offset 14, -4
 2615 0002 86B0     		sub	sp, sp, #24
 2616              	.LCFI55:
 2617              		.cfi_def_cfa_offset 32
 2618 0004 00AF     		add	r7, sp, #0
 2619              	.LCFI56:
 2620              		.cfi_def_cfa_register 7
 2621 0006 F860     		str	r0, [r7, #12]
 2622 0008 B960     		str	r1, [r7, #8]
 2623 000a 7A60     		str	r2, [r7, #4]
 2624              	.LBB34:
2234:../Generated_Code/tasks.c **** TickType_t xTimeToWake;
2235:../Generated_Code/tasks.c **** 
2236:../Generated_Code/tasks.c ****         configASSERT( pxEventList );
 2625              		.loc 1 2236 0
 2626 000c FB68     		ldr	r3, [r7, #12]
 2627 000e 002B     		cmp	r3, #0
 2628 0010 01D1     		bne	.L184
 2629              		.loc 1 2236 0 is_stmt 0
 2630              	@ 2236 "../Generated_Code/tasks.c" 1
 2631 0012 72B6     		cpsid i
 2632              	@ 0 "" 2
 2633              		.code	16
 2634              	.L185:
 2635              		.loc 1 2236 0
 2636 0014 FEE7     		b	.L185
 2637              	.L184:
2237:../Generated_Code/tasks.c **** 
2238:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2239:../Generated_Code/tasks.c ****         the event groups implementation. */
2240:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended != 0 );
 2638              		.loc 1 2240 0 is_stmt 1
 2639 0016 1B4B     		ldr	r3, .L190
 2640 0018 1B68     		ldr	r3, [r3]
 2641 001a 5A42     		neg	r2, r3
 2642 001c 5341     		adc	r3, r3, r2
 2643 001e DBB2     		uxtb	r3, r3
 2644 0020 002B     		cmp	r3, #0
 2645 0022 01D0     		beq	.L186
 2646              		.loc 1 2240 0 is_stmt 0
 2647              	@ 2240 "../Generated_Code/tasks.c" 1
 2648 0024 72B6     		cpsid i
 2649              	@ 0 "" 2
 2650              		.code	16
 2651              	.L187:
 2652              		.loc 1 2240 0
 2653 0026 FEE7     		b	.L187
 2654              	.L186:
2241:../Generated_Code/tasks.c **** 
2242:../Generated_Code/tasks.c ****         /* Store the item value in the event list item.  It is safe to access the
2243:../Generated_Code/tasks.c ****         event list item here as interrupts won't access the event list item of a
2244:../Generated_Code/tasks.c ****         task that is not in the Blocked state. */
2245:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITE
 2655              		.loc 1 2245 0 is_stmt 1
 2656 0028 174B     		ldr	r3, .L190+4
 2657 002a 1B68     		ldr	r3, [r3]
 2658 002c BA68     		ldr	r2, [r7, #8]
 2659 002e 8021     		mov	r1, #128
 2660 0030 0906     		lsl	r1, r1, #24
 2661 0032 0A43     		orr	r2, r1
 2662 0034 9A61     		str	r2, [r3, #24]
2246:../Generated_Code/tasks.c **** 
2247:../Generated_Code/tasks.c ****         /* Place the event list item of the TCB at the end of the appropriate event
2248:../Generated_Code/tasks.c ****         list.  It is safe to access the event list here because it is part of an
2249:../Generated_Code/tasks.c ****         event group implementation - and interrupts don't access event groups
2250:../Generated_Code/tasks.c ****         directly (instead they access them indirectly by pending function calls to
2251:../Generated_Code/tasks.c ****         the task level). */
2252:../Generated_Code/tasks.c ****         vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2663              		.loc 1 2252 0
 2664 0036 144B     		ldr	r3, .L190+4
 2665 0038 1B68     		ldr	r3, [r3]
 2666 003a 1833     		add	r3, r3, #24
 2667 003c FA68     		ldr	r2, [r7, #12]
 2668 003e 101C     		mov	r0, r2
 2669 0040 191C     		mov	r1, r3
 2670 0042 FFF7FEFF 		bl	vListInsertEnd
2253:../Generated_Code/tasks.c **** 
2254:../Generated_Code/tasks.c ****         /* The task must be removed from the ready list before it is added to the
2255:../Generated_Code/tasks.c ****         blocked list.  Exclusive access can be assured to the ready list as the
2256:../Generated_Code/tasks.c ****         scheduler is locked. */
2257:../Generated_Code/tasks.c ****         if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2671              		.loc 1 2257 0
 2672 0046 104B     		ldr	r3, .L190+4
 2673 0048 1B68     		ldr	r3, [r3]
 2674 004a 0433     		add	r3, r3, #4
 2675 004c 181C     		mov	r0, r3
 2676 004e FFF7FEFF 		bl	uxListRemove
2258:../Generated_Code/tasks.c ****         {
2259:../Generated_Code/tasks.c ****                 /* The current task must be in a ready list, so there is no need to
2260:../Generated_Code/tasks.c ****                 check, and the port reset macro can be called directly. */
2261:../Generated_Code/tasks.c ****                 portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2262:../Generated_Code/tasks.c ****         }
2263:../Generated_Code/tasks.c ****         else
2264:../Generated_Code/tasks.c ****         {
2265:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2266:../Generated_Code/tasks.c ****         }
2267:../Generated_Code/tasks.c **** 
2268:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2269:../Generated_Code/tasks.c ****         {
2270:../Generated_Code/tasks.c ****                 if( xTicksToWait == portMAX_DELAY )
 2677              		.loc 1 2270 0
 2678 0052 7B68     		ldr	r3, [r7, #4]
 2679 0054 0133     		add	r3, r3, #1
 2680 0056 08D1     		bne	.L188
2271:../Generated_Code/tasks.c ****                 {
2272:../Generated_Code/tasks.c ****                         /* Add the task to the suspended task list instead of a delayed task
2273:../Generated_Code/tasks.c ****                         list to ensure it is not woken by a timing event.  It will block
2274:../Generated_Code/tasks.c ****                         indefinitely. */
2275:../Generated_Code/tasks.c ****                         vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2681              		.loc 1 2275 0
 2682 0058 0B4B     		ldr	r3, .L190+4
 2683 005a 1B68     		ldr	r3, [r3]
 2684 005c 0433     		add	r3, r3, #4
 2685 005e 0B4A     		ldr	r2, .L190+8
 2686 0060 101C     		mov	r0, r2
 2687 0062 191C     		mov	r1, r3
 2688 0064 FFF7FEFF 		bl	vListInsertEnd
 2689 0068 08E0     		b	.L183
 2690              	.L188:
2276:../Generated_Code/tasks.c ****                 }
2277:../Generated_Code/tasks.c ****                 else
2278:../Generated_Code/tasks.c ****                 {
2279:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event
2280:../Generated_Code/tasks.c ****                         does not occur.  This may overflow but this doesn't matter, the
2281:../Generated_Code/tasks.c ****                         kernel will manage it correctly. */
2282:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
 2691              		.loc 1 2282 0
 2692 006a 094B     		ldr	r3, .L190+12
 2693 006c 1A68     		ldr	r2, [r3]
 2694 006e 7B68     		ldr	r3, [r7, #4]
 2695 0070 D318     		add	r3, r2, r3
 2696 0072 7B61     		str	r3, [r7, #20]
2283:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
 2697              		.loc 1 2283 0
 2698 0074 7B69     		ldr	r3, [r7, #20]
 2699 0076 181C     		mov	r0, r3
 2700 0078 FFF7FEFF 		bl	_ZL30prvAddCurrentTaskToDelayedListm
 2701              	.L183:
 2702              	.LBE34:
2284:../Generated_Code/tasks.c ****                 }
2285:../Generated_Code/tasks.c ****         }
2286:../Generated_Code/tasks.c ****         #else /* INCLUDE_vTaskSuspend */
2287:../Generated_Code/tasks.c ****         {
2288:../Generated_Code/tasks.c ****                         /* Calculate the time at which the task should be woken if the event does
2289:../Generated_Code/tasks.c ****                         not occur.  This may overflow but this doesn't matter, the kernel
2290:../Generated_Code/tasks.c ****                         will manage it correctly. */
2291:../Generated_Code/tasks.c ****                         xTimeToWake = xTickCount + xTicksToWait;
2292:../Generated_Code/tasks.c ****                         prvAddCurrentTaskToDelayedList( xTimeToWake );
2293:../Generated_Code/tasks.c ****         }
2294:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2295:../Generated_Code/tasks.c **** }
 2703              		.loc 1 2295 0
 2704 007c BD46     		mov	sp, r7
 2705 007e 06B0     		add	sp, sp, #24
 2706              		@ sp needed for prologue
 2707 0080 80BD     		pop	{r7, pc}
 2708              	.L191:
 2709 0082 C046     		.align	2
 2710              	.L190:
 2711 0084 00000000 		.word	_ZL20uxSchedulerSuspended
 2712 0088 00000000 		.word	pxCurrentTCB
 2713 008c 00000000 		.word	_ZL18xSuspendedTaskList
 2714 0090 00000000 		.word	_ZL10xTickCount
 2715              		.cfi_endproc
 2716              	.LFE28:
 2718              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2719              		.align	2
 2720              		.global	xTaskRemoveFromEventList
 2721              		.code	16
 2722              		.thumb_func
 2724              	xTaskRemoveFromEventList:
 2725              	.LFB29:
2296:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2297:../Generated_Code/tasks.c **** 
2298:../Generated_Code/tasks.c **** #if configUSE_TIMERS == 1
2299:../Generated_Code/tasks.c **** 
2300:../Generated_Code/tasks.c ****         void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksTo
2301:../Generated_Code/tasks.c ****         {
2302:../Generated_Code/tasks.c ****         TickType_t xTimeToWake;
2303:../Generated_Code/tasks.c **** 
2304:../Generated_Code/tasks.c ****                 configASSERT( pxEventList );
2305:../Generated_Code/tasks.c **** 
2306:../Generated_Code/tasks.c ****                 /* This function should not be called by application code hence the
2307:../Generated_Code/tasks.c ****                 'Restricted' in its name.  It is not part of the public API.  It is
2308:../Generated_Code/tasks.c ****                 designed for use by kernel code, and has special calling requirements -
2309:../Generated_Code/tasks.c ****                 it should be called from a critical section. */
2310:../Generated_Code/tasks.c **** 
2311:../Generated_Code/tasks.c **** 
2312:../Generated_Code/tasks.c ****                 /* Place the event list item of the TCB in the appropriate event list.
2313:../Generated_Code/tasks.c ****                 In this case it is assume that this is the only task that is going to
2314:../Generated_Code/tasks.c ****                 be waiting on this event list, so the faster vListInsertEnd() function
2315:../Generated_Code/tasks.c ****                 can be used in place of vListInsert. */
2316:../Generated_Code/tasks.c ****                 vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2317:../Generated_Code/tasks.c **** 
2318:../Generated_Code/tasks.c ****                 /* We must remove this task from the ready list before adding it to the
2319:../Generated_Code/tasks.c ****                 blocked list as the same list item is used for both lists.  This
2320:../Generated_Code/tasks.c ****                 function is called form a critical section. */
2321:../Generated_Code/tasks.c ****                 if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2322:../Generated_Code/tasks.c ****                 {
2323:../Generated_Code/tasks.c ****                         /* The current task must be in a ready list, so there is no need to
2324:../Generated_Code/tasks.c ****                         check, and the port reset macro can be called directly. */
2325:../Generated_Code/tasks.c ****                         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2326:../Generated_Code/tasks.c ****                 }
2327:../Generated_Code/tasks.c ****                 else
2328:../Generated_Code/tasks.c ****                 {
2329:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2330:../Generated_Code/tasks.c ****                 }
2331:../Generated_Code/tasks.c **** 
2332:../Generated_Code/tasks.c ****                 /* Calculate the time at which the task should be woken if the event does
2333:../Generated_Code/tasks.c ****                 not occur.  This may overflow but this doesn't matter. */
2334:../Generated_Code/tasks.c ****                 xTimeToWake = xTickCount + xTicksToWait;
2335:../Generated_Code/tasks.c **** 
2336:../Generated_Code/tasks.c ****                 traceTASK_DELAY_UNTIL();
2337:../Generated_Code/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTimeToWake );
2338:../Generated_Code/tasks.c ****         }
2339:../Generated_Code/tasks.c **** 
2340:../Generated_Code/tasks.c **** #endif /* configUSE_TIMERS */
2341:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2342:../Generated_Code/tasks.c **** 
2343:../Generated_Code/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2344:../Generated_Code/tasks.c **** {
 2726              		.loc 1 2344 0
 2727              		.cfi_startproc
 2728 0000 80B5     		push	{r7, lr}
 2729              	.LCFI57:
 2730              		.cfi_def_cfa_offset 8
 2731              		.cfi_offset 7, -8
 2732              		.cfi_offset 14, -4
 2733 0002 84B0     		sub	sp, sp, #16
 2734              	.LCFI58:
 2735              		.cfi_def_cfa_offset 24
 2736 0004 00AF     		add	r7, sp, #0
 2737              	.LCFI59:
 2738              		.cfi_def_cfa_register 7
 2739 0006 7860     		str	r0, [r7, #4]
 2740              	.LBB35:
2345:../Generated_Code/tasks.c **** TCB_t *pxUnblockedTCB;
2346:../Generated_Code/tasks.c **** BaseType_t xReturn;
2347:../Generated_Code/tasks.c **** 
2348:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2349:../Generated_Code/tasks.c ****         called from a critical section within an ISR. */
2350:../Generated_Code/tasks.c **** 
2351:../Generated_Code/tasks.c ****         /* The event list is sorted in priority order, so the first in the list can
2352:../Generated_Code/tasks.c ****         be removed as it is known to be the highest priority.  Remove the TCB from
2353:../Generated_Code/tasks.c ****         the delayed list, and add it to the ready list.
2354:../Generated_Code/tasks.c **** 
2355:../Generated_Code/tasks.c ****         If an event is for a queue that is locked then this function will never
2356:../Generated_Code/tasks.c ****         get called - the lock count on the queue will get modified instead.  This
2357:../Generated_Code/tasks.c ****         means exclusive access to the event list is guaranteed here.
2358:../Generated_Code/tasks.c **** 
2359:../Generated_Code/tasks.c ****         This function assumes that a check has already been made to ensure that
2360:../Generated_Code/tasks.c ****         pxEventList is not empty. */
2361:../Generated_Code/tasks.c ****         pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2741              		.loc 1 2361 0
 2742 0008 7B68     		ldr	r3, [r7, #4]
 2743 000a DB68     		ldr	r3, [r3, #12]
 2744 000c DB68     		ldr	r3, [r3, #12]
 2745 000e BB60     		str	r3, [r7, #8]
2362:../Generated_Code/tasks.c ****         configASSERT( pxUnblockedTCB );
 2746              		.loc 1 2362 0
 2747 0010 BB68     		ldr	r3, [r7, #8]
 2748 0012 002B     		cmp	r3, #0
 2749 0014 01D1     		bne	.L193
 2750              		.loc 1 2362 0 is_stmt 0
 2751              	@ 2362 "../Generated_Code/tasks.c" 1
 2752 0016 72B6     		cpsid i
 2753              	@ 0 "" 2
 2754              		.code	16
 2755              	.L194:
 2756              		.loc 1 2362 0
 2757 0018 FEE7     		b	.L194
 2758              	.L193:
2363:../Generated_Code/tasks.c ****         ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2759              		.loc 1 2363 0 is_stmt 1
 2760 001a BB68     		ldr	r3, [r7, #8]
 2761 001c 1833     		add	r3, r3, #24
 2762 001e 181C     		mov	r0, r3
 2763 0020 FFF7FEFF 		bl	uxListRemove
2364:../Generated_Code/tasks.c **** 
2365:../Generated_Code/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2764              		.loc 1 2365 0
 2765 0024 234B     		ldr	r3, .L201
 2766 0026 1B68     		ldr	r3, [r3]
 2767 0028 5A42     		neg	r2, r3
 2768 002a 5341     		adc	r3, r3, r2
 2769 002c DBB2     		uxtb	r3, r3
 2770 002e 002B     		cmp	r3, #0
 2771 0030 21D0     		beq	.L195
2366:../Generated_Code/tasks.c ****         {
2367:../Generated_Code/tasks.c ****                 ( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2772              		.loc 1 2367 0
 2773 0032 BB68     		ldr	r3, [r7, #8]
 2774 0034 0433     		add	r3, r3, #4
 2775 0036 181C     		mov	r0, r3
 2776 0038 FFF7FEFF 		bl	uxListRemove
2368:../Generated_Code/tasks.c ****                 prvAddTaskToReadyList( pxUnblockedTCB );
 2777              		.loc 1 2368 0
 2778 003c BB68     		ldr	r3, [r7, #8]
 2779 003e DA6A     		ldr	r2, [r3, #44]
 2780 0040 1D4B     		ldr	r3, .L201+4
 2781 0042 1B68     		ldr	r3, [r3]
 2782 0044 9342     		cmp	r3, r2
 2783 0046 9B41     		sbc	r3, r3, r3
 2784 0048 5B42     		neg	r3, r3
 2785 004a DBB2     		uxtb	r3, r3
 2786 004c 002B     		cmp	r3, #0
 2787 004e 03D0     		beq	.L196
 2788              		.loc 1 2368 0 is_stmt 0
 2789 0050 BB68     		ldr	r3, [r7, #8]
 2790 0052 DA6A     		ldr	r2, [r3, #44]
 2791 0054 184B     		ldr	r3, .L201+4
 2792 0056 1A60     		str	r2, [r3]
 2793              	.L196:
 2794              		.loc 1 2368 0
 2795 0058 BB68     		ldr	r3, [r7, #8]
 2796 005a DA6A     		ldr	r2, [r3, #44]
 2797 005c 131C     		mov	r3, r2
 2798 005e 9B00     		lsl	r3, r3, #2
 2799 0060 9B18     		add	r3, r3, r2
 2800 0062 9B00     		lsl	r3, r3, #2
 2801 0064 154A     		ldr	r2, .L201+8
 2802 0066 9A18     		add	r2, r3, r2
 2803 0068 BB68     		ldr	r3, [r7, #8]
 2804 006a 0433     		add	r3, r3, #4
 2805 006c 101C     		mov	r0, r2
 2806 006e 191C     		mov	r1, r3
 2807 0070 FFF7FEFF 		bl	vListInsertEnd
 2808 0074 06E0     		b	.L197
 2809              	.L195:
2369:../Generated_Code/tasks.c ****         }
2370:../Generated_Code/tasks.c ****         else
2371:../Generated_Code/tasks.c ****         {
2372:../Generated_Code/tasks.c ****                 /* The delayed and ready lists cannot be accessed, so hold this task
2373:../Generated_Code/tasks.c ****                 pending until the scheduler is resumed. */
2374:../Generated_Code/tasks.c ****                 vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2810              		.loc 1 2374 0 is_stmt 1
 2811 0076 BB68     		ldr	r3, [r7, #8]
 2812 0078 1833     		add	r3, r3, #24
 2813 007a 114A     		ldr	r2, .L201+12
 2814 007c 101C     		mov	r0, r2
 2815 007e 191C     		mov	r1, r3
 2816 0080 FFF7FEFF 		bl	vListInsertEnd
 2817              	.L197:
2375:../Generated_Code/tasks.c ****         }
2376:../Generated_Code/tasks.c **** 
2377:../Generated_Code/tasks.c ****         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2818              		.loc 1 2377 0
 2819 0084 BB68     		ldr	r3, [r7, #8]
 2820 0086 DA6A     		ldr	r2, [r3, #44]
 2821 0088 0E4B     		ldr	r3, .L201+16
 2822 008a 1B68     		ldr	r3, [r3]
 2823 008c DB6A     		ldr	r3, [r3, #44]
 2824 008e 9342     		cmp	r3, r2
 2825 0090 9B41     		sbc	r3, r3, r3
 2826 0092 5B42     		neg	r3, r3
 2827 0094 DBB2     		uxtb	r3, r3
 2828 0096 002B     		cmp	r3, #0
 2829 0098 05D0     		beq	.L198
2378:../Generated_Code/tasks.c ****         {
2379:../Generated_Code/tasks.c ****                 /* Return true if the task removed from the event list has a higher
2380:../Generated_Code/tasks.c ****                 priority than the calling task.  This allows the calling task to know if
2381:../Generated_Code/tasks.c ****                 it should force a context switch now. */
2382:../Generated_Code/tasks.c ****                 xReturn = pdTRUE;
 2830              		.loc 1 2382 0
 2831 009a 0123     		mov	r3, #1
 2832 009c FB60     		str	r3, [r7, #12]
2383:../Generated_Code/tasks.c **** 
2384:../Generated_Code/tasks.c ****                 /* Mark that a yield is pending in case the user is not using the
2385:../Generated_Code/tasks.c ****                 "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2386:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 2833              		.loc 1 2386 0
 2834 009e 0A4B     		ldr	r3, .L201+20
 2835 00a0 0122     		mov	r2, #1
 2836 00a2 1A60     		str	r2, [r3]
 2837 00a4 01E0     		b	.L199
 2838              	.L198:
2387:../Generated_Code/tasks.c ****         }
2388:../Generated_Code/tasks.c ****         else
2389:../Generated_Code/tasks.c ****         {
2390:../Generated_Code/tasks.c ****                 xReturn = pdFALSE;
 2839              		.loc 1 2390 0
 2840 00a6 0023     		mov	r3, #0
 2841 00a8 FB60     		str	r3, [r7, #12]
 2842              	.L199:
2391:../Generated_Code/tasks.c ****         }
2392:../Generated_Code/tasks.c **** 
2393:../Generated_Code/tasks.c ****         return xReturn;
 2843              		.loc 1 2393 0
 2844 00aa FB68     		ldr	r3, [r7, #12]
 2845              	.LBE35:
2394:../Generated_Code/tasks.c **** }
 2846              		.loc 1 2394 0
 2847 00ac 181C     		mov	r0, r3
 2848 00ae BD46     		mov	sp, r7
 2849 00b0 04B0     		add	sp, sp, #16
 2850              		@ sp needed for prologue
 2851 00b2 80BD     		pop	{r7, pc}
 2852              	.L202:
 2853              		.align	2
 2854              	.L201:
 2855 00b4 00000000 		.word	_ZL20uxSchedulerSuspended
 2856 00b8 00000000 		.word	_ZL18uxTopReadyPriority
 2857 00bc 00000000 		.word	_ZL17pxReadyTasksLists
 2858 00c0 00000000 		.word	_ZL17xPendingReadyList
 2859 00c4 00000000 		.word	pxCurrentTCB
 2860 00c8 00000000 		.word	_ZL13xYieldPending
 2861              		.cfi_endproc
 2862              	.LFE29:
 2864              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 2865              		.align	2
 2866              		.global	xTaskRemoveFromUnorderedEventList
 2867              		.code	16
 2868              		.thumb_func
 2870              	xTaskRemoveFromUnorderedEventList:
 2871              	.LFB30:
2395:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2396:../Generated_Code/tasks.c **** 
2397:../Generated_Code/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2398:../Generated_Code/tasks.c **** {
 2872              		.loc 1 2398 0
 2873              		.cfi_startproc
 2874 0000 80B5     		push	{r7, lr}
 2875              	.LCFI60:
 2876              		.cfi_def_cfa_offset 8
 2877              		.cfi_offset 7, -8
 2878              		.cfi_offset 14, -4
 2879 0002 84B0     		sub	sp, sp, #16
 2880              	.LCFI61:
 2881              		.cfi_def_cfa_offset 24
 2882 0004 00AF     		add	r7, sp, #0
 2883              	.LCFI62:
 2884              		.cfi_def_cfa_register 7
 2885 0006 7860     		str	r0, [r7, #4]
 2886 0008 3960     		str	r1, [r7]
 2887              	.LBB36:
2399:../Generated_Code/tasks.c **** TCB_t *pxUnblockedTCB;
2400:../Generated_Code/tasks.c **** BaseType_t xReturn;
2401:../Generated_Code/tasks.c **** 
2402:../Generated_Code/tasks.c ****         /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2403:../Generated_Code/tasks.c ****         the event flags implementation. */
2404:../Generated_Code/tasks.c ****         configASSERT( uxSchedulerSuspended != pdFALSE );
 2888              		.loc 1 2404 0
 2889 000a 2A4B     		ldr	r3, .L212
 2890 000c 1B68     		ldr	r3, [r3]
 2891 000e 5A42     		neg	r2, r3
 2892 0010 5341     		adc	r3, r3, r2
 2893 0012 DBB2     		uxtb	r3, r3
 2894 0014 002B     		cmp	r3, #0
 2895 0016 01D0     		beq	.L204
 2896              		.loc 1 2404 0 is_stmt 0
 2897              	@ 2404 "../Generated_Code/tasks.c" 1
 2898 0018 72B6     		cpsid i
 2899              	@ 0 "" 2
 2900              		.code	16
 2901              	.L205:
 2902              		.loc 1 2404 0
 2903 001a FEE7     		b	.L205
 2904              	.L204:
2405:../Generated_Code/tasks.c **** 
2406:../Generated_Code/tasks.c ****         /* Store the new item value in the event list. */
2407:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2905              		.loc 1 2407 0 is_stmt 1
 2906 001c 3B68     		ldr	r3, [r7]
 2907 001e 8022     		mov	r2, #128
 2908 0020 1206     		lsl	r2, r2, #24
 2909 0022 1A43     		orr	r2, r3
 2910 0024 7B68     		ldr	r3, [r7, #4]
 2911 0026 1A60     		str	r2, [r3]
2408:../Generated_Code/tasks.c **** 
2409:../Generated_Code/tasks.c ****         /* Remove the event list form the event flag.  Interrupts do not access
2410:../Generated_Code/tasks.c ****         event flags. */
2411:../Generated_Code/tasks.c ****         pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 2912              		.loc 1 2411 0
 2913 0028 7B68     		ldr	r3, [r7, #4]
 2914 002a DB68     		ldr	r3, [r3, #12]
 2915 002c BB60     		str	r3, [r7, #8]
2412:../Generated_Code/tasks.c ****         configASSERT( pxUnblockedTCB );
 2916              		.loc 1 2412 0
 2917 002e BB68     		ldr	r3, [r7, #8]
 2918 0030 002B     		cmp	r3, #0
 2919 0032 01D1     		bne	.L206
 2920              		.loc 1 2412 0 is_stmt 0
 2921              	@ 2412 "../Generated_Code/tasks.c" 1
 2922 0034 72B6     		cpsid i
 2923              	@ 0 "" 2
 2924              		.code	16
 2925              	.L207:
 2926              		.loc 1 2412 0
 2927 0036 FEE7     		b	.L207
 2928              	.L206:
2413:../Generated_Code/tasks.c ****         ( void ) uxListRemove( pxEventListItem );
 2929              		.loc 1 2413 0 is_stmt 1
 2930 0038 7B68     		ldr	r3, [r7, #4]
 2931 003a 181C     		mov	r0, r3
 2932 003c FFF7FEFF 		bl	uxListRemove
2414:../Generated_Code/tasks.c **** 
2415:../Generated_Code/tasks.c ****         /* Remove the task from the delayed list and add it to the ready list.  The
2416:../Generated_Code/tasks.c ****         scheduler is suspended so interrupts will not be accessing the ready
2417:../Generated_Code/tasks.c ****         lists. */
2418:../Generated_Code/tasks.c ****         ( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2933              		.loc 1 2418 0
 2934 0040 BB68     		ldr	r3, [r7, #8]
 2935 0042 0433     		add	r3, r3, #4
 2936 0044 181C     		mov	r0, r3
 2937 0046 FFF7FEFF 		bl	uxListRemove
2419:../Generated_Code/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 2938              		.loc 1 2419 0
 2939 004a BB68     		ldr	r3, [r7, #8]
 2940 004c DA6A     		ldr	r2, [r3, #44]
 2941 004e 1A4B     		ldr	r3, .L212+4
 2942 0050 1B68     		ldr	r3, [r3]
 2943 0052 9342     		cmp	r3, r2
 2944 0054 9B41     		sbc	r3, r3, r3
 2945 0056 5B42     		neg	r3, r3
 2946 0058 DBB2     		uxtb	r3, r3
 2947 005a 002B     		cmp	r3, #0
 2948 005c 03D0     		beq	.L208
 2949              		.loc 1 2419 0 is_stmt 0
 2950 005e BB68     		ldr	r3, [r7, #8]
 2951 0060 DA6A     		ldr	r2, [r3, #44]
 2952 0062 154B     		ldr	r3, .L212+4
 2953 0064 1A60     		str	r2, [r3]
 2954              	.L208:
 2955              		.loc 1 2419 0
 2956 0066 BB68     		ldr	r3, [r7, #8]
 2957 0068 DA6A     		ldr	r2, [r3, #44]
 2958 006a 131C     		mov	r3, r2
 2959 006c 9B00     		lsl	r3, r3, #2
 2960 006e 9B18     		add	r3, r3, r2
 2961 0070 9B00     		lsl	r3, r3, #2
 2962 0072 124A     		ldr	r2, .L212+8
 2963 0074 9A18     		add	r2, r3, r2
 2964 0076 BB68     		ldr	r3, [r7, #8]
 2965 0078 0433     		add	r3, r3, #4
 2966 007a 101C     		mov	r0, r2
 2967 007c 191C     		mov	r1, r3
 2968 007e FFF7FEFF 		bl	vListInsertEnd
2420:../Generated_Code/tasks.c **** 
2421:../Generated_Code/tasks.c ****         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2969              		.loc 1 2421 0 is_stmt 1
 2970 0082 BB68     		ldr	r3, [r7, #8]
 2971 0084 DA6A     		ldr	r2, [r3, #44]
 2972 0086 0E4B     		ldr	r3, .L212+12
 2973 0088 1B68     		ldr	r3, [r3]
 2974 008a DB6A     		ldr	r3, [r3, #44]
 2975 008c 9342     		cmp	r3, r2
 2976 008e 9B41     		sbc	r3, r3, r3
 2977 0090 5B42     		neg	r3, r3
 2978 0092 DBB2     		uxtb	r3, r3
 2979 0094 002B     		cmp	r3, #0
 2980 0096 05D0     		beq	.L209
2422:../Generated_Code/tasks.c ****         {
2423:../Generated_Code/tasks.c ****                 /* Return true if the task removed from the event list has
2424:../Generated_Code/tasks.c ****                 a higher priority than the calling task.  This allows
2425:../Generated_Code/tasks.c ****                 the calling task to know if it should force a context
2426:../Generated_Code/tasks.c ****                 switch now. */
2427:../Generated_Code/tasks.c ****                 xReturn = pdTRUE;
 2981              		.loc 1 2427 0
 2982 0098 0123     		mov	r3, #1
 2983 009a FB60     		str	r3, [r7, #12]
2428:../Generated_Code/tasks.c **** 
2429:../Generated_Code/tasks.c ****                 /* Mark that a yield is pending in case the user is not using the
2430:../Generated_Code/tasks.c ****                 "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2431:../Generated_Code/tasks.c ****                 xYieldPending = pdTRUE;
 2984              		.loc 1 2431 0
 2985 009c 094B     		ldr	r3, .L212+16
 2986 009e 0122     		mov	r2, #1
 2987 00a0 1A60     		str	r2, [r3]
 2988 00a2 01E0     		b	.L210
 2989              	.L209:
2432:../Generated_Code/tasks.c ****         }
2433:../Generated_Code/tasks.c ****         else
2434:../Generated_Code/tasks.c ****         {
2435:../Generated_Code/tasks.c ****                 xReturn = pdFALSE;
 2990              		.loc 1 2435 0
 2991 00a4 0023     		mov	r3, #0
 2992 00a6 FB60     		str	r3, [r7, #12]
 2993              	.L210:
2436:../Generated_Code/tasks.c ****         }
2437:../Generated_Code/tasks.c **** 
2438:../Generated_Code/tasks.c ****         return xReturn;
 2994              		.loc 1 2438 0
 2995 00a8 FB68     		ldr	r3, [r7, #12]
 2996              	.LBE36:
2439:../Generated_Code/tasks.c **** }
 2997              		.loc 1 2439 0
 2998 00aa 181C     		mov	r0, r3
 2999 00ac BD46     		mov	sp, r7
 3000 00ae 04B0     		add	sp, sp, #16
 3001              		@ sp needed for prologue
 3002 00b0 80BD     		pop	{r7, pc}
 3003              	.L213:
 3004 00b2 C046     		.align	2
 3005              	.L212:
 3006 00b4 00000000 		.word	_ZL20uxSchedulerSuspended
 3007 00b8 00000000 		.word	_ZL18uxTopReadyPriority
 3008 00bc 00000000 		.word	_ZL17pxReadyTasksLists
 3009 00c0 00000000 		.word	pxCurrentTCB
 3010 00c4 00000000 		.word	_ZL13xYieldPending
 3011              		.cfi_endproc
 3012              	.LFE30:
 3014              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3015              		.align	2
 3016              		.global	vTaskSetTimeOutState
 3017              		.code	16
 3018              		.thumb_func
 3020              	vTaskSetTimeOutState:
 3021              	.LFB31:
2440:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2441:../Generated_Code/tasks.c **** 
2442:../Generated_Code/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2443:../Generated_Code/tasks.c **** {
 3022              		.loc 1 2443 0
 3023              		.cfi_startproc
 3024 0000 80B5     		push	{r7, lr}
 3025              	.LCFI63:
 3026              		.cfi_def_cfa_offset 8
 3027              		.cfi_offset 7, -8
 3028              		.cfi_offset 14, -4
 3029 0002 82B0     		sub	sp, sp, #8
 3030              	.LCFI64:
 3031              		.cfi_def_cfa_offset 16
 3032 0004 00AF     		add	r7, sp, #0
 3033              	.LCFI65:
 3034              		.cfi_def_cfa_register 7
 3035 0006 7860     		str	r0, [r7, #4]
2444:../Generated_Code/tasks.c ****         configASSERT( pxTimeOut );
 3036              		.loc 1 2444 0
 3037 0008 7B68     		ldr	r3, [r7, #4]
 3038 000a 002B     		cmp	r3, #0
 3039 000c 01D1     		bne	.L215
 3040              		.loc 1 2444 0 is_stmt 0
 3041              	@ 2444 "../Generated_Code/tasks.c" 1
 3042 000e 72B6     		cpsid i
 3043              	@ 0 "" 2
 3044              		.code	16
 3045              	.L216:
 3046              		.loc 1 2444 0
 3047 0010 FEE7     		b	.L216
 3048              	.L215:
2445:../Generated_Code/tasks.c ****         pxTimeOut->xOverflowCount = xNumOfOverflows;
 3049              		.loc 1 2445 0 is_stmt 1
 3050 0012 054B     		ldr	r3, .L217
 3051 0014 1A68     		ldr	r2, [r3]
 3052 0016 7B68     		ldr	r3, [r7, #4]
 3053 0018 1A60     		str	r2, [r3]
2446:../Generated_Code/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
 3054              		.loc 1 2446 0
 3055 001a 044B     		ldr	r3, .L217+4
 3056 001c 1A68     		ldr	r2, [r3]
 3057 001e 7B68     		ldr	r3, [r7, #4]
 3058 0020 5A60     		str	r2, [r3, #4]
2447:../Generated_Code/tasks.c **** }
 3059              		.loc 1 2447 0
 3060 0022 BD46     		mov	sp, r7
 3061 0024 02B0     		add	sp, sp, #8
 3062              		@ sp needed for prologue
 3063 0026 80BD     		pop	{r7, pc}
 3064              	.L218:
 3065              		.align	2
 3066              	.L217:
 3067 0028 00000000 		.word	_ZL15xNumOfOverflows
 3068 002c 00000000 		.word	_ZL10xTickCount
 3069              		.cfi_endproc
 3070              	.LFE31:
 3072              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3073              		.align	2
 3074              		.global	xTaskCheckForTimeOut
 3075              		.code	16
 3076              		.thumb_func
 3078              	xTaskCheckForTimeOut:
 3079              	.LFB32:
2448:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2449:../Generated_Code/tasks.c **** 
2450:../Generated_Code/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2451:../Generated_Code/tasks.c **** {
 3080              		.loc 1 2451 0
 3081              		.cfi_startproc
 3082 0000 80B5     		push	{r7, lr}
 3083              	.LCFI66:
 3084              		.cfi_def_cfa_offset 8
 3085              		.cfi_offset 7, -8
 3086              		.cfi_offset 14, -4
 3087 0002 84B0     		sub	sp, sp, #16
 3088              	.LCFI67:
 3089              		.cfi_def_cfa_offset 24
 3090 0004 00AF     		add	r7, sp, #0
 3091              	.LCFI68:
 3092              		.cfi_def_cfa_register 7
 3093 0006 7860     		str	r0, [r7, #4]
 3094 0008 3960     		str	r1, [r7]
 3095              	.LBB37:
2452:../Generated_Code/tasks.c **** BaseType_t xReturn;
2453:../Generated_Code/tasks.c **** 
2454:../Generated_Code/tasks.c ****         configASSERT( pxTimeOut );
 3096              		.loc 1 2454 0
 3097 000a 7B68     		ldr	r3, [r7, #4]
 3098 000c 002B     		cmp	r3, #0
 3099 000e 01D1     		bne	.L220
 3100              		.loc 1 2454 0 is_stmt 0
 3101              	@ 2454 "../Generated_Code/tasks.c" 1
 3102 0010 72B6     		cpsid i
 3103              	@ 0 "" 2
 3104              		.code	16
 3105              	.L221:
 3106              		.loc 1 2454 0
 3107 0012 FEE7     		b	.L221
 3108              	.L220:
2455:../Generated_Code/tasks.c ****         configASSERT( pxTicksToWait );
 3109              		.loc 1 2455 0 is_stmt 1
 3110 0014 3B68     		ldr	r3, [r7]
 3111 0016 002B     		cmp	r3, #0
 3112 0018 01D1     		bne	.L222
 3113              		.loc 1 2455 0 is_stmt 0
 3114              	@ 2455 "../Generated_Code/tasks.c" 1
 3115 001a 72B6     		cpsid i
 3116              	@ 0 "" 2
 3117              		.code	16
 3118              	.L223:
 3119              		.loc 1 2455 0
 3120 001c FEE7     		b	.L223
 3121              	.L222:
2456:../Generated_Code/tasks.c **** 
2457:../Generated_Code/tasks.c ****         taskENTER_CRITICAL();
 3122              		.loc 1 2457 0 is_stmt 1
 3123 001e FFF7FEFF 		bl	vPortEnterCritical
 3124              	.LBB38:
2458:../Generated_Code/tasks.c ****         {
2459:../Generated_Code/tasks.c ****                 /* Minor optimisation.  The tick count cannot change in this block. */
2460:../Generated_Code/tasks.c ****                 const TickType_t xConstTickCount = xTickCount;
 3125              		.loc 1 2460 0
 3126 0022 1F4B     		ldr	r3, .L231
 3127 0024 1B68     		ldr	r3, [r3]
 3128 0026 BB60     		str	r3, [r7, #8]
2461:../Generated_Code/tasks.c **** 
2462:../Generated_Code/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
2463:../Generated_Code/tasks.c ****                         /* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2464:../Generated_Code/tasks.c ****                         the maximum block time then the task should block indefinitely, and
2465:../Generated_Code/tasks.c ****                         therefore never time out. */
2466:../Generated_Code/tasks.c ****                         if( *pxTicksToWait == portMAX_DELAY )
 3129              		.loc 1 2466 0
 3130 0028 3B68     		ldr	r3, [r7]
 3131 002a 1B68     		ldr	r3, [r3]
 3132 002c 0133     		add	r3, r3, #1
 3133 002e 02D1     		bne	.L224
2467:../Generated_Code/tasks.c ****                         {
2468:../Generated_Code/tasks.c ****                                 xReturn = pdFALSE;
 3134              		.loc 1 2468 0
 3135 0030 0023     		mov	r3, #0
 3136 0032 FB60     		str	r3, [r7, #12]
 3137 0034 2CE0     		b	.L225
 3138              	.L224:
2469:../Generated_Code/tasks.c ****                         }
2470:../Generated_Code/tasks.c ****                         else /* We are not blocking indefinitely, perform the checks below. */
2471:../Generated_Code/tasks.c ****                 #endif
2472:../Generated_Code/tasks.c **** 
2473:../Generated_Code/tasks.c ****                 if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTime
 3139              		.loc 1 2473 0
 3140 0036 7B68     		ldr	r3, [r7, #4]
 3141 0038 1A68     		ldr	r2, [r3]
 3142 003a 1A4B     		ldr	r3, .L231+4
 3143 003c 1B68     		ldr	r3, [r3]
 3144 003e 9A42     		cmp	r2, r3
 3145 0040 06D0     		beq	.L226
 3146              		.loc 1 2473 0 is_stmt 0
 3147 0042 7B68     		ldr	r3, [r7, #4]
 3148 0044 5A68     		ldr	r2, [r3, #4]
 3149 0046 BB68     		ldr	r3, [r7, #8]
 3150 0048 9A42     		cmp	r2, r3
 3151 004a 01D8     		bhi	.L226
 3152              		.loc 1 2473 0
 3153 004c 0123     		mov	r3, #1
 3154 004e 00E0     		b	.L227
 3155              	.L226:
 3156              		.loc 1 2473 0
 3157 0050 0023     		mov	r3, #0
 3158              	.L227:
 3159              		.loc 1 2473 0
 3160 0052 002B     		cmp	r3, #0
 3161 0054 02D0     		beq	.L228
2474:../Generated_Code/tasks.c ****                 {
2475:../Generated_Code/tasks.c ****                         /* The tick count is greater than the time at which vTaskSetTimeout()
2476:../Generated_Code/tasks.c ****                         was called, but has also overflowed since vTaskSetTimeOut() was called.
2477:../Generated_Code/tasks.c ****                         It must have wrapped all the way around and gone past us again. This
2478:../Generated_Code/tasks.c ****                         passed since vTaskSetTimeout() was called. */
2479:../Generated_Code/tasks.c ****                         xReturn = pdTRUE;
 3162              		.loc 1 2479 0 is_stmt 1
 3163 0056 0123     		mov	r3, #1
 3164 0058 FB60     		str	r3, [r7, #12]
 3165 005a 19E0     		b	.L225
 3166              	.L228:
2480:../Generated_Code/tasks.c ****                 }
2481:../Generated_Code/tasks.c ****                 else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 3167              		.loc 1 2481 0
 3168 005c 7B68     		ldr	r3, [r7, #4]
 3169 005e 5B68     		ldr	r3, [r3, #4]
 3170 0060 BA68     		ldr	r2, [r7, #8]
 3171 0062 D21A     		sub	r2, r2, r3
 3172 0064 3B68     		ldr	r3, [r7]
 3173 0066 1B68     		ldr	r3, [r3]
 3174 0068 9A42     		cmp	r2, r3
 3175 006a 0FD2     		bcs	.L229
2482:../Generated_Code/tasks.c ****                 {
2483:../Generated_Code/tasks.c ****                         /* Not a genuine timeout. Adjust parameters for time remaining. */
2484:../Generated_Code/tasks.c ****                         *pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 3176              		.loc 1 2484 0
 3177 006c 3B68     		ldr	r3, [r7]
 3178 006e 1A68     		ldr	r2, [r3]
 3179 0070 7B68     		ldr	r3, [r7, #4]
 3180 0072 5968     		ldr	r1, [r3, #4]
 3181 0074 BB68     		ldr	r3, [r7, #8]
 3182 0076 CB1A     		sub	r3, r1, r3
 3183 0078 D218     		add	r2, r2, r3
 3184 007a 3B68     		ldr	r3, [r7]
 3185 007c 1A60     		str	r2, [r3]
2485:../Generated_Code/tasks.c ****                         vTaskSetTimeOutState( pxTimeOut );
 3186              		.loc 1 2485 0
 3187 007e 7B68     		ldr	r3, [r7, #4]
 3188 0080 181C     		mov	r0, r3
 3189 0082 FFF7FEFF 		bl	vTaskSetTimeOutState
2486:../Generated_Code/tasks.c ****                         xReturn = pdFALSE;
 3190              		.loc 1 2486 0
 3191 0086 0023     		mov	r3, #0
 3192 0088 FB60     		str	r3, [r7, #12]
 3193 008a 01E0     		b	.L225
 3194              	.L229:
2487:../Generated_Code/tasks.c ****                 }
2488:../Generated_Code/tasks.c ****                 else
2489:../Generated_Code/tasks.c ****                 {
2490:../Generated_Code/tasks.c ****                         xReturn = pdTRUE;
 3195              		.loc 1 2490 0
 3196 008c 0123     		mov	r3, #1
 3197 008e FB60     		str	r3, [r7, #12]
 3198              	.L225:
 3199              	.LBE38:
2491:../Generated_Code/tasks.c ****                 }
2492:../Generated_Code/tasks.c ****         }
2493:../Generated_Code/tasks.c ****         taskEXIT_CRITICAL();
 3200              		.loc 1 2493 0
 3201 0090 FFF7FEFF 		bl	vPortExitCritical
2494:../Generated_Code/tasks.c **** 
2495:../Generated_Code/tasks.c ****         return xReturn;
 3202              		.loc 1 2495 0
 3203 0094 FB68     		ldr	r3, [r7, #12]
 3204              	.LBE37:
2496:../Generated_Code/tasks.c **** }
 3205              		.loc 1 2496 0
 3206 0096 181C     		mov	r0, r3
 3207 0098 BD46     		mov	sp, r7
 3208 009a 04B0     		add	sp, sp, #16
 3209              		@ sp needed for prologue
 3210 009c 80BD     		pop	{r7, pc}
 3211              	.L232:
 3212 009e C046     		.align	2
 3213              	.L231:
 3214 00a0 00000000 		.word	_ZL10xTickCount
 3215 00a4 00000000 		.word	_ZL15xNumOfOverflows
 3216              		.cfi_endproc
 3217              	.LFE32:
 3219              		.section	.text.vTaskMissedYield,"ax",%progbits
 3220              		.align	2
 3221              		.global	vTaskMissedYield
 3222              		.code	16
 3223              		.thumb_func
 3225              	vTaskMissedYield:
 3226              	.LFB33:
2497:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2498:../Generated_Code/tasks.c **** 
2499:../Generated_Code/tasks.c **** void vTaskMissedYield( void )
2500:../Generated_Code/tasks.c **** {
 3227              		.loc 1 2500 0
 3228              		.cfi_startproc
 3229 0000 80B5     		push	{r7, lr}
 3230              	.LCFI69:
 3231              		.cfi_def_cfa_offset 8
 3232              		.cfi_offset 7, -8
 3233              		.cfi_offset 14, -4
 3234 0002 00AF     		add	r7, sp, #0
 3235              	.LCFI70:
 3236              		.cfi_def_cfa_register 7
2501:../Generated_Code/tasks.c ****         xYieldPending = pdTRUE;
 3237              		.loc 1 2501 0
 3238 0004 024B     		ldr	r3, .L234
 3239 0006 0122     		mov	r2, #1
 3240 0008 1A60     		str	r2, [r3]
2502:../Generated_Code/tasks.c **** }
 3241              		.loc 1 2502 0
 3242 000a BD46     		mov	sp, r7
 3243              		@ sp needed for prologue
 3244 000c 80BD     		pop	{r7, pc}
 3245              	.L235:
 3246 000e C046     		.align	2
 3247              	.L234:
 3248 0010 00000000 		.word	_ZL13xYieldPending
 3249              		.cfi_endproc
 3250              	.LFE33:
 3252              		.section	.text._ZL11prvIdleTaskPv,"ax",%progbits
 3253              		.align	2
 3254              		.code	16
 3255              		.thumb_func
 3257              	_ZL11prvIdleTaskPv:
 3258              	.LFB34:
2503:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2504:../Generated_Code/tasks.c **** 
2505:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2506:../Generated_Code/tasks.c **** 
2507:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2508:../Generated_Code/tasks.c ****         {
2509:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
2510:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2511:../Generated_Code/tasks.c **** 
2512:../Generated_Code/tasks.c ****                 if( xTask != NULL )
2513:../Generated_Code/tasks.c ****                 {
2514:../Generated_Code/tasks.c ****                         pxTCB = ( TCB_t * ) xTask;
2515:../Generated_Code/tasks.c ****                         uxReturn = pxTCB->uxTaskNumber;
2516:../Generated_Code/tasks.c ****                 }
2517:../Generated_Code/tasks.c ****                 else
2518:../Generated_Code/tasks.c ****                 {
2519:../Generated_Code/tasks.c ****                         uxReturn = 0U;
2520:../Generated_Code/tasks.c ****                 }
2521:../Generated_Code/tasks.c **** 
2522:../Generated_Code/tasks.c ****                 return uxReturn;
2523:../Generated_Code/tasks.c ****         }
2524:../Generated_Code/tasks.c **** 
2525:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2527:../Generated_Code/tasks.c **** 
2528:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2529:../Generated_Code/tasks.c **** 
2530:../Generated_Code/tasks.c ****         void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2531:../Generated_Code/tasks.c ****         {
2532:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2533:../Generated_Code/tasks.c **** 
2534:../Generated_Code/tasks.c ****                 if( xTask != NULL )
2535:../Generated_Code/tasks.c ****                 {
2536:../Generated_Code/tasks.c ****                         pxTCB = ( TCB_t * ) xTask;
2537:../Generated_Code/tasks.c ****                         pxTCB->uxTaskNumber = uxHandle;
2538:../Generated_Code/tasks.c ****                 }
2539:../Generated_Code/tasks.c ****         }
2540:../Generated_Code/tasks.c **** 
2541:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2542:../Generated_Code/tasks.c **** 
2543:../Generated_Code/tasks.c **** /*
2544:../Generated_Code/tasks.c ****  * -----------------------------------------------------------
2545:../Generated_Code/tasks.c ****  * The Idle task.
2546:../Generated_Code/tasks.c ****  * ----------------------------------------------------------
2547:../Generated_Code/tasks.c ****  *
2548:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2549:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2550:../Generated_Code/tasks.c ****  *
2551:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
2552:../Generated_Code/tasks.c ****  *
2553:../Generated_Code/tasks.c ****  */
2554:../Generated_Code/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2555:../Generated_Code/tasks.c **** {
 3259              		.loc 1 2555 0
 3260              		.cfi_startproc
 3261 0000 80B5     		push	{r7, lr}
 3262              	.LCFI71:
 3263              		.cfi_def_cfa_offset 8
 3264              		.cfi_offset 7, -8
 3265              		.cfi_offset 14, -4
 3266 0002 82B0     		sub	sp, sp, #8
 3267              	.LCFI72:
 3268              		.cfi_def_cfa_offset 16
 3269 0004 00AF     		add	r7, sp, #0
 3270              	.LCFI73:
 3271              		.cfi_def_cfa_register 7
 3272 0006 7860     		str	r0, [r7, #4]
 3273              	.L238:
2556:../Generated_Code/tasks.c ****         /* Stop warnings. */
2557:../Generated_Code/tasks.c ****         ( void ) pvParameters;
2558:../Generated_Code/tasks.c **** 
2559:../Generated_Code/tasks.c ****         for( ;; )
2560:../Generated_Code/tasks.c ****         {
2561:../Generated_Code/tasks.c ****                 /* See if any tasks have been deleted. */
2562:../Generated_Code/tasks.c ****                 prvCheckTasksWaitingTermination();
 3274              		.loc 1 2562 0
 3275 0008 FFF7FEFF 		bl	_ZL31prvCheckTasksWaitingTerminationv
2563:../Generated_Code/tasks.c **** 
2564:../Generated_Code/tasks.c ****                 #if ( configUSE_PREEMPTION == 0 )
2565:../Generated_Code/tasks.c ****                 {
2566:../Generated_Code/tasks.c ****                         /* If we are not using preemption we keep forcing a task switch to
2567:../Generated_Code/tasks.c ****                         see if any other task has become available.  If we are using
2568:../Generated_Code/tasks.c ****                         preemption we don't need to do this as any task becoming available
2569:../Generated_Code/tasks.c ****                         will automatically get the processor anyway. */
2570:../Generated_Code/tasks.c ****                         taskYIELD();
2571:../Generated_Code/tasks.c ****                 }
2572:../Generated_Code/tasks.c ****                 #endif /* configUSE_PREEMPTION */
2573:../Generated_Code/tasks.c **** 
2574:../Generated_Code/tasks.c ****                 #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2575:../Generated_Code/tasks.c ****                 {
2576:../Generated_Code/tasks.c ****                         /* When using preemption tasks of equal priority will be
2577:../Generated_Code/tasks.c ****                         timesliced.  If a task that is sharing the idle priority is ready
2578:../Generated_Code/tasks.c ****                         to run then the idle task should yield before the end of the
2579:../Generated_Code/tasks.c ****                         timeslice.
2580:../Generated_Code/tasks.c **** 
2581:../Generated_Code/tasks.c ****                         A critical region is not required here as we are just reading from
2582:../Generated_Code/tasks.c ****                         the list, and an occasional incorrect value will not matter.  If
2583:../Generated_Code/tasks.c ****                         the ready list at the idle priority contains more than one task
2584:../Generated_Code/tasks.c ****                         then a task other than the idle task is ready to execute. */
2585:../Generated_Code/tasks.c ****                         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) >
 3276              		.loc 1 2585 0
 3277 000c 044B     		ldr	r3, .L239
 3278 000e 1B68     		ldr	r3, [r3]
 3279 0010 012B     		cmp	r3, #1
 3280 0012 01D9     		bls	.L237
2586:../Generated_Code/tasks.c ****                         {
2587:../Generated_Code/tasks.c ****                                 taskYIELD();
 3281              		.loc 1 2587 0
 3282 0014 FFF7FEFF 		bl	vPortYieldFromISR
 3283              	.L237:
2588:../Generated_Code/tasks.c ****                         }
2589:../Generated_Code/tasks.c ****                         else
2590:../Generated_Code/tasks.c ****                         {
2591:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2592:../Generated_Code/tasks.c ****                         }
2593:../Generated_Code/tasks.c ****                 }
2594:../Generated_Code/tasks.c ****                 #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2595:../Generated_Code/tasks.c **** 
2596:../Generated_Code/tasks.c ****                 #if ( configUSE_IDLE_HOOK == 1 )
2597:../Generated_Code/tasks.c ****                 {
2598:../Generated_Code/tasks.c **** 
2599:../Generated_Code/tasks.c ****                         /* Call the user defined function from within the idle task.  This
2600:../Generated_Code/tasks.c ****                         allows the application designer to add background functionality
2601:../Generated_Code/tasks.c ****                         without the overhead of a separate task.
2602:../Generated_Code/tasks.c ****                         NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2603:../Generated_Code/tasks.c ****                         CALL A FUNCTION THAT MIGHT BLOCK. */
2604:../Generated_Code/tasks.c ****                         FreeRTOS0_vApplicationIdleHook();
 3284              		.loc 1 2604 0
 3285 0018 FFF7FEFF 		bl	_Z30FreeRTOS0_vApplicationIdleHookv
2559:../Generated_Code/tasks.c ****         for( ;; )
 3286              		.loc 1 2559 0
 3287 001c F4E7     		b	.L238
 3288              	.L240:
 3289 001e C046     		.align	2
 3290              	.L239:
 3291 0020 00000000 		.word	_ZL17pxReadyTasksLists
 3292              		.cfi_endproc
 3293              	.LFE34:
 3295              		.section	.text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt,"ax",%p
 3296              		.align	2
 3297              		.code	16
 3298              		.thumb_func
 3300              	_ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:
 3301              	.LFB35:
2605:../Generated_Code/tasks.c ****                 }
2606:../Generated_Code/tasks.c ****                 #endif /* configUSE_IDLE_HOOK */
2607:../Generated_Code/tasks.c **** 
2608:../Generated_Code/tasks.c ****                 /* This conditional compilation should use inequality to 0, not equality
2609:../Generated_Code/tasks.c ****                 to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2610:../Generated_Code/tasks.c ****                 user defined low power mode     implementations require
2611:../Generated_Code/tasks.c ****                 configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2612:../Generated_Code/tasks.c ****                 #if ( configUSE_TICKLESS_IDLE != 0 )
2613:../Generated_Code/tasks.c ****                 {
2614:../Generated_Code/tasks.c ****                 TickType_t xExpectedIdleTime;
2615:../Generated_Code/tasks.c **** 
2616:../Generated_Code/tasks.c ****                         /* It is not desirable to suspend then resume the scheduler on
2617:../Generated_Code/tasks.c ****                         each iteration of the idle task.  Therefore, a preliminary
2618:../Generated_Code/tasks.c ****                         test of the expected idle time is performed without the
2619:../Generated_Code/tasks.c ****                         scheduler suspended.  The result here is not necessarily
2620:../Generated_Code/tasks.c ****                         valid. */
2621:../Generated_Code/tasks.c ****                         xExpectedIdleTime = prvGetExpectedIdleTime();
2622:../Generated_Code/tasks.c **** 
2623:../Generated_Code/tasks.c ****                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2624:../Generated_Code/tasks.c ****                         {
2625:../Generated_Code/tasks.c ****                                 vTaskSuspendAll();
2626:../Generated_Code/tasks.c ****                                 {
2627:../Generated_Code/tasks.c ****                                         /* Now the scheduler is suspended, the expected idle
2628:../Generated_Code/tasks.c ****                                         time can be sampled again, and this time its value can
2629:../Generated_Code/tasks.c ****                                         be used. */
2630:../Generated_Code/tasks.c ****                                         configASSERT( xNextTaskUnblockTime >= xTickCount );
2631:../Generated_Code/tasks.c ****                                         xExpectedIdleTime = prvGetExpectedIdleTime();
2632:../Generated_Code/tasks.c **** 
2633:../Generated_Code/tasks.c ****                                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SL
2634:../Generated_Code/tasks.c ****                                         {
2635:../Generated_Code/tasks.c ****                                                 traceLOW_POWER_IDLE_BEGIN();
2636:../Generated_Code/tasks.c ****                                                 portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2637:../Generated_Code/tasks.c ****                                                 traceLOW_POWER_IDLE_END();
2638:../Generated_Code/tasks.c ****                                         }
2639:../Generated_Code/tasks.c ****                                         else
2640:../Generated_Code/tasks.c ****                                         {
2641:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
2642:../Generated_Code/tasks.c ****                                         }
2643:../Generated_Code/tasks.c ****                                 }
2644:../Generated_Code/tasks.c ****                                 ( void ) xTaskResumeAll();
2645:../Generated_Code/tasks.c ****                         }
2646:../Generated_Code/tasks.c ****                         else
2647:../Generated_Code/tasks.c ****                         {
2648:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2649:../Generated_Code/tasks.c ****                         }
2650:../Generated_Code/tasks.c ****                 }
2651:../Generated_Code/tasks.c ****                 #endif /* configUSE_TICKLESS_IDLE */
2652:../Generated_Code/tasks.c ****         }
2653:../Generated_Code/tasks.c **** }
2654:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2655:../Generated_Code/tasks.c **** 
2656:../Generated_Code/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2657:../Generated_Code/tasks.c **** 
2658:../Generated_Code/tasks.c ****         eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2659:../Generated_Code/tasks.c ****         {
2660:../Generated_Code/tasks.c ****         eSleepModeStatus eReturn = eStandardSleep;
2661:../Generated_Code/tasks.c **** 
2662:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2663:../Generated_Code/tasks.c ****                 {
2664:../Generated_Code/tasks.c ****                         /* A task was made ready while the scheduler was suspended. */
2665:../Generated_Code/tasks.c ****                         eReturn = eAbortSleep;
2666:../Generated_Code/tasks.c ****                 }
2667:../Generated_Code/tasks.c ****                 else if( xYieldPending != pdFALSE )
2668:../Generated_Code/tasks.c ****                 {
2669:../Generated_Code/tasks.c ****                         /* A yield was pended while the scheduler was suspended. */
2670:../Generated_Code/tasks.c ****                         eReturn = eAbortSleep;
2671:../Generated_Code/tasks.c ****                 }
2672:../Generated_Code/tasks.c ****                 else
2673:../Generated_Code/tasks.c ****                 {
2674:../Generated_Code/tasks.c ****                         #if configUSE_TIMERS == 0
2675:../Generated_Code/tasks.c ****                         {
2676:../Generated_Code/tasks.c ****                                 /* The idle task exists in addition to the application tasks. */
2677:../Generated_Code/tasks.c ****                                 const UBaseType_t uxNonApplicationTasks = 1;
2678:../Generated_Code/tasks.c **** 
2679:../Generated_Code/tasks.c ****                                 /* If timers are not being used and all the tasks are in the
2680:../Generated_Code/tasks.c ****                                 suspended list (which might mean they have an infinite block
2681:../Generated_Code/tasks.c ****                                 time rather than actually being suspended) then it is safe to
2682:../Generated_Code/tasks.c ****                                 turn all clocks off and just wait for external interrupts. */
2683:../Generated_Code/tasks.c ****                                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNu
2684:../Generated_Code/tasks.c ****                                 {
2685:../Generated_Code/tasks.c ****                                         eReturn = eNoTasksWaitingTimeout;
2686:../Generated_Code/tasks.c ****                                 }
2687:../Generated_Code/tasks.c ****                                 else
2688:../Generated_Code/tasks.c ****                                 {
2689:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
2690:../Generated_Code/tasks.c ****                                 }
2691:../Generated_Code/tasks.c ****                         }
2692:../Generated_Code/tasks.c ****                         #endif /* configUSE_TIMERS */
2693:../Generated_Code/tasks.c ****                 }
2694:../Generated_Code/tasks.c **** 
2695:../Generated_Code/tasks.c ****                 return eReturn;
2696:../Generated_Code/tasks.c ****         }
2697:../Generated_Code/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2698:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2699:../Generated_Code/tasks.c **** 
2700:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2701:../Generated_Code/tasks.c **** {
 3302              		.loc 1 2701 0
 3303              		.cfi_startproc
 3304 0000 80B5     		push	{r7, lr}
 3305              	.LCFI74:
 3306              		.cfi_def_cfa_offset 8
 3307              		.cfi_offset 7, -8
 3308              		.cfi_offset 14, -4
 3309 0002 86B0     		sub	sp, sp, #24
 3310              	.LCFI75:
 3311              		.cfi_def_cfa_offset 32
 3312 0004 00AF     		add	r7, sp, #0
 3313              	.LCFI76:
 3314              		.cfi_def_cfa_register 7
 3315 0006 F860     		str	r0, [r7, #12]
 3316 0008 B960     		str	r1, [r7, #8]
 3317 000a 7A60     		str	r2, [r7, #4]
 3318 000c 3B60     		str	r3, [r7]
 3319              	.LBB39:
2702:../Generated_Code/tasks.c **** UBaseType_t x;
2703:../Generated_Code/tasks.c **** 
2704:../Generated_Code/tasks.c ****         /* Store the task name in the TCB. */
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3320              		.loc 1 2705 0
 3321 000e 0023     		mov	r3, #0
 3322 0010 7B61     		str	r3, [r7, #20]
 3323 0012 12E0     		b	.L242
 3324              	.L245:
2706:../Generated_Code/tasks.c ****         {
2707:../Generated_Code/tasks.c ****                 pxTCB->pcTaskName[ x ] = pcName[ x ];
 3325              		.loc 1 2707 0
 3326 0014 BA68     		ldr	r2, [r7, #8]
 3327 0016 7B69     		ldr	r3, [r7, #20]
 3328 0018 D318     		add	r3, r2, r3
 3329 001a 1A78     		ldrb	r2, [r3]
 3330 001c F868     		ldr	r0, [r7, #12]
 3331 001e 3023     		mov	r3, #48
 3332 0020 7969     		ldr	r1, [r7, #20]
 3333 0022 4118     		add	r1, r0, r1
 3334 0024 CB18     		add	r3, r1, r3
 3335 0026 1A71     		strb	r2, [r3, #4]
2708:../Generated_Code/tasks.c **** 
2709:../Generated_Code/tasks.c ****                 /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2710:../Generated_Code/tasks.c ****                 configMAX_TASK_NAME_LEN characters just in case the memory after the
2711:../Generated_Code/tasks.c ****                 string is not accessible (extremely unlikely). */
2712:../Generated_Code/tasks.c ****                 if( pcName[ x ] == 0x00 )
 3336              		.loc 1 2712 0
 3337 0028 BA68     		ldr	r2, [r7, #8]
 3338 002a 7B69     		ldr	r3, [r7, #20]
 3339 002c D318     		add	r3, r2, r3
 3340 002e 1B78     		ldrb	r3, [r3]
 3341 0030 002B     		cmp	r3, #0
 3342 0032 0BD0     		beq	.L247
 3343              	.L243:
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3344              		.loc 1 2705 0
 3345 0034 7B69     		ldr	r3, [r7, #20]
 3346 0036 0133     		add	r3, r3, #1
 3347 0038 7B61     		str	r3, [r7, #20]
 3348              	.L242:
2705:../Generated_Code/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3349              		.loc 1 2705 0 is_stmt 0
 3350 003a 7A69     		ldr	r2, [r7, #20]
 3351 003c 1821     		mov	r1, #24
 3352 003e 0023     		mov	r3, #0
 3353 0040 9142     		cmp	r1, r2
 3354 0042 5B41     		adc	r3, r3, r3
 3355 0044 DBB2     		uxtb	r3, r3
 3356 0046 002B     		cmp	r3, #0
 3357 0048 E4D1     		bne	.L245
 3358 004a 00E0     		b	.L244
 3359              	.L247:
2713:../Generated_Code/tasks.c ****                 {
2714:../Generated_Code/tasks.c ****                         break;
 3360              		.loc 1 2714 0 is_stmt 1
 3361 004c C046     		mov	r8, r8
 3362              	.L244:
2715:../Generated_Code/tasks.c ****                 }
2716:../Generated_Code/tasks.c ****                 else
2717:../Generated_Code/tasks.c ****                 {
2718:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2719:../Generated_Code/tasks.c ****                 }
2720:../Generated_Code/tasks.c ****         }
2721:../Generated_Code/tasks.c **** 
2722:../Generated_Code/tasks.c ****         /* Ensure the name string is terminated in the case that the string length
2723:../Generated_Code/tasks.c ****         was greater or equal to configMAX_TASK_NAME_LEN. */
2724:../Generated_Code/tasks.c ****         pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 3363              		.loc 1 2724 0
 3364 004e FA68     		ldr	r2, [r7, #12]
 3365 0050 4C23     		mov	r3, #76
 3366 0052 0021     		mov	r1, #0
 3367 0054 D154     		strb	r1, [r2, r3]
2725:../Generated_Code/tasks.c **** 
2726:../Generated_Code/tasks.c ****         /* This is used as an array index so must ensure it's not too large.  First
2727:../Generated_Code/tasks.c ****         remove the privilege bit if one is present. */
2728:../Generated_Code/tasks.c ****         if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 3368              		.loc 1 2728 0
 3369 0056 7B68     		ldr	r3, [r7, #4]
 3370 0058 052B     		cmp	r3, #5
 3371 005a 01D9     		bls	.L246
2729:../Generated_Code/tasks.c ****         {
2730:../Generated_Code/tasks.c ****                 uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 3372              		.loc 1 2730 0
 3373 005c 0523     		mov	r3, #5
 3374 005e 7B60     		str	r3, [r7, #4]
 3375              	.L246:
2731:../Generated_Code/tasks.c ****         }
2732:../Generated_Code/tasks.c ****         else
2733:../Generated_Code/tasks.c ****         {
2734:../Generated_Code/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2735:../Generated_Code/tasks.c ****         }
2736:../Generated_Code/tasks.c **** 
2737:../Generated_Code/tasks.c ****         pxTCB->uxPriority = uxPriority;
 3376              		.loc 1 2737 0
 3377 0060 FB68     		ldr	r3, [r7, #12]
 3378 0062 7A68     		ldr	r2, [r7, #4]
 3379 0064 DA62     		str	r2, [r3, #44]
2738:../Generated_Code/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
2739:../Generated_Code/tasks.c ****         {
2740:../Generated_Code/tasks.c ****                 pxTCB->uxBasePriority = uxPriority;
 3380              		.loc 1 2740 0
 3381 0066 FB68     		ldr	r3, [r7, #12]
 3382 0068 7A68     		ldr	r2, [r7, #4]
 3383 006a 1A65     		str	r2, [r3, #80]
2741:../Generated_Code/tasks.c ****         }
2742:../Generated_Code/tasks.c ****         #endif /* configUSE_MUTEXES */
2743:../Generated_Code/tasks.c **** 
2744:../Generated_Code/tasks.c ****         vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3384              		.loc 1 2744 0
 3385 006c FB68     		ldr	r3, [r7, #12]
 3386 006e 0433     		add	r3, r3, #4
 3387 0070 181C     		mov	r0, r3
 3388 0072 FFF7FEFF 		bl	vListInitialiseItem
2745:../Generated_Code/tasks.c ****         vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3389              		.loc 1 2745 0
 3390 0076 FB68     		ldr	r3, [r7, #12]
 3391 0078 1833     		add	r3, r3, #24
 3392 007a 181C     		mov	r0, r3
 3393 007c FFF7FEFF 		bl	vListInitialiseItem
2746:../Generated_Code/tasks.c **** 
2747:../Generated_Code/tasks.c ****         /* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2748:../Generated_Code/tasks.c ****         back to the containing TCB from a generic item in a list. */
2749:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3394              		.loc 1 2749 0
 3395 0080 FB68     		ldr	r3, [r7, #12]
 3396 0082 FA68     		ldr	r2, [r7, #12]
 3397 0084 1A61     		str	r2, [r3, #16]
2750:../Generated_Code/tasks.c **** 
2751:../Generated_Code/tasks.c ****         /* Event lists are always in priority order. */
2752:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - 
 3398              		.loc 1 2752 0
 3399 0086 7B68     		ldr	r3, [r7, #4]
 3400 0088 0622     		mov	r2, #6
 3401 008a D21A     		sub	r2, r2, r3
 3402 008c FB68     		ldr	r3, [r7, #12]
 3403 008e 9A61     		str	r2, [r3, #24]
2753:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3404              		.loc 1 2753 0
 3405 0090 FB68     		ldr	r3, [r7, #12]
 3406 0092 FA68     		ldr	r2, [r7, #12]
 3407 0094 5A62     		str	r2, [r3, #36]
 3408              	.LBE39:
2754:../Generated_Code/tasks.c **** 
2755:../Generated_Code/tasks.c ****         #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2756:../Generated_Code/tasks.c ****         {
2757:../Generated_Code/tasks.c ****                 pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2758:../Generated_Code/tasks.c ****         }
2759:../Generated_Code/tasks.c ****         #endif /* portCRITICAL_NESTING_IN_TCB */
2760:../Generated_Code/tasks.c **** 
2761:../Generated_Code/tasks.c ****         #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2762:../Generated_Code/tasks.c ****         {
2763:../Generated_Code/tasks.c ****                 pxTCB->pxTaskTag = NULL;
2764:../Generated_Code/tasks.c ****         }
2765:../Generated_Code/tasks.c ****         #endif /* configUSE_APPLICATION_TASK_TAG */
2766:../Generated_Code/tasks.c **** 
2767:../Generated_Code/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
2768:../Generated_Code/tasks.c ****         {
2769:../Generated_Code/tasks.c ****                 pxTCB->ulRunTimeCounter = 0UL;
2770:../Generated_Code/tasks.c ****         }
2771:../Generated_Code/tasks.c ****         #endif /* configGENERATE_RUN_TIME_STATS */
2772:../Generated_Code/tasks.c **** 
2773:../Generated_Code/tasks.c ****         #if ( portUSING_MPU_WRAPPERS == 1 )
2774:../Generated_Code/tasks.c ****         {
2775:../Generated_Code/tasks.c ****                 vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usSt
2776:../Generated_Code/tasks.c ****         }
2777:../Generated_Code/tasks.c ****         #else /* portUSING_MPU_WRAPPERS */
2778:../Generated_Code/tasks.c ****         {
2779:../Generated_Code/tasks.c ****                 ( void ) xRegions;
2780:../Generated_Code/tasks.c ****                 ( void ) usStackDepth;
2781:../Generated_Code/tasks.c ****         }
2782:../Generated_Code/tasks.c ****         #endif /* portUSING_MPU_WRAPPERS */
2783:../Generated_Code/tasks.c **** 
2784:../Generated_Code/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
2785:../Generated_Code/tasks.c ****         {
2786:../Generated_Code/tasks.c ****                 /* Initialise this task's Newlib reent structure. */
2787:../Generated_Code/tasks.c ****                 _REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2788:../Generated_Code/tasks.c ****         }
2789:../Generated_Code/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
2790:../Generated_Code/tasks.c **** }
 3409              		.loc 1 2790 0
 3410 0096 BD46     		mov	sp, r7
 3411 0098 06B0     		add	sp, sp, #24
 3412              		@ sp needed for prologue
 3413 009a 80BD     		pop	{r7, pc}
 3414              		.cfi_endproc
 3415              	.LFE35:
 3417              		.section	.text._ZL22prvInitialiseTaskListsv,"ax",%progbits
 3418              		.align	2
 3419              		.code	16
 3420              		.thumb_func
 3422              	_ZL22prvInitialiseTaskListsv:
 3423              	.LFB36:
2791:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2792:../Generated_Code/tasks.c **** 
2793:../Generated_Code/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2794:../Generated_Code/tasks.c **** 
2795:../Generated_Code/tasks.c ****         void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xReg
2796:../Generated_Code/tasks.c ****         {
2797:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
2798:../Generated_Code/tasks.c **** 
2799:../Generated_Code/tasks.c ****                 /* If null is passed in here then we are deleting ourselves. */
2800:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTaskToModify );
2801:../Generated_Code/tasks.c **** 
2802:../Generated_Code/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2803:../Generated_Code/tasks.c ****         }
2804:../Generated_Code/tasks.c **** 
2805:../Generated_Code/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2806:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2807:../Generated_Code/tasks.c **** 
2808:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void )
2809:../Generated_Code/tasks.c **** {
 3424              		.loc 1 2809 0
 3425              		.cfi_startproc
 3426 0000 80B5     		push	{r7, lr}
 3427              	.LCFI77:
 3428              		.cfi_def_cfa_offset 8
 3429              		.cfi_offset 7, -8
 3430              		.cfi_offset 14, -4
 3431 0002 82B0     		sub	sp, sp, #8
 3432              	.LCFI78:
 3433              		.cfi_def_cfa_offset 16
 3434 0004 00AF     		add	r7, sp, #0
 3435              	.LCFI79:
 3436              		.cfi_def_cfa_register 7
 3437              	.LBB40:
2810:../Generated_Code/tasks.c **** UBaseType_t uxPriority;
2811:../Generated_Code/tasks.c **** 
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3438              		.loc 1 2812 0
 3439 0006 0023     		mov	r3, #0
 3440 0008 7B60     		str	r3, [r7, #4]
 3441 000a 0CE0     		b	.L249
 3442              	.L250:
2813:../Generated_Code/tasks.c ****         {
2814:../Generated_Code/tasks.c ****                 vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3443              		.loc 1 2814 0
 3444 000c 7A68     		ldr	r2, [r7, #4]
 3445 000e 131C     		mov	r3, r2
 3446 0010 9B00     		lsl	r3, r3, #2
 3447 0012 9B18     		add	r3, r3, r2
 3448 0014 9B00     		lsl	r3, r3, #2
 3449 0016 144A     		ldr	r2, .L251
 3450 0018 9B18     		add	r3, r3, r2
 3451 001a 181C     		mov	r0, r3
 3452 001c FFF7FEFF 		bl	vListInitialise
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3453              		.loc 1 2812 0
 3454 0020 7B68     		ldr	r3, [r7, #4]
 3455 0022 0133     		add	r3, r3, #1
 3456 0024 7B60     		str	r3, [r7, #4]
 3457              	.L249:
2812:../Generated_Code/tasks.c ****         for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; ux
 3458              		.loc 1 2812 0 is_stmt 0
 3459 0026 7A68     		ldr	r2, [r7, #4]
 3460 0028 0521     		mov	r1, #5
 3461 002a 0023     		mov	r3, #0
 3462 002c 9142     		cmp	r1, r2
 3463 002e 5B41     		adc	r3, r3, r3
 3464 0030 DBB2     		uxtb	r3, r3
 3465 0032 002B     		cmp	r3, #0
 3466 0034 EAD1     		bne	.L250
2815:../Generated_Code/tasks.c ****         }
2816:../Generated_Code/tasks.c **** 
2817:../Generated_Code/tasks.c ****         vListInitialise( &xDelayedTaskList1 );
 3467              		.loc 1 2817 0 is_stmt 1
 3468 0036 0D4B     		ldr	r3, .L251+4
 3469 0038 181C     		mov	r0, r3
 3470 003a FFF7FEFF 		bl	vListInitialise
2818:../Generated_Code/tasks.c ****         vListInitialise( &xDelayedTaskList2 );
 3471              		.loc 1 2818 0
 3472 003e 0C4B     		ldr	r3, .L251+8
 3473 0040 181C     		mov	r0, r3
 3474 0042 FFF7FEFF 		bl	vListInitialise
2819:../Generated_Code/tasks.c ****         vListInitialise( &xPendingReadyList );
 3475              		.loc 1 2819 0
 3476 0046 0B4B     		ldr	r3, .L251+12
 3477 0048 181C     		mov	r0, r3
 3478 004a FFF7FEFF 		bl	vListInitialise
2820:../Generated_Code/tasks.c **** 
2821:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskDelete == 1 )
2822:../Generated_Code/tasks.c ****         {
2823:../Generated_Code/tasks.c ****                 vListInitialise( &xTasksWaitingTermination );
2824:../Generated_Code/tasks.c ****         }
2825:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskDelete */
2826:../Generated_Code/tasks.c **** 
2827:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
2828:../Generated_Code/tasks.c ****         {
2829:../Generated_Code/tasks.c ****                 vListInitialise( &xSuspendedTaskList );
 3479              		.loc 1 2829 0
 3480 004e 0A4B     		ldr	r3, .L251+16
 3481 0050 181C     		mov	r0, r3
 3482 0052 FFF7FEFF 		bl	vListInitialise
2830:../Generated_Code/tasks.c ****         }
2831:../Generated_Code/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
2832:../Generated_Code/tasks.c **** 
2833:../Generated_Code/tasks.c ****         /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2834:../Generated_Code/tasks.c ****         using list2. */
2835:../Generated_Code/tasks.c ****         pxDelayedTaskList = &xDelayedTaskList1;
 3483              		.loc 1 2835 0
 3484 0056 094B     		ldr	r3, .L251+20
 3485 0058 044A     		ldr	r2, .L251+4
 3486 005a 1A60     		str	r2, [r3]
2836:../Generated_Code/tasks.c ****         pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3487              		.loc 1 2836 0
 3488 005c 084B     		ldr	r3, .L251+24
 3489 005e 044A     		ldr	r2, .L251+8
 3490 0060 1A60     		str	r2, [r3]
 3491              	.LBE40:
2837:../Generated_Code/tasks.c **** }
 3492              		.loc 1 2837 0
 3493 0062 BD46     		mov	sp, r7
 3494 0064 02B0     		add	sp, sp, #8
 3495              		@ sp needed for prologue
 3496 0066 80BD     		pop	{r7, pc}
 3497              	.L252:
 3498              		.align	2
 3499              	.L251:
 3500 0068 00000000 		.word	_ZL17pxReadyTasksLists
 3501 006c 00000000 		.word	_ZL17xDelayedTaskList1
 3502 0070 00000000 		.word	_ZL17xDelayedTaskList2
 3503 0074 00000000 		.word	_ZL17xPendingReadyList
 3504 0078 00000000 		.word	_ZL18xSuspendedTaskList
 3505 007c 00000000 		.word	_ZL17pxDelayedTaskList
 3506 0080 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 3507              		.cfi_endproc
 3508              	.LFE36:
 3510              		.section	.text._ZL31prvCheckTasksWaitingTerminationv,"ax",%progbits
 3511              		.align	2
 3512              		.code	16
 3513              		.thumb_func
 3515              	_ZL31prvCheckTasksWaitingTerminationv:
 3516              	.LFB37:
2838:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2839:../Generated_Code/tasks.c **** 
2840:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2841:../Generated_Code/tasks.c **** {
 3517              		.loc 1 2841 0
 3518              		.cfi_startproc
 3519 0000 80B5     		push	{r7, lr}
 3520              	.LCFI80:
 3521              		.cfi_def_cfa_offset 8
 3522              		.cfi_offset 7, -8
 3523              		.cfi_offset 14, -4
 3524 0002 00AF     		add	r7, sp, #0
 3525              	.LCFI81:
 3526              		.cfi_def_cfa_register 7
2842:../Generated_Code/tasks.c ****         #if ( INCLUDE_vTaskDelete == 1 )
2843:../Generated_Code/tasks.c ****         {
2844:../Generated_Code/tasks.c ****                 BaseType_t xListIsEmpty;
2845:../Generated_Code/tasks.c **** 
2846:../Generated_Code/tasks.c ****                 /* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2847:../Generated_Code/tasks.c ****                 too often in the idle task. */
2848:../Generated_Code/tasks.c ****                 while( uxTasksDeleted > ( UBaseType_t ) 0U )
2849:../Generated_Code/tasks.c ****                 {
2850:../Generated_Code/tasks.c ****                         vTaskSuspendAll();
2851:../Generated_Code/tasks.c ****                         {
2852:../Generated_Code/tasks.c ****                                 xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2853:../Generated_Code/tasks.c ****                         }
2854:../Generated_Code/tasks.c ****                         ( void ) xTaskResumeAll();
2855:../Generated_Code/tasks.c **** 
2856:../Generated_Code/tasks.c ****                         if( xListIsEmpty == pdFALSE )
2857:../Generated_Code/tasks.c ****                         {
2858:../Generated_Code/tasks.c ****                                 TCB_t *pxTCB;
2859:../Generated_Code/tasks.c **** 
2860:../Generated_Code/tasks.c ****                                 taskENTER_CRITICAL();
2861:../Generated_Code/tasks.c ****                                 {
2862:../Generated_Code/tasks.c ****                                         pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksW
2863:../Generated_Code/tasks.c ****                                         ( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2864:../Generated_Code/tasks.c ****                                         --uxCurrentNumberOfTasks;
2865:../Generated_Code/tasks.c ****                                         --uxTasksDeleted;
2866:../Generated_Code/tasks.c ****                                 }
2867:../Generated_Code/tasks.c ****                                 taskEXIT_CRITICAL();
2868:../Generated_Code/tasks.c **** 
2869:../Generated_Code/tasks.c ****                                 prvDeleteTCB( pxTCB );
2870:../Generated_Code/tasks.c ****                         }
2871:../Generated_Code/tasks.c ****                         else
2872:../Generated_Code/tasks.c ****                         {
2873:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2874:../Generated_Code/tasks.c ****                         }
2875:../Generated_Code/tasks.c ****                 }
2876:../Generated_Code/tasks.c ****         }
2877:../Generated_Code/tasks.c ****         #endif /* vTaskDelete */
2878:../Generated_Code/tasks.c **** }
 3527              		.loc 1 2878 0
 3528 0004 BD46     		mov	sp, r7
 3529              		@ sp needed for prologue
 3530 0006 80BD     		pop	{r7, pc}
 3531              		.cfi_endproc
 3532              	.LFE37:
 3534              		.section	.text._ZL30prvAddCurrentTaskToDelayedListm,"ax",%progbits
 3535              		.align	2
 3536              		.code	16
 3537              		.thumb_func
 3539              	_ZL30prvAddCurrentTaskToDelayedListm:
 3540              	.LFB38:
2879:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2880:../Generated_Code/tasks.c **** 
2881:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2882:../Generated_Code/tasks.c **** {
 3541              		.loc 1 2882 0
 3542              		.cfi_startproc
 3543 0000 80B5     		push	{r7, lr}
 3544              	.LCFI82:
 3545              		.cfi_def_cfa_offset 8
 3546              		.cfi_offset 7, -8
 3547              		.cfi_offset 14, -4
 3548 0002 82B0     		sub	sp, sp, #8
 3549              	.LCFI83:
 3550              		.cfi_def_cfa_offset 16
 3551 0004 00AF     		add	r7, sp, #0
 3552              	.LCFI84:
 3553              		.cfi_def_cfa_register 7
 3554 0006 7860     		str	r0, [r7, #4]
2883:../Generated_Code/tasks.c ****         /* The list item will be inserted in wake time order. */
2884:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3555              		.loc 1 2884 0
 3556 0008 174B     		ldr	r3, .L257
 3557 000a 1B68     		ldr	r3, [r3]
 3558 000c 7A68     		ldr	r2, [r7, #4]
 3559 000e 5A60     		str	r2, [r3, #4]
2885:../Generated_Code/tasks.c **** 
2886:../Generated_Code/tasks.c ****         if( xTimeToWake < xTickCount )
 3560              		.loc 1 2886 0
 3561 0010 164B     		ldr	r3, .L257+4
 3562 0012 1B68     		ldr	r3, [r3]
 3563 0014 7A68     		ldr	r2, [r7, #4]
 3564 0016 9A42     		cmp	r2, r3
 3565 0018 9B41     		sbc	r3, r3, r3
 3566 001a 5B42     		neg	r3, r3
 3567 001c DBB2     		uxtb	r3, r3
 3568 001e 002B     		cmp	r3, #0
 3569 0020 09D0     		beq	.L255
2887:../Generated_Code/tasks.c ****         {
2888:../Generated_Code/tasks.c ****                 /* Wake time has overflowed.  Place this item in the overflow list. */
2889:../Generated_Code/tasks.c ****                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3570              		.loc 1 2889 0
 3571 0022 134B     		ldr	r3, .L257+8
 3572 0024 1A68     		ldr	r2, [r3]
 3573 0026 104B     		ldr	r3, .L257
 3574 0028 1B68     		ldr	r3, [r3]
 3575 002a 0433     		add	r3, r3, #4
 3576 002c 101C     		mov	r0, r2
 3577 002e 191C     		mov	r1, r3
 3578 0030 FFF7FEFF 		bl	vListInsert
 3579 0034 14E0     		b	.L254
 3580              	.L255:
2890:../Generated_Code/tasks.c ****         }
2891:../Generated_Code/tasks.c ****         else
2892:../Generated_Code/tasks.c ****         {
2893:../Generated_Code/tasks.c ****                 /* The wake time has not overflowed, so the current block list is used. */
2894:../Generated_Code/tasks.c ****                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3581              		.loc 1 2894 0
 3582 0036 0F4B     		ldr	r3, .L257+12
 3583 0038 1A68     		ldr	r2, [r3]
 3584 003a 0B4B     		ldr	r3, .L257
 3585 003c 1B68     		ldr	r3, [r3]
 3586 003e 0433     		add	r3, r3, #4
 3587 0040 101C     		mov	r0, r2
 3588 0042 191C     		mov	r1, r3
 3589 0044 FFF7FEFF 		bl	vListInsert
2895:../Generated_Code/tasks.c **** 
2896:../Generated_Code/tasks.c ****                 /* If the task entering the blocked state was placed at the head of the
2897:../Generated_Code/tasks.c ****                 list of blocked tasks then xNextTaskUnblockTime needs to be updated
2898:../Generated_Code/tasks.c ****                 too. */
2899:../Generated_Code/tasks.c ****                 if( xTimeToWake < xNextTaskUnblockTime )
 3590              		.loc 1 2899 0
 3591 0048 0B4B     		ldr	r3, .L257+16
 3592 004a 1B68     		ldr	r3, [r3]
 3593 004c 7A68     		ldr	r2, [r7, #4]
 3594 004e 9A42     		cmp	r2, r3
 3595 0050 9B41     		sbc	r3, r3, r3
 3596 0052 5B42     		neg	r3, r3
 3597 0054 DBB2     		uxtb	r3, r3
 3598 0056 002B     		cmp	r3, #0
 3599 0058 02D0     		beq	.L254
2900:../Generated_Code/tasks.c ****                 {
2901:../Generated_Code/tasks.c ****                         xNextTaskUnblockTime = xTimeToWake;
 3600              		.loc 1 2901 0
 3601 005a 074B     		ldr	r3, .L257+16
 3602 005c 7A68     		ldr	r2, [r7, #4]
 3603 005e 1A60     		str	r2, [r3]
 3604              	.L254:
2902:../Generated_Code/tasks.c ****                 }
2903:../Generated_Code/tasks.c ****                 else
2904:../Generated_Code/tasks.c ****                 {
2905:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2906:../Generated_Code/tasks.c ****                 }
2907:../Generated_Code/tasks.c ****         }
2908:../Generated_Code/tasks.c **** }
 3605              		.loc 1 2908 0
 3606 0060 BD46     		mov	sp, r7
 3607 0062 02B0     		add	sp, sp, #8
 3608              		@ sp needed for prologue
 3609 0064 80BD     		pop	{r7, pc}
 3610              	.L258:
 3611 0066 C046     		.align	2
 3612              	.L257:
 3613 0068 00000000 		.word	pxCurrentTCB
 3614 006c 00000000 		.word	_ZL10xTickCount
 3615 0070 00000000 		.word	_ZL25pxOverflowDelayedTaskList
 3616 0074 00000000 		.word	_ZL17pxDelayedTaskList
 3617 0078 00000000 		.word	_ZL20xNextTaskUnblockTime
 3618              		.cfi_endproc
 3619              	.LFE38:
 3621              		.section	.text._ZL22prvAllocateTCBAndStacktPm,"ax",%progbits
 3622              		.align	2
 3623              		.code	16
 3624              		.thumb_func
 3626              	_ZL22prvAllocateTCBAndStacktPm:
 3627              	.LFB39:
2909:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2910:../Generated_Code/tasks.c **** 
2911:../Generated_Code/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
2912:../Generated_Code/tasks.c **** {
 3628              		.loc 1 2912 0
 3629              		.cfi_startproc
 3630 0000 80B5     		push	{r7, lr}
 3631              	.LCFI85:
 3632              		.cfi_def_cfa_offset 8
 3633              		.cfi_offset 7, -8
 3634              		.cfi_offset 14, -4
 3635 0002 84B0     		sub	sp, sp, #16
 3636              	.LCFI86:
 3637              		.cfi_def_cfa_offset 24
 3638 0004 00AF     		add	r7, sp, #0
 3639              	.LCFI87:
 3640              		.cfi_def_cfa_register 7
 3641 0006 021C     		mov	r2, r0
 3642 0008 3960     		str	r1, [r7]
 3643 000a BB1D     		add	r3, r7, #6
 3644 000c 1A80     		strh	r2, [r3]
 3645              	.LBB41:
2913:../Generated_Code/tasks.c **** TCB_t *pxNewTCB;
2914:../Generated_Code/tasks.c **** 
2915:../Generated_Code/tasks.c ****         /* Allocate space for the TCB.  Where the memory comes from depends on
2916:../Generated_Code/tasks.c ****         the implementation of the port malloc function. */
2917:../Generated_Code/tasks.c ****         pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 3646              		.loc 1 2917 0
 3647 000e 5420     		mov	r0, #84
 3648 0010 FFF7FEFF 		bl	pvPortMalloc
 3649 0014 031C     		mov	r3, r0
 3650 0016 FB60     		str	r3, [r7, #12]
2918:../Generated_Code/tasks.c **** 
2919:../Generated_Code/tasks.c ****         if( pxNewTCB != NULL )
 3651              		.loc 1 2919 0
 3652 0018 FB68     		ldr	r3, [r7, #12]
 3653 001a 002B     		cmp	r3, #0
 3654 001c 22D0     		beq	.L260
2920:../Generated_Code/tasks.c ****         {
2921:../Generated_Code/tasks.c ****                 /* Allocate space for the stack used by the task being created.
2922:../Generated_Code/tasks.c ****                 The base of the stack memory stored in the TCB so the task can
2923:../Generated_Code/tasks.c ****                 be deleted later if required. */
2924:../Generated_Code/tasks.c ****                 pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDe
 3655              		.loc 1 2924 0
 3656 001e 3B68     		ldr	r3, [r7]
 3657 0020 002B     		cmp	r3, #0
 3658 0022 07D1     		bne	.L261
 3659              		.loc 1 2924 0 is_stmt 0
 3660 0024 BB1D     		add	r3, r7, #6
 3661 0026 1B88     		ldrh	r3, [r3]
 3662 0028 9B00     		lsl	r3, r3, #2
 3663 002a 181C     		mov	r0, r3
 3664 002c FFF7FEFF 		bl	pvPortMalloc
 3665 0030 021C     		mov	r2, r0
 3666 0032 00E0     		b	.L262
 3667              	.L261:
 3668              		.loc 1 2924 0
 3669 0034 3A68     		ldr	r2, [r7]
 3670              	.L262:
 3671              		.loc 1 2924 0
 3672 0036 FB68     		ldr	r3, [r7, #12]
 3673 0038 1A63     		str	r2, [r3, #48]
2925:../Generated_Code/tasks.c **** 
2926:../Generated_Code/tasks.c ****                 if( pxNewTCB->pxStack == NULL )
 3674              		.loc 1 2926 0 is_stmt 1
 3675 003a FB68     		ldr	r3, [r7, #12]
 3676 003c 1B6B     		ldr	r3, [r3, #48]
 3677 003e 002B     		cmp	r3, #0
 3678 0040 06D1     		bne	.L263
2927:../Generated_Code/tasks.c ****                 {
2928:../Generated_Code/tasks.c ****                         /* Could not allocate the stack.  Delete the allocated TCB. */
2929:../Generated_Code/tasks.c ****                         vPortFree( pxNewTCB );
 3679              		.loc 1 2929 0
 3680 0042 FB68     		ldr	r3, [r7, #12]
 3681 0044 181C     		mov	r0, r3
 3682 0046 FFF7FEFF 		bl	vPortFree
2930:../Generated_Code/tasks.c ****                         pxNewTCB = NULL;
 3683              		.loc 1 2930 0
 3684 004a 0023     		mov	r3, #0
 3685 004c FB60     		str	r3, [r7, #12]
 3686 004e 09E0     		b	.L260
 3687              	.L263:
2931:../Generated_Code/tasks.c ****                 }
2932:../Generated_Code/tasks.c ****                 else
2933:../Generated_Code/tasks.c ****                 {
2934:../Generated_Code/tasks.c ****                         /* Avoid dependency on memset() if it is not required. */
2935:../Generated_Code/tasks.c ****                         #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY =
2936:../Generated_Code/tasks.c ****                         {
2937:../Generated_Code/tasks.c ****                                 /* Just to help debugging. */
2938:../Generated_Code/tasks.c ****                                 ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( s
 3688              		.loc 1 2938 0
 3689 0050 FB68     		ldr	r3, [r7, #12]
 3690 0052 1A6B     		ldr	r2, [r3, #48]
 3691 0054 BB1D     		add	r3, r7, #6
 3692 0056 1B88     		ldrh	r3, [r3]
 3693 0058 9B00     		lsl	r3, r3, #2
 3694 005a 101C     		mov	r0, r2
 3695 005c A521     		mov	r1, #165
 3696 005e 1A1C     		mov	r2, r3
 3697 0060 FFF7FEFF 		bl	memset
 3698              	.L260:
2939:../Generated_Code/tasks.c ****                         }
2940:../Generated_Code/tasks.c ****                         #endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_F
2941:../Generated_Code/tasks.c ****                 }
2942:../Generated_Code/tasks.c ****         }
2943:../Generated_Code/tasks.c **** 
2944:../Generated_Code/tasks.c ****         return pxNewTCB;
 3699              		.loc 1 2944 0
 3700 0064 FB68     		ldr	r3, [r7, #12]
 3701              	.LBE41:
2945:../Generated_Code/tasks.c **** }
 3702              		.loc 1 2945 0
 3703 0066 181C     		mov	r0, r3
 3704 0068 BD46     		mov	sp, r7
 3705 006a 04B0     		add	sp, sp, #16
 3706              		@ sp needed for prologue
 3707 006c 80BD     		pop	{r7, pc}
 3708              		.cfi_endproc
 3709              	.LFE39:
 3711 006e C046     		.section	.text._ZL26prvTaskCheckFreeStackSpacePKh,"ax",%progbits
 3712              		.align	2
 3713              		.code	16
 3714              		.thumb_func
 3716              	_ZL26prvTaskCheckFreeStackSpacePKh:
 3717              	.LFB40:
2946:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2947:../Generated_Code/tasks.c **** 
2948:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2949:../Generated_Code/tasks.c **** 
2950:../Generated_Code/tasks.c ****         static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *px
2951:../Generated_Code/tasks.c ****         {
2952:../Generated_Code/tasks.c ****         volatile TCB_t *pxNextTCB, *pxFirstTCB;
2953:../Generated_Code/tasks.c ****         UBaseType_t uxTask = 0;
2954:../Generated_Code/tasks.c **** 
2955:../Generated_Code/tasks.c ****                 if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2956:../Generated_Code/tasks.c ****                 {
2957:../Generated_Code/tasks.c ****                         listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2958:../Generated_Code/tasks.c **** 
2959:../Generated_Code/tasks.c ****                         /* Populate an TaskStatus_t structure within the
2960:../Generated_Code/tasks.c ****                         pxTaskStatusArray array for each task that is referenced from
2961:../Generated_Code/tasks.c ****                         pxList.  See the definition of TaskStatus_t in task.h for the
2962:../Generated_Code/tasks.c ****                         meaning of each TaskStatus_t structure member. */
2963:../Generated_Code/tasks.c ****                         do
2964:../Generated_Code/tasks.c ****                         {
2965:../Generated_Code/tasks.c ****                                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2966:../Generated_Code/tasks.c **** 
2967:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
2968:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNext
2969:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2970:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2971:../Generated_Code/tasks.c ****                                 pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriori
2972:../Generated_Code/tasks.c **** 
2973:../Generated_Code/tasks.c ****                                 #if ( INCLUDE_vTaskSuspend == 1 )
2974:../Generated_Code/tasks.c ****                                 {
2975:../Generated_Code/tasks.c ****                                         /* If the task is in the suspended list then there is a cha
2976:../Generated_Code/tasks.c ****                                         it is actually just blocked indefinitely - so really it sho
2977:../Generated_Code/tasks.c ****                                         be reported as being in the Blocked state. */
2978:../Generated_Code/tasks.c ****                                         if( eState == eSuspended )
2979:../Generated_Code/tasks.c ****                                         {
2980:../Generated_Code/tasks.c ****                                                 if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventLi
2981:../Generated_Code/tasks.c ****                                                 {
2982:../Generated_Code/tasks.c ****                                                         pxTaskStatusArray[ uxTask ].eCurrentState =
2983:../Generated_Code/tasks.c ****                                                 }
2984:../Generated_Code/tasks.c ****                                         }
2985:../Generated_Code/tasks.c ****                                 }
2986:../Generated_Code/tasks.c ****                                 #endif /* INCLUDE_vTaskSuspend */
2987:../Generated_Code/tasks.c **** 
2988:../Generated_Code/tasks.c ****                                 #if ( configUSE_MUTEXES == 1 )
2989:../Generated_Code/tasks.c ****                                 {
2990:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxB
2991:../Generated_Code/tasks.c ****                                 }
2992:../Generated_Code/tasks.c ****                                 #else
2993:../Generated_Code/tasks.c ****                                 {
2994:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2995:../Generated_Code/tasks.c ****                                 }
2996:../Generated_Code/tasks.c ****                                 #endif
2997:../Generated_Code/tasks.c **** 
2998:../Generated_Code/tasks.c ****                                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2999:../Generated_Code/tasks.c ****                                 {
3000:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->u
3001:../Generated_Code/tasks.c ****                                 }
3002:../Generated_Code/tasks.c ****                                 #else
3003:../Generated_Code/tasks.c ****                                 {
3004:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3005:../Generated_Code/tasks.c ****                                 }
3006:../Generated_Code/tasks.c ****                                 #endif
3007:../Generated_Code/tasks.c **** 
3008:../Generated_Code/tasks.c ****                                 #if ( portSTACK_GROWTH > 0 )
3009:../Generated_Code/tasks.c ****                                 {
3010:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskC
3011:../Generated_Code/tasks.c ****                                 }
3012:../Generated_Code/tasks.c ****                                 #else
3013:../Generated_Code/tasks.c ****                                 {
3014:../Generated_Code/tasks.c ****                                         pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskC
3015:../Generated_Code/tasks.c ****                                 }
3016:../Generated_Code/tasks.c ****                                 #endif
3017:../Generated_Code/tasks.c **** 
3018:../Generated_Code/tasks.c ****                                 uxTask++;
3019:../Generated_Code/tasks.c **** 
3020:../Generated_Code/tasks.c ****                         } while( pxNextTCB != pxFirstTCB );
3021:../Generated_Code/tasks.c ****                 }
3022:../Generated_Code/tasks.c ****                 else
3023:../Generated_Code/tasks.c ****                 {
3024:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3025:../Generated_Code/tasks.c ****                 }
3026:../Generated_Code/tasks.c **** 
3027:../Generated_Code/tasks.c ****                 return uxTask;
3028:../Generated_Code/tasks.c ****         }
3029:../Generated_Code/tasks.c **** 
3030:../Generated_Code/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3031:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3032:../Generated_Code/tasks.c **** 
3033:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3034:../Generated_Code/tasks.c **** 
3035:../Generated_Code/tasks.c ****         static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3036:../Generated_Code/tasks.c ****         {
 3718              		.loc 1 3036 0
 3719              		.cfi_startproc
 3720 0000 80B5     		push	{r7, lr}
 3721              	.LCFI88:
 3722              		.cfi_def_cfa_offset 8
 3723              		.cfi_offset 7, -8
 3724              		.cfi_offset 14, -4
 3725 0002 84B0     		sub	sp, sp, #16
 3726              	.LCFI89:
 3727              		.cfi_def_cfa_offset 24
 3728 0004 00AF     		add	r7, sp, #0
 3729              	.LCFI90:
 3730              		.cfi_def_cfa_register 7
 3731 0006 7860     		str	r0, [r7, #4]
 3732              	.LBB42:
3037:../Generated_Code/tasks.c ****         uint32_t ulCount = 0U;
 3733              		.loc 1 3037 0
 3734 0008 0023     		mov	r3, #0
 3735 000a FB60     		str	r3, [r7, #12]
3038:../Generated_Code/tasks.c **** 
3039:../Generated_Code/tasks.c ****                 while( *pucStackByte == tskSTACK_FILL_BYTE )
 3736              		.loc 1 3039 0
 3737 000c 05E0     		b	.L266
 3738              	.L267:
3040:../Generated_Code/tasks.c ****                 {
3041:../Generated_Code/tasks.c ****                         pucStackByte -= portSTACK_GROWTH;
 3739              		.loc 1 3041 0
 3740 000e 7B68     		ldr	r3, [r7, #4]
 3741 0010 0133     		add	r3, r3, #1
 3742 0012 7B60     		str	r3, [r7, #4]
3042:../Generated_Code/tasks.c ****                         ulCount++;
 3743              		.loc 1 3042 0
 3744 0014 FB68     		ldr	r3, [r7, #12]
 3745 0016 0133     		add	r3, r3, #1
 3746 0018 FB60     		str	r3, [r7, #12]
 3747              	.L266:
3039:../Generated_Code/tasks.c ****                 while( *pucStackByte == tskSTACK_FILL_BYTE )
 3748              		.loc 1 3039 0
 3749 001a 7B68     		ldr	r3, [r7, #4]
 3750 001c 1B78     		ldrb	r3, [r3]
 3751 001e A53B     		sub	r3, r3, #165
 3752 0020 5A42     		neg	r2, r3
 3753 0022 5341     		adc	r3, r3, r2
 3754 0024 DBB2     		uxtb	r3, r3
 3755 0026 002B     		cmp	r3, #0
 3756 0028 F1D1     		bne	.L267
3043:../Generated_Code/tasks.c ****                 }
3044:../Generated_Code/tasks.c **** 
3045:../Generated_Code/tasks.c ****                 ulCount /= ( uint32_t ) sizeof( StackType_t );
 3757              		.loc 1 3045 0
 3758 002a FB68     		ldr	r3, [r7, #12]
 3759 002c 9B08     		lsr	r3, r3, #2
 3760 002e FB60     		str	r3, [r7, #12]
3046:../Generated_Code/tasks.c **** 
3047:../Generated_Code/tasks.c ****                 return ( uint16_t ) ulCount;
 3761              		.loc 1 3047 0
 3762 0030 FB68     		ldr	r3, [r7, #12]
 3763 0032 9BB2     		uxth	r3, r3
 3764              	.LBE42:
3048:../Generated_Code/tasks.c ****         }
 3765              		.loc 1 3048 0
 3766 0034 181C     		mov	r0, r3
 3767 0036 BD46     		mov	sp, r7
 3768 0038 04B0     		add	sp, sp, #16
 3769              		@ sp needed for prologue
 3770 003a 80BD     		pop	{r7, pc}
 3771              		.cfi_endproc
 3772              	.LFE40:
 3774              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3775              		.align	2
 3776              		.global	uxTaskGetStackHighWaterMark
 3777              		.code	16
 3778              		.thumb_func
 3780              	uxTaskGetStackHighWaterMark:
 3781              	.LFB41:
3049:../Generated_Code/tasks.c **** 
3050:../Generated_Code/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3051:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3052:../Generated_Code/tasks.c **** 
3053:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3054:../Generated_Code/tasks.c **** 
3055:../Generated_Code/tasks.c ****         UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3056:../Generated_Code/tasks.c ****         {
 3782              		.loc 1 3056 0
 3783              		.cfi_startproc
 3784 0000 80B5     		push	{r7, lr}
 3785              	.LCFI91:
 3786              		.cfi_def_cfa_offset 8
 3787              		.cfi_offset 7, -8
 3788              		.cfi_offset 14, -4
 3789 0002 86B0     		sub	sp, sp, #24
 3790              	.LCFI92:
 3791              		.cfi_def_cfa_offset 32
 3792 0004 00AF     		add	r7, sp, #0
 3793              	.LCFI93:
 3794              		.cfi_def_cfa_register 7
 3795 0006 7860     		str	r0, [r7, #4]
 3796              	.LBB43:
3057:../Generated_Code/tasks.c ****         TCB_t *pxTCB;
3058:../Generated_Code/tasks.c ****         uint8_t *pucEndOfStack;
3059:../Generated_Code/tasks.c ****         UBaseType_t uxReturn;
3060:../Generated_Code/tasks.c **** 
3061:../Generated_Code/tasks.c ****                 pxTCB = prvGetTCBFromHandle( xTask );
 3797              		.loc 1 3061 0
 3798 0008 7B68     		ldr	r3, [r7, #4]
 3799 000a 002B     		cmp	r3, #0
 3800 000c 02D1     		bne	.L270
 3801              		.loc 1 3061 0 is_stmt 0
 3802 000e 094B     		ldr	r3, .L273
 3803 0010 1B68     		ldr	r3, [r3]
 3804 0012 00E0     		b	.L271
 3805              	.L270:
 3806              		.loc 1 3061 0
 3807 0014 7B68     		ldr	r3, [r7, #4]
 3808              	.L271:
 3809              		.loc 1 3061 0
 3810 0016 7B61     		str	r3, [r7, #20]
3062:../Generated_Code/tasks.c **** 
3063:../Generated_Code/tasks.c ****                 #if portSTACK_GROWTH < 0
3064:../Generated_Code/tasks.c ****                 {
3065:../Generated_Code/tasks.c ****                         pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 3811              		.loc 1 3065 0 is_stmt 1
 3812 0018 7B69     		ldr	r3, [r7, #20]
 3813 001a 1B6B     		ldr	r3, [r3, #48]
 3814 001c 3B61     		str	r3, [r7, #16]
3066:../Generated_Code/tasks.c ****                 }
3067:../Generated_Code/tasks.c ****                 #else
3068:../Generated_Code/tasks.c ****                 {
3069:../Generated_Code/tasks.c ****                         pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3070:../Generated_Code/tasks.c ****                 }
3071:../Generated_Code/tasks.c ****                 #endif
3072:../Generated_Code/tasks.c **** 
3073:../Generated_Code/tasks.c ****                 uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 3815              		.loc 1 3073 0
 3816 001e 3B69     		ldr	r3, [r7, #16]
 3817 0020 181C     		mov	r0, r3
 3818 0022 FFF7FEFF 		bl	_ZL26prvTaskCheckFreeStackSpacePKh
 3819 0026 031C     		mov	r3, r0
 3820 0028 FB60     		str	r3, [r7, #12]
3074:../Generated_Code/tasks.c **** 
3075:../Generated_Code/tasks.c ****                 return uxReturn;
 3821              		.loc 1 3075 0
 3822 002a FB68     		ldr	r3, [r7, #12]
 3823              	.LBE43:
3076:../Generated_Code/tasks.c ****         }
 3824              		.loc 1 3076 0
 3825 002c 181C     		mov	r0, r3
 3826 002e BD46     		mov	sp, r7
 3827 0030 06B0     		add	sp, sp, #24
 3828              		@ sp needed for prologue
 3829 0032 80BD     		pop	{r7, pc}
 3830              	.L274:
 3831              		.align	2
 3832              	.L273:
 3833 0034 00000000 		.word	pxCurrentTCB
 3834              		.cfi_endproc
 3835              	.LFE41:
 3837              		.section	.text._ZL27prvResetNextTaskUnblockTimev,"ax",%progbits
 3838              		.align	2
 3839              		.code	16
 3840              		.thumb_func
 3842              	_ZL27prvResetNextTaskUnblockTimev:
 3843              	.LFB42:
3077:../Generated_Code/tasks.c **** 
3078:../Generated_Code/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3079:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3080:../Generated_Code/tasks.c **** 
3081:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3082:../Generated_Code/tasks.c **** 
3083:../Generated_Code/tasks.c ****         static void prvDeleteTCB( TCB_t *pxTCB )
3084:../Generated_Code/tasks.c ****         {
3085:../Generated_Code/tasks.c ****                 /* This call is required specifically for the TriCore port.  It must be
3086:../Generated_Code/tasks.c ****                 above the vPortFree() calls.  The call is also used by ports/demos that
3087:../Generated_Code/tasks.c ****                 want to allocate and clean RAM statically. */
3088:../Generated_Code/tasks.c ****                 portCLEAN_UP_TCB( pxTCB );
3089:../Generated_Code/tasks.c **** 
3090:../Generated_Code/tasks.c ****                 /* Free up the memory allocated by the scheduler for the task.  It is up to
3091:../Generated_Code/tasks.c ****                 the task to free any memory allocated at the application level. */
3092:../Generated_Code/tasks.c ****                 vPortFreeAligned( pxTCB->pxStack );
3093:../Generated_Code/tasks.c ****                 vPortFree( pxTCB );
3094:../Generated_Code/tasks.c ****         }
3095:../Generated_Code/tasks.c **** 
3096:../Generated_Code/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3097:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3098:../Generated_Code/tasks.c **** 
3099:../Generated_Code/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3100:../Generated_Code/tasks.c **** {
 3844              		.loc 1 3100 0
 3845              		.cfi_startproc
 3846 0000 80B5     		push	{r7, lr}
 3847              	.LCFI94:
 3848              		.cfi_def_cfa_offset 8
 3849              		.cfi_offset 7, -8
 3850              		.cfi_offset 14, -4
 3851 0002 82B0     		sub	sp, sp, #8
 3852              	.LCFI95:
 3853              		.cfi_def_cfa_offset 16
 3854 0004 00AF     		add	r7, sp, #0
 3855              	.LCFI96:
 3856              		.cfi_def_cfa_register 7
 3857              	.LBB44:
3101:../Generated_Code/tasks.c **** TCB_t *pxTCB;
3102:../Generated_Code/tasks.c **** 
3103:../Generated_Code/tasks.c ****         if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3858              		.loc 1 3103 0
 3859 0006 0D4B     		ldr	r3, .L280
 3860 0008 1B68     		ldr	r3, [r3]
 3861 000a 1B68     		ldr	r3, [r3]
 3862 000c 002B     		cmp	r3, #0
 3863 000e 01D1     		bne	.L276
 3864              		.loc 1 3103 0 is_stmt 0
 3865 0010 0123     		mov	r3, #1
 3866 0012 00E0     		b	.L277
 3867              	.L276:
 3868              		.loc 1 3103 0
 3869 0014 0023     		mov	r3, #0
 3870              	.L277:
 3871              		.loc 1 3103 0
 3872 0016 002B     		cmp	r3, #0
 3873 0018 04D0     		beq	.L278
3104:../Generated_Code/tasks.c ****         {
3105:../Generated_Code/tasks.c ****                 /* The new current delayed list is empty.  Set
3106:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime to the maximum possible value so it is
3107:../Generated_Code/tasks.c ****                 extremely unlikely that the
3108:../Generated_Code/tasks.c ****                 if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3109:../Generated_Code/tasks.c ****                 there is an item in the delayed list. */
3110:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime = portMAX_DELAY;
 3874              		.loc 1 3110 0 is_stmt 1
 3875 001a 094B     		ldr	r3, .L280+4
 3876 001c 0122     		mov	r2, #1
 3877 001e 5242     		neg	r2, r2
 3878 0020 1A60     		str	r2, [r3]
 3879 0022 08E0     		b	.L275
 3880              	.L278:
3111:../Generated_Code/tasks.c ****         }
3112:../Generated_Code/tasks.c ****         else
3113:../Generated_Code/tasks.c ****         {
3114:../Generated_Code/tasks.c ****                 /* The new current delayed list is not empty, get the value of
3115:../Generated_Code/tasks.c ****                 the item at the head of the delayed list.  This is the time at
3116:../Generated_Code/tasks.c ****                 which the task at the head of the delayed list should be removed
3117:../Generated_Code/tasks.c ****                 from the Blocked state. */
3118:../Generated_Code/tasks.c ****                 ( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 3881              		.loc 1 3118 0
 3882 0024 054B     		ldr	r3, .L280
 3883 0026 1B68     		ldr	r3, [r3]
 3884 0028 DB68     		ldr	r3, [r3, #12]
 3885 002a DB68     		ldr	r3, [r3, #12]
 3886 002c 7B60     		str	r3, [r7, #4]
3119:../Generated_Code/tasks.c ****                 xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 3887              		.loc 1 3119 0
 3888 002e 7B68     		ldr	r3, [r7, #4]
 3889 0030 5A68     		ldr	r2, [r3, #4]
 3890 0032 034B     		ldr	r3, .L280+4
 3891 0034 1A60     		str	r2, [r3]
 3892              	.L275:
 3893              	.LBE44:
3120:../Generated_Code/tasks.c ****         }
3121:../Generated_Code/tasks.c **** }
 3894              		.loc 1 3121 0
 3895 0036 BD46     		mov	sp, r7
 3896 0038 02B0     		add	sp, sp, #8
 3897              		@ sp needed for prologue
 3898 003a 80BD     		pop	{r7, pc}
 3899              	.L281:
 3900              		.align	2
 3901              	.L280:
 3902 003c 00000000 		.word	_ZL17pxDelayedTaskList
 3903 0040 00000000 		.word	_ZL20xNextTaskUnblockTime
 3904              		.cfi_endproc
 3905              	.LFE42:
 3907              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3908              		.align	2
 3909              		.global	xTaskGetCurrentTaskHandle
 3910              		.code	16
 3911              		.thumb_func
 3913              	xTaskGetCurrentTaskHandle:
 3914              	.LFB43:
3122:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3123:../Generated_Code/tasks.c **** 
3124:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3125:../Generated_Code/tasks.c **** 
3126:../Generated_Code/tasks.c ****         TaskHandle_t xTaskGetCurrentTaskHandle( void )
3127:../Generated_Code/tasks.c ****         {
 3915              		.loc 1 3127 0
 3916              		.cfi_startproc
 3917 0000 80B5     		push	{r7, lr}
 3918              	.LCFI97:
 3919              		.cfi_def_cfa_offset 8
 3920              		.cfi_offset 7, -8
 3921              		.cfi_offset 14, -4
 3922 0002 82B0     		sub	sp, sp, #8
 3923              	.LCFI98:
 3924              		.cfi_def_cfa_offset 16
 3925 0004 00AF     		add	r7, sp, #0
 3926              	.LCFI99:
 3927              		.cfi_def_cfa_register 7
 3928              	.LBB45:
3128:../Generated_Code/tasks.c ****         TaskHandle_t xReturn;
3129:../Generated_Code/tasks.c **** 
3130:../Generated_Code/tasks.c ****                 /* A critical section is not required as this is not called from
3131:../Generated_Code/tasks.c ****                 an interrupt and the current TCB will always be the same for any
3132:../Generated_Code/tasks.c ****                 individual execution thread. */
3133:../Generated_Code/tasks.c ****                 xReturn = pxCurrentTCB;
 3929              		.loc 1 3133 0
 3930 0006 044B     		ldr	r3, .L284
 3931 0008 1B68     		ldr	r3, [r3]
 3932 000a 7B60     		str	r3, [r7, #4]
3134:../Generated_Code/tasks.c **** 
3135:../Generated_Code/tasks.c ****                 return xReturn;
 3933              		.loc 1 3135 0
 3934 000c 7B68     		ldr	r3, [r7, #4]
 3935              	.LBE45:
3136:../Generated_Code/tasks.c ****         }
 3936              		.loc 1 3136 0
 3937 000e 181C     		mov	r0, r3
 3938 0010 BD46     		mov	sp, r7
 3939 0012 02B0     		add	sp, sp, #8
 3940              		@ sp needed for prologue
 3941 0014 80BD     		pop	{r7, pc}
 3942              	.L285:
 3943 0016 C046     		.align	2
 3944              	.L284:
 3945 0018 00000000 		.word	pxCurrentTCB
 3946              		.cfi_endproc
 3947              	.LFE43:
 3949              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3950              		.align	2
 3951              		.global	xTaskGetSchedulerState
 3952              		.code	16
 3953              		.thumb_func
 3955              	xTaskGetSchedulerState:
 3956              	.LFB44:
3137:../Generated_Code/tasks.c **** 
3138:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3139:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3140:../Generated_Code/tasks.c **** 
3141:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3142:../Generated_Code/tasks.c **** 
3143:../Generated_Code/tasks.c ****         BaseType_t xTaskGetSchedulerState( void )
3144:../Generated_Code/tasks.c ****         {
 3957              		.loc 1 3144 0
 3958              		.cfi_startproc
 3959 0000 80B5     		push	{r7, lr}
 3960              	.LCFI100:
 3961              		.cfi_def_cfa_offset 8
 3962              		.cfi_offset 7, -8
 3963              		.cfi_offset 14, -4
 3964 0002 82B0     		sub	sp, sp, #8
 3965              	.LCFI101:
 3966              		.cfi_def_cfa_offset 16
 3967 0004 00AF     		add	r7, sp, #0
 3968              	.LCFI102:
 3969              		.cfi_def_cfa_register 7
 3970              	.LBB46:
3145:../Generated_Code/tasks.c ****         BaseType_t xReturn;
3146:../Generated_Code/tasks.c **** 
3147:../Generated_Code/tasks.c ****                 if( xSchedulerRunning == pdFALSE )
 3971              		.loc 1 3147 0
 3972 0006 0D4B     		ldr	r3, .L291
 3973 0008 1B68     		ldr	r3, [r3]
 3974 000a 5A42     		neg	r2, r3
 3975 000c 5341     		adc	r3, r3, r2
 3976 000e DBB2     		uxtb	r3, r3
 3977 0010 002B     		cmp	r3, #0
 3978 0012 02D0     		beq	.L287
3148:../Generated_Code/tasks.c ****                 {
3149:../Generated_Code/tasks.c ****                         xReturn = taskSCHEDULER_NOT_STARTED;
 3979              		.loc 1 3149 0
 3980 0014 0123     		mov	r3, #1
 3981 0016 7B60     		str	r3, [r7, #4]
 3982 0018 0BE0     		b	.L288
 3983              	.L287:
3150:../Generated_Code/tasks.c ****                 }
3151:../Generated_Code/tasks.c ****                 else
3152:../Generated_Code/tasks.c ****                 {
3153:../Generated_Code/tasks.c ****                         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3984              		.loc 1 3153 0
 3985 001a 094B     		ldr	r3, .L291+4
 3986 001c 1B68     		ldr	r3, [r3]
 3987 001e 5A42     		neg	r2, r3
 3988 0020 5341     		adc	r3, r3, r2
 3989 0022 DBB2     		uxtb	r3, r3
 3990 0024 002B     		cmp	r3, #0
 3991 0026 02D0     		beq	.L289
3154:../Generated_Code/tasks.c ****                         {
3155:../Generated_Code/tasks.c ****                                 xReturn = taskSCHEDULER_RUNNING;
 3992              		.loc 1 3155 0
 3993 0028 0223     		mov	r3, #2
 3994 002a 7B60     		str	r3, [r7, #4]
 3995 002c 01E0     		b	.L288
 3996              	.L289:
3156:../Generated_Code/tasks.c ****                         }
3157:../Generated_Code/tasks.c ****                         else
3158:../Generated_Code/tasks.c ****                         {
3159:../Generated_Code/tasks.c ****                                 xReturn = taskSCHEDULER_SUSPENDED;
 3997              		.loc 1 3159 0
 3998 002e 0023     		mov	r3, #0
 3999 0030 7B60     		str	r3, [r7, #4]
 4000              	.L288:
3160:../Generated_Code/tasks.c ****                         }
3161:../Generated_Code/tasks.c ****                 }
3162:../Generated_Code/tasks.c **** 
3163:../Generated_Code/tasks.c ****                 return xReturn;
 4001              		.loc 1 3163 0
 4002 0032 7B68     		ldr	r3, [r7, #4]
 4003              	.LBE46:
3164:../Generated_Code/tasks.c ****         }
 4004              		.loc 1 3164 0
 4005 0034 181C     		mov	r0, r3
 4006 0036 BD46     		mov	sp, r7
 4007 0038 02B0     		add	sp, sp, #8
 4008              		@ sp needed for prologue
 4009 003a 80BD     		pop	{r7, pc}
 4010              	.L292:
 4011              		.align	2
 4012              	.L291:
 4013 003c 00000000 		.word	_ZL17xSchedulerRunning
 4014 0040 00000000 		.word	_ZL20uxSchedulerSuspended
 4015              		.cfi_endproc
 4016              	.LFE44:
 4018              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 4019              		.align	2
 4020              		.global	vTaskPriorityInherit
 4021              		.code	16
 4022              		.thumb_func
 4024              	vTaskPriorityInherit:
 4025              	.LFB45:
3165:../Generated_Code/tasks.c **** 
3166:../Generated_Code/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3167:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3168:../Generated_Code/tasks.c **** 
3169:../Generated_Code/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3170:../Generated_Code/tasks.c **** 
3171:../Generated_Code/tasks.c ****         void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3172:../Generated_Code/tasks.c ****         {
 4026              		.loc 1 3172 0
 4027              		.cfi_startproc
 4028 0000 80B5     		push	{r7, lr}
 4029              	.LCFI103:
 4030              		.cfi_def_cfa_offset 8
 4031              		.cfi_offset 7, -8
 4032              		.cfi_offset 14, -4
 4033 0002 84B0     		sub	sp, sp, #16
 4034              	.LCFI104:
 4035              		.cfi_def_cfa_offset 24
 4036 0004 00AF     		add	r7, sp, #0
 4037              	.LCFI105:
 4038              		.cfi_def_cfa_register 7
 4039 0006 7860     		str	r0, [r7, #4]
 4040              	.LBB47:
3173:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4041              		.loc 1 3173 0
 4042 0008 7B68     		ldr	r3, [r7, #4]
 4043 000a FB60     		str	r3, [r7, #12]
3174:../Generated_Code/tasks.c **** 
3175:../Generated_Code/tasks.c ****                 /* If the mutex was given back by an interrupt while the queue was
3176:../Generated_Code/tasks.c ****                 locked then the mutex holder might now be NULL. */
3177:../Generated_Code/tasks.c ****                 if( pxMutexHolder != NULL )
 4044              		.loc 1 3177 0
 4045 000c 7B68     		ldr	r3, [r7, #4]
 4046 000e 002B     		cmp	r3, #0
 4047 0010 52D0     		beq	.L293
3178:../Generated_Code/tasks.c ****                 {
3179:../Generated_Code/tasks.c ****                         if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4048              		.loc 1 3179 0
 4049 0012 FB68     		ldr	r3, [r7, #12]
 4050 0014 DA6A     		ldr	r2, [r3, #44]
 4051 0016 2A4B     		ldr	r3, .L300
 4052 0018 1B68     		ldr	r3, [r3]
 4053 001a DB6A     		ldr	r3, [r3, #44]
 4054 001c 9A42     		cmp	r2, r3
 4055 001e 9B41     		sbc	r3, r3, r3
 4056 0020 5B42     		neg	r3, r3
 4057 0022 DBB2     		uxtb	r3, r3
 4058 0024 002B     		cmp	r3, #0
 4059 0026 47D0     		beq	.L293
3180:../Generated_Code/tasks.c ****                         {
3181:../Generated_Code/tasks.c ****                                 /* Adjust the mutex holder state to account for its new
3182:../Generated_Code/tasks.c ****                                 priority.  Only reset the event list item value if the value is
3183:../Generated_Code/tasks.c ****                                 not     being used for anything else. */
3184:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 4060              		.loc 1 3184 0
 4061 0028 FB68     		ldr	r3, [r7, #12]
 4062 002a 9B69     		ldr	r3, [r3, #24]
 4063 002c 002B     		cmp	r3, #0
 4064 002e 06DB     		blt	.L295
3185:../Generated_Code/tasks.c ****                                 {
3186:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( Tick
 4065              		.loc 1 3186 0
 4066 0030 234B     		ldr	r3, .L300
 4067 0032 1B68     		ldr	r3, [r3]
 4068 0034 DB6A     		ldr	r3, [r3, #44]
 4069 0036 0622     		mov	r2, #6
 4070 0038 D21A     		sub	r2, r2, r3
 4071 003a FB68     		ldr	r3, [r7, #12]
 4072 003c 9A61     		str	r2, [r3, #24]
 4073              	.L295:
3187:../Generated_Code/tasks.c ****                                 }
3188:../Generated_Code/tasks.c ****                                 else
3189:../Generated_Code/tasks.c ****                                 {
3190:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3191:../Generated_Code/tasks.c ****                                 }
3192:../Generated_Code/tasks.c **** 
3193:../Generated_Code/tasks.c ****                                 /* If the task being modified is in the ready state it will need to
3194:../Generated_Code/tasks.c ****                                 be moved into a new list. */
3195:../Generated_Code/tasks.c ****                                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriorit
 4074              		.loc 1 3195 0
 4075 003e FB68     		ldr	r3, [r7, #12]
 4076 0040 5969     		ldr	r1, [r3, #20]
 4077 0042 FB68     		ldr	r3, [r7, #12]
 4078 0044 DA6A     		ldr	r2, [r3, #44]
 4079 0046 131C     		mov	r3, r2
 4080 0048 9B00     		lsl	r3, r3, #2
 4081 004a 9B18     		add	r3, r3, r2
 4082 004c 9B00     		lsl	r3, r3, #2
 4083 004e 1D4A     		ldr	r2, .L300+4
 4084 0050 9B18     		add	r3, r3, r2
 4085 0052 9942     		cmp	r1, r3
 4086 0054 01D1     		bne	.L296
 4087              		.loc 1 3195 0 is_stmt 0
 4088 0056 0123     		mov	r3, #1
 4089 0058 00E0     		b	.L297
 4090              	.L296:
 4091              		.loc 1 3195 0
 4092 005a 0023     		mov	r3, #0
 4093              	.L297:
 4094              		.loc 1 3195 0
 4095 005c 002B     		cmp	r3, #0
 4096 005e 26D0     		beq	.L298
3196:../Generated_Code/tasks.c ****                                 {
3197:../Generated_Code/tasks.c ****                                         if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBase
 4097              		.loc 1 3197 0 is_stmt 1
 4098 0060 FB68     		ldr	r3, [r7, #12]
 4099 0062 0433     		add	r3, r3, #4
 4100 0064 181C     		mov	r0, r3
 4101 0066 FFF7FEFF 		bl	uxListRemove
3198:../Generated_Code/tasks.c ****                                         {
3199:../Generated_Code/tasks.c ****                                                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3200:../Generated_Code/tasks.c ****                                         }
3201:../Generated_Code/tasks.c ****                                         else
3202:../Generated_Code/tasks.c ****                                         {
3203:../Generated_Code/tasks.c ****                                                 mtCOVERAGE_TEST_MARKER();
3204:../Generated_Code/tasks.c ****                                         }
3205:../Generated_Code/tasks.c **** 
3206:../Generated_Code/tasks.c ****                                         /* Inherit the priority before being moved into the new lis
3207:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4102              		.loc 1 3207 0
 4103 006a 154B     		ldr	r3, .L300
 4104 006c 1B68     		ldr	r3, [r3]
 4105 006e DA6A     		ldr	r2, [r3, #44]
 4106 0070 FB68     		ldr	r3, [r7, #12]
 4107 0072 DA62     		str	r2, [r3, #44]
3208:../Generated_Code/tasks.c ****                                         prvAddTaskToReadyList( pxTCB );
 4108              		.loc 1 3208 0
 4109 0074 FB68     		ldr	r3, [r7, #12]
 4110 0076 DA6A     		ldr	r2, [r3, #44]
 4111 0078 134B     		ldr	r3, .L300+8
 4112 007a 1B68     		ldr	r3, [r3]
 4113 007c 9342     		cmp	r3, r2
 4114 007e 9B41     		sbc	r3, r3, r3
 4115 0080 5B42     		neg	r3, r3
 4116 0082 DBB2     		uxtb	r3, r3
 4117 0084 002B     		cmp	r3, #0
 4118 0086 03D0     		beq	.L299
 4119              		.loc 1 3208 0 is_stmt 0
 4120 0088 FB68     		ldr	r3, [r7, #12]
 4121 008a DA6A     		ldr	r2, [r3, #44]
 4122 008c 0E4B     		ldr	r3, .L300+8
 4123 008e 1A60     		str	r2, [r3]
 4124              	.L299:
 4125              		.loc 1 3208 0
 4126 0090 FB68     		ldr	r3, [r7, #12]
 4127 0092 DA6A     		ldr	r2, [r3, #44]
 4128 0094 131C     		mov	r3, r2
 4129 0096 9B00     		lsl	r3, r3, #2
 4130 0098 9B18     		add	r3, r3, r2
 4131 009a 9B00     		lsl	r3, r3, #2
 4132 009c 094A     		ldr	r2, .L300+4
 4133 009e 9A18     		add	r2, r3, r2
 4134 00a0 FB68     		ldr	r3, [r7, #12]
 4135 00a2 0433     		add	r3, r3, #4
 4136 00a4 101C     		mov	r0, r2
 4137 00a6 191C     		mov	r1, r3
 4138 00a8 FFF7FEFF 		bl	vListInsertEnd
 4139 00ac 04E0     		b	.L293
 4140              	.L298:
3209:../Generated_Code/tasks.c ****                                 }
3210:../Generated_Code/tasks.c ****                                 else
3211:../Generated_Code/tasks.c ****                                 {
3212:../Generated_Code/tasks.c ****                                         /* Just inherit the priority. */
3213:../Generated_Code/tasks.c ****                                         pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4141              		.loc 1 3213 0 is_stmt 1
 4142 00ae 044B     		ldr	r3, .L300
 4143 00b0 1B68     		ldr	r3, [r3]
 4144 00b2 DA6A     		ldr	r2, [r3, #44]
 4145 00b4 FB68     		ldr	r3, [r7, #12]
 4146 00b6 DA62     		str	r2, [r3, #44]
 4147              	.L293:
 4148              	.LBE47:
3214:../Generated_Code/tasks.c ****                                 }
3215:../Generated_Code/tasks.c **** 
3216:../Generated_Code/tasks.c ****                                 traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3217:../Generated_Code/tasks.c ****                         }
3218:../Generated_Code/tasks.c ****                         else
3219:../Generated_Code/tasks.c ****                         {
3220:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3221:../Generated_Code/tasks.c ****                         }
3222:../Generated_Code/tasks.c ****                 }
3223:../Generated_Code/tasks.c ****                 else
3224:../Generated_Code/tasks.c ****                 {
3225:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3226:../Generated_Code/tasks.c ****                 }
3227:../Generated_Code/tasks.c ****         }
 4149              		.loc 1 3227 0
 4150 00b8 BD46     		mov	sp, r7
 4151 00ba 04B0     		add	sp, sp, #16
 4152              		@ sp needed for prologue
 4153 00bc 80BD     		pop	{r7, pc}
 4154              	.L301:
 4155 00be C046     		.align	2
 4156              	.L300:
 4157 00c0 00000000 		.word	pxCurrentTCB
 4158 00c4 00000000 		.word	_ZL17pxReadyTasksLists
 4159 00c8 00000000 		.word	_ZL18uxTopReadyPriority
 4160              		.cfi_endproc
 4161              	.LFE45:
 4163              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 4164              		.align	2
 4165              		.global	vTaskPriorityDisinherit
 4166              		.code	16
 4167              		.thumb_func
 4169              	vTaskPriorityDisinherit:
 4170              	.LFB46:
3228:../Generated_Code/tasks.c **** 
3229:../Generated_Code/tasks.c **** #endif /* configUSE_MUTEXES */
3230:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3231:../Generated_Code/tasks.c **** 
3232:../Generated_Code/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3233:../Generated_Code/tasks.c **** 
3234:../Generated_Code/tasks.c ****         void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3235:../Generated_Code/tasks.c ****         {
 4171              		.loc 1 3235 0
 4172              		.cfi_startproc
 4173 0000 80B5     		push	{r7, lr}
 4174              	.LCFI106:
 4175              		.cfi_def_cfa_offset 8
 4176              		.cfi_offset 7, -8
 4177              		.cfi_offset 14, -4
 4178 0002 84B0     		sub	sp, sp, #16
 4179              	.LCFI107:
 4180              		.cfi_def_cfa_offset 24
 4181 0004 00AF     		add	r7, sp, #0
 4182              	.LCFI108:
 4183              		.cfi_def_cfa_register 7
 4184 0006 7860     		str	r0, [r7, #4]
 4185              	.LBB48:
3236:../Generated_Code/tasks.c ****         TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4186              		.loc 1 3236 0
 4187 0008 7B68     		ldr	r3, [r7, #4]
 4188 000a FB60     		str	r3, [r7, #12]
3237:../Generated_Code/tasks.c **** 
3238:../Generated_Code/tasks.c ****                 if( pxMutexHolder != NULL )
 4189              		.loc 1 3238 0
 4190 000c 7B68     		ldr	r3, [r7, #4]
 4191 000e 002B     		cmp	r3, #0
 4192 0010 34D0     		beq	.L302
3239:../Generated_Code/tasks.c ****                 {
3240:../Generated_Code/tasks.c ****                         if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4193              		.loc 1 3240 0
 4194 0012 FB68     		ldr	r3, [r7, #12]
 4195 0014 DA6A     		ldr	r2, [r3, #44]
 4196 0016 FB68     		ldr	r3, [r7, #12]
 4197 0018 1B6D     		ldr	r3, [r3, #80]
 4198 001a 9A42     		cmp	r2, r3
 4199 001c 2ED0     		beq	.L302
3241:../Generated_Code/tasks.c ****                         {
3242:../Generated_Code/tasks.c ****                                 /* We must be the running task to be able to give the mutex back.
3243:../Generated_Code/tasks.c ****                                 Remove ourselves from the ready list we currently appear in. */
3244:../Generated_Code/tasks.c ****                                 if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t )
 4200              		.loc 1 3244 0
 4201 001e FB68     		ldr	r3, [r7, #12]
 4202 0020 0433     		add	r3, r3, #4
 4203 0022 181C     		mov	r0, r3
 4204 0024 FFF7FEFF 		bl	uxListRemove
3245:../Generated_Code/tasks.c ****                                 {
3246:../Generated_Code/tasks.c ****                                         taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3247:../Generated_Code/tasks.c ****                                 }
3248:../Generated_Code/tasks.c ****                                 else
3249:../Generated_Code/tasks.c ****                                 {
3250:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3251:../Generated_Code/tasks.c ****                                 }
3252:../Generated_Code/tasks.c **** 
3253:../Generated_Code/tasks.c ****                                 /* Disinherit the priority before adding the task into the new
3254:../Generated_Code/tasks.c ****                                 ready list. */
3255:../Generated_Code/tasks.c ****                                 traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3256:../Generated_Code/tasks.c ****                                 pxTCB->uxPriority = pxTCB->uxBasePriority;
 4205              		.loc 1 3256 0
 4206 0028 FB68     		ldr	r3, [r7, #12]
 4207 002a 1A6D     		ldr	r2, [r3, #80]
 4208 002c FB68     		ldr	r3, [r7, #12]
 4209 002e DA62     		str	r2, [r3, #44]
3257:../Generated_Code/tasks.c **** 
3258:../Generated_Code/tasks.c ****                                 /* Only reset the event list item value if the value is not
3259:../Generated_Code/tasks.c ****                                 being used for anything else. */
3260:../Generated_Code/tasks.c ****                                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskE
 4210              		.loc 1 3260 0
 4211 0030 FB68     		ldr	r3, [r7, #12]
 4212 0032 9B69     		ldr	r3, [r3, #24]
 4213 0034 002B     		cmp	r3, #0
 4214 0036 05DB     		blt	.L304
3261:../Generated_Code/tasks.c ****                                 {
3262:../Generated_Code/tasks.c ****                                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( Tick
 4215              		.loc 1 3262 0
 4216 0038 FB68     		ldr	r3, [r7, #12]
 4217 003a DB6A     		ldr	r3, [r3, #44]
 4218 003c 0622     		mov	r2, #6
 4219 003e D21A     		sub	r2, r2, r3
 4220 0040 FB68     		ldr	r3, [r7, #12]
 4221 0042 9A61     		str	r2, [r3, #24]
 4222              	.L304:
3263:../Generated_Code/tasks.c ****                                 }
3264:../Generated_Code/tasks.c ****                                 else
3265:../Generated_Code/tasks.c ****                                 {
3266:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3267:../Generated_Code/tasks.c ****                                 }
3268:../Generated_Code/tasks.c ****                                 prvAddTaskToReadyList( pxTCB );
 4223              		.loc 1 3268 0
 4224 0044 FB68     		ldr	r3, [r7, #12]
 4225 0046 DA6A     		ldr	r2, [r3, #44]
 4226 0048 0E4B     		ldr	r3, .L306
 4227 004a 1B68     		ldr	r3, [r3]
 4228 004c 9342     		cmp	r3, r2
 4229 004e 9B41     		sbc	r3, r3, r3
 4230 0050 5B42     		neg	r3, r3
 4231 0052 DBB2     		uxtb	r3, r3
 4232 0054 002B     		cmp	r3, #0
 4233 0056 03D0     		beq	.L305
 4234              		.loc 1 3268 0 is_stmt 0
 4235 0058 FB68     		ldr	r3, [r7, #12]
 4236 005a DA6A     		ldr	r2, [r3, #44]
 4237 005c 094B     		ldr	r3, .L306
 4238 005e 1A60     		str	r2, [r3]
 4239              	.L305:
 4240              		.loc 1 3268 0
 4241 0060 FB68     		ldr	r3, [r7, #12]
 4242 0062 DA6A     		ldr	r2, [r3, #44]
 4243 0064 131C     		mov	r3, r2
 4244 0066 9B00     		lsl	r3, r3, #2
 4245 0068 9B18     		add	r3, r3, r2
 4246 006a 9B00     		lsl	r3, r3, #2
 4247 006c 064A     		ldr	r2, .L306+4
 4248 006e 9A18     		add	r2, r3, r2
 4249 0070 FB68     		ldr	r3, [r7, #12]
 4250 0072 0433     		add	r3, r3, #4
 4251 0074 101C     		mov	r0, r2
 4252 0076 191C     		mov	r1, r3
 4253 0078 FFF7FEFF 		bl	vListInsertEnd
 4254              	.L302:
 4255              	.LBE48:
3269:../Generated_Code/tasks.c ****                         }
3270:../Generated_Code/tasks.c ****                         else
3271:../Generated_Code/tasks.c ****                         {
3272:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3273:../Generated_Code/tasks.c ****                         }
3274:../Generated_Code/tasks.c ****                 }
3275:../Generated_Code/tasks.c ****                 else
3276:../Generated_Code/tasks.c ****                 {
3277:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3278:../Generated_Code/tasks.c ****                 }
3279:../Generated_Code/tasks.c ****         }
 4256              		.loc 1 3279 0 is_stmt 1
 4257 007c BD46     		mov	sp, r7
 4258 007e 04B0     		add	sp, sp, #16
 4259              		@ sp needed for prologue
 4260 0080 80BD     		pop	{r7, pc}
 4261              	.L307:
 4262 0082 C046     		.align	2
 4263              	.L306:
 4264 0084 00000000 		.word	_ZL18uxTopReadyPriority
 4265 0088 00000000 		.word	_ZL17pxReadyTasksLists
 4266              		.cfi_endproc
 4267              	.LFE46:
 4269              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4270              		.align	2
 4271              		.global	uxTaskResetEventItemValue
 4272              		.code	16
 4273              		.thumb_func
 4275              	uxTaskResetEventItemValue:
 4276              	.LFB47:
3280:../Generated_Code/tasks.c **** 
3281:../Generated_Code/tasks.c **** #endif /* configUSE_MUTEXES */
3282:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3283:../Generated_Code/tasks.c **** 
3284:../Generated_Code/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3285:../Generated_Code/tasks.c **** 
3286:../Generated_Code/tasks.c ****         void vTaskEnterCritical( void )
3287:../Generated_Code/tasks.c ****         {
3288:../Generated_Code/tasks.c ****                 portDISABLE_INTERRUPTS();
3289:../Generated_Code/tasks.c **** 
3290:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
3291:../Generated_Code/tasks.c ****                 {
3292:../Generated_Code/tasks.c ****                         ( pxCurrentTCB->uxCriticalNesting )++;
3293:../Generated_Code/tasks.c ****                 }
3294:../Generated_Code/tasks.c ****                 else
3295:../Generated_Code/tasks.c ****                 {
3296:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3297:../Generated_Code/tasks.c ****                 }
3298:../Generated_Code/tasks.c ****         }
3299:../Generated_Code/tasks.c **** 
3300:../Generated_Code/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3301:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3302:../Generated_Code/tasks.c **** 
3303:../Generated_Code/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3304:../Generated_Code/tasks.c **** 
3305:../Generated_Code/tasks.c ****         void vTaskExitCritical( void )
3306:../Generated_Code/tasks.c ****         {
3307:../Generated_Code/tasks.c ****                 if( xSchedulerRunning != pdFALSE )
3308:../Generated_Code/tasks.c ****                 {
3309:../Generated_Code/tasks.c ****                         if( pxCurrentTCB->uxCriticalNesting > 0U )
3310:../Generated_Code/tasks.c ****                         {
3311:../Generated_Code/tasks.c ****                                 ( pxCurrentTCB->uxCriticalNesting )--;
3312:../Generated_Code/tasks.c **** 
3313:../Generated_Code/tasks.c ****                                 if( pxCurrentTCB->uxCriticalNesting == 0U )
3314:../Generated_Code/tasks.c ****                                 {
3315:../Generated_Code/tasks.c ****                                         portENABLE_INTERRUPTS();
3316:../Generated_Code/tasks.c ****                                 }
3317:../Generated_Code/tasks.c ****                                 else
3318:../Generated_Code/tasks.c ****                                 {
3319:../Generated_Code/tasks.c ****                                         mtCOVERAGE_TEST_MARKER();
3320:../Generated_Code/tasks.c ****                                 }
3321:../Generated_Code/tasks.c ****                         }
3322:../Generated_Code/tasks.c ****                         else
3323:../Generated_Code/tasks.c ****                         {
3324:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3325:../Generated_Code/tasks.c ****                         }
3326:../Generated_Code/tasks.c ****                 }
3327:../Generated_Code/tasks.c ****                 else
3328:../Generated_Code/tasks.c ****                 {
3329:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3330:../Generated_Code/tasks.c ****                 }
3331:../Generated_Code/tasks.c ****         }
3332:../Generated_Code/tasks.c **** 
3333:../Generated_Code/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3334:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3335:../Generated_Code/tasks.c **** 
3336:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3337:../Generated_Code/tasks.c **** 
3338:../Generated_Code/tasks.c ****         void vTaskList( char * pcWriteBuffer, size_t bufSize)
3339:../Generated_Code/tasks.c ****         {
3340:../Generated_Code/tasks.c ****         TaskStatus_t *pxTaskStatusArray;
3341:../Generated_Code/tasks.c ****         volatile UBaseType_t uxArraySize, x;
3342:../Generated_Code/tasks.c ****         char cStatus;
3343:../Generated_Code/tasks.c **** 
3344:../Generated_Code/tasks.c ****                 /*
3345:../Generated_Code/tasks.c ****                  * PLEASE NOTE:
3346:../Generated_Code/tasks.c ****                  *
3347:../Generated_Code/tasks.c ****                  * This function is provided for convenience only, and is used by many
3348:../Generated_Code/tasks.c ****                  * of the demo applications.  Do not consider it to be part of the
3349:../Generated_Code/tasks.c ****                  * scheduler.
3350:../Generated_Code/tasks.c ****                  *
3351:../Generated_Code/tasks.c ****                  * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3352:../Generated_Code/tasks.c ****                  * uxTaskGetSystemState() output into a human readable table that
3353:../Generated_Code/tasks.c ****                  * displays task names, states and stack usage.
3354:../Generated_Code/tasks.c ****                  *
3355:../Generated_Code/tasks.c ****                  * vTaskList() has a dependency on the sprintf() C library function that
3356:../Generated_Code/tasks.c ****                  * might bloat the code size, use a lot of stack, and provide different
3357:../Generated_Code/tasks.c ****                  * results on different platforms.  An alternative, tiny, third party,
3358:../Generated_Code/tasks.c ****                  * and limited functionality implementation of sprintf() is provided in
3359:../Generated_Code/tasks.c ****                  * many of the FreeRTOS/Demo sub-directories in a file called
3360:../Generated_Code/tasks.c ****                  * printf-stdarg.c (note printf-stdarg.c does not provide a full
3361:../Generated_Code/tasks.c ****                  * snprintf() implementation!).
3362:../Generated_Code/tasks.c ****                  *
3363:../Generated_Code/tasks.c ****                  * It is recommended that production systems call uxTaskGetSystemState()
3364:../Generated_Code/tasks.c ****                  * directly to get access to raw stats data, rather than indirectly
3365:../Generated_Code/tasks.c ****                  * through a call to vTaskList().
3366:../Generated_Code/tasks.c ****                  */
3367:../Generated_Code/tasks.c **** 
3368:../Generated_Code/tasks.c **** 
3369:../Generated_Code/tasks.c ****                 /* Make sure the write buffer does not contain a string. */
3370:../Generated_Code/tasks.c ****                 *pcWriteBuffer = 0x00;
3371:../Generated_Code/tasks.c **** 
3372:../Generated_Code/tasks.c ****                 /* Take a snapshot of the number of tasks in case it changes while this
3373:../Generated_Code/tasks.c ****                 function is executing. */
3374:../Generated_Code/tasks.c ****                 uxArraySize = uxCurrentNumberOfTasks;
3375:../Generated_Code/tasks.c **** 
3376:../Generated_Code/tasks.c ****                 /* Allocate an array index for each task. */
3377:../Generated_Code/tasks.c ****                 pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) )
3378:../Generated_Code/tasks.c **** 
3379:../Generated_Code/tasks.c ****                 if( pxTaskStatusArray != NULL )
3380:../Generated_Code/tasks.c ****                 {
3381:../Generated_Code/tasks.c ****                         /* Generate the (binary) data. */
3382:../Generated_Code/tasks.c ****                         uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3383:../Generated_Code/tasks.c **** 
3384:../Generated_Code/tasks.c ****                         /* Create a human readable table from the binary data. */
3385:../Generated_Code/tasks.c ****                         for( x = 0; x < uxArraySize; x++ )
3386:../Generated_Code/tasks.c ****                         {
3387:../Generated_Code/tasks.c ****                                 switch( pxTaskStatusArray[ x ].eCurrentState )
3388:../Generated_Code/tasks.c ****                                 {
3389:../Generated_Code/tasks.c ****                                 case eReady:            cStatus = tskREADY_CHAR;
3390:../Generated_Code/tasks.c ****                                                                         break;
3391:../Generated_Code/tasks.c **** 
3392:../Generated_Code/tasks.c ****                                 case eBlocked:          cStatus = tskBLOCKED_CHAR;
3393:../Generated_Code/tasks.c ****                                                                         break;
3394:../Generated_Code/tasks.c **** 
3395:../Generated_Code/tasks.c ****                                 case eSuspended:        cStatus = tskSUSPENDED_CHAR;
3396:../Generated_Code/tasks.c ****                                                                         break;
3397:../Generated_Code/tasks.c **** 
3398:../Generated_Code/tasks.c ****                                 case eDeleted:          cStatus = tskDELETED_CHAR;
3399:../Generated_Code/tasks.c ****                                                                         break;
3400:../Generated_Code/tasks.c **** 
3401:../Generated_Code/tasks.c ****                                 default:                        /* Should not get here, but it is i
3402:../Generated_Code/tasks.c ****                                                                         to prevent static checking 
3403:../Generated_Code/tasks.c ****                                                                         cStatus = 0x00;
3404:../Generated_Code/tasks.c ****                                                                         break;
3405:../Generated_Code/tasks.c ****                                 }
3406:../Generated_Code/tasks.c **** #if 0
3407:../Generated_Code/tasks.c ****                                 sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%c\t%u\t%u\t%u
3408:../Generated_Code/tasks.c **** #else /* << EST */
3409:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3410:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3411:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)cStatus);
3412:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3413:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].uxCurrent
3414:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3415:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].usStackHi
3416:../Generated_Code/tasks.c ****               UTIL0_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
3417:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].xTaskNumb
3418:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
3419:../Generated_Code/tasks.c **** #endif
3420:../Generated_Code/tasks.c ****                         }
3421:../Generated_Code/tasks.c **** 
3422:../Generated_Code/tasks.c ****                         /* Free the array again. */
3423:../Generated_Code/tasks.c ****                         vPortFree( pxTaskStatusArray );
3424:../Generated_Code/tasks.c ****                 }
3425:../Generated_Code/tasks.c ****                 else
3426:../Generated_Code/tasks.c ****                 {
3427:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3428:../Generated_Code/tasks.c ****                 }
3429:../Generated_Code/tasks.c ****         }
3430:../Generated_Code/tasks.c **** 
3431:../Generated_Code/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3432:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
3433:../Generated_Code/tasks.c **** 
3434:../Generated_Code/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3435:../Generated_Code/tasks.c **** 
3436:../Generated_Code/tasks.c ****         void vTaskGetRunTimeStats( char *pcWriteBuffer, size_t bufSize)
3437:../Generated_Code/tasks.c ****         {
3438:../Generated_Code/tasks.c ****         TaskStatus_t *pxTaskStatusArray;
3439:../Generated_Code/tasks.c ****         volatile UBaseType_t uxArraySize, x;
3440:../Generated_Code/tasks.c ****         uint32_t ulTotalTime, ulStatsAsPercentage;
3441:../Generated_Code/tasks.c **** 
3442:../Generated_Code/tasks.c ****                 #if( configUSE_TRACE_FACILITY != 1 )
3443:../Generated_Code/tasks.c ****                 {
3444:../Generated_Code/tasks.c ****                         #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h t
3445:../Generated_Code/tasks.c ****                 }
3446:../Generated_Code/tasks.c ****                 #endif
3447:../Generated_Code/tasks.c **** 
3448:../Generated_Code/tasks.c ****                 /*
3449:../Generated_Code/tasks.c ****                  * PLEASE NOTE:
3450:../Generated_Code/tasks.c ****                  *
3451:../Generated_Code/tasks.c ****                  * This function is provided for convenience only, and is used by many
3452:../Generated_Code/tasks.c ****                  * of the demo applications.  Do not consider it to be part of the
3453:../Generated_Code/tasks.c ****                  * scheduler.
3454:../Generated_Code/tasks.c ****                  *
3455:../Generated_Code/tasks.c ****                  * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3456:../Generated_Code/tasks.c ****                  * of the uxTaskGetSystemState() output into a human readable table that
3457:../Generated_Code/tasks.c ****                  * displays the amount of time each task has spent in the Running state
3458:../Generated_Code/tasks.c ****                  * in both absolute and percentage terms.
3459:../Generated_Code/tasks.c ****                  *
3460:../Generated_Code/tasks.c ****                  * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3461:../Generated_Code/tasks.c ****                  * function that might bloat the code size, use a lot of stack, and
3462:../Generated_Code/tasks.c ****                  * provide different results on different platforms.  An alternative,
3463:../Generated_Code/tasks.c ****                  * tiny, third party, and limited functionality implementation of
3464:../Generated_Code/tasks.c ****                  * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3465:../Generated_Code/tasks.c ****                  * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3466:../Generated_Code/tasks.c ****                  * a full snprintf() implementation!).
3467:../Generated_Code/tasks.c ****                  *
3468:../Generated_Code/tasks.c ****                  * It is recommended that production systems call uxTaskGetSystemState()
3469:../Generated_Code/tasks.c ****                  * directly to get access to raw stats data, rather than indirectly
3470:../Generated_Code/tasks.c ****                  * through a call to vTaskGetRunTimeStats().
3471:../Generated_Code/tasks.c ****                  */
3472:../Generated_Code/tasks.c **** 
3473:../Generated_Code/tasks.c ****                 /* Make sure the write buffer does not contain a string. */
3474:../Generated_Code/tasks.c ****                 *pcWriteBuffer = 0x00;
3475:../Generated_Code/tasks.c **** 
3476:../Generated_Code/tasks.c ****                 /* Take a snapshot of the number of tasks in case it changes while this
3477:../Generated_Code/tasks.c ****                 function is executing. */
3478:../Generated_Code/tasks.c ****                 uxArraySize = uxCurrentNumberOfTasks;
3479:../Generated_Code/tasks.c **** 
3480:../Generated_Code/tasks.c ****                 /* Allocate an array index for each task. */
3481:../Generated_Code/tasks.c ****                 pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) )
3482:../Generated_Code/tasks.c **** 
3483:../Generated_Code/tasks.c ****                 if( pxTaskStatusArray != NULL )
3484:../Generated_Code/tasks.c ****                 {
3485:../Generated_Code/tasks.c ****                         /* Generate the (binary) data. */
3486:../Generated_Code/tasks.c ****                         uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTota
3487:../Generated_Code/tasks.c **** 
3488:../Generated_Code/tasks.c ****                         /* For percentage calculations. */
3489:../Generated_Code/tasks.c ****                         ulTotalTime /= 100UL;
3490:../Generated_Code/tasks.c **** 
3491:../Generated_Code/tasks.c ****                         /* Avoid divide by zero errors. */
3492:../Generated_Code/tasks.c ****                         if( ulTotalTime > 0 )
3493:../Generated_Code/tasks.c ****                         {
3494:../Generated_Code/tasks.c ****                                 /* Create a human readable table from the binary data. */
3495:../Generated_Code/tasks.c ****                                 for( x = 0; x < uxArraySize; x++ )
3496:../Generated_Code/tasks.c ****                                 {
3497:../Generated_Code/tasks.c ****                                         /* What percentage of the total run time has the task used?
3498:../Generated_Code/tasks.c ****                                         This will always be rounded down to the nearest integer.
3499:../Generated_Code/tasks.c ****                                         ulTotalRunTimeDiv100 has already been divided by 100. */
3500:../Generated_Code/tasks.c ****                                         ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCount
3501:../Generated_Code/tasks.c **** 
3502:../Generated_Code/tasks.c ****                                         if( ulStatsAsPercentage > 0UL )
3503:../Generated_Code/tasks.c ****                                         {
3504:../Generated_Code/tasks.c ****                                                 #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3505:../Generated_Code/tasks.c ****                                                 {
3506:../Generated_Code/tasks.c ****                                                   sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s
3507:../Generated_Code/tasks.c ****                                                 }
3508:../Generated_Code/tasks.c ****                                                 #else
3509:../Generated_Code/tasks.c ****                                                 {
3510:../Generated_Code/tasks.c ****                                                         /* sizeof( int ) == sizeof( long ) so a sma
3511:../Generated_Code/tasks.c ****                                                         printf() library can be used. */
3512:../Generated_Code/tasks.c **** #if 0
3513:../Generated_Code/tasks.c ****                                                         sprintf( ( char * ) pcWriteBuffer, ( char *
3514:../Generated_Code/tasks.c **** #else /* << EST */
3515:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3516:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3517:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTime
3518:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3519:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, ulStatsAsPercentage);
3520:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"%\r\n");
3521:../Generated_Code/tasks.c **** #endif
3522:../Generated_Code/tasks.c ****                                                 }
3523:../Generated_Code/tasks.c ****                                                 #endif
3524:../Generated_Code/tasks.c ****                                         }
3525:../Generated_Code/tasks.c ****                                         else
3526:../Generated_Code/tasks.c ****                                         {
3527:../Generated_Code/tasks.c ****                                                 /* If the percentage is zero here then the task has
3528:../Generated_Code/tasks.c ****                                                 consumed less than 1% of the total run time. */
3529:../Generated_Code/tasks.c ****                                                 #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3530:../Generated_Code/tasks.c ****                                                 {
3531:../Generated_Code/tasks.c ****                                                         sprintf( ( char * ) pcWriteBuffer, ( char *
3532:../Generated_Code/tasks.c ****                                                 }
3533:../Generated_Code/tasks.c ****                                                 #else
3534:../Generated_Code/tasks.c ****                                                 {
3535:../Generated_Code/tasks.c ****                                                         /* sizeof( int ) == sizeof( long ) so a sma
3536:../Generated_Code/tasks.c ****                                                         printf() library can be used. */
3537:../Generated_Code/tasks.c **** #if 0
3538:../Generated_Code/tasks.c ****               sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArr
3539:../Generated_Code/tasks.c **** #else /* << EST */
3540:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArra
3541:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
3542:../Generated_Code/tasks.c ****               UTIL0_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].ulRunTime
3543:../Generated_Code/tasks.c ****               UTIL0_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t\t<1%\r\n");
3544:../Generated_Code/tasks.c **** #endif
3545:../Generated_Code/tasks.c ****                                                 }
3546:../Generated_Code/tasks.c ****                                                 #endif
3547:../Generated_Code/tasks.c ****                                         }
3548:../Generated_Code/tasks.c **** 
3549:../Generated_Code/tasks.c ****                                         pcWriteBuffer += strlen( pcWriteBuffer );
3550:../Generated_Code/tasks.c ****                                 }
3551:../Generated_Code/tasks.c ****                         }
3552:../Generated_Code/tasks.c ****                         else
3553:../Generated_Code/tasks.c ****                         {
3554:../Generated_Code/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
3555:../Generated_Code/tasks.c ****                         }
3556:../Generated_Code/tasks.c **** 
3557:../Generated_Code/tasks.c ****                         /* Free the array again. */
3558:../Generated_Code/tasks.c ****                         vPortFree( pxTaskStatusArray );
3559:../Generated_Code/tasks.c ****                 }
3560:../Generated_Code/tasks.c ****                 else
3561:../Generated_Code/tasks.c ****                 {
3562:../Generated_Code/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3563:../Generated_Code/tasks.c ****                 }
3564:../Generated_Code/tasks.c ****         }
3565:../Generated_Code/tasks.c **** 
3566:../Generated_Code/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
3567:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
3568:../Generated_Code/tasks.c **** 
3569:../Generated_Code/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3570:../Generated_Code/tasks.c **** {
 4277              		.loc 1 3570 0
 4278              		.cfi_startproc
 4279 0000 80B5     		push	{r7, lr}
 4280              	.LCFI109:
 4281              		.cfi_def_cfa_offset 8
 4282              		.cfi_offset 7, -8
 4283              		.cfi_offset 14, -4
 4284 0002 82B0     		sub	sp, sp, #8
 4285              	.LCFI110:
 4286              		.cfi_def_cfa_offset 16
 4287 0004 00AF     		add	r7, sp, #0
 4288              	.LCFI111:
 4289              		.cfi_def_cfa_register 7
 4290              	.LBB49:
3571:../Generated_Code/tasks.c **** TickType_t uxReturn;
3572:../Generated_Code/tasks.c **** 
3573:../Generated_Code/tasks.c ****         uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4291              		.loc 1 3573 0
 4292 0006 084B     		ldr	r3, .L310
 4293 0008 1B68     		ldr	r3, [r3]
 4294 000a 9B69     		ldr	r3, [r3, #24]
 4295 000c 7B60     		str	r3, [r7, #4]
3574:../Generated_Code/tasks.c **** 
3575:../Generated_Code/tasks.c ****         /* Reset the event list item to its normal value - so it can be used with
3576:../Generated_Code/tasks.c ****         queues and semaphores. */
3577:../Generated_Code/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIO
 4296              		.loc 1 3577 0
 4297 000e 064B     		ldr	r3, .L310
 4298 0010 1B68     		ldr	r3, [r3]
 4299 0012 054A     		ldr	r2, .L310
 4300 0014 1268     		ldr	r2, [r2]
 4301 0016 D26A     		ldr	r2, [r2, #44]
 4302 0018 0621     		mov	r1, #6
 4303 001a 8A1A     		sub	r2, r1, r2
 4304 001c 9A61     		str	r2, [r3, #24]
3578:../Generated_Code/tasks.c **** 
3579:../Generated_Code/tasks.c ****         return uxReturn;
 4305              		.loc 1 3579 0
 4306 001e 7B68     		ldr	r3, [r7, #4]
 4307              	.LBE49:
3580:../Generated_Code/tasks.c **** }
 4308              		.loc 1 3580 0
 4309 0020 181C     		mov	r0, r3
 4310 0022 BD46     		mov	sp, r7
 4311 0024 02B0     		add	sp, sp, #8
 4312              		@ sp needed for prologue
 4313 0026 80BD     		pop	{r7, pc}
 4314              	.L311:
 4315              		.align	2
 4316              	.L310:
 4317 0028 00000000 		.word	pxCurrentTCB
 4318              		.cfi_endproc
 4319              	.LFE47:
 4321              		.text
 4322              	.Letext0:
 4323              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 4324              		.file 3 "../Generated_Code/projdefs.h"
 4325              		.file 4 "../Generated_Code/portmacro.h"
 4326              		.file 5 "../Generated_Code/list.h"
 4327              		.file 6 "../Generated_Code/task.h"
 4328              		.file 7 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:22     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:19     .bss.pxCurrentTCB:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:25     .bss._ZL17pxReadyTasksLists:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:28     .bss._ZL17pxReadyTasksLists:00000000 _ZL17pxReadyTasksLists
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:31     .bss._ZL17xDelayedTaskList1:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:34     .bss._ZL17xDelayedTaskList1:00000000 _ZL17xDelayedTaskList1
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:37     .bss._ZL17xDelayedTaskList2:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:40     .bss._ZL17xDelayedTaskList2:00000000 _ZL17xDelayedTaskList2
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:43     .bss._ZL17pxDelayedTaskList:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:46     .bss._ZL17pxDelayedTaskList:00000000 _ZL17pxDelayedTaskList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:49     .bss._ZL25pxOverflowDelayedTaskList:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:52     .bss._ZL25pxOverflowDelayedTaskList:00000000 _ZL25pxOverflowDelayedTaskList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:55     .bss._ZL17xPendingReadyList:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:58     .bss._ZL17xPendingReadyList:00000000 _ZL17xPendingReadyList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:61     .bss._ZL18xSuspendedTaskList:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:64     .bss._ZL18xSuspendedTaskList:00000000 _ZL18xSuspendedTaskList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:67     .bss._ZL22uxCurrentNumberOfTasks:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:70     .bss._ZL22uxCurrentNumberOfTasks:00000000 _ZL22uxCurrentNumberOfTasks
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:73     .bss._ZL10xTickCount:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:76     .bss._ZL10xTickCount:00000000 _ZL10xTickCount
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:79     .bss._ZL18uxTopReadyPriority:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:82     .bss._ZL18uxTopReadyPriority:00000000 _ZL18uxTopReadyPriority
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:85     .bss._ZL17xSchedulerRunning:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:88     .bss._ZL17xSchedulerRunning:00000000 _ZL17xSchedulerRunning
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:91     .bss._ZL13uxPendedTicks:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:94     .bss._ZL13uxPendedTicks:00000000 _ZL13uxPendedTicks
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:97     .bss._ZL13xYieldPending:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:100    .bss._ZL13xYieldPending:00000000 _ZL13xYieldPending
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:103    .bss._ZL15xNumOfOverflows:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:106    .bss._ZL15xNumOfOverflows:00000000 _ZL15xNumOfOverflows
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:109    .bss._ZL12uxTaskNumber:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:112    .bss._ZL12uxTaskNumber:00000000 _ZL12uxTaskNumber
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:115    .data._ZL20xNextTaskUnblockTime:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:118    .data._ZL20xNextTaskUnblockTime:00000000 _ZL20xNextTaskUnblockTime
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:121    .bss._ZL20uxSchedulerSuspended:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:124    .bss._ZL20uxSchedulerSuspended:00000000 _ZL20uxSchedulerSuspended
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:127    .text.xTaskGenericCreate:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:132    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3626   .text._ZL22prvAllocateTCBAndStacktPm:00000000 _ZL22prvAllocateTCBAndStacktPm
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3300   .text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:00000000 _ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3422   .text._ZL22prvInitialiseTaskListsv:00000000 _ZL22prvInitialiseTaskListsv
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:401    .text.xTaskGenericCreate:00000180 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:411    .text.vTaskDelayUntil:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:416    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1652   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3539   .text._ZL30prvAddCurrentTaskToDelayedListm:00000000 _ZL30prvAddCurrentTaskToDelayedListm
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1687   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:571    .text.vTaskDelayUntil:000000b8 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:578    .text.vTaskDelay:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:583    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:663    .text.vTaskDelay:00000060 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:670    .text.uxTaskPriorityGet:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:675    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:726    .text.uxTaskPriorityGet:00000030 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:731    .text.vTaskPrioritySet:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:736    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:959    .text.vTaskPrioritySet:00000138 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:966    .text.vTaskSuspend:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:971    .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2352   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3842   .text._ZL27prvResetNextTaskUnblockTimev:00000000 _ZL27prvResetNextTaskUnblockTimev
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1109   .text.vTaskSuspend:000000bc $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1118   .text._ZL22prvTaskIsTaskSuspendedPv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1122   .text._ZL22prvTaskIsTaskSuspendedPv:00000000 _ZL22prvTaskIsTaskSuspendedPv
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1211   .text._ZL22prvTaskIsTaskSuspendedPv:00000058 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1217   .text.vTaskResume:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1222   .text.vTaskResume:00000000 vTaskResume
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1351   .text.vTaskResume:000000b0 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1358   .text.xTaskResumeFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1363   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1504   .text.xTaskResumeFromISR:000000bc $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1513   .rodata:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1517   .text.vTaskStartScheduler:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1522   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1599   .text.vTaskStartScheduler:00000054 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3257   .text._ZL11prvIdleTaskPv:00000000 _ZL11prvIdleTaskPv
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1607   .text.vTaskEndScheduler:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1612   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1642   .text.vTaskEndScheduler:00000014 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1647   .text.vTaskSuspendAll:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1677   .text.vTaskSuspendAll:00000014 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1682   .text.xTaskResumeAll:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2042   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1892   .text.xTaskResumeAll:0000012c $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1904   .text.xTaskGetTickCount:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1909   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1945   .text.xTaskGetTickCount:00000020 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1950   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1955   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:1999   .text.xTaskGetTickCountFromISR:00000020 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2004   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2009   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2032   .text.uxTaskGetNumberOfTasks:00000010 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2037   .text.xTaskIncrementTick:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2332   .text.xTaskIncrementTick:00000190 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2347   .text.vTaskSwitchContext:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2501   .text.vTaskSwitchContext:000000c8 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2510   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2515   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2594   .text.vTaskPlaceOnEventList:00000060 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2601   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2606   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2711   .text.vTaskPlaceOnUnorderedEventList:00000084 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2719   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2724   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2855   .text.xTaskRemoveFromEventList:000000b4 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2865   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:2870   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3006   .text.xTaskRemoveFromUnorderedEventList:000000b4 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3015   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3020   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3067   .text.vTaskSetTimeOutState:00000028 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3073   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3078   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3214   .text.xTaskCheckForTimeOut:000000a0 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3220   .text.vTaskMissedYield:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3225   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3248   .text.vTaskMissedYield:00000010 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3253   .text._ZL11prvIdleTaskPv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3515   .text._ZL31prvCheckTasksWaitingTerminationv:00000000 _ZL31prvCheckTasksWaitingTerminationv
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3291   .text._ZL11prvIdleTaskPv:00000020 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3296   .text._ZL25prvInitialiseTCBVariablesP19tskTaskControlBlockPKcmPK14xMEMORY_REGIONt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3418   .text._ZL22prvInitialiseTaskListsv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3500   .text._ZL22prvInitialiseTaskListsv:00000068 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3511   .text._ZL31prvCheckTasksWaitingTerminationv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3535   .text._ZL30prvAddCurrentTaskToDelayedListm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3613   .text._ZL30prvAddCurrentTaskToDelayedListm:00000068 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3622   .text._ZL22prvAllocateTCBAndStacktPm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3712   .text._ZL26prvTaskCheckFreeStackSpacePKh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3716   .text._ZL26prvTaskCheckFreeStackSpacePKh:00000000 _ZL26prvTaskCheckFreeStackSpacePKh
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3775   .text.uxTaskGetStackHighWaterMark:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3780   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3833   .text.uxTaskGetStackHighWaterMark:00000034 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3838   .text._ZL27prvResetNextTaskUnblockTimev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3902   .text._ZL27prvResetNextTaskUnblockTimev:0000003c $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3908   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3913   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3945   .text.xTaskGetCurrentTaskHandle:00000018 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3950   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:3955   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4013   .text.xTaskGetSchedulerState:0000003c $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4019   .text.vTaskPriorityInherit:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4024   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4157   .text.vTaskPriorityInherit:000000c0 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4164   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4169   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4264   .text.vTaskPriorityDisinherit:00000084 $d
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4270   .text.uxTaskResetEventItemValue:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4275   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\JH\AppData\Local\Temp\ccklujBj.s:4317   .text.uxTaskResetEventItemValue:00000028 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
uxListRemove
xPortStartScheduler
vPortEndScheduler
_Z30FreeRTOS0_vApplicationTickHookv
_Z39FreeRTOS0_vApplicationStackOverflowHookPvPc
vListInsert
_Z30FreeRTOS0_vApplicationIdleHookv
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
