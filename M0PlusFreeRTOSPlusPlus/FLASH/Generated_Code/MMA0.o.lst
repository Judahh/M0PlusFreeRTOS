   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"MMA0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss._ZL10sCalValues,"aw",%nobits
  18              		.align	2
  21              	_ZL10sCalValues:
  22 0000 00000000 		.space	6
  22      0000
  23 0006 0000     		.section	.text._Z15MMA0_GetRaw8XYZPh,"ax",%progbits
  24              		.align	2
  25              		.global	_Z15MMA0_GetRaw8XYZPh
  26              		.code	16
  27              		.thumb_func
  29              	_Z15MMA0_GetRaw8XYZPh:
  30              	.LFB5:
  31              		.file 1 "../Generated_Code/MMA0.c"
   1:../Generated_Code/MMA0.c **** /* ###################################################################
   2:../Generated_Code/MMA0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/MMA0.c **** **     Filename    : MMA0.c
   4:../Generated_Code/MMA0.c **** **     CDE edition : Standard
   5:../Generated_Code/MMA0.c **** **     Project     : ProcessorExpert
   6:../Generated_Code/MMA0.c **** **     Processor   : MKL25Z128VLK4
   7:../Generated_Code/MMA0.c **** **     Component   : MMA8451Q
   8:../Generated_Code/MMA0.c **** **     Version     : Component 01.028, Driver 01.00, CPU db: 3.00.000
   9:../Generated_Code/MMA0.c **** **     Compiler    : GNU C Compiler
  10:../Generated_Code/MMA0.c **** **     Date/Time   : 2014-04-05, 15:28, # CodeGen: 4
  11:../Generated_Code/MMA0.c **** **     Abstract    :
  12:../Generated_Code/MMA0.c **** **         Implements a Driver for the MMA8451 accelerometer from Freescale.
  13:../Generated_Code/MMA0.c **** **     Settings    :
  14:../Generated_Code/MMA0.c **** **          Component Name                                 : MMA0
  15:../Generated_Code/MMA0.c **** **          Slave Address                                  : 1D
  16:../Generated_Code/MMA0.c **** **          I2C Bus                                        : GI2C0
  17:../Generated_Code/MMA0.c **** **          Constant Offsets                               : Enabled
  18:../Generated_Code/MMA0.c **** **            X offset                                     : 0
  19:../Generated_Code/MMA0.c **** **            Y offset                                     : 0
  20:../Generated_Code/MMA0.c **** **            Z offset                                     : 0
  21:../Generated_Code/MMA0.c **** **          Shell                                          : Disabled
  22:../Generated_Code/MMA0.c **** **     Contents    :
  23:../Generated_Code/MMA0.c **** **         Enable         - byte MMA0_Enable(void);
  24:../Generated_Code/MMA0.c **** **         Disable        - byte MMA0_Disable(void);
  25:../Generated_Code/MMA0.c **** **         isEnabled      - byte MMA0_isEnabled(bool *isEnabled);
  26:../Generated_Code/MMA0.c **** **         GetX           - int16_t MMA0_GetX(void);
  27:../Generated_Code/MMA0.c **** **         GetY           - int16_t MMA0_GetY(void);
  28:../Generated_Code/MMA0.c **** **         GetZ           - int16_t MMA0_GetZ(void);
  29:../Generated_Code/MMA0.c **** **         GetRaw8XYZ     - uint8_t MMA0_GetRaw8XYZ(void* *xyz);
  30:../Generated_Code/MMA0.c **** **         CalibrateX1g   - void MMA0_CalibrateX1g(void);
  31:../Generated_Code/MMA0.c **** **         CalibrateY1g   - void MMA0_CalibrateY1g(void);
  32:../Generated_Code/MMA0.c **** **         CalibrateZ1g   - void MMA0_CalibrateZ1g(void);
  33:../Generated_Code/MMA0.c **** **         GetXmg         - int16_t MMA0_GetXmg(void);
  34:../Generated_Code/MMA0.c **** **         GetYmg         - int16_t MMA0_GetYmg(void);
  35:../Generated_Code/MMA0.c **** **         GetZmg         - int16_t MMA0_GetZmg(void);
  36:../Generated_Code/MMA0.c **** **         MeasureGetRawX - word MMA0_MeasureGetRawX(void);
  37:../Generated_Code/MMA0.c **** **         MeasureGetRawY - word MMA0_MeasureGetRawY(void);
  38:../Generated_Code/MMA0.c **** **         MeasureGetRawZ - word MMA0_MeasureGetRawZ(void);
  39:../Generated_Code/MMA0.c **** **         GetXOffset     - int16_t MMA0_GetXOffset(void);
  40:../Generated_Code/MMA0.c **** **         GetYOffset     - int16_t MMA0_GetYOffset(void);
  41:../Generated_Code/MMA0.c **** **         GetZOffset     - int16_t MMA0_GetZOffset(void);
  42:../Generated_Code/MMA0.c **** **         GetX1gValue    - int16_t MMA0_GetX1gValue(void);
  43:../Generated_Code/MMA0.c **** **         GetY1gValue    - int16_t MMA0_GetY1gValue(void);
  44:../Generated_Code/MMA0.c **** **         GetZ1gValue    - int16_t MMA0_GetZ1gValue(void);
  45:../Generated_Code/MMA0.c **** **         SetFastMode    - byte MMA0_SetFastMode(bool on);
  46:../Generated_Code/MMA0.c **** **         Init           - uint8_t MMA0_Init(void);
  47:../Generated_Code/MMA0.c **** **         Deinit         - uint8_t MMA0_Deinit(void);
  48:../Generated_Code/MMA0.c **** **
  49:../Generated_Code/MMA0.c **** **     License : Open Source (LGPL)
  50:../Generated_Code/MMA0.c **** **     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
  51:../Generated_Code/MMA0.c **** **     http://www.mcuoneclipse.com
  52:../Generated_Code/MMA0.c **** **     This an open source software in the form of a Processor Expert Embedded Component.
  53:../Generated_Code/MMA0.c **** **     This is a free software and is opened for education, research and commercial developments un
  54:../Generated_Code/MMA0.c **** **     * This is a free software and there is NO WARRANTY.
  55:../Generated_Code/MMA0.c **** **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or
  56:../Generated_Code/MMA0.c **** **     * Redistributions of source code must retain the above copyright notice.
  57:../Generated_Code/MMA0.c **** ** ###################################################################*/
  58:../Generated_Code/MMA0.c **** /*!
  59:../Generated_Code/MMA0.c **** ** @file MMA0.c
  60:../Generated_Code/MMA0.c **** ** @version 01.00
  61:../Generated_Code/MMA0.c **** ** @brief
  62:../Generated_Code/MMA0.c **** **         Implements a Driver for the MMA8451 accelerometer from Freescale.
  63:../Generated_Code/MMA0.c **** */         
  64:../Generated_Code/MMA0.c **** /*!
  65:../Generated_Code/MMA0.c **** **  @addtogroup MMA0_module MMA0 module documentation
  66:../Generated_Code/MMA0.c **** **  @{
  67:../Generated_Code/MMA0.c **** */         
  68:../Generated_Code/MMA0.c **** 
  69:../Generated_Code/MMA0.c **** /* MODULE MMA0. */
  70:../Generated_Code/MMA0.c **** 
  71:../Generated_Code/MMA0.c **** #include "MMA0.h"
  72:../Generated_Code/MMA0.c **** 
  73:../Generated_Code/MMA0.c **** #define MMA0_CPU_IS_LITTLE_ENDIAN 1 /* Cpu is little endian */
  74:../Generated_Code/MMA0.c **** 
  75:../Generated_Code/MMA0.c **** /* External 3-axis accelerometer control register addresses */
  76:../Generated_Code/MMA0.c **** #define MMA0_CTRL_REG_1 0x2A
  77:../Generated_Code/MMA0.c **** /* MMA8451 3-axis accelerometer control register bit masks */
  78:../Generated_Code/MMA0.c **** #define MMA0_ACTIVE_BIT_MASK 0x01
  79:../Generated_Code/MMA0.c **** #define MMA0_F_READ_BIT_MASK 0x02
  80:../Generated_Code/MMA0.c **** 
  81:../Generated_Code/MMA0.c **** /* External 3-axis accelerometer data register addresses */
  82:../Generated_Code/MMA0.c **** #define MMA0_OUT_X_MSB 0x01
  83:../Generated_Code/MMA0.c **** #define MMA0_OUT_X_LSB 0x02
  84:../Generated_Code/MMA0.c **** #define MMA0_OUT_Y_MSB 0x03
  85:../Generated_Code/MMA0.c **** #define MMA0_OUT_Y_LSB 0x04
  86:../Generated_Code/MMA0.c **** #define MMA0_OUT_Z_MSB 0x05
  87:../Generated_Code/MMA0.c **** #define MMA0_OUT_Z_LSB 0x06
  88:../Generated_Code/MMA0.c **** 
  89:../Generated_Code/MMA0.c **** #define MMA0_I2C_ADDR   (0x1D) /* I2C slave device address as set in the properties */
  90:../Generated_Code/MMA0.c **** 
  91:../Generated_Code/MMA0.c **** typedef struct {
  92:../Generated_Code/MMA0.c ****   int16_t NxOff; /* offset for X axis */
  93:../Generated_Code/MMA0.c ****   int16_t NyOff; /* offset for Y axis */
  94:../Generated_Code/MMA0.c ****   int16_t NzOff; /* offset for Z axis */
  95:../Generated_Code/MMA0.c **** } tAccelCal;
  96:../Generated_Code/MMA0.c **** 
  97:../Generated_Code/MMA0.c **** /* default calibration values from component properties */
  98:../Generated_Code/MMA0.c **** static const tAccelCal InitialCalibration = { /* Initial default calibration values */
  99:../Generated_Code/MMA0.c ****   0, /* X offset */
 100:../Generated_Code/MMA0.c ****   0, /* Y offset */
 101:../Generated_Code/MMA0.c ****   0, /* Z offset */
 102:../Generated_Code/MMA0.c **** };
 103:../Generated_Code/MMA0.c **** static tAccelCal sCalValues; /* calibration values in RAM */
 104:../Generated_Code/MMA0.c **** 
 105:../Generated_Code/MMA0.c **** #define CalNxOff   sCalValues.NxOff
 106:../Generated_Code/MMA0.c **** #define CalNyOff   sCalValues.NyOff
 107:../Generated_Code/MMA0.c **** #define CalNzOff   sCalValues.NzOff
 108:../Generated_Code/MMA0.c **** 
 109:../Generated_Code/MMA0.c **** /*
 110:../Generated_Code/MMA0.c **** ** ===================================================================
 111:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetRaw8XYZ (component MMA8451Q)
 112:../Generated_Code/MMA0.c **** **     Description :
 113:../Generated_Code/MMA0.c **** **         Returns in an array the x, y and z accelerometer as 8bit
 114:../Generated_Code/MMA0.c **** **         values.
 115:../Generated_Code/MMA0.c **** **     Parameters  :
 116:../Generated_Code/MMA0.c **** **         NAME            - DESCRIPTION
 117:../Generated_Code/MMA0.c **** **       * xyz             - Pointer to an array of three unsigned 8bit
 118:../Generated_Code/MMA0.c **** **                           values which are used to return the
 119:../Generated_Code/MMA0.c **** **                           accelerometer values.
 120:../Generated_Code/MMA0.c **** **     Returns     :
 121:../Generated_Code/MMA0.c **** **         ---             - Error code, ERR_OK for no error.
 122:../Generated_Code/MMA0.c **** ** ===================================================================
 123:../Generated_Code/MMA0.c **** */
 124:../Generated_Code/MMA0.c **** uint8_t MMA0_GetRaw8XYZ(uint8_t *xyz)
 125:../Generated_Code/MMA0.c **** {
  32              		.loc 1 125 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 02AF     		add	r7, sp, #8
  43              	.LCFI2:
  44              		.cfi_def_cfa 7, 16
  45 0006 7860     		str	r0, [r7, #4]
  46              	.LBB2:
 126:../Generated_Code/MMA0.c ****   static const uint8_t addr = MMA0_OUT_X_MSB;
 127:../Generated_Code/MMA0.c **** 
 128:../Generated_Code/MMA0.c ****   return GI2C0_ReadAddress(MMA0_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &xyz[0], 3);
  47              		.loc 1 128 0
  48 0008 064A     		ldr	r2, .L3
  49 000a 7B68     		ldr	r3, [r7, #4]
  50 000c 0321     		mov	r1, #3
  51 000e 0091     		str	r1, [sp]
  52 0010 1D20     		mov	r0, #29
  53 0012 111C     		mov	r1, r2
  54 0014 0122     		mov	r2, #1
  55 0016 FFF7FEFF 		bl	_Z17GI2C0_ReadAddresshPhhS_t
  56 001a 031C     		mov	r3, r0
  57              	.LBE2:
 129:../Generated_Code/MMA0.c **** }
  58              		.loc 1 129 0
  59 001c 181C     		mov	r0, r3
  60 001e BD46     		mov	sp, r7
  61 0020 02B0     		add	sp, sp, #8
  62              		@ sp needed for prologue
  63 0022 80BD     		pop	{r7, pc}
  64              	.L4:
  65              		.align	2
  66              	.L3:
  67 0024 00000000 		.word	_ZZ15MMA0_GetRaw8XYZPhE4addr
  68              		.cfi_endproc
  69              	.LFE5:
  71              		.section	.text._Z11MMA0_Deinitv,"ax",%progbits
  72              		.align	2
  73              		.global	_Z11MMA0_Deinitv
  74              		.code	16
  75              		.thumb_func
  77              	_Z11MMA0_Deinitv:
  78              	.LFB6:
 130:../Generated_Code/MMA0.c **** 
 131:../Generated_Code/MMA0.c **** /*
 132:../Generated_Code/MMA0.c **** ** ===================================================================
 133:../Generated_Code/MMA0.c **** **     Method      :  MMA0_Deinit (component MMA8451Q)
 134:../Generated_Code/MMA0.c **** **     Description :
 135:../Generated_Code/MMA0.c **** **         Counterpart to Init() method.
 136:../Generated_Code/MMA0.c **** **     Parameters  : None
 137:../Generated_Code/MMA0.c **** **     Returns     :
 138:../Generated_Code/MMA0.c **** **         ---             - Error code, ERR_OK if everything is ok.
 139:../Generated_Code/MMA0.c **** ** ===================================================================
 140:../Generated_Code/MMA0.c **** */
 141:../Generated_Code/MMA0.c **** uint8_t MMA0_Deinit(void)
 142:../Generated_Code/MMA0.c **** {
  79              		.loc 1 142 0
  80              		.cfi_startproc
  81 0000 80B5     		push	{r7, lr}
  82              	.LCFI3:
  83              		.cfi_def_cfa_offset 8
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86 0002 00AF     		add	r7, sp, #0
  87              	.LCFI4:
  88              		.cfi_def_cfa_register 7
 143:../Generated_Code/MMA0.c ****   return ERR_OK; /* nothing to do */
  89              		.loc 1 143 0
  90 0004 0023     		mov	r3, #0
 144:../Generated_Code/MMA0.c **** }
  91              		.loc 1 144 0
  92 0006 181C     		mov	r0, r3
  93 0008 BD46     		mov	sp, r7
  94              		@ sp needed for prologue
  95 000a 80BD     		pop	{r7, pc}
  96              		.cfi_endproc
  97              	.LFE6:
  99              		.section	.text._Z9MMA0_Initv,"ax",%progbits
 100              		.align	2
 101              		.global	_Z9MMA0_Initv
 102              		.code	16
 103              		.thumb_func
 105              	_Z9MMA0_Initv:
 106              	.LFB7:
 145:../Generated_Code/MMA0.c **** 
 146:../Generated_Code/MMA0.c **** /*
 147:../Generated_Code/MMA0.c **** ** ===================================================================
 148:../Generated_Code/MMA0.c **** **     Method      :  MMA0_Init (component MMA8451Q)
 149:../Generated_Code/MMA0.c **** **     Description :
 150:../Generated_Code/MMA0.c **** **         Initializes the device driver
 151:../Generated_Code/MMA0.c **** **     Parameters  : None
 152:../Generated_Code/MMA0.c **** **     Returns     :
 153:../Generated_Code/MMA0.c **** **         ---             - Error code, ERR_OK if everything is ok.
 154:../Generated_Code/MMA0.c **** ** ===================================================================
 155:../Generated_Code/MMA0.c **** */
 156:../Generated_Code/MMA0.c **** uint8_t MMA0_Init(void)
 157:../Generated_Code/MMA0.c **** {
 107              		.loc 1 157 0
 108              		.cfi_startproc
 109 0000 80B5     		push	{r7, lr}
 110              	.LCFI5:
 111              		.cfi_def_cfa_offset 8
 112              		.cfi_offset 7, -8
 113              		.cfi_offset 14, -4
 114 0002 00AF     		add	r7, sp, #0
 115              	.LCFI6:
 116              		.cfi_def_cfa_register 7
 158:../Generated_Code/MMA0.c ****   sCalValues.NxOff = InitialCalibration.NxOff;
 117              		.loc 1 158 0
 118 0004 0A4B     		ldr	r3, .L9
 119 0006 1A88     		ldrh	r2, [r3]
 120 0008 0A4B     		ldr	r3, .L9+4
 121 000a 1A80     		strh	r2, [r3]
 159:../Generated_Code/MMA0.c ****   sCalValues.NyOff = InitialCalibration.NyOff;
 122              		.loc 1 159 0
 123 000c 084B     		ldr	r3, .L9
 124 000e 5A88     		ldrh	r2, [r3, #2]
 125 0010 084B     		ldr	r3, .L9+4
 126 0012 5A80     		strh	r2, [r3, #2]
 160:../Generated_Code/MMA0.c ****   sCalValues.NzOff = InitialCalibration.NzOff;
 127              		.loc 1 160 0
 128 0014 064B     		ldr	r3, .L9
 129 0016 9A88     		ldrh	r2, [r3, #4]
 130 0018 064B     		ldr	r3, .L9+4
 131 001a 9A80     		strh	r2, [r3, #4]
 161:../Generated_Code/MMA0.c ****   return GI2C0_WriteByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, MMA0_ACTIVE_BIT_MASK); /* enable d
 132              		.loc 1 161 0
 133 001c 1D20     		mov	r0, #29
 134 001e 2A21     		mov	r1, #42
 135 0020 0122     		mov	r2, #1
 136 0022 FFF7FEFF 		bl	_Z23GI2C0_WriteByteAddress8hhh
 137 0026 031C     		mov	r3, r0
 162:../Generated_Code/MMA0.c **** }
 138              		.loc 1 162 0
 139 0028 181C     		mov	r0, r3
 140 002a BD46     		mov	sp, r7
 141              		@ sp needed for prologue
 142 002c 80BD     		pop	{r7, pc}
 143              	.L10:
 144 002e C046     		.align	2
 145              	.L9:
 146 0030 00000000 		.word	_ZL18InitialCalibration
 147 0034 00000000 		.word	_ZL10sCalValues
 148              		.cfi_endproc
 149              	.LFE7:
 151              		.section	.text._Z17MMA0_CalibrateX1gv,"ax",%progbits
 152              		.align	2
 153              		.global	_Z17MMA0_CalibrateX1gv
 154              		.code	16
 155              		.thumb_func
 157              	_Z17MMA0_CalibrateX1gv:
 158              	.LFB8:
 163:../Generated_Code/MMA0.c **** 
 164:../Generated_Code/MMA0.c **** /*
 165:../Generated_Code/MMA0.c **** ** ===================================================================
 166:../Generated_Code/MMA0.c **** **     Method      :  MMA0_CalibrateX1g (component MMA8451Q)
 167:../Generated_Code/MMA0.c **** **     Description :
 168:../Generated_Code/MMA0.c **** **         Performs a calibration of the sensor. It is assumed that the
 169:../Generated_Code/MMA0.c **** **         Y and Z sensors have 0 g, and the X sensor has 1 g.
 170:../Generated_Code/MMA0.c **** **     Parameters  : None
 171:../Generated_Code/MMA0.c **** **     Returns     : Nothing
 172:../Generated_Code/MMA0.c **** ** ===================================================================
 173:../Generated_Code/MMA0.c **** */
 174:../Generated_Code/MMA0.c **** void MMA0_CalibrateX1g(void)
 175:../Generated_Code/MMA0.c **** {
 159              		.loc 1 175 0
 160              		.cfi_startproc
 161 0000 80B5     		push	{r7, lr}
 162              	.LCFI7:
 163              		.cfi_def_cfa_offset 8
 164              		.cfi_offset 7, -8
 165              		.cfi_offset 14, -4
 166 0002 84B0     		sub	sp, sp, #16
 167              	.LCFI8:
 168              		.cfi_def_cfa_offset 24
 169 0004 00AF     		add	r7, sp, #0
 170              	.LCFI9:
 171              		.cfi_def_cfa_register 7
 172              	.LBB3:
 176:../Generated_Code/MMA0.c ****   /* assumption is that accelerometer is placed with 1g for X and 0g for Y and Z */
 177:../Generated_Code/MMA0.c ****   uint32_t X=0, Y=0, Z=0;
 173              		.loc 1 177 0
 174 0006 0023     		mov	r3, #0
 175 0008 FB60     		str	r3, [r7, #12]
 176 000a 0023     		mov	r3, #0
 177 000c BB60     		str	r3, [r7, #8]
 178 000e 0023     		mov	r3, #0
 179 0010 7B60     		str	r3, [r7, #4]
 178:../Generated_Code/MMA0.c ****   uint8_t i;
 179:../Generated_Code/MMA0.c **** 
 180:../Generated_Code/MMA0.c ****   /* Get the raw data */
 181:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 180              		.loc 1 181 0
 181 0012 FB1C     		add	r3, r7, #3
 182 0014 0022     		mov	r2, #0
 183 0016 1A70     		strb	r2, [r3]
 184 0018 16E0     		b	.L12
 185              	.L13:
 182:../Generated_Code/MMA0.c ****    X += MMA0_MeasureGetRawX();
 186              		.loc 1 182 0
 187 001a FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawXv
 188 001e 031C     		mov	r3, r0
 189 0020 FA68     		ldr	r2, [r7, #12]
 190 0022 D318     		add	r3, r2, r3
 191 0024 FB60     		str	r3, [r7, #12]
 183:../Generated_Code/MMA0.c ****    Y += MMA0_MeasureGetRawY();
 192              		.loc 1 183 0
 193 0026 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawYv
 194 002a 031C     		mov	r3, r0
 195 002c BA68     		ldr	r2, [r7, #8]
 196 002e D318     		add	r3, r2, r3
 197 0030 BB60     		str	r3, [r7, #8]
 184:../Generated_Code/MMA0.c ****    Z += MMA0_MeasureGetRawZ();
 198              		.loc 1 184 0
 199 0032 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawZv
 200 0036 031C     		mov	r3, r0
 201 0038 7A68     		ldr	r2, [r7, #4]
 202 003a D318     		add	r3, r2, r3
 203 003c 7B60     		str	r3, [r7, #4]
 181:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 204              		.loc 1 181 0
 205 003e FB1C     		add	r3, r7, #3
 206 0040 FA1C     		add	r2, r7, #3
 207 0042 1278     		ldrb	r2, [r2]
 208 0044 0132     		add	r2, r2, #1
 209 0046 1A70     		strb	r2, [r3]
 210              	.L12:
 181:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 211              		.loc 1 181 0 is_stmt 0
 212 0048 FB1C     		add	r3, r7, #3
 213 004a 1A78     		ldrb	r2, [r3]
 214 004c 0721     		mov	r1, #7
 215 004e 0023     		mov	r3, #0
 216 0050 9142     		cmp	r1, r2
 217 0052 5B41     		adc	r3, r3, r3
 218 0054 DBB2     		uxtb	r3, r3
 219 0056 002B     		cmp	r3, #0
 220 0058 DFD1     		bne	.L13
 185:../Generated_Code/MMA0.c ****   }
 186:../Generated_Code/MMA0.c ****   /* build average of 8 measured values */
 187:../Generated_Code/MMA0.c ****   X >>= 3;
 221              		.loc 1 187 0 is_stmt 1
 222 005a FB68     		ldr	r3, [r7, #12]
 223 005c DB08     		lsr	r3, r3, #3
 224 005e FB60     		str	r3, [r7, #12]
 188:../Generated_Code/MMA0.c ****   Y >>= 3;
 225              		.loc 1 188 0
 226 0060 BB68     		ldr	r3, [r7, #8]
 227 0062 DB08     		lsr	r3, r3, #3
 228 0064 BB60     		str	r3, [r7, #8]
 189:../Generated_Code/MMA0.c ****   Z >>= 3;
 229              		.loc 1 189 0
 230 0066 7B68     		ldr	r3, [r7, #4]
 231 0068 DB08     		lsr	r3, r3, #3
 232 006a 7B60     		str	r3, [r7, #4]
 190:../Generated_Code/MMA0.c ****   /* store the calibration values */
 191:../Generated_Code/MMA0.c ****   /* offset: both Y and Z shall have zero g */
 192:../Generated_Code/MMA0.c ****   sCalValues.NyOff = (int16_t)Y;
 233              		.loc 1 192 0
 234 006c BB68     		ldr	r3, [r7, #8]
 235 006e 9AB2     		uxth	r2, r3
 236 0070 044B     		ldr	r3, .L14
 237 0072 5A80     		strh	r2, [r3, #2]
 193:../Generated_Code/MMA0.c ****   sCalValues.NzOff = (int16_t)Z;
 238              		.loc 1 193 0
 239 0074 7B68     		ldr	r3, [r7, #4]
 240 0076 9AB2     		uxth	r2, r3
 241 0078 024B     		ldr	r3, .L14
 242 007a 9A80     		strh	r2, [r3, #4]
 243              	.LBE3:
 194:../Generated_Code/MMA0.c **** }
 244              		.loc 1 194 0
 245 007c BD46     		mov	sp, r7
 246 007e 04B0     		add	sp, sp, #16
 247              		@ sp needed for prologue
 248 0080 80BD     		pop	{r7, pc}
 249              	.L15:
 250 0082 C046     		.align	2
 251              	.L14:
 252 0084 00000000 		.word	_ZL10sCalValues
 253              		.cfi_endproc
 254              	.LFE8:
 256              		.section	.text._Z17MMA0_CalibrateY1gv,"ax",%progbits
 257              		.align	2
 258              		.global	_Z17MMA0_CalibrateY1gv
 259              		.code	16
 260              		.thumb_func
 262              	_Z17MMA0_CalibrateY1gv:
 263              	.LFB9:
 195:../Generated_Code/MMA0.c **** 
 196:../Generated_Code/MMA0.c **** /*
 197:../Generated_Code/MMA0.c **** ** ===================================================================
 198:../Generated_Code/MMA0.c **** **     Method      :  MMA0_CalibrateY1g (component MMA8451Q)
 199:../Generated_Code/MMA0.c **** **     Description :
 200:../Generated_Code/MMA0.c **** **         Performs a calibration of the sensor. It is assumed that the
 201:../Generated_Code/MMA0.c **** **         Y and Z sensors have 0 g, and the X sensor has 1 g.
 202:../Generated_Code/MMA0.c **** **     Parameters  : None
 203:../Generated_Code/MMA0.c **** **     Returns     : Nothing
 204:../Generated_Code/MMA0.c **** ** ===================================================================
 205:../Generated_Code/MMA0.c **** */
 206:../Generated_Code/MMA0.c **** void MMA0_CalibrateY1g(void)
 207:../Generated_Code/MMA0.c **** {
 264              		.loc 1 207 0
 265              		.cfi_startproc
 266 0000 80B5     		push	{r7, lr}
 267              	.LCFI10:
 268              		.cfi_def_cfa_offset 8
 269              		.cfi_offset 7, -8
 270              		.cfi_offset 14, -4
 271 0002 84B0     		sub	sp, sp, #16
 272              	.LCFI11:
 273              		.cfi_def_cfa_offset 24
 274 0004 00AF     		add	r7, sp, #0
 275              	.LCFI12:
 276              		.cfi_def_cfa_register 7
 277              	.LBB4:
 208:../Generated_Code/MMA0.c ****   /* assumption is that accelerometer is placed with 1g for Y and 0g for X and Z */
 209:../Generated_Code/MMA0.c ****   uint32_t X=0, Y=0, Z=0;
 278              		.loc 1 209 0
 279 0006 0023     		mov	r3, #0
 280 0008 FB60     		str	r3, [r7, #12]
 281 000a 0023     		mov	r3, #0
 282 000c BB60     		str	r3, [r7, #8]
 283 000e 0023     		mov	r3, #0
 284 0010 7B60     		str	r3, [r7, #4]
 210:../Generated_Code/MMA0.c ****   uint8_t i;
 211:../Generated_Code/MMA0.c **** 
 212:../Generated_Code/MMA0.c ****   /* Get the raw data */
 213:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 285              		.loc 1 213 0
 286 0012 FB1C     		add	r3, r7, #3
 287 0014 0022     		mov	r2, #0
 288 0016 1A70     		strb	r2, [r3]
 289 0018 16E0     		b	.L17
 290              	.L18:
 214:../Generated_Code/MMA0.c ****    X += MMA0_MeasureGetRawX();
 291              		.loc 1 214 0
 292 001a FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawXv
 293 001e 031C     		mov	r3, r0
 294 0020 FA68     		ldr	r2, [r7, #12]
 295 0022 D318     		add	r3, r2, r3
 296 0024 FB60     		str	r3, [r7, #12]
 215:../Generated_Code/MMA0.c ****    Y += MMA0_MeasureGetRawY();
 297              		.loc 1 215 0
 298 0026 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawYv
 299 002a 031C     		mov	r3, r0
 300 002c BA68     		ldr	r2, [r7, #8]
 301 002e D318     		add	r3, r2, r3
 302 0030 BB60     		str	r3, [r7, #8]
 216:../Generated_Code/MMA0.c ****    Z += MMA0_MeasureGetRawZ();
 303              		.loc 1 216 0
 304 0032 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawZv
 305 0036 031C     		mov	r3, r0
 306 0038 7A68     		ldr	r2, [r7, #4]
 307 003a D318     		add	r3, r2, r3
 308 003c 7B60     		str	r3, [r7, #4]
 213:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 309              		.loc 1 213 0
 310 003e FB1C     		add	r3, r7, #3
 311 0040 FA1C     		add	r2, r7, #3
 312 0042 1278     		ldrb	r2, [r2]
 313 0044 0132     		add	r2, r2, #1
 314 0046 1A70     		strb	r2, [r3]
 315              	.L17:
 213:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 316              		.loc 1 213 0 is_stmt 0
 317 0048 FB1C     		add	r3, r7, #3
 318 004a 1A78     		ldrb	r2, [r3]
 319 004c 0721     		mov	r1, #7
 320 004e 0023     		mov	r3, #0
 321 0050 9142     		cmp	r1, r2
 322 0052 5B41     		adc	r3, r3, r3
 323 0054 DBB2     		uxtb	r3, r3
 324 0056 002B     		cmp	r3, #0
 325 0058 DFD1     		bne	.L18
 217:../Generated_Code/MMA0.c ****   }
 218:../Generated_Code/MMA0.c ****   /* build average of 8 measured values */
 219:../Generated_Code/MMA0.c ****   X >>= 3;
 326              		.loc 1 219 0 is_stmt 1
 327 005a FB68     		ldr	r3, [r7, #12]
 328 005c DB08     		lsr	r3, r3, #3
 329 005e FB60     		str	r3, [r7, #12]
 220:../Generated_Code/MMA0.c ****   Y >>= 3;
 330              		.loc 1 220 0
 331 0060 BB68     		ldr	r3, [r7, #8]
 332 0062 DB08     		lsr	r3, r3, #3
 333 0064 BB60     		str	r3, [r7, #8]
 221:../Generated_Code/MMA0.c ****   Z >>= 3;
 334              		.loc 1 221 0
 335 0066 7B68     		ldr	r3, [r7, #4]
 336 0068 DB08     		lsr	r3, r3, #3
 337 006a 7B60     		str	r3, [r7, #4]
 222:../Generated_Code/MMA0.c ****   /* store the calibration values */
 223:../Generated_Code/MMA0.c ****   /* offset: both X and Z shall have zero g */
 224:../Generated_Code/MMA0.c ****   sCalValues.NxOff = (int16_t)X;
 338              		.loc 1 224 0
 339 006c FB68     		ldr	r3, [r7, #12]
 340 006e 9AB2     		uxth	r2, r3
 341 0070 044B     		ldr	r3, .L19
 342 0072 1A80     		strh	r2, [r3]
 225:../Generated_Code/MMA0.c ****   sCalValues.NzOff = (int16_t)Z;
 343              		.loc 1 225 0
 344 0074 7B68     		ldr	r3, [r7, #4]
 345 0076 9AB2     		uxth	r2, r3
 346 0078 024B     		ldr	r3, .L19
 347 007a 9A80     		strh	r2, [r3, #4]
 348              	.LBE4:
 226:../Generated_Code/MMA0.c **** }
 349              		.loc 1 226 0
 350 007c BD46     		mov	sp, r7
 351 007e 04B0     		add	sp, sp, #16
 352              		@ sp needed for prologue
 353 0080 80BD     		pop	{r7, pc}
 354              	.L20:
 355 0082 C046     		.align	2
 356              	.L19:
 357 0084 00000000 		.word	_ZL10sCalValues
 358              		.cfi_endproc
 359              	.LFE9:
 361              		.section	.text._Z17MMA0_CalibrateZ1gv,"ax",%progbits
 362              		.align	2
 363              		.global	_Z17MMA0_CalibrateZ1gv
 364              		.code	16
 365              		.thumb_func
 367              	_Z17MMA0_CalibrateZ1gv:
 368              	.LFB10:
 227:../Generated_Code/MMA0.c **** 
 228:../Generated_Code/MMA0.c **** /*
 229:../Generated_Code/MMA0.c **** ** ===================================================================
 230:../Generated_Code/MMA0.c **** **     Method      :  MMA0_CalibrateZ1g (component MMA8451Q)
 231:../Generated_Code/MMA0.c **** **     Description :
 232:../Generated_Code/MMA0.c **** **         Performs a calibration of the sensor. It is assumed that the
 233:../Generated_Code/MMA0.c **** **         X and Y sensors have 0 g, and the X sensor has 1 g.
 234:../Generated_Code/MMA0.c **** **     Parameters  : None
 235:../Generated_Code/MMA0.c **** **     Returns     : Nothing
 236:../Generated_Code/MMA0.c **** ** ===================================================================
 237:../Generated_Code/MMA0.c **** */
 238:../Generated_Code/MMA0.c **** void MMA0_CalibrateZ1g(void)
 239:../Generated_Code/MMA0.c **** {
 369              		.loc 1 239 0
 370              		.cfi_startproc
 371 0000 80B5     		push	{r7, lr}
 372              	.LCFI13:
 373              		.cfi_def_cfa_offset 8
 374              		.cfi_offset 7, -8
 375              		.cfi_offset 14, -4
 376 0002 84B0     		sub	sp, sp, #16
 377              	.LCFI14:
 378              		.cfi_def_cfa_offset 24
 379 0004 00AF     		add	r7, sp, #0
 380              	.LCFI15:
 381              		.cfi_def_cfa_register 7
 382              	.LBB5:
 240:../Generated_Code/MMA0.c ****   /* assumption is that accelerometer is placed with 1g for Z and 0g for X and Y */
 241:../Generated_Code/MMA0.c ****   uint32_t X=0, Y=0, Z=0;
 383              		.loc 1 241 0
 384 0006 0023     		mov	r3, #0
 385 0008 FB60     		str	r3, [r7, #12]
 386 000a 0023     		mov	r3, #0
 387 000c BB60     		str	r3, [r7, #8]
 388 000e 0023     		mov	r3, #0
 389 0010 7B60     		str	r3, [r7, #4]
 242:../Generated_Code/MMA0.c ****   uint8_t i;
 243:../Generated_Code/MMA0.c **** 
 244:../Generated_Code/MMA0.c ****   /* Get the raw data */
 245:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 390              		.loc 1 245 0
 391 0012 FB1C     		add	r3, r7, #3
 392 0014 0022     		mov	r2, #0
 393 0016 1A70     		strb	r2, [r3]
 394 0018 16E0     		b	.L22
 395              	.L23:
 246:../Generated_Code/MMA0.c ****    X += MMA0_MeasureGetRawX();
 396              		.loc 1 246 0
 397 001a FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawXv
 398 001e 031C     		mov	r3, r0
 399 0020 FA68     		ldr	r2, [r7, #12]
 400 0022 D318     		add	r3, r2, r3
 401 0024 FB60     		str	r3, [r7, #12]
 247:../Generated_Code/MMA0.c ****    Y += MMA0_MeasureGetRawY();
 402              		.loc 1 247 0
 403 0026 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawYv
 404 002a 031C     		mov	r3, r0
 405 002c BA68     		ldr	r2, [r7, #8]
 406 002e D318     		add	r3, r2, r3
 407 0030 BB60     		str	r3, [r7, #8]
 248:../Generated_Code/MMA0.c ****    Z += MMA0_MeasureGetRawZ();
 408              		.loc 1 248 0
 409 0032 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawZv
 410 0036 031C     		mov	r3, r0
 411 0038 7A68     		ldr	r2, [r7, #4]
 412 003a D318     		add	r3, r2, r3
 413 003c 7B60     		str	r3, [r7, #4]
 245:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 414              		.loc 1 245 0
 415 003e FB1C     		add	r3, r7, #3
 416 0040 FA1C     		add	r2, r7, #3
 417 0042 1278     		ldrb	r2, [r2]
 418 0044 0132     		add	r2, r2, #1
 419 0046 1A70     		strb	r2, [r3]
 420              	.L22:
 245:../Generated_Code/MMA0.c ****   for (i=0; i<8; i++) {
 421              		.loc 1 245 0 is_stmt 0
 422 0048 FB1C     		add	r3, r7, #3
 423 004a 1A78     		ldrb	r2, [r3]
 424 004c 0721     		mov	r1, #7
 425 004e 0023     		mov	r3, #0
 426 0050 9142     		cmp	r1, r2
 427 0052 5B41     		adc	r3, r3, r3
 428 0054 DBB2     		uxtb	r3, r3
 429 0056 002B     		cmp	r3, #0
 430 0058 DFD1     		bne	.L23
 249:../Generated_Code/MMA0.c ****   }
 250:../Generated_Code/MMA0.c ****   /* build average of 8 measured values */
 251:../Generated_Code/MMA0.c ****   X >>= 3;
 431              		.loc 1 251 0 is_stmt 1
 432 005a FB68     		ldr	r3, [r7, #12]
 433 005c DB08     		lsr	r3, r3, #3
 434 005e FB60     		str	r3, [r7, #12]
 252:../Generated_Code/MMA0.c ****   Y >>= 3;
 435              		.loc 1 252 0
 436 0060 BB68     		ldr	r3, [r7, #8]
 437 0062 DB08     		lsr	r3, r3, #3
 438 0064 BB60     		str	r3, [r7, #8]
 253:../Generated_Code/MMA0.c ****   Z >>= 3;
 439              		.loc 1 253 0
 440 0066 7B68     		ldr	r3, [r7, #4]
 441 0068 DB08     		lsr	r3, r3, #3
 442 006a 7B60     		str	r3, [r7, #4]
 254:../Generated_Code/MMA0.c ****   /* store the calibration values */
 255:../Generated_Code/MMA0.c ****   /* offset: both X and Y shall have zero g (midpoint) */
 256:../Generated_Code/MMA0.c ****   sCalValues.NxOff = (int16_t)X;
 443              		.loc 1 256 0
 444 006c FB68     		ldr	r3, [r7, #12]
 445 006e 9AB2     		uxth	r2, r3
 446 0070 044B     		ldr	r3, .L24
 447 0072 1A80     		strh	r2, [r3]
 257:../Generated_Code/MMA0.c ****   sCalValues.NyOff = (int16_t)Y;
 448              		.loc 1 257 0
 449 0074 BB68     		ldr	r3, [r7, #8]
 450 0076 9AB2     		uxth	r2, r3
 451 0078 024B     		ldr	r3, .L24
 452 007a 5A80     		strh	r2, [r3, #2]
 453              	.LBE5:
 258:../Generated_Code/MMA0.c **** }
 454              		.loc 1 258 0
 455 007c BD46     		mov	sp, r7
 456 007e 04B0     		add	sp, sp, #16
 457              		@ sp needed for prologue
 458 0080 80BD     		pop	{r7, pc}
 459              	.L25:
 460 0082 C046     		.align	2
 461              	.L24:
 462 0084 00000000 		.word	_ZL10sCalValues
 463              		.cfi_endproc
 464              	.LFE10:
 466              		.section	.text._Z11MMA0_GetXmgv,"ax",%progbits
 467              		.align	2
 468              		.global	_Z11MMA0_GetXmgv
 469              		.code	16
 470              		.thumb_func
 472              	_Z11MMA0_GetXmgv:
 473              	.LFB11:
 259:../Generated_Code/MMA0.c **** 
 260:../Generated_Code/MMA0.c **** /*
 261:../Generated_Code/MMA0.c **** ** ===================================================================
 262:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetXmg (component MMA8451Q)
 263:../Generated_Code/MMA0.c **** **     Description :
 264:../Generated_Code/MMA0.c **** **         Returns the X value in mg
 265:../Generated_Code/MMA0.c **** **     Parameters  : None
 266:../Generated_Code/MMA0.c **** **     Returns     :
 267:../Generated_Code/MMA0.c **** **         ---             - The g value in 1/1000g units
 268:../Generated_Code/MMA0.c **** ** ===================================================================
 269:../Generated_Code/MMA0.c **** */
 270:../Generated_Code/MMA0.c **** int16_t MMA0_GetXmg(void)
 271:../Generated_Code/MMA0.c **** {
 474              		.loc 1 271 0
 475              		.cfi_startproc
 476 0000 90B5     		push	{r4, r7, lr}
 477              	.LCFI16:
 478              		.cfi_def_cfa_offset 12
 479              		.cfi_offset 4, -12
 480              		.cfi_offset 7, -8
 481              		.cfi_offset 14, -4
 482 0002 83B0     		sub	sp, sp, #12
 483              	.LCFI17:
 484              		.cfi_def_cfa_offset 24
 485 0004 00AF     		add	r7, sp, #0
 486              	.LCFI18:
 487              		.cfi_def_cfa_register 7
 488              	.LBB6:
 272:../Generated_Code/MMA0.c ****   int16_t val;
 273:../Generated_Code/MMA0.c **** 
 274:../Generated_Code/MMA0.c ****   val = MMA0_GetX();
 489              		.loc 1 274 0
 490 0006 BC1D     		add	r4, r7, #6
 491 0008 FFF7FEFF 		bl	_Z9MMA0_GetXv
 492 000c 031C     		mov	r3, r0
 493 000e 2380     		strh	r3, [r4]
 275:../Generated_Code/MMA0.c ****   /* with 14bits and 2g mode, each count corresponds to 0.25 mg */
 276:../Generated_Code/MMA0.c ****   return (int16_t)((val>>2)/4); /* remove 2 bits (16bit to 14bit) and scale */
 494              		.loc 1 276 0
 495 0010 BB1D     		add	r3, r7, #6
 496 0012 0022     		mov	r2, #0
 497 0014 9B5E     		ldrsh	r3, [r3, r2]
 498 0016 9B10     		asr	r3, r3, #2
 499 0018 00D5     		bpl	.L27
 500 001a 0333     		add	r3, r3, #3
 501              	.L27:
 502 001c 9B10     		asr	r3, r3, #2
 503 001e 9BB2     		uxth	r3, r3
 504 0020 1BB2     		sxth	r3, r3
 505              	.LBE6:
 277:../Generated_Code/MMA0.c **** }
 506              		.loc 1 277 0
 507 0022 181C     		mov	r0, r3
 508 0024 BD46     		mov	sp, r7
 509 0026 03B0     		add	sp, sp, #12
 510              		@ sp needed for prologue
 511 0028 90BD     		pop	{r4, r7, pc}
 512              		.cfi_endproc
 513              	.LFE11:
 515 002a C046     		.section	.text._Z11MMA0_GetYmgv,"ax",%progbits
 516              		.align	2
 517              		.global	_Z11MMA0_GetYmgv
 518              		.code	16
 519              		.thumb_func
 521              	_Z11MMA0_GetYmgv:
 522              	.LFB12:
 278:../Generated_Code/MMA0.c **** 
 279:../Generated_Code/MMA0.c **** /*
 280:../Generated_Code/MMA0.c **** ** ===================================================================
 281:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetYmg (component MMA8451Q)
 282:../Generated_Code/MMA0.c **** **     Description :
 283:../Generated_Code/MMA0.c **** **         Returns the Y value in mg
 284:../Generated_Code/MMA0.c **** **     Parameters  : None
 285:../Generated_Code/MMA0.c **** **     Returns     :
 286:../Generated_Code/MMA0.c **** **         ---             - The g value in 1/1000g units
 287:../Generated_Code/MMA0.c **** ** ===================================================================
 288:../Generated_Code/MMA0.c **** */
 289:../Generated_Code/MMA0.c **** int16_t MMA0_GetYmg(void)
 290:../Generated_Code/MMA0.c **** {
 523              		.loc 1 290 0
 524              		.cfi_startproc
 525 0000 90B5     		push	{r4, r7, lr}
 526              	.LCFI19:
 527              		.cfi_def_cfa_offset 12
 528              		.cfi_offset 4, -12
 529              		.cfi_offset 7, -8
 530              		.cfi_offset 14, -4
 531 0002 83B0     		sub	sp, sp, #12
 532              	.LCFI20:
 533              		.cfi_def_cfa_offset 24
 534 0004 00AF     		add	r7, sp, #0
 535              	.LCFI21:
 536              		.cfi_def_cfa_register 7
 537              	.LBB7:
 291:../Generated_Code/MMA0.c ****   int16_t val;
 292:../Generated_Code/MMA0.c **** 
 293:../Generated_Code/MMA0.c ****   val = MMA0_GetY();
 538              		.loc 1 293 0
 539 0006 BC1D     		add	r4, r7, #6
 540 0008 FFF7FEFF 		bl	_Z9MMA0_GetYv
 541 000c 031C     		mov	r3, r0
 542 000e 2380     		strh	r3, [r4]
 294:../Generated_Code/MMA0.c ****   /* with 14bits and 2g mode, each count corresponds to 0.25 mg */
 295:../Generated_Code/MMA0.c ****   return (int16_t)((val>>2)/4); /* remove 2 bits (16bit to 14bit) and scale */
 543              		.loc 1 295 0
 544 0010 BB1D     		add	r3, r7, #6
 545 0012 0022     		mov	r2, #0
 546 0014 9B5E     		ldrsh	r3, [r3, r2]
 547 0016 9B10     		asr	r3, r3, #2
 548 0018 00D5     		bpl	.L30
 549 001a 0333     		add	r3, r3, #3
 550              	.L30:
 551 001c 9B10     		asr	r3, r3, #2
 552 001e 9BB2     		uxth	r3, r3
 553 0020 1BB2     		sxth	r3, r3
 554              	.LBE7:
 296:../Generated_Code/MMA0.c **** }
 555              		.loc 1 296 0
 556 0022 181C     		mov	r0, r3
 557 0024 BD46     		mov	sp, r7
 558 0026 03B0     		add	sp, sp, #12
 559              		@ sp needed for prologue
 560 0028 90BD     		pop	{r4, r7, pc}
 561              		.cfi_endproc
 562              	.LFE12:
 564 002a C046     		.section	.text._Z11MMA0_GetZmgv,"ax",%progbits
 565              		.align	2
 566              		.global	_Z11MMA0_GetZmgv
 567              		.code	16
 568              		.thumb_func
 570              	_Z11MMA0_GetZmgv:
 571              	.LFB13:
 297:../Generated_Code/MMA0.c **** 
 298:../Generated_Code/MMA0.c **** /*
 299:../Generated_Code/MMA0.c **** ** ===================================================================
 300:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetZmg (component MMA8451Q)
 301:../Generated_Code/MMA0.c **** **     Description :
 302:../Generated_Code/MMA0.c **** **         Returns the Z value in mg
 303:../Generated_Code/MMA0.c **** **     Parameters  : None
 304:../Generated_Code/MMA0.c **** **     Returns     :
 305:../Generated_Code/MMA0.c **** **         ---             - The g value in 1/1000g units
 306:../Generated_Code/MMA0.c **** ** ===================================================================
 307:../Generated_Code/MMA0.c **** */
 308:../Generated_Code/MMA0.c **** int16_t MMA0_GetZmg(void)
 309:../Generated_Code/MMA0.c **** {
 572              		.loc 1 309 0
 573              		.cfi_startproc
 574 0000 90B5     		push	{r4, r7, lr}
 575              	.LCFI22:
 576              		.cfi_def_cfa_offset 12
 577              		.cfi_offset 4, -12
 578              		.cfi_offset 7, -8
 579              		.cfi_offset 14, -4
 580 0002 83B0     		sub	sp, sp, #12
 581              	.LCFI23:
 582              		.cfi_def_cfa_offset 24
 583 0004 00AF     		add	r7, sp, #0
 584              	.LCFI24:
 585              		.cfi_def_cfa_register 7
 586              	.LBB8:
 310:../Generated_Code/MMA0.c ****   int16_t val;
 311:../Generated_Code/MMA0.c **** 
 312:../Generated_Code/MMA0.c ****   val = MMA0_GetZ();
 587              		.loc 1 312 0
 588 0006 BC1D     		add	r4, r7, #6
 589 0008 FFF7FEFF 		bl	_Z9MMA0_GetZv
 590 000c 031C     		mov	r3, r0
 591 000e 2380     		strh	r3, [r4]
 313:../Generated_Code/MMA0.c ****   /* with 14bits and 2g mode, each count corresponds to 0.25 mg */
 314:../Generated_Code/MMA0.c ****   return (int16_t)((val>>2)/4); /* remove 2 bits (16bit to 14bit) and scale */
 592              		.loc 1 314 0
 593 0010 BB1D     		add	r3, r7, #6
 594 0012 0022     		mov	r2, #0
 595 0014 9B5E     		ldrsh	r3, [r3, r2]
 596 0016 9B10     		asr	r3, r3, #2
 597 0018 00D5     		bpl	.L33
 598 001a 0333     		add	r3, r3, #3
 599              	.L33:
 600 001c 9B10     		asr	r3, r3, #2
 601 001e 9BB2     		uxth	r3, r3
 602 0020 1BB2     		sxth	r3, r3
 603              	.LBE8:
 315:../Generated_Code/MMA0.c **** }
 604              		.loc 1 315 0
 605 0022 181C     		mov	r0, r3
 606 0024 BD46     		mov	sp, r7
 607 0026 03B0     		add	sp, sp, #12
 608              		@ sp needed for prologue
 609 0028 90BD     		pop	{r4, r7, pc}
 610              		.cfi_endproc
 611              	.LFE13:
 613 002a C046     		.section	.text._Z19MMA0_MeasureGetRawXv,"ax",%progbits
 614              		.align	2
 615              		.global	_Z19MMA0_MeasureGetRawXv
 616              		.code	16
 617              		.thumb_func
 619              	_Z19MMA0_MeasureGetRawXv:
 620              	.LFB14:
 316:../Generated_Code/MMA0.c **** 
 317:../Generated_Code/MMA0.c **** /*
 318:../Generated_Code/MMA0.c **** ** ===================================================================
 319:../Generated_Code/MMA0.c **** **     Method      :  MMA0_MeasureGetRawX (component MMA8451Q)
 320:../Generated_Code/MMA0.c **** **     Description :
 321:../Generated_Code/MMA0.c **** **         Performs a measurement on X channel and returns the raw
 322:../Generated_Code/MMA0.c **** **         value.
 323:../Generated_Code/MMA0.c **** **     Parameters  : None
 324:../Generated_Code/MMA0.c **** **     Returns     :
 325:../Generated_Code/MMA0.c **** **         ---             - X sensor value
 326:../Generated_Code/MMA0.c **** ** ===================================================================
 327:../Generated_Code/MMA0.c **** */
 328:../Generated_Code/MMA0.c **** word MMA0_MeasureGetRawX(void)
 329:../Generated_Code/MMA0.c **** {
 621              		.loc 1 329 0
 622              		.cfi_startproc
 623 0000 80B5     		push	{r7, lr}
 624              	.LCFI25:
 625              		.cfi_def_cfa_offset 8
 626              		.cfi_offset 7, -8
 627              		.cfi_offset 14, -4
 628 0002 84B0     		sub	sp, sp, #16
 629              	.LCFI26:
 630              		.cfi_def_cfa_offset 24
 631 0004 02AF     		add	r7, sp, #8
 632              	.LCFI27:
 633              		.cfi_def_cfa 7, 16
 634              	.LBB9:
 330:../Generated_Code/MMA0.c ****   union {
 331:../Generated_Code/MMA0.c ****     uint8_t buf[2]; /* value from device is in big endian */
 332:../Generated_Code/MMA0.c ****     uint16_t be;
 333:../Generated_Code/MMA0.c ****   } val;
 334:../Generated_Code/MMA0.c ****   static const uint8_t addr = MMA0_OUT_X_MSB;
 335:../Generated_Code/MMA0.c **** 
 336:../Generated_Code/MMA0.c ****   if(GI2C0_ReadAddress(MMA0_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!
 635              		.loc 1 336 0
 636 0006 0F4A     		ldr	r2, .L39
 637 0008 3B1D     		add	r3, r7, #4
 638 000a 0221     		mov	r1, #2
 639 000c 0091     		str	r1, [sp]
 640 000e 1D20     		mov	r0, #29
 641 0010 111C     		mov	r1, r2
 642 0012 0122     		mov	r2, #1
 643 0014 FFF7FEFF 		bl	_Z17GI2C0_ReadAddresshPhhS_t
 644 0018 031C     		mov	r3, r0
 645 001a 5A1E     		sub	r2, r3, #1
 646 001c 9341     		sbc	r3, r3, r2
 647 001e DBB2     		uxtb	r3, r3
 648 0020 002B     		cmp	r3, #0
 649 0022 01D0     		beq	.L36
 337:../Generated_Code/MMA0.c ****     return 0; /* failure */
 650              		.loc 1 337 0
 651 0024 0023     		mov	r3, #0
 652 0026 08E0     		b	.L38
 653              	.L36:
 338:../Generated_Code/MMA0.c ****   }
 339:../Generated_Code/MMA0.c **** #if MMA0_CPU_IS_LITTLE_ENDIAN
 340:../Generated_Code/MMA0.c ****   return (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
 654              		.loc 1 340 0
 655 0028 3B1D     		add	r3, r7, #4
 656 002a 1B78     		ldrb	r3, [r3]
 657 002c 1B02     		lsl	r3, r3, #8
 658 002e 9AB2     		uxth	r2, r3
 659 0030 3B1D     		add	r3, r7, #4
 660 0032 5B78     		ldrb	r3, [r3, #1]
 661 0034 1343     		orr	r3, r2
 662 0036 9BB2     		uxth	r3, r3
 663 0038 9BB2     		uxth	r3, r3
 664              	.L38:
 665              	.LBE9:
 341:../Generated_Code/MMA0.c **** #else
 342:../Generated_Code/MMA0.c ****   return val.be; /* already in BE */
 343:../Generated_Code/MMA0.c **** #endif
 344:../Generated_Code/MMA0.c **** }
 666              		.loc 1 344 0
 667 003a 181C     		mov	r0, r3
 668 003c BD46     		mov	sp, r7
 669 003e 02B0     		add	sp, sp, #8
 670              		@ sp needed for prologue
 671 0040 80BD     		pop	{r7, pc}
 672              	.L40:
 673 0042 C046     		.align	2
 674              	.L39:
 675 0044 00000000 		.word	_ZZ19MMA0_MeasureGetRawXvE4addr
 676              		.cfi_endproc
 677              	.LFE14:
 679              		.section	.text._Z19MMA0_MeasureGetRawYv,"ax",%progbits
 680              		.align	2
 681              		.global	_Z19MMA0_MeasureGetRawYv
 682              		.code	16
 683              		.thumb_func
 685              	_Z19MMA0_MeasureGetRawYv:
 686              	.LFB15:
 345:../Generated_Code/MMA0.c **** 
 346:../Generated_Code/MMA0.c **** /*
 347:../Generated_Code/MMA0.c **** ** ===================================================================
 348:../Generated_Code/MMA0.c **** **     Method      :  MMA0_MeasureGetRawY (component MMA8451Q)
 349:../Generated_Code/MMA0.c **** **     Description :
 350:../Generated_Code/MMA0.c **** **         Performs a measurement on Y channel and returns the raw
 351:../Generated_Code/MMA0.c **** **         value.
 352:../Generated_Code/MMA0.c **** **     Parameters  : None
 353:../Generated_Code/MMA0.c **** **     Returns     :
 354:../Generated_Code/MMA0.c **** **         ---             - Y sensor value
 355:../Generated_Code/MMA0.c **** ** ===================================================================
 356:../Generated_Code/MMA0.c **** */
 357:../Generated_Code/MMA0.c **** word MMA0_MeasureGetRawY(void)
 358:../Generated_Code/MMA0.c **** {
 687              		.loc 1 358 0
 688              		.cfi_startproc
 689 0000 80B5     		push	{r7, lr}
 690              	.LCFI28:
 691              		.cfi_def_cfa_offset 8
 692              		.cfi_offset 7, -8
 693              		.cfi_offset 14, -4
 694 0002 84B0     		sub	sp, sp, #16
 695              	.LCFI29:
 696              		.cfi_def_cfa_offset 24
 697 0004 02AF     		add	r7, sp, #8
 698              	.LCFI30:
 699              		.cfi_def_cfa 7, 16
 700              	.LBB10:
 359:../Generated_Code/MMA0.c ****   union {
 360:../Generated_Code/MMA0.c ****     uint8_t buf[2]; /* value from device is in big endian */
 361:../Generated_Code/MMA0.c ****     uint16_t be;
 362:../Generated_Code/MMA0.c ****   } val;
 363:../Generated_Code/MMA0.c ****   static const uint8_t addr = MMA0_OUT_Y_MSB;
 364:../Generated_Code/MMA0.c **** 
 365:../Generated_Code/MMA0.c ****   if(GI2C0_ReadAddress(MMA0_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!
 701              		.loc 1 365 0
 702 0006 0F4A     		ldr	r2, .L45
 703 0008 3B1D     		add	r3, r7, #4
 704 000a 0221     		mov	r1, #2
 705 000c 0091     		str	r1, [sp]
 706 000e 1D20     		mov	r0, #29
 707 0010 111C     		mov	r1, r2
 708 0012 0122     		mov	r2, #1
 709 0014 FFF7FEFF 		bl	_Z17GI2C0_ReadAddresshPhhS_t
 710 0018 031C     		mov	r3, r0
 711 001a 5A1E     		sub	r2, r3, #1
 712 001c 9341     		sbc	r3, r3, r2
 713 001e DBB2     		uxtb	r3, r3
 714 0020 002B     		cmp	r3, #0
 715 0022 01D0     		beq	.L42
 366:../Generated_Code/MMA0.c ****     return 0; /* failure */
 716              		.loc 1 366 0
 717 0024 0023     		mov	r3, #0
 718 0026 08E0     		b	.L44
 719              	.L42:
 367:../Generated_Code/MMA0.c ****   }
 368:../Generated_Code/MMA0.c **** #if MMA0_CPU_IS_LITTLE_ENDIAN
 369:../Generated_Code/MMA0.c ****   return (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
 720              		.loc 1 369 0
 721 0028 3B1D     		add	r3, r7, #4
 722 002a 1B78     		ldrb	r3, [r3]
 723 002c 1B02     		lsl	r3, r3, #8
 724 002e 9AB2     		uxth	r2, r3
 725 0030 3B1D     		add	r3, r7, #4
 726 0032 5B78     		ldrb	r3, [r3, #1]
 727 0034 1343     		orr	r3, r2
 728 0036 9BB2     		uxth	r3, r3
 729 0038 9BB2     		uxth	r3, r3
 730              	.L44:
 731              	.LBE10:
 370:../Generated_Code/MMA0.c **** #else
 371:../Generated_Code/MMA0.c ****   return val.be; /* already in BE */
 372:../Generated_Code/MMA0.c **** #endif
 373:../Generated_Code/MMA0.c **** }
 732              		.loc 1 373 0
 733 003a 181C     		mov	r0, r3
 734 003c BD46     		mov	sp, r7
 735 003e 02B0     		add	sp, sp, #8
 736              		@ sp needed for prologue
 737 0040 80BD     		pop	{r7, pc}
 738              	.L46:
 739 0042 C046     		.align	2
 740              	.L45:
 741 0044 00000000 		.word	_ZZ19MMA0_MeasureGetRawYvE4addr
 742              		.cfi_endproc
 743              	.LFE15:
 745              		.section	.text._Z19MMA0_MeasureGetRawZv,"ax",%progbits
 746              		.align	2
 747              		.global	_Z19MMA0_MeasureGetRawZv
 748              		.code	16
 749              		.thumb_func
 751              	_Z19MMA0_MeasureGetRawZv:
 752              	.LFB16:
 374:../Generated_Code/MMA0.c **** 
 375:../Generated_Code/MMA0.c **** /*
 376:../Generated_Code/MMA0.c **** ** ===================================================================
 377:../Generated_Code/MMA0.c **** **     Method      :  MMA0_MeasureGetRawZ (component MMA8451Q)
 378:../Generated_Code/MMA0.c **** **     Description :
 379:../Generated_Code/MMA0.c **** **         Performs a measurement on Z channel and returns the raw
 380:../Generated_Code/MMA0.c **** **         value.
 381:../Generated_Code/MMA0.c **** **     Parameters  : None
 382:../Generated_Code/MMA0.c **** **     Returns     :
 383:../Generated_Code/MMA0.c **** **         ---             - Z sensor value
 384:../Generated_Code/MMA0.c **** ** ===================================================================
 385:../Generated_Code/MMA0.c **** */
 386:../Generated_Code/MMA0.c **** word MMA0_MeasureGetRawZ(void)
 387:../Generated_Code/MMA0.c **** {
 753              		.loc 1 387 0
 754              		.cfi_startproc
 755 0000 80B5     		push	{r7, lr}
 756              	.LCFI31:
 757              		.cfi_def_cfa_offset 8
 758              		.cfi_offset 7, -8
 759              		.cfi_offset 14, -4
 760 0002 84B0     		sub	sp, sp, #16
 761              	.LCFI32:
 762              		.cfi_def_cfa_offset 24
 763 0004 02AF     		add	r7, sp, #8
 764              	.LCFI33:
 765              		.cfi_def_cfa 7, 16
 766              	.LBB11:
 388:../Generated_Code/MMA0.c ****   union {
 389:../Generated_Code/MMA0.c ****     uint8_t buf[2]; /* value from device is in big endian */
 390:../Generated_Code/MMA0.c ****     uint16_t be;
 391:../Generated_Code/MMA0.c ****   } val;
 392:../Generated_Code/MMA0.c ****   static const uint8_t addr = MMA0_OUT_Z_MSB;
 393:../Generated_Code/MMA0.c **** 
 394:../Generated_Code/MMA0.c ****   if(GI2C0_ReadAddress(MMA0_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!
 767              		.loc 1 394 0
 768 0006 0F4A     		ldr	r2, .L51
 769 0008 3B1D     		add	r3, r7, #4
 770 000a 0221     		mov	r1, #2
 771 000c 0091     		str	r1, [sp]
 772 000e 1D20     		mov	r0, #29
 773 0010 111C     		mov	r1, r2
 774 0012 0122     		mov	r2, #1
 775 0014 FFF7FEFF 		bl	_Z17GI2C0_ReadAddresshPhhS_t
 776 0018 031C     		mov	r3, r0
 777 001a 5A1E     		sub	r2, r3, #1
 778 001c 9341     		sbc	r3, r3, r2
 779 001e DBB2     		uxtb	r3, r3
 780 0020 002B     		cmp	r3, #0
 781 0022 01D0     		beq	.L48
 395:../Generated_Code/MMA0.c ****     return 0; /* failure */
 782              		.loc 1 395 0
 783 0024 0023     		mov	r3, #0
 784 0026 08E0     		b	.L50
 785              	.L48:
 396:../Generated_Code/MMA0.c ****   }
 397:../Generated_Code/MMA0.c **** #if MMA0_CPU_IS_LITTLE_ENDIAN
 398:../Generated_Code/MMA0.c ****   return (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
 786              		.loc 1 398 0
 787 0028 3B1D     		add	r3, r7, #4
 788 002a 1B78     		ldrb	r3, [r3]
 789 002c 1B02     		lsl	r3, r3, #8
 790 002e 9AB2     		uxth	r2, r3
 791 0030 3B1D     		add	r3, r7, #4
 792 0032 5B78     		ldrb	r3, [r3, #1]
 793 0034 1343     		orr	r3, r2
 794 0036 9BB2     		uxth	r3, r3
 795 0038 9BB2     		uxth	r3, r3
 796              	.L50:
 797              	.LBE11:
 399:../Generated_Code/MMA0.c **** #else
 400:../Generated_Code/MMA0.c ****   return val.be; /* already in BE */
 401:../Generated_Code/MMA0.c **** #endif
 402:../Generated_Code/MMA0.c **** }
 798              		.loc 1 402 0
 799 003a 181C     		mov	r0, r3
 800 003c BD46     		mov	sp, r7
 801 003e 02B0     		add	sp, sp, #8
 802              		@ sp needed for prologue
 803 0040 80BD     		pop	{r7, pc}
 804              	.L52:
 805 0042 C046     		.align	2
 806              	.L51:
 807 0044 00000000 		.word	_ZZ19MMA0_MeasureGetRawZvE4addr
 808              		.cfi_endproc
 809              	.LFE16:
 811              		.section	.text._Z15MMA0_GetXOffsetv,"ax",%progbits
 812              		.align	2
 813              		.global	_Z15MMA0_GetXOffsetv
 814              		.code	16
 815              		.thumb_func
 817              	_Z15MMA0_GetXOffsetv:
 818              	.LFB17:
 403:../Generated_Code/MMA0.c **** 
 404:../Generated_Code/MMA0.c **** /*
 405:../Generated_Code/MMA0.c **** ** ===================================================================
 406:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetXOffset (component MMA8451Q)
 407:../Generated_Code/MMA0.c **** **     Description :
 408:../Generated_Code/MMA0.c **** **         Returns the offset applied to the X value.
 409:../Generated_Code/MMA0.c **** **     Parameters  : None
 410:../Generated_Code/MMA0.c **** **     Returns     :
 411:../Generated_Code/MMA0.c **** **         ---             - Error code
 412:../Generated_Code/MMA0.c **** ** ===================================================================
 413:../Generated_Code/MMA0.c **** */
 414:../Generated_Code/MMA0.c **** int16_t MMA0_GetXOffset(void)
 415:../Generated_Code/MMA0.c **** {
 819              		.loc 1 415 0
 820              		.cfi_startproc
 821 0000 80B5     		push	{r7, lr}
 822              	.LCFI34:
 823              		.cfi_def_cfa_offset 8
 824              		.cfi_offset 7, -8
 825              		.cfi_offset 14, -4
 826 0002 00AF     		add	r7, sp, #0
 827              	.LCFI35:
 828              		.cfi_def_cfa_register 7
 416:../Generated_Code/MMA0.c ****   return CalNxOff;
 829              		.loc 1 416 0
 830 0004 024B     		ldr	r3, .L55
 831 0006 1B88     		ldrh	r3, [r3]
 832 0008 1BB2     		sxth	r3, r3
 417:../Generated_Code/MMA0.c **** }
 833              		.loc 1 417 0
 834 000a 181C     		mov	r0, r3
 835 000c BD46     		mov	sp, r7
 836              		@ sp needed for prologue
 837 000e 80BD     		pop	{r7, pc}
 838              	.L56:
 839              		.align	2
 840              	.L55:
 841 0010 00000000 		.word	_ZL10sCalValues
 842              		.cfi_endproc
 843              	.LFE17:
 845              		.section	.text._Z15MMA0_GetYOffsetv,"ax",%progbits
 846              		.align	2
 847              		.global	_Z15MMA0_GetYOffsetv
 848              		.code	16
 849              		.thumb_func
 851              	_Z15MMA0_GetYOffsetv:
 852              	.LFB18:
 418:../Generated_Code/MMA0.c **** 
 419:../Generated_Code/MMA0.c **** /*
 420:../Generated_Code/MMA0.c **** ** ===================================================================
 421:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetYOffset (component MMA8451Q)
 422:../Generated_Code/MMA0.c **** **     Description :
 423:../Generated_Code/MMA0.c **** **         Returns the offset applied to the Y value.
 424:../Generated_Code/MMA0.c **** **     Parameters  : None
 425:../Generated_Code/MMA0.c **** **     Returns     :
 426:../Generated_Code/MMA0.c **** **         ---             - Error code
 427:../Generated_Code/MMA0.c **** ** ===================================================================
 428:../Generated_Code/MMA0.c **** */
 429:../Generated_Code/MMA0.c **** int16_t MMA0_GetYOffset(void)
 430:../Generated_Code/MMA0.c **** {
 853              		.loc 1 430 0
 854              		.cfi_startproc
 855 0000 80B5     		push	{r7, lr}
 856              	.LCFI36:
 857              		.cfi_def_cfa_offset 8
 858              		.cfi_offset 7, -8
 859              		.cfi_offset 14, -4
 860 0002 00AF     		add	r7, sp, #0
 861              	.LCFI37:
 862              		.cfi_def_cfa_register 7
 431:../Generated_Code/MMA0.c ****   return CalNyOff;
 863              		.loc 1 431 0
 864 0004 024B     		ldr	r3, .L59
 865 0006 5B88     		ldrh	r3, [r3, #2]
 866 0008 1BB2     		sxth	r3, r3
 432:../Generated_Code/MMA0.c **** }
 867              		.loc 1 432 0
 868 000a 181C     		mov	r0, r3
 869 000c BD46     		mov	sp, r7
 870              		@ sp needed for prologue
 871 000e 80BD     		pop	{r7, pc}
 872              	.L60:
 873              		.align	2
 874              	.L59:
 875 0010 00000000 		.word	_ZL10sCalValues
 876              		.cfi_endproc
 877              	.LFE18:
 879              		.section	.text._Z15MMA0_GetZOffsetv,"ax",%progbits
 880              		.align	2
 881              		.global	_Z15MMA0_GetZOffsetv
 882              		.code	16
 883              		.thumb_func
 885              	_Z15MMA0_GetZOffsetv:
 886              	.LFB19:
 433:../Generated_Code/MMA0.c **** 
 434:../Generated_Code/MMA0.c **** /*
 435:../Generated_Code/MMA0.c **** ** ===================================================================
 436:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetZOffset (component MMA8451Q)
 437:../Generated_Code/MMA0.c **** **     Description :
 438:../Generated_Code/MMA0.c **** **         Returns the offset applied to the Z value.
 439:../Generated_Code/MMA0.c **** **     Parameters  : None
 440:../Generated_Code/MMA0.c **** **     Returns     :
 441:../Generated_Code/MMA0.c **** **         ---             - Error code
 442:../Generated_Code/MMA0.c **** ** ===================================================================
 443:../Generated_Code/MMA0.c **** */
 444:../Generated_Code/MMA0.c **** int16_t MMA0_GetZOffset(void)
 445:../Generated_Code/MMA0.c **** {
 887              		.loc 1 445 0
 888              		.cfi_startproc
 889 0000 80B5     		push	{r7, lr}
 890              	.LCFI38:
 891              		.cfi_def_cfa_offset 8
 892              		.cfi_offset 7, -8
 893              		.cfi_offset 14, -4
 894 0002 00AF     		add	r7, sp, #0
 895              	.LCFI39:
 896              		.cfi_def_cfa_register 7
 446:../Generated_Code/MMA0.c ****   return CalNzOff;
 897              		.loc 1 446 0
 898 0004 024B     		ldr	r3, .L63
 899 0006 9B88     		ldrh	r3, [r3, #4]
 900 0008 1BB2     		sxth	r3, r3
 447:../Generated_Code/MMA0.c **** }
 901              		.loc 1 447 0
 902 000a 181C     		mov	r0, r3
 903 000c BD46     		mov	sp, r7
 904              		@ sp needed for prologue
 905 000e 80BD     		pop	{r7, pc}
 906              	.L64:
 907              		.align	2
 908              	.L63:
 909 0010 00000000 		.word	_ZL10sCalValues
 910              		.cfi_endproc
 911              	.LFE19:
 913              		.section	.text._Z16MMA0_GetX1gValuev,"ax",%progbits
 914              		.align	2
 915              		.global	_Z16MMA0_GetX1gValuev
 916              		.code	16
 917              		.thumb_func
 919              	_Z16MMA0_GetX1gValuev:
 920              	.LFB20:
 448:../Generated_Code/MMA0.c **** 
 449:../Generated_Code/MMA0.c **** /*
 450:../Generated_Code/MMA0.c **** ** ===================================================================
 451:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetX1gValue (component MMA8451Q)
 452:../Generated_Code/MMA0.c **** **     Description :
 453:../Generated_Code/MMA0.c **** **         Returns the value for 1g for channel  X.
 454:../Generated_Code/MMA0.c **** **     Parameters  : None
 455:../Generated_Code/MMA0.c **** **     Returns     :
 456:../Generated_Code/MMA0.c **** **         ---             - 1g value for X
 457:../Generated_Code/MMA0.c **** ** ===================================================================
 458:../Generated_Code/MMA0.c **** */
 459:../Generated_Code/MMA0.c **** int16_t MMA0_GetX1gValue(void)
 460:../Generated_Code/MMA0.c **** {
 921              		.loc 1 460 0
 922              		.cfi_startproc
 923 0000 80B5     		push	{r7, lr}
 924              	.LCFI40:
 925              		.cfi_def_cfa_offset 8
 926              		.cfi_offset 7, -8
 927              		.cfi_offset 14, -4
 928 0002 00AF     		add	r7, sp, #0
 929              	.LCFI41:
 930              		.cfi_def_cfa_register 7
 461:../Generated_Code/MMA0.c ****   return 4096;
 931              		.loc 1 461 0
 932 0004 8023     		mov	r3, #128
 933 0006 5B01     		lsl	r3, r3, #5
 934 0008 1BB2     		sxth	r3, r3
 462:../Generated_Code/MMA0.c **** }
 935              		.loc 1 462 0
 936 000a 181C     		mov	r0, r3
 937 000c BD46     		mov	sp, r7
 938              		@ sp needed for prologue
 939 000e 80BD     		pop	{r7, pc}
 940              		.cfi_endproc
 941              	.LFE20:
 943              		.section	.text._Z16MMA0_GetY1gValuev,"ax",%progbits
 944              		.align	2
 945              		.global	_Z16MMA0_GetY1gValuev
 946              		.code	16
 947              		.thumb_func
 949              	_Z16MMA0_GetY1gValuev:
 950              	.LFB21:
 463:../Generated_Code/MMA0.c **** 
 464:../Generated_Code/MMA0.c **** /*
 465:../Generated_Code/MMA0.c **** ** ===================================================================
 466:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetY1gValue (component MMA8451Q)
 467:../Generated_Code/MMA0.c **** **     Description :
 468:../Generated_Code/MMA0.c **** **         Returns the value for 1g for channel  Y.
 469:../Generated_Code/MMA0.c **** **     Parameters  : None
 470:../Generated_Code/MMA0.c **** **     Returns     :
 471:../Generated_Code/MMA0.c **** **         ---             - 1g value for Y
 472:../Generated_Code/MMA0.c **** ** ===================================================================
 473:../Generated_Code/MMA0.c **** */
 474:../Generated_Code/MMA0.c **** int16_t MMA0_GetY1gValue(void)
 475:../Generated_Code/MMA0.c **** {
 951              		.loc 1 475 0
 952              		.cfi_startproc
 953 0000 80B5     		push	{r7, lr}
 954              	.LCFI42:
 955              		.cfi_def_cfa_offset 8
 956              		.cfi_offset 7, -8
 957              		.cfi_offset 14, -4
 958 0002 00AF     		add	r7, sp, #0
 959              	.LCFI43:
 960              		.cfi_def_cfa_register 7
 476:../Generated_Code/MMA0.c ****   return 4096;
 961              		.loc 1 476 0
 962 0004 8023     		mov	r3, #128
 963 0006 5B01     		lsl	r3, r3, #5
 964 0008 1BB2     		sxth	r3, r3
 477:../Generated_Code/MMA0.c **** }
 965              		.loc 1 477 0
 966 000a 181C     		mov	r0, r3
 967 000c BD46     		mov	sp, r7
 968              		@ sp needed for prologue
 969 000e 80BD     		pop	{r7, pc}
 970              		.cfi_endproc
 971              	.LFE21:
 973              		.section	.text._Z16MMA0_GetZ1gValuev,"ax",%progbits
 974              		.align	2
 975              		.global	_Z16MMA0_GetZ1gValuev
 976              		.code	16
 977              		.thumb_func
 979              	_Z16MMA0_GetZ1gValuev:
 980              	.LFB22:
 478:../Generated_Code/MMA0.c **** 
 479:../Generated_Code/MMA0.c **** /*
 480:../Generated_Code/MMA0.c **** ** ===================================================================
 481:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetZ1gValue (component MMA8451Q)
 482:../Generated_Code/MMA0.c **** **     Description :
 483:../Generated_Code/MMA0.c **** **         Returns the value for 1g for channel  Z.
 484:../Generated_Code/MMA0.c **** **     Parameters  : None
 485:../Generated_Code/MMA0.c **** **     Returns     :
 486:../Generated_Code/MMA0.c **** **         ---             - 1g value for Z
 487:../Generated_Code/MMA0.c **** ** ===================================================================
 488:../Generated_Code/MMA0.c **** */
 489:../Generated_Code/MMA0.c **** int16_t MMA0_GetZ1gValue(void)
 490:../Generated_Code/MMA0.c **** {
 981              		.loc 1 490 0
 982              		.cfi_startproc
 983 0000 80B5     		push	{r7, lr}
 984              	.LCFI44:
 985              		.cfi_def_cfa_offset 8
 986              		.cfi_offset 7, -8
 987              		.cfi_offset 14, -4
 988 0002 00AF     		add	r7, sp, #0
 989              	.LCFI45:
 990              		.cfi_def_cfa_register 7
 491:../Generated_Code/MMA0.c ****   return 4096;
 991              		.loc 1 491 0
 992 0004 8023     		mov	r3, #128
 993 0006 5B01     		lsl	r3, r3, #5
 994 0008 1BB2     		sxth	r3, r3
 492:../Generated_Code/MMA0.c **** }
 995              		.loc 1 492 0
 996 000a 181C     		mov	r0, r3
 997 000c BD46     		mov	sp, r7
 998              		@ sp needed for prologue
 999 000e 80BD     		pop	{r7, pc}
 1000              		.cfi_endproc
 1001              	.LFE22:
 1003              		.section	.text._Z9MMA0_GetXv,"ax",%progbits
 1004              		.align	2
 1005              		.global	_Z9MMA0_GetXv
 1006              		.code	16
 1007              		.thumb_func
 1009              	_Z9MMA0_GetXv:
 1010              	.LFB23:
 493:../Generated_Code/MMA0.c **** 
 494:../Generated_Code/MMA0.c **** /*
 495:../Generated_Code/MMA0.c **** ** ===================================================================
 496:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetX (component MMA8451Q)
 497:../Generated_Code/MMA0.c **** **     Description :
 498:../Generated_Code/MMA0.c **** **         Retrieves the value for the X axis. The value is adjusted
 499:../Generated_Code/MMA0.c **** **         with the zero calibration value (0 for 0 g, negative for
 500:../Generated_Code/MMA0.c **** **         negative acceleration and positive for positive acceleration).
 501:../Generated_Code/MMA0.c **** **     Parameters  : None
 502:../Generated_Code/MMA0.c **** **     Returns     :
 503:../Generated_Code/MMA0.c **** **         ---             - Measured X value
 504:../Generated_Code/MMA0.c **** ** ===================================================================
 505:../Generated_Code/MMA0.c **** */
 506:../Generated_Code/MMA0.c **** int16_t MMA0_GetX(void)
 507:../Generated_Code/MMA0.c **** {
 1011              		.loc 1 507 0
 1012              		.cfi_startproc
 1013 0000 80B5     		push	{r7, lr}
 1014              	.LCFI46:
 1015              		.cfi_def_cfa_offset 8
 1016              		.cfi_offset 7, -8
 1017              		.cfi_offset 14, -4
 1018 0002 82B0     		sub	sp, sp, #8
 1019              	.LCFI47:
 1020              		.cfi_def_cfa_offset 16
 1021 0004 00AF     		add	r7, sp, #0
 1022              	.LCFI48:
 1023              		.cfi_def_cfa_register 7
 1024              	.LBB12:
 508:../Generated_Code/MMA0.c ****   int16_t value;
 509:../Generated_Code/MMA0.c **** 
 510:../Generated_Code/MMA0.c ****   value = (int16_t)MMA0_MeasureGetRawX();
 1025              		.loc 1 510 0
 1026 0006 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawXv
 1027 000a 031C     		mov	r3, r0
 1028 000c 1A1C     		mov	r2, r3
 1029 000e BB1D     		add	r3, r7, #6
 1030 0010 1A80     		strh	r2, [r3]
 511:../Generated_Code/MMA0.c ****   value += CalNxOff; /* adjust with calibration offset */
 1031              		.loc 1 511 0
 1032 0012 084B     		ldr	r3, .L73
 1033 0014 1B88     		ldrh	r3, [r3]
 1034 0016 9AB2     		uxth	r2, r3
 1035 0018 BB1D     		add	r3, r7, #6
 1036 001a 1B88     		ldrh	r3, [r3]
 1037 001c D318     		add	r3, r2, r3
 1038 001e 9AB2     		uxth	r2, r3
 1039 0020 BB1D     		add	r3, r7, #6
 1040 0022 1A80     		strh	r2, [r3]
 512:../Generated_Code/MMA0.c ****   return value;
 1041              		.loc 1 512 0
 1042 0024 BB1D     		add	r3, r7, #6
 1043 0026 1B88     		ldrh	r3, [r3]
 1044 0028 1BB2     		sxth	r3, r3
 1045              	.LBE12:
 513:../Generated_Code/MMA0.c **** }
 1046              		.loc 1 513 0
 1047 002a 181C     		mov	r0, r3
 1048 002c BD46     		mov	sp, r7
 1049 002e 02B0     		add	sp, sp, #8
 1050              		@ sp needed for prologue
 1051 0030 80BD     		pop	{r7, pc}
 1052              	.L74:
 1053 0032 C046     		.align	2
 1054              	.L73:
 1055 0034 00000000 		.word	_ZL10sCalValues
 1056              		.cfi_endproc
 1057              	.LFE23:
 1059              		.section	.text._Z9MMA0_GetYv,"ax",%progbits
 1060              		.align	2
 1061              		.global	_Z9MMA0_GetYv
 1062              		.code	16
 1063              		.thumb_func
 1065              	_Z9MMA0_GetYv:
 1066              	.LFB24:
 514:../Generated_Code/MMA0.c **** 
 515:../Generated_Code/MMA0.c **** /*
 516:../Generated_Code/MMA0.c **** ** ===================================================================
 517:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetY (component MMA8451Q)
 518:../Generated_Code/MMA0.c **** **     Description :
 519:../Generated_Code/MMA0.c **** **         Retrieves the value for the Y axis. The value is adjusted
 520:../Generated_Code/MMA0.c **** **         with the zero calibration value (0 for 0 g, negative for
 521:../Generated_Code/MMA0.c **** **         negative acceleration and positive for positive acceleration).
 522:../Generated_Code/MMA0.c **** **     Parameters  : None
 523:../Generated_Code/MMA0.c **** **     Returns     :
 524:../Generated_Code/MMA0.c **** **         ---             - Measured Y value
 525:../Generated_Code/MMA0.c **** ** ===================================================================
 526:../Generated_Code/MMA0.c **** */
 527:../Generated_Code/MMA0.c **** int16_t MMA0_GetY(void)
 528:../Generated_Code/MMA0.c **** {
 1067              		.loc 1 528 0
 1068              		.cfi_startproc
 1069 0000 80B5     		push	{r7, lr}
 1070              	.LCFI49:
 1071              		.cfi_def_cfa_offset 8
 1072              		.cfi_offset 7, -8
 1073              		.cfi_offset 14, -4
 1074 0002 82B0     		sub	sp, sp, #8
 1075              	.LCFI50:
 1076              		.cfi_def_cfa_offset 16
 1077 0004 00AF     		add	r7, sp, #0
 1078              	.LCFI51:
 1079              		.cfi_def_cfa_register 7
 1080              	.LBB13:
 529:../Generated_Code/MMA0.c ****   int16_t value;
 530:../Generated_Code/MMA0.c **** 
 531:../Generated_Code/MMA0.c ****   value = (int16_t)MMA0_MeasureGetRawY();
 1081              		.loc 1 531 0
 1082 0006 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawYv
 1083 000a 031C     		mov	r3, r0
 1084 000c 1A1C     		mov	r2, r3
 1085 000e BB1D     		add	r3, r7, #6
 1086 0010 1A80     		strh	r2, [r3]
 532:../Generated_Code/MMA0.c ****   value += CalNyOff; /* adjust with calibration offset */
 1087              		.loc 1 532 0
 1088 0012 084B     		ldr	r3, .L77
 1089 0014 5B88     		ldrh	r3, [r3, #2]
 1090 0016 9AB2     		uxth	r2, r3
 1091 0018 BB1D     		add	r3, r7, #6
 1092 001a 1B88     		ldrh	r3, [r3]
 1093 001c D318     		add	r3, r2, r3
 1094 001e 9AB2     		uxth	r2, r3
 1095 0020 BB1D     		add	r3, r7, #6
 1096 0022 1A80     		strh	r2, [r3]
 533:../Generated_Code/MMA0.c ****   return value;
 1097              		.loc 1 533 0
 1098 0024 BB1D     		add	r3, r7, #6
 1099 0026 1B88     		ldrh	r3, [r3]
 1100 0028 1BB2     		sxth	r3, r3
 1101              	.LBE13:
 534:../Generated_Code/MMA0.c **** }
 1102              		.loc 1 534 0
 1103 002a 181C     		mov	r0, r3
 1104 002c BD46     		mov	sp, r7
 1105 002e 02B0     		add	sp, sp, #8
 1106              		@ sp needed for prologue
 1107 0030 80BD     		pop	{r7, pc}
 1108              	.L78:
 1109 0032 C046     		.align	2
 1110              	.L77:
 1111 0034 00000000 		.word	_ZL10sCalValues
 1112              		.cfi_endproc
 1113              	.LFE24:
 1115              		.section	.text._Z9MMA0_GetZv,"ax",%progbits
 1116              		.align	2
 1117              		.global	_Z9MMA0_GetZv
 1118              		.code	16
 1119              		.thumb_func
 1121              	_Z9MMA0_GetZv:
 1122              	.LFB25:
 535:../Generated_Code/MMA0.c **** 
 536:../Generated_Code/MMA0.c **** /*
 537:../Generated_Code/MMA0.c **** ** ===================================================================
 538:../Generated_Code/MMA0.c **** **     Method      :  MMA0_GetZ (component MMA8451Q)
 539:../Generated_Code/MMA0.c **** **     Description :
 540:../Generated_Code/MMA0.c **** **         Retrieves the value for the Z axis. The value is adjusted
 541:../Generated_Code/MMA0.c **** **         with the zero calibration value (0 for 0 g, negative for
 542:../Generated_Code/MMA0.c **** **         negative acceleration and positive for positive acceleration).
 543:../Generated_Code/MMA0.c **** **     Parameters  : None
 544:../Generated_Code/MMA0.c **** **     Returns     :
 545:../Generated_Code/MMA0.c **** **         ---             - Measured Z value
 546:../Generated_Code/MMA0.c **** ** ===================================================================
 547:../Generated_Code/MMA0.c **** */
 548:../Generated_Code/MMA0.c **** int16_t MMA0_GetZ(void)
 549:../Generated_Code/MMA0.c **** {
 1123              		.loc 1 549 0
 1124              		.cfi_startproc
 1125 0000 80B5     		push	{r7, lr}
 1126              	.LCFI52:
 1127              		.cfi_def_cfa_offset 8
 1128              		.cfi_offset 7, -8
 1129              		.cfi_offset 14, -4
 1130 0002 82B0     		sub	sp, sp, #8
 1131              	.LCFI53:
 1132              		.cfi_def_cfa_offset 16
 1133 0004 00AF     		add	r7, sp, #0
 1134              	.LCFI54:
 1135              		.cfi_def_cfa_register 7
 1136              	.LBB14:
 550:../Generated_Code/MMA0.c ****   int16_t value;
 551:../Generated_Code/MMA0.c **** 
 552:../Generated_Code/MMA0.c ****   value = (int16_t)MMA0_MeasureGetRawZ();
 1137              		.loc 1 552 0
 1138 0006 FFF7FEFF 		bl	_Z19MMA0_MeasureGetRawZv
 1139 000a 031C     		mov	r3, r0
 1140 000c 1A1C     		mov	r2, r3
 1141 000e BB1D     		add	r3, r7, #6
 1142 0010 1A80     		strh	r2, [r3]
 553:../Generated_Code/MMA0.c ****   value += CalNzOff; /* adjust with calibration offset */
 1143              		.loc 1 553 0
 1144 0012 084B     		ldr	r3, .L81
 1145 0014 9B88     		ldrh	r3, [r3, #4]
 1146 0016 9AB2     		uxth	r2, r3
 1147 0018 BB1D     		add	r3, r7, #6
 1148 001a 1B88     		ldrh	r3, [r3]
 1149 001c D318     		add	r3, r2, r3
 1150 001e 9AB2     		uxth	r2, r3
 1151 0020 BB1D     		add	r3, r7, #6
 1152 0022 1A80     		strh	r2, [r3]
 554:../Generated_Code/MMA0.c ****   return value;
 1153              		.loc 1 554 0
 1154 0024 BB1D     		add	r3, r7, #6
 1155 0026 1B88     		ldrh	r3, [r3]
 1156 0028 1BB2     		sxth	r3, r3
 1157              	.LBE14:
 555:../Generated_Code/MMA0.c **** }
 1158              		.loc 1 555 0
 1159 002a 181C     		mov	r0, r3
 1160 002c BD46     		mov	sp, r7
 1161 002e 02B0     		add	sp, sp, #8
 1162              		@ sp needed for prologue
 1163 0030 80BD     		pop	{r7, pc}
 1164              	.L82:
 1165 0032 C046     		.align	2
 1166              	.L81:
 1167 0034 00000000 		.word	_ZL10sCalValues
 1168              		.cfi_endproc
 1169              	.LFE25:
 1171              		.section	.text._Z16MMA0_SetFastModeb,"ax",%progbits
 1172              		.align	2
 1173              		.global	_Z16MMA0_SetFastModeb
 1174              		.code	16
 1175              		.thumb_func
 1177              	_Z16MMA0_SetFastModeb:
 1178              	.LFB26:
 556:../Generated_Code/MMA0.c **** 
 557:../Generated_Code/MMA0.c **** /*
 558:../Generated_Code/MMA0.c **** ** ===================================================================
 559:../Generated_Code/MMA0.c **** **     Method      :  MMA0_SetFastMode (component MMA8451Q)
 560:../Generated_Code/MMA0.c **** **     Description :
 561:../Generated_Code/MMA0.c **** **         Turns the F_READ (Fast Read Mode) on or off
 562:../Generated_Code/MMA0.c **** **     Parameters  :
 563:../Generated_Code/MMA0.c **** **         NAME            - DESCRIPTION
 564:../Generated_Code/MMA0.c **** **         on              - if to turn the F_READ mode on or off
 565:../Generated_Code/MMA0.c **** **     Returns     :
 566:../Generated_Code/MMA0.c **** **         ---             - Error code
 567:../Generated_Code/MMA0.c **** ** ===================================================================
 568:../Generated_Code/MMA0.c **** */
 569:../Generated_Code/MMA0.c **** byte MMA0_SetFastMode(bool on)
 570:../Generated_Code/MMA0.c **** {
 1179              		.loc 1 570 0
 1180              		.cfi_startproc
 1181 0000 90B5     		push	{r4, r7, lr}
 1182              	.LCFI55:
 1183              		.cfi_def_cfa_offset 12
 1184              		.cfi_offset 4, -12
 1185              		.cfi_offset 7, -8
 1186              		.cfi_offset 14, -4
 1187 0002 85B0     		sub	sp, sp, #20
 1188              	.LCFI56:
 1189              		.cfi_def_cfa_offset 32
 1190 0004 00AF     		add	r7, sp, #0
 1191              	.LCFI57:
 1192              		.cfi_def_cfa_register 7
 1193 0006 021C     		mov	r2, r0
 1194 0008 FB1D     		add	r3, r7, #7
 1195 000a 1A70     		strb	r2, [r3]
 1196              	.LBB15:
 571:../Generated_Code/MMA0.c ****   uint8_t val, res;
 572:../Generated_Code/MMA0.c **** 
 573:../Generated_Code/MMA0.c ****   res = GI2C0_ReadByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, &val);
 1197              		.loc 1 573 0
 1198 000c 3C1C     		mov	r4, r7
 1199 000e 0F34     		add	r4, r4, #15
 1200 0010 3B1C     		mov	r3, r7
 1201 0012 0E33     		add	r3, r3, #14
 1202 0014 1D20     		mov	r0, #29
 1203 0016 2A21     		mov	r1, #42
 1204 0018 1A1C     		mov	r2, r3
 1205 001a FFF7FEFF 		bl	_Z22GI2C0_ReadByteAddress8hhPh
 1206 001e 031C     		mov	r3, r0
 1207 0020 2370     		strb	r3, [r4]
 574:../Generated_Code/MMA0.c ****   if (res!=ERR_OK) {
 1208              		.loc 1 574 0
 1209 0022 3B1C     		mov	r3, r7
 1210 0024 0F33     		add	r3, r3, #15
 1211 0026 1B78     		ldrb	r3, [r3]
 1212 0028 002B     		cmp	r3, #0
 1213 002a 03D0     		beq	.L84
 575:../Generated_Code/MMA0.c ****     return res;
 1214              		.loc 1 575 0
 1215 002c 3B1C     		mov	r3, r7
 1216 002e 0F33     		add	r3, r3, #15
 1217 0030 1B78     		ldrb	r3, [r3]
 1218 0032 1FE0     		b	.L88
 1219              	.L84:
 576:../Generated_Code/MMA0.c ****   }
 577:../Generated_Code/MMA0.c ****   if (on) {
 1220              		.loc 1 577 0
 1221 0034 FB1D     		add	r3, r7, #7
 1222 0036 1B78     		ldrb	r3, [r3]
 1223 0038 002B     		cmp	r3, #0
 1224 003a 09D0     		beq	.L86
 578:../Generated_Code/MMA0.c ****     val |= MMA0_F_READ_BIT_MASK; /* enable F_READ: Fast read mode, data format limited to single by
 1225              		.loc 1 578 0
 1226 003c 3B1C     		mov	r3, r7
 1227 003e 0E33     		add	r3, r3, #14
 1228 0040 1B78     		ldrb	r3, [r3]
 1229 0042 0222     		mov	r2, #2
 1230 0044 1343     		orr	r3, r2
 1231 0046 DAB2     		uxtb	r2, r3
 1232 0048 3B1C     		mov	r3, r7
 1233 004a 0E33     		add	r3, r3, #14
 1234 004c 1A70     		strb	r2, [r3]
 1235 004e 08E0     		b	.L87
 1236              	.L86:
 579:../Generated_Code/MMA0.c ****   } else {
 580:../Generated_Code/MMA0.c ****     val &= ~MMA0_F_READ_BIT_MASK; /* disable F_READ: Fast read mode, data format limited to single 
 1237              		.loc 1 580 0
 1238 0050 3B1C     		mov	r3, r7
 1239 0052 0E33     		add	r3, r3, #14
 1240 0054 1B78     		ldrb	r3, [r3]
 1241 0056 0222     		mov	r2, #2
 1242 0058 9343     		bic	r3, r2
 1243 005a DAB2     		uxtb	r2, r3
 1244 005c 3B1C     		mov	r3, r7
 1245 005e 0E33     		add	r3, r3, #14
 1246 0060 1A70     		strb	r2, [r3]
 1247              	.L87:
 581:../Generated_Code/MMA0.c ****   }
 582:../Generated_Code/MMA0.c ****   return GI2C0_WriteByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, val);
 1248              		.loc 1 582 0
 1249 0062 3B1C     		mov	r3, r7
 1250 0064 0E33     		add	r3, r3, #14
 1251 0066 1B78     		ldrb	r3, [r3]
 1252 0068 1D20     		mov	r0, #29
 1253 006a 2A21     		mov	r1, #42
 1254 006c 1A1C     		mov	r2, r3
 1255 006e FFF7FEFF 		bl	_Z23GI2C0_WriteByteAddress8hhh
 1256 0072 031C     		mov	r3, r0
 1257              	.L88:
 1258              	.LBE15:
 583:../Generated_Code/MMA0.c **** }
 1259              		.loc 1 583 0
 1260 0074 181C     		mov	r0, r3
 1261 0076 BD46     		mov	sp, r7
 1262 0078 05B0     		add	sp, sp, #20
 1263              		@ sp needed for prologue
 1264 007a 90BD     		pop	{r4, r7, pc}
 1265              		.cfi_endproc
 1266              	.LFE26:
 1268              		.section	.text._Z11MMA0_Enablev,"ax",%progbits
 1269              		.align	2
 1270              		.global	_Z11MMA0_Enablev
 1271              		.code	16
 1272              		.thumb_func
 1274              	_Z11MMA0_Enablev:
 1275              	.LFB27:
 584:../Generated_Code/MMA0.c **** 
 585:../Generated_Code/MMA0.c **** /*
 586:../Generated_Code/MMA0.c **** ** ===================================================================
 587:../Generated_Code/MMA0.c **** **     Method      :  MMA0_Enable (component MMA8451Q)
 588:../Generated_Code/MMA0.c **** **     Description :
 589:../Generated_Code/MMA0.c **** **         Enables the device with setting the ACTIVE bit in the CTRL
 590:../Generated_Code/MMA0.c **** **         register 1
 591:../Generated_Code/MMA0.c **** **     Parameters  : None
 592:../Generated_Code/MMA0.c **** **     Returns     :
 593:../Generated_Code/MMA0.c **** **         ---             - Error code
 594:../Generated_Code/MMA0.c **** ** ===================================================================
 595:../Generated_Code/MMA0.c **** */
 596:../Generated_Code/MMA0.c **** byte MMA0_Enable(void)
 597:../Generated_Code/MMA0.c **** {
 1276              		.loc 1 597 0
 1277              		.cfi_startproc
 1278 0000 90B5     		push	{r4, r7, lr}
 1279              	.LCFI58:
 1280              		.cfi_def_cfa_offset 12
 1281              		.cfi_offset 4, -12
 1282              		.cfi_offset 7, -8
 1283              		.cfi_offset 14, -4
 1284 0002 83B0     		sub	sp, sp, #12
 1285              	.LCFI59:
 1286              		.cfi_def_cfa_offset 24
 1287 0004 00AF     		add	r7, sp, #0
 1288              	.LCFI60:
 1289              		.cfi_def_cfa_register 7
 1290              	.LBB16:
 598:../Generated_Code/MMA0.c ****   uint8_t val, res;
 599:../Generated_Code/MMA0.c **** 
 600:../Generated_Code/MMA0.c ****   res = GI2C0_ReadByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, &val);
 1291              		.loc 1 600 0
 1292 0006 FC1D     		add	r4, r7, #7
 1293 0008 BB1D     		add	r3, r7, #6
 1294 000a 1D20     		mov	r0, #29
 1295 000c 2A21     		mov	r1, #42
 1296 000e 1A1C     		mov	r2, r3
 1297 0010 FFF7FEFF 		bl	_Z22GI2C0_ReadByteAddress8hhPh
 1298 0014 031C     		mov	r3, r0
 1299 0016 2370     		strb	r3, [r4]
 601:../Generated_Code/MMA0.c ****   if (res!=ERR_OK) {
 1300              		.loc 1 601 0
 1301 0018 FB1D     		add	r3, r7, #7
 1302 001a 1B78     		ldrb	r3, [r3]
 1303 001c 002B     		cmp	r3, #0
 1304 001e 02D0     		beq	.L90
 602:../Generated_Code/MMA0.c ****     return res;
 1305              		.loc 1 602 0
 1306 0020 FB1D     		add	r3, r7, #7
 1307 0022 1B78     		ldrb	r3, [r3]
 1308 0024 0EE0     		b	.L92
 1309              	.L90:
 603:../Generated_Code/MMA0.c ****   }
 604:../Generated_Code/MMA0.c ****   val |= MMA0_ACTIVE_BIT_MASK; /* enable device */
 1310              		.loc 1 604 0
 1311 0026 BB1D     		add	r3, r7, #6
 1312 0028 1B78     		ldrb	r3, [r3]
 1313 002a 0122     		mov	r2, #1
 1314 002c 1343     		orr	r3, r2
 1315 002e DAB2     		uxtb	r2, r3
 1316 0030 BB1D     		add	r3, r7, #6
 1317 0032 1A70     		strb	r2, [r3]
 605:../Generated_Code/MMA0.c ****   return GI2C0_WriteByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, val);
 1318              		.loc 1 605 0
 1319 0034 BB1D     		add	r3, r7, #6
 1320 0036 1B78     		ldrb	r3, [r3]
 1321 0038 1D20     		mov	r0, #29
 1322 003a 2A21     		mov	r1, #42
 1323 003c 1A1C     		mov	r2, r3
 1324 003e FFF7FEFF 		bl	_Z23GI2C0_WriteByteAddress8hhh
 1325 0042 031C     		mov	r3, r0
 1326              	.L92:
 1327              	.LBE16:
 606:../Generated_Code/MMA0.c **** }
 1328              		.loc 1 606 0
 1329 0044 181C     		mov	r0, r3
 1330 0046 BD46     		mov	sp, r7
 1331 0048 03B0     		add	sp, sp, #12
 1332              		@ sp needed for prologue
 1333 004a 90BD     		pop	{r4, r7, pc}
 1334              		.cfi_endproc
 1335              	.LFE27:
 1337              		.section	.text._Z12MMA0_Disablev,"ax",%progbits
 1338              		.align	2
 1339              		.global	_Z12MMA0_Disablev
 1340              		.code	16
 1341              		.thumb_func
 1343              	_Z12MMA0_Disablev:
 1344              	.LFB28:
 607:../Generated_Code/MMA0.c **** 
 608:../Generated_Code/MMA0.c **** /*
 609:../Generated_Code/MMA0.c **** ** ===================================================================
 610:../Generated_Code/MMA0.c **** **     Method      :  MMA0_Disable (component MMA8451Q)
 611:../Generated_Code/MMA0.c **** **     Description :
 612:../Generated_Code/MMA0.c **** **         Disables the device with clearing the ACTIVE bit in the CTRL
 613:../Generated_Code/MMA0.c **** **         register 1
 614:../Generated_Code/MMA0.c **** **     Parameters  : None
 615:../Generated_Code/MMA0.c **** **     Returns     :
 616:../Generated_Code/MMA0.c **** **         ---             - Error code
 617:../Generated_Code/MMA0.c **** ** ===================================================================
 618:../Generated_Code/MMA0.c **** */
 619:../Generated_Code/MMA0.c **** byte MMA0_Disable(void)
 620:../Generated_Code/MMA0.c **** {
 1345              		.loc 1 620 0
 1346              		.cfi_startproc
 1347 0000 90B5     		push	{r4, r7, lr}
 1348              	.LCFI61:
 1349              		.cfi_def_cfa_offset 12
 1350              		.cfi_offset 4, -12
 1351              		.cfi_offset 7, -8
 1352              		.cfi_offset 14, -4
 1353 0002 83B0     		sub	sp, sp, #12
 1354              	.LCFI62:
 1355              		.cfi_def_cfa_offset 24
 1356 0004 00AF     		add	r7, sp, #0
 1357              	.LCFI63:
 1358              		.cfi_def_cfa_register 7
 1359              	.LBB17:
 621:../Generated_Code/MMA0.c ****   uint8_t val, res;
 622:../Generated_Code/MMA0.c **** 
 623:../Generated_Code/MMA0.c ****   res = GI2C0_ReadByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, &val);
 1360              		.loc 1 623 0
 1361 0006 FC1D     		add	r4, r7, #7
 1362 0008 BB1D     		add	r3, r7, #6
 1363 000a 1D20     		mov	r0, #29
 1364 000c 2A21     		mov	r1, #42
 1365 000e 1A1C     		mov	r2, r3
 1366 0010 FFF7FEFF 		bl	_Z22GI2C0_ReadByteAddress8hhPh
 1367 0014 031C     		mov	r3, r0
 1368 0016 2370     		strb	r3, [r4]
 624:../Generated_Code/MMA0.c ****   if (res!=ERR_OK) {
 1369              		.loc 1 624 0
 1370 0018 FB1D     		add	r3, r7, #7
 1371 001a 1B78     		ldrb	r3, [r3]
 1372 001c 002B     		cmp	r3, #0
 1373 001e 02D0     		beq	.L94
 625:../Generated_Code/MMA0.c ****     return res;
 1374              		.loc 1 625 0
 1375 0020 FB1D     		add	r3, r7, #7
 1376 0022 1B78     		ldrb	r3, [r3]
 1377 0024 0EE0     		b	.L96
 1378              	.L94:
 626:../Generated_Code/MMA0.c ****   }
 627:../Generated_Code/MMA0.c ****   val &= ~MMA0_ACTIVE_BIT_MASK; /* disable device */
 1379              		.loc 1 627 0
 1380 0026 BB1D     		add	r3, r7, #6
 1381 0028 1B78     		ldrb	r3, [r3]
 1382 002a 0122     		mov	r2, #1
 1383 002c 9343     		bic	r3, r2
 1384 002e DAB2     		uxtb	r2, r3
 1385 0030 BB1D     		add	r3, r7, #6
 1386 0032 1A70     		strb	r2, [r3]
 628:../Generated_Code/MMA0.c ****   return GI2C0_WriteByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, val);
 1387              		.loc 1 628 0
 1388 0034 BB1D     		add	r3, r7, #6
 1389 0036 1B78     		ldrb	r3, [r3]
 1390 0038 1D20     		mov	r0, #29
 1391 003a 2A21     		mov	r1, #42
 1392 003c 1A1C     		mov	r2, r3
 1393 003e FFF7FEFF 		bl	_Z23GI2C0_WriteByteAddress8hhh
 1394 0042 031C     		mov	r3, r0
 1395              	.L96:
 1396              	.LBE17:
 629:../Generated_Code/MMA0.c **** }
 1397              		.loc 1 629 0
 1398 0044 181C     		mov	r0, r3
 1399 0046 BD46     		mov	sp, r7
 1400 0048 03B0     		add	sp, sp, #12
 1401              		@ sp needed for prologue
 1402 004a 90BD     		pop	{r4, r7, pc}
 1403              		.cfi_endproc
 1404              	.LFE28:
 1406              		.section	.text._Z14MMA0_isEnabledPb,"ax",%progbits
 1407              		.align	2
 1408              		.global	_Z14MMA0_isEnabledPb
 1409              		.code	16
 1410              		.thumb_func
 1412              	_Z14MMA0_isEnabledPb:
 1413              	.LFB29:
 630:../Generated_Code/MMA0.c **** 
 631:../Generated_Code/MMA0.c **** /*
 632:../Generated_Code/MMA0.c **** ** ===================================================================
 633:../Generated_Code/MMA0.c **** **     Method      :  MMA0_isEnabled (component MMA8451Q)
 634:../Generated_Code/MMA0.c **** **     Description :
 635:../Generated_Code/MMA0.c **** **         Returns the status of the the ACTIVE bit in the CTRL
 636:../Generated_Code/MMA0.c **** **         register 1
 637:../Generated_Code/MMA0.c **** **     Parameters  :
 638:../Generated_Code/MMA0.c **** **         NAME            - DESCRIPTION
 639:../Generated_Code/MMA0.c **** **       * isEnabled       - Pointer to where to store the
 640:../Generated_Code/MMA0.c **** **                           result, TRUE if ACTIVE bit is set, FALSE
 641:../Generated_Code/MMA0.c **** **                           otherwise
 642:../Generated_Code/MMA0.c **** **     Returns     :
 643:../Generated_Code/MMA0.c **** **         ---             - error code
 644:../Generated_Code/MMA0.c **** ** ===================================================================
 645:../Generated_Code/MMA0.c **** */
 646:../Generated_Code/MMA0.c **** byte MMA0_isEnabled(bool *isEnabled)
 647:../Generated_Code/MMA0.c **** {
 1414              		.loc 1 647 0
 1415              		.cfi_startproc
 1416 0000 90B5     		push	{r4, r7, lr}
 1417              	.LCFI64:
 1418              		.cfi_def_cfa_offset 12
 1419              		.cfi_offset 4, -12
 1420              		.cfi_offset 7, -8
 1421              		.cfi_offset 14, -4
 1422 0002 85B0     		sub	sp, sp, #20
 1423              	.LCFI65:
 1424              		.cfi_def_cfa_offset 32
 1425 0004 00AF     		add	r7, sp, #0
 1426              	.LCFI66:
 1427              		.cfi_def_cfa_register 7
 1428 0006 7860     		str	r0, [r7, #4]
 1429              	.LBB18:
 648:../Generated_Code/MMA0.c ****   uint8_t val, res;
 649:../Generated_Code/MMA0.c **** 
 650:../Generated_Code/MMA0.c ****   res = GI2C0_ReadByteAddress8(MMA0_I2C_ADDR, MMA0_CTRL_REG_1, &val);
 1430              		.loc 1 650 0
 1431 0008 3C1C     		mov	r4, r7
 1432 000a 0F34     		add	r4, r4, #15
 1433 000c 3B1C     		mov	r3, r7
 1434 000e 0E33     		add	r3, r3, #14
 1435 0010 1D20     		mov	r0, #29
 1436 0012 2A21     		mov	r1, #42
 1437 0014 1A1C     		mov	r2, r3
 1438 0016 FFF7FEFF 		bl	_Z22GI2C0_ReadByteAddress8hhPh
 1439 001a 031C     		mov	r3, r0
 1440 001c 2370     		strb	r3, [r4]
 651:../Generated_Code/MMA0.c ****   if (res!=ERR_OK) {
 1441              		.loc 1 651 0
 1442 001e 3B1C     		mov	r3, r7
 1443 0020 0F33     		add	r3, r3, #15
 1444 0022 1B78     		ldrb	r3, [r3]
 1445 0024 002B     		cmp	r3, #0
 1446 0026 01D0     		beq	.L98
 652:../Generated_Code/MMA0.c ****     return ERR_FAILED;
 1447              		.loc 1 652 0
 1448 0028 1B23     		mov	r3, #27
 1449 002a 0BE0     		b	.L100
 1450              	.L98:
 653:../Generated_Code/MMA0.c ****   }
 654:../Generated_Code/MMA0.c ****   *isEnabled = (val&MMA0_ACTIVE_BIT_MASK)!=0; /* TRUE if bit is set, FALSE otherwise */
 1451              		.loc 1 654 0
 1452 002c 3B1C     		mov	r3, r7
 1453 002e 0E33     		add	r3, r3, #14
 1454 0030 1B78     		ldrb	r3, [r3]
 1455 0032 1A1C     		mov	r2, r3
 1456 0034 0123     		mov	r3, #1
 1457 0036 1340     		and	r3, r2
 1458 0038 5A1E     		sub	r2, r3, #1
 1459 003a 9341     		sbc	r3, r3, r2
 1460 003c DAB2     		uxtb	r2, r3
 1461 003e 7B68     		ldr	r3, [r7, #4]
 1462 0040 1A70     		strb	r2, [r3]
 655:../Generated_Code/MMA0.c ****   return ERR_OK;
 1463              		.loc 1 655 0
 1464 0042 0023     		mov	r3, #0
 1465              	.L100:
 1466              	.LBE18:
 656:../Generated_Code/MMA0.c **** }
 1467              		.loc 1 656 0
 1468 0044 181C     		mov	r0, r3
 1469 0046 BD46     		mov	sp, r7
 1470 0048 05B0     		add	sp, sp, #20
 1471              		@ sp needed for prologue
 1472 004a 90BD     		pop	{r4, r7, pc}
 1473              		.cfi_endproc
 1474              	.LFE29:
 1476              		.section	.rodata._ZL18InitialCalibration,"a",%progbits
 1477              		.align	2
 1480              	_ZL18InitialCalibration:
 1481 0000 00000000 		.space	6
 1481      0000
 1482 0006 0000     		.section	.rodata._ZZ19MMA0_MeasureGetRawZvE4addr,"a",%progbits
 1485              	_ZZ19MMA0_MeasureGetRawZvE4addr:
 1486 0000 05       		.byte	5
 1487              		.section	.rodata._ZZ19MMA0_MeasureGetRawYvE4addr,"a",%progbits
 1490              	_ZZ19MMA0_MeasureGetRawYvE4addr:
 1491 0000 03       		.byte	3
 1492              		.section	.rodata._ZZ19MMA0_MeasureGetRawXvE4addr,"a",%progbits
 1495              	_ZZ19MMA0_MeasureGetRawXvE4addr:
 1496 0000 01       		.byte	1
 1497              		.section	.rodata._ZZ15MMA0_GetRaw8XYZPhE4addr,"a",%progbits
 1500              	_ZZ15MMA0_GetRaw8XYZPhE4addr:
 1501 0000 01       		.byte	1
 1502              		.text
 1503              	.Letext0:
 1504              		.file 2 "../Generated_Code/PE_Types.h"
 1505              		.file 3 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
DEFINED SYMBOLS
                            *ABS*:00000000 MMA0.c
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:18     .bss._ZL10sCalValues:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:21     .bss._ZL10sCalValues:00000000 _ZL10sCalValues
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:24     .text._Z15MMA0_GetRaw8XYZPh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:29     .text._Z15MMA0_GetRaw8XYZPh:00000000 _Z15MMA0_GetRaw8XYZPh
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:67     .text._Z15MMA0_GetRaw8XYZPh:00000024 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1500   .rodata._ZZ15MMA0_GetRaw8XYZPhE4addr:00000000 _ZZ15MMA0_GetRaw8XYZPhE4addr
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:72     .text._Z11MMA0_Deinitv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:77     .text._Z11MMA0_Deinitv:00000000 _Z11MMA0_Deinitv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:100    .text._Z9MMA0_Initv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:105    .text._Z9MMA0_Initv:00000000 _Z9MMA0_Initv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:146    .text._Z9MMA0_Initv:00000030 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1480   .rodata._ZL18InitialCalibration:00000000 _ZL18InitialCalibration
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:152    .text._Z17MMA0_CalibrateX1gv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:157    .text._Z17MMA0_CalibrateX1gv:00000000 _Z17MMA0_CalibrateX1gv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:619    .text._Z19MMA0_MeasureGetRawXv:00000000 _Z19MMA0_MeasureGetRawXv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:685    .text._Z19MMA0_MeasureGetRawYv:00000000 _Z19MMA0_MeasureGetRawYv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:751    .text._Z19MMA0_MeasureGetRawZv:00000000 _Z19MMA0_MeasureGetRawZv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:252    .text._Z17MMA0_CalibrateX1gv:00000084 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:257    .text._Z17MMA0_CalibrateY1gv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:262    .text._Z17MMA0_CalibrateY1gv:00000000 _Z17MMA0_CalibrateY1gv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:357    .text._Z17MMA0_CalibrateY1gv:00000084 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:362    .text._Z17MMA0_CalibrateZ1gv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:367    .text._Z17MMA0_CalibrateZ1gv:00000000 _Z17MMA0_CalibrateZ1gv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:462    .text._Z17MMA0_CalibrateZ1gv:00000084 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:467    .text._Z11MMA0_GetXmgv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:472    .text._Z11MMA0_GetXmgv:00000000 _Z11MMA0_GetXmgv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1009   .text._Z9MMA0_GetXv:00000000 _Z9MMA0_GetXv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:516    .text._Z11MMA0_GetYmgv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:521    .text._Z11MMA0_GetYmgv:00000000 _Z11MMA0_GetYmgv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1065   .text._Z9MMA0_GetYv:00000000 _Z9MMA0_GetYv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:565    .text._Z11MMA0_GetZmgv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:570    .text._Z11MMA0_GetZmgv:00000000 _Z11MMA0_GetZmgv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1121   .text._Z9MMA0_GetZv:00000000 _Z9MMA0_GetZv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:614    .text._Z19MMA0_MeasureGetRawXv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:675    .text._Z19MMA0_MeasureGetRawXv:00000044 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1495   .rodata._ZZ19MMA0_MeasureGetRawXvE4addr:00000000 _ZZ19MMA0_MeasureGetRawXvE4addr
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:680    .text._Z19MMA0_MeasureGetRawYv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:741    .text._Z19MMA0_MeasureGetRawYv:00000044 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1490   .rodata._ZZ19MMA0_MeasureGetRawYvE4addr:00000000 _ZZ19MMA0_MeasureGetRawYvE4addr
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:746    .text._Z19MMA0_MeasureGetRawZv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:807    .text._Z19MMA0_MeasureGetRawZv:00000044 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1485   .rodata._ZZ19MMA0_MeasureGetRawZvE4addr:00000000 _ZZ19MMA0_MeasureGetRawZvE4addr
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:812    .text._Z15MMA0_GetXOffsetv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:817    .text._Z15MMA0_GetXOffsetv:00000000 _Z15MMA0_GetXOffsetv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:841    .text._Z15MMA0_GetXOffsetv:00000010 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:846    .text._Z15MMA0_GetYOffsetv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:851    .text._Z15MMA0_GetYOffsetv:00000000 _Z15MMA0_GetYOffsetv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:875    .text._Z15MMA0_GetYOffsetv:00000010 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:880    .text._Z15MMA0_GetZOffsetv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:885    .text._Z15MMA0_GetZOffsetv:00000000 _Z15MMA0_GetZOffsetv
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:909    .text._Z15MMA0_GetZOffsetv:00000010 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:914    .text._Z16MMA0_GetX1gValuev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:919    .text._Z16MMA0_GetX1gValuev:00000000 _Z16MMA0_GetX1gValuev
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:944    .text._Z16MMA0_GetY1gValuev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:949    .text._Z16MMA0_GetY1gValuev:00000000 _Z16MMA0_GetY1gValuev
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:974    .text._Z16MMA0_GetZ1gValuev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:979    .text._Z16MMA0_GetZ1gValuev:00000000 _Z16MMA0_GetZ1gValuev
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1004   .text._Z9MMA0_GetXv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1055   .text._Z9MMA0_GetXv:00000034 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1060   .text._Z9MMA0_GetYv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1111   .text._Z9MMA0_GetYv:00000034 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1116   .text._Z9MMA0_GetZv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1167   .text._Z9MMA0_GetZv:00000034 $d
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1172   .text._Z16MMA0_SetFastModeb:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1177   .text._Z16MMA0_SetFastModeb:00000000 _Z16MMA0_SetFastModeb
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1269   .text._Z11MMA0_Enablev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1274   .text._Z11MMA0_Enablev:00000000 _Z11MMA0_Enablev
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1338   .text._Z12MMA0_Disablev:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1343   .text._Z12MMA0_Disablev:00000000 _Z12MMA0_Disablev
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1407   .text._Z14MMA0_isEnabledPb:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1412   .text._Z14MMA0_isEnabledPb:00000000 _Z14MMA0_isEnabledPb
C:\Users\JH\AppData\Local\Temp\ccfGyROc.s:1477   .rodata._ZL18InitialCalibration:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_Z17GI2C0_ReadAddresshPhhS_t
_Z23GI2C0_WriteByteAddress8hhh
_Z22GI2C0_ReadByteAddress8hhPh
