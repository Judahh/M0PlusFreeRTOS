   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"event_groups.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.xEventGroupCreate,"ax",%progbits
  18              		.align	2
  19              		.global	xEventGroupCreate
  20              		.code	16
  21              		.thumb_func
  23              	xEventGroupCreate:
  24              	.LFB4:
  25              		.file 1 "../Generated_Code/event_groups.c"
   1:../Generated_Code/event_groups.c **** /*
   2:../Generated_Code/event_groups.c ****     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:../Generated_Code/event_groups.c ****     All rights reserved
   4:../Generated_Code/event_groups.c **** 
   5:../Generated_Code/event_groups.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Generated_Code/event_groups.c **** 
   7:../Generated_Code/event_groups.c ****     ***************************************************************************
   8:../Generated_Code/event_groups.c ****      *                                                                       *
   9:../Generated_Code/event_groups.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Generated_Code/event_groups.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Generated_Code/event_groups.c ****      *    platform software that has become a de facto standard.             *
  12:../Generated_Code/event_groups.c ****      *                                                                       *
  13:../Generated_Code/event_groups.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Generated_Code/event_groups.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Generated_Code/event_groups.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Generated_Code/event_groups.c ****      *                                                                       *
  17:../Generated_Code/event_groups.c ****      *    Thank you!                                                         *
  18:../Generated_Code/event_groups.c ****      *                                                                       *
  19:../Generated_Code/event_groups.c ****     ***************************************************************************
  20:../Generated_Code/event_groups.c **** 
  21:../Generated_Code/event_groups.c ****     This file is part of the FreeRTOS distribution.
  22:../Generated_Code/event_groups.c **** 
  23:../Generated_Code/event_groups.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Generated_Code/event_groups.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Generated_Code/event_groups.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Generated_Code/event_groups.c **** 
  27:../Generated_Code/event_groups.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Generated_Code/event_groups.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Generated_Code/event_groups.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Generated_Code/event_groups.c ****     >>! kernel.
  31:../Generated_Code/event_groups.c **** 
  32:../Generated_Code/event_groups.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Generated_Code/event_groups.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Generated_Code/event_groups.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Generated_Code/event_groups.c ****     link: http://www.freertos.org/a00114.html
  36:../Generated_Code/event_groups.c **** 
  37:../Generated_Code/event_groups.c ****     1 tab == 4 spaces!
  38:../Generated_Code/event_groups.c **** 
  39:../Generated_Code/event_groups.c ****     ***************************************************************************
  40:../Generated_Code/event_groups.c ****      *                                                                       *
  41:../Generated_Code/event_groups.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Generated_Code/event_groups.c ****      *    not run, what could be wrong?"                                     *
  43:../Generated_Code/event_groups.c ****      *                                                                       *
  44:../Generated_Code/event_groups.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Generated_Code/event_groups.c ****      *                                                                       *
  46:../Generated_Code/event_groups.c ****     ***************************************************************************
  47:../Generated_Code/event_groups.c **** 
  48:../Generated_Code/event_groups.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Generated_Code/event_groups.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Generated_Code/event_groups.c **** 
  51:../Generated_Code/event_groups.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Generated_Code/event_groups.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Generated_Code/event_groups.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Generated_Code/event_groups.c **** 
  55:../Generated_Code/event_groups.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Generated_Code/event_groups.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Generated_Code/event_groups.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Generated_Code/event_groups.c **** 
  59:../Generated_Code/event_groups.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Generated_Code/event_groups.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Generated_Code/event_groups.c ****     mission critical applications that require provable dependability.
  62:../Generated_Code/event_groups.c **** 
  63:../Generated_Code/event_groups.c ****     1 tab == 4 spaces!
  64:../Generated_Code/event_groups.c **** */
  65:../Generated_Code/event_groups.c **** 
  66:../Generated_Code/event_groups.c **** /* Standard includes. */
  67:../Generated_Code/event_groups.c **** #include <stdlib.h>
  68:../Generated_Code/event_groups.c **** 
  69:../Generated_Code/event_groups.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:../Generated_Code/event_groups.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:../Generated_Code/event_groups.c **** task.h is included from an application file. */
  72:../Generated_Code/event_groups.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:../Generated_Code/event_groups.c **** 
  74:../Generated_Code/event_groups.c **** /* FreeRTOS includes. */
  75:../Generated_Code/event_groups.c **** #include "FreeRTOS.h"
  76:../Generated_Code/event_groups.c **** #include "task.h"
  77:../Generated_Code/event_groups.c **** #include "timers.h"
  78:../Generated_Code/event_groups.c **** #include "event_groups.h"
  79:../Generated_Code/event_groups.c **** 
  80:../Generated_Code/event_groups.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  81:../Generated_Code/event_groups.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  82:../Generated_Code/event_groups.c **** header files above, but not in this file, in order to generate the correct
  83:../Generated_Code/event_groups.c **** privileged Vs unprivileged linkage and placement. */
  84:../Generated_Code/event_groups.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  85:../Generated_Code/event_groups.c **** 
  86:../Generated_Code/event_groups.c **** #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( configUSE_TIMERS == 0 )
  87:../Generated_Code/event_groups.c ****         #error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function av
  88:../Generated_Code/event_groups.c **** #endif
  89:../Generated_Code/event_groups.c **** 
  90:../Generated_Code/event_groups.c **** #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
  91:../Generated_Code/event_groups.c ****         #error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBit
  92:../Generated_Code/event_groups.c **** #endif
  93:../Generated_Code/event_groups.c **** 
  94:../Generated_Code/event_groups.c **** /* The following bit fields convey control information in a task's event list
  95:../Generated_Code/event_groups.c **** item value.  It is important they don't clash with the
  96:../Generated_Code/event_groups.c **** taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
  97:../Generated_Code/event_groups.c **** #if configUSE_16_BIT_TICKS == 1
  98:../Generated_Code/event_groups.c ****         #define eventCLEAR_EVENTS_ON_EXIT_BIT   0x0100U
  99:../Generated_Code/event_groups.c ****         #define eventUNBLOCKED_DUE_TO_BIT_SET   0x0200U
 100:../Generated_Code/event_groups.c ****         #define eventWAIT_FOR_ALL_BITS                  0x0400U
 101:../Generated_Code/event_groups.c ****         #define eventEVENT_BITS_CONTROL_BYTES   0xff00U
 102:../Generated_Code/event_groups.c **** #else
 103:../Generated_Code/event_groups.c ****         #define eventCLEAR_EVENTS_ON_EXIT_BIT   0x01000000UL
 104:../Generated_Code/event_groups.c ****         #define eventUNBLOCKED_DUE_TO_BIT_SET   0x02000000UL
 105:../Generated_Code/event_groups.c ****         #define eventWAIT_FOR_ALL_BITS                  0x04000000UL
 106:../Generated_Code/event_groups.c ****         #define eventEVENT_BITS_CONTROL_BYTES   0xff000000UL
 107:../Generated_Code/event_groups.c **** #endif
 108:../Generated_Code/event_groups.c **** 
 109:../Generated_Code/event_groups.c **** typedef struct xEventGroupDefinition
 110:../Generated_Code/event_groups.c **** {
 111:../Generated_Code/event_groups.c ****         EventBits_t uxEventBits;
 112:../Generated_Code/event_groups.c ****         List_t xTasksWaitingForBits;            /*< List of tasks waiting for a bit to be set. */
 113:../Generated_Code/event_groups.c **** 
 114:../Generated_Code/event_groups.c ****         #if( configUSE_TRACE_FACILITY == 1 )
 115:../Generated_Code/event_groups.c ****                 UBaseType_t uxEventGroupNumber;
 116:../Generated_Code/event_groups.c ****         #endif
 117:../Generated_Code/event_groups.c **** 
 118:../Generated_Code/event_groups.c **** } EventGroup_t;
 119:../Generated_Code/event_groups.c **** 
 120:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 121:../Generated_Code/event_groups.c **** 
 122:../Generated_Code/event_groups.c **** /*
 123:../Generated_Code/event_groups.c ****  * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
 124:../Generated_Code/event_groups.c ****  * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
 125:../Generated_Code/event_groups.c ****  * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
 126:../Generated_Code/event_groups.c ****  * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
 127:../Generated_Code/event_groups.c ****  * wait condition is met if any of the bits set in uxBitsToWait for are also set
 128:../Generated_Code/event_groups.c ****  * in uxCurrentEventBits.
 129:../Generated_Code/event_groups.c ****  */
 130:../Generated_Code/event_groups.c **** static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxB
 131:../Generated_Code/event_groups.c **** 
 132:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 133:../Generated_Code/event_groups.c **** 
 134:../Generated_Code/event_groups.c **** EventGroupHandle_t xEventGroupCreate( void )
 135:../Generated_Code/event_groups.c **** {
  26              		.loc 1 135 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 82B0     		sub	sp, sp, #8
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 16
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39              	.LBB2:
 136:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits;
 137:../Generated_Code/event_groups.c **** 
 138:../Generated_Code/event_groups.c ****         pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
  40              		.loc 1 138 0
  41 0006 1820     		mov	r0, #24
  42 0008 FFF7FEFF 		bl	pvPortMalloc
  43 000c 031C     		mov	r3, r0
  44 000e 7B60     		str	r3, [r7, #4]
 139:../Generated_Code/event_groups.c ****         if( pxEventBits != NULL )
  45              		.loc 1 139 0
  46 0010 7B68     		ldr	r3, [r7, #4]
  47 0012 002B     		cmp	r3, #0
  48 0014 07D0     		beq	.L2
 140:../Generated_Code/event_groups.c ****         {
 141:../Generated_Code/event_groups.c ****                 pxEventBits->uxEventBits = 0;
  49              		.loc 1 141 0
  50 0016 7B68     		ldr	r3, [r7, #4]
  51 0018 0022     		mov	r2, #0
  52 001a 1A60     		str	r2, [r3]
 142:../Generated_Code/event_groups.c ****                 vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
  53              		.loc 1 142 0
  54 001c 7B68     		ldr	r3, [r7, #4]
  55 001e 0433     		add	r3, r3, #4
  56 0020 181C     		mov	r0, r3
  57 0022 FFF7FEFF 		bl	vListInitialise
  58              	.L2:
 143:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_CREATE( pxEventBits );
 144:../Generated_Code/event_groups.c ****         }
 145:../Generated_Code/event_groups.c ****         else
 146:../Generated_Code/event_groups.c ****         {
 147:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_CREATE_FAILED();
 148:../Generated_Code/event_groups.c ****         }
 149:../Generated_Code/event_groups.c **** 
 150:../Generated_Code/event_groups.c ****         return ( EventGroupHandle_t ) pxEventBits;
  59              		.loc 1 150 0
  60 0026 7B68     		ldr	r3, [r7, #4]
  61              	.LBE2:
 151:../Generated_Code/event_groups.c **** }
  62              		.loc 1 151 0
  63 0028 181C     		mov	r0, r3
  64 002a BD46     		mov	sp, r7
  65 002c 02B0     		add	sp, sp, #8
  66              		@ sp needed for prologue
  67 002e 80BD     		pop	{r7, pc}
  68              		.cfi_endproc
  69              	.LFE4:
  71              		.section	.text.xEventGroupSync,"ax",%progbits
  72              		.align	2
  73              		.global	xEventGroupSync
  74              		.code	16
  75              		.thumb_func
  77              	xEventGroupSync:
  78              	.LFB5:
 152:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 153:../Generated_Code/event_groups.c **** 
 154:../Generated_Code/event_groups.c **** EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const E
 155:../Generated_Code/event_groups.c **** {
  79              		.loc 1 155 0
  80              		.cfi_startproc
  81 0000 80B5     		push	{r7, lr}
  82              	.LCFI3:
  83              		.cfi_def_cfa_offset 8
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86 0002 8AB0     		sub	sp, sp, #40
  87              	.LCFI4:
  88              		.cfi_def_cfa_offset 48
  89 0004 00AF     		add	r7, sp, #0
  90              	.LCFI5:
  91              		.cfi_def_cfa_register 7
  92 0006 F860     		str	r0, [r7, #12]
  93 0008 B960     		str	r1, [r7, #8]
  94 000a 7A60     		str	r2, [r7, #4]
  95 000c 3B60     		str	r3, [r7]
  96              	.LBB3:
 156:../Generated_Code/event_groups.c **** EventBits_t uxOriginalBitValue, uxReturn;
 157:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
  97              		.loc 1 157 0
  98 000e FB68     		ldr	r3, [r7, #12]
  99 0010 3B62     		str	r3, [r7, #32]
 158:../Generated_Code/event_groups.c **** BaseType_t xAlreadyYielded;
 159:../Generated_Code/event_groups.c **** BaseType_t xTimeoutOccurred = pdFALSE;
 100              		.loc 1 159 0
 101 0012 0023     		mov	r3, #0
 102 0014 FB61     		str	r3, [r7, #28]
 160:../Generated_Code/event_groups.c **** 
 161:../Generated_Code/event_groups.c ****         configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 103              		.loc 1 161 0
 104 0016 7B68     		ldr	r3, [r7, #4]
 105 0018 1B0E     		lsr	r3, r3, #24
 106 001a 1B06     		lsl	r3, r3, #24
 107 001c 01D0     		beq	.L5
 108              		.loc 1 161 0 is_stmt 0
 109              	@ 161 "../Generated_Code/event_groups.c" 1
 110 001e 72B6     		cpsid i
 111              	@ 0 "" 2
 112              		.code	16
 113              	.L6:
 114              		.loc 1 161 0
 115 0020 FEE7     		b	.L6
 116              	.L5:
 162:../Generated_Code/event_groups.c ****         configASSERT( uxBitsToWaitFor != 0 );
 117              		.loc 1 162 0 is_stmt 1
 118 0022 7B68     		ldr	r3, [r7, #4]
 119 0024 002B     		cmp	r3, #0
 120 0026 01D1     		bne	.L7
 121              		.loc 1 162 0 is_stmt 0
 122              	@ 162 "../Generated_Code/event_groups.c" 1
 123 0028 72B6     		cpsid i
 124              	@ 0 "" 2
 125              		.code	16
 126              	.L8:
 127              		.loc 1 162 0
 128 002a FEE7     		b	.L8
 129              	.L7:
 163:../Generated_Code/event_groups.c ****         #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 164:../Generated_Code/event_groups.c ****         {
 165:../Generated_Code/event_groups.c ****                 configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTick
 130              		.loc 1 165 0 is_stmt 1
 131 002c FFF7FEFF 		bl	xTaskGetSchedulerState
 132 0030 031C     		mov	r3, r0
 133 0032 002B     		cmp	r3, #0
 134 0034 04D1     		bne	.L9
 135              		.loc 1 165 0 is_stmt 0
 136 0036 3B68     		ldr	r3, [r7]
 137 0038 002B     		cmp	r3, #0
 138 003a 01D0     		beq	.L9
 139              		.loc 1 165 0
 140 003c 0123     		mov	r3, #1
 141 003e 00E0     		b	.L10
 142              	.L9:
 143              		.loc 1 165 0
 144 0040 0023     		mov	r3, #0
 145              	.L10:
 146              		.loc 1 165 0
 147 0042 002B     		cmp	r3, #0
 148 0044 01D0     		beq	.L11
 149              		.loc 1 165 0
 150              	@ 165 "../Generated_Code/event_groups.c" 1
 151 0046 72B6     		cpsid i
 152              	@ 0 "" 2
 153              		.code	16
 154              	.L12:
 155              		.loc 1 165 0
 156 0048 FEE7     		b	.L12
 157              	.L11:
 166:../Generated_Code/event_groups.c ****         }
 167:../Generated_Code/event_groups.c ****         #endif
 168:../Generated_Code/event_groups.c **** 
 169:../Generated_Code/event_groups.c ****         vTaskSuspendAll();
 158              		.loc 1 169 0 is_stmt 1
 159 004a FFF7FEFF 		bl	vTaskSuspendAll
 170:../Generated_Code/event_groups.c ****         {
 171:../Generated_Code/event_groups.c ****                 uxOriginalBitValue = pxEventBits->uxEventBits;
 160              		.loc 1 171 0
 161 004e 3B6A     		ldr	r3, [r7, #32]
 162 0050 1B68     		ldr	r3, [r3]
 163 0052 BB61     		str	r3, [r7, #24]
 172:../Generated_Code/event_groups.c **** 
 173:../Generated_Code/event_groups.c ****                 ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 164              		.loc 1 173 0
 165 0054 FA68     		ldr	r2, [r7, #12]
 166 0056 BB68     		ldr	r3, [r7, #8]
 167 0058 101C     		mov	r0, r2
 168 005a 191C     		mov	r1, r3
 169 005c FFF7FEFF 		bl	xEventGroupSetBits
 174:../Generated_Code/event_groups.c **** 
 175:../Generated_Code/event_groups.c ****                 if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 170              		.loc 1 175 0
 171 0060 BA69     		ldr	r2, [r7, #24]
 172 0062 BB68     		ldr	r3, [r7, #8]
 173 0064 1343     		orr	r3, r2
 174 0066 7A68     		ldr	r2, [r7, #4]
 175 0068 1A40     		and	r2, r3
 176 006a 7B68     		ldr	r3, [r7, #4]
 177 006c 9A42     		cmp	r2, r3
 178 006e 0CD1     		bne	.L13
 176:../Generated_Code/event_groups.c ****                 {
 177:../Generated_Code/event_groups.c ****                         /* All the rendezvous bits are now set - no need to block. */
 178:../Generated_Code/event_groups.c ****                         uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 179              		.loc 1 178 0
 180 0070 BA69     		ldr	r2, [r7, #24]
 181 0072 BB68     		ldr	r3, [r7, #8]
 182 0074 1343     		orr	r3, r2
 183 0076 7B62     		str	r3, [r7, #36]
 179:../Generated_Code/event_groups.c **** 
 180:../Generated_Code/event_groups.c ****                         /* Rendezvous always clear the bits.  They will have been cleared
 181:../Generated_Code/event_groups.c ****                         already unless this is the only task in the rendezvous. */
 182:../Generated_Code/event_groups.c ****                         pxEventBits->uxEventBits &= uxBitsToWaitFor;
 184              		.loc 1 182 0
 185 0078 3B6A     		ldr	r3, [r7, #32]
 186 007a 1B68     		ldr	r3, [r3]
 187 007c 7A68     		ldr	r2, [r7, #4]
 188 007e 1A40     		and	r2, r3
 189 0080 3B6A     		ldr	r3, [r7, #32]
 190 0082 1A60     		str	r2, [r3]
 183:../Generated_Code/event_groups.c **** 
 184:../Generated_Code/event_groups.c ****                         xTicksToWait = 0;
 191              		.loc 1 184 0
 192 0084 0023     		mov	r3, #0
 193 0086 3B60     		str	r3, [r7]
 194 0088 14E0     		b	.L14
 195              	.L13:
 185:../Generated_Code/event_groups.c ****                 }
 186:../Generated_Code/event_groups.c ****                 else
 187:../Generated_Code/event_groups.c ****                 {
 188:../Generated_Code/event_groups.c ****                         if( xTicksToWait != ( TickType_t ) 0 )
 196              		.loc 1 188 0
 197 008a 3B68     		ldr	r3, [r7]
 198 008c 002B     		cmp	r3, #0
 199 008e 0ED0     		beq	.L15
 189:../Generated_Code/event_groups.c ****                         {
 190:../Generated_Code/event_groups.c ****                                 traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWait
 191:../Generated_Code/event_groups.c **** 
 192:../Generated_Code/event_groups.c ****                                 /* Store the bits that the calling task is waiting for in the
 193:../Generated_Code/event_groups.c ****                                 task's event list item so the kernel knows when a match is
 194:../Generated_Code/event_groups.c ****                                 found.  Then enter the blocked state. */
 195:../Generated_Code/event_groups.c ****                                 vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBit
 200              		.loc 1 195 0
 201 0090 3B6A     		ldr	r3, [r7, #32]
 202 0092 191D     		add	r1, r3, #4
 203 0094 7B68     		ldr	r3, [r7, #4]
 204 0096 A022     		mov	r2, #160
 205 0098 D204     		lsl	r2, r2, #19
 206 009a 1A43     		orr	r2, r3
 207 009c 3B68     		ldr	r3, [r7]
 208 009e 081C     		mov	r0, r1
 209 00a0 111C     		mov	r1, r2
 210 00a2 1A1C     		mov	r2, r3
 211 00a4 FFF7FEFF 		bl	vTaskPlaceOnUnorderedEventList
 196:../Generated_Code/event_groups.c **** 
 197:../Generated_Code/event_groups.c ****                                 /* This assignment is obsolete as uxReturn will get set after
 198:../Generated_Code/event_groups.c ****                                 the task unblocks, but some compilers mistakenly generate a
 199:../Generated_Code/event_groups.c ****                                 warning about uxReturn being returned without being set if the
 200:../Generated_Code/event_groups.c ****                                 assignment is omitted. */
 201:../Generated_Code/event_groups.c ****                                 uxReturn = 0;
 212              		.loc 1 201 0
 213 00a8 0023     		mov	r3, #0
 214 00aa 7B62     		str	r3, [r7, #36]
 215 00ac 02E0     		b	.L14
 216              	.L15:
 202:../Generated_Code/event_groups.c ****                         }
 203:../Generated_Code/event_groups.c ****                         else
 204:../Generated_Code/event_groups.c ****                         {
 205:../Generated_Code/event_groups.c ****                                 /* The rendezvous bits were not set, but no block time was
 206:../Generated_Code/event_groups.c ****                                 specified - just return the current event bit value. */
 207:../Generated_Code/event_groups.c ****                                 uxReturn = pxEventBits->uxEventBits;
 217              		.loc 1 207 0
 218 00ae 3B6A     		ldr	r3, [r7, #32]
 219 00b0 1B68     		ldr	r3, [r3]
 220 00b2 7B62     		str	r3, [r7, #36]
 221              	.L14:
 208:../Generated_Code/event_groups.c ****                         }
 209:../Generated_Code/event_groups.c ****                 }
 210:../Generated_Code/event_groups.c ****         }
 211:../Generated_Code/event_groups.c ****         xAlreadyYielded = xTaskResumeAll();
 222              		.loc 1 211 0
 223 00b4 FFF7FEFF 		bl	xTaskResumeAll
 224 00b8 031C     		mov	r3, r0
 225 00ba 7B61     		str	r3, [r7, #20]
 212:../Generated_Code/event_groups.c **** 
 213:../Generated_Code/event_groups.c ****         if( xTicksToWait != ( TickType_t ) 0 )
 226              		.loc 1 213 0
 227 00bc 3B68     		ldr	r3, [r7]
 228 00be 002B     		cmp	r3, #0
 229 00c0 28D0     		beq	.L16
 214:../Generated_Code/event_groups.c ****         {
 215:../Generated_Code/event_groups.c ****                 if( xAlreadyYielded == pdFALSE )
 230              		.loc 1 215 0
 231 00c2 7B69     		ldr	r3, [r7, #20]
 232 00c4 002B     		cmp	r3, #0
 233 00c6 01D1     		bne	.L17
 216:../Generated_Code/event_groups.c ****                 {
 217:../Generated_Code/event_groups.c ****                         portYIELD_WITHIN_API();
 234              		.loc 1 217 0
 235 00c8 FFF7FEFF 		bl	vPortYieldFromISR
 236              	.L17:
 218:../Generated_Code/event_groups.c ****                 }
 219:../Generated_Code/event_groups.c ****                 else
 220:../Generated_Code/event_groups.c ****                 {
 221:../Generated_Code/event_groups.c ****                         mtCOVERAGE_TEST_MARKER();
 222:../Generated_Code/event_groups.c ****                 }
 223:../Generated_Code/event_groups.c **** 
 224:../Generated_Code/event_groups.c ****                 /* The task blocked to wait for its required bits to be set - at this
 225:../Generated_Code/event_groups.c ****                 point either the required bits were set or the block time expired.  If
 226:../Generated_Code/event_groups.c ****                 the required bits were set they will have been stored in the task's
 227:../Generated_Code/event_groups.c ****                 event list item, and they should now be retrieved then cleared. */
 228:../Generated_Code/event_groups.c ****                 uxReturn = uxTaskResetEventItemValue();
 237              		.loc 1 228 0
 238 00cc FFF7FEFF 		bl	uxTaskResetEventItemValue
 239 00d0 031C     		mov	r3, r0
 240 00d2 7B62     		str	r3, [r7, #36]
 229:../Generated_Code/event_groups.c **** 
 230:../Generated_Code/event_groups.c ****                 if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 241              		.loc 1 230 0
 242 00d4 7A6A     		ldr	r2, [r7, #36]
 243 00d6 8023     		mov	r3, #128
 244 00d8 9B04     		lsl	r3, r3, #18
 245 00da 1340     		and	r3, r2
 246 00dc 16D1     		bne	.L18
 231:../Generated_Code/event_groups.c ****                 {
 232:../Generated_Code/event_groups.c ****                         /* The task timed out, just return the current event bit value. */
 233:../Generated_Code/event_groups.c ****                         taskENTER_CRITICAL();
 247              		.loc 1 233 0
 248 00de FFF7FEFF 		bl	vPortEnterCritical
 234:../Generated_Code/event_groups.c ****                         {
 235:../Generated_Code/event_groups.c ****                                 uxReturn = pxEventBits->uxEventBits;
 249              		.loc 1 235 0
 250 00e2 3B6A     		ldr	r3, [r7, #32]
 251 00e4 1B68     		ldr	r3, [r3]
 252 00e6 7B62     		str	r3, [r7, #36]
 236:../Generated_Code/event_groups.c **** 
 237:../Generated_Code/event_groups.c ****                                 /* Although the task got here because it timed out before the
 238:../Generated_Code/event_groups.c ****                                 bits it was waiting for were set, it is possible that since it
 239:../Generated_Code/event_groups.c ****                                 unblocked another task has set the bits.  If this is the case
 240:../Generated_Code/event_groups.c ****                                 then it may be required to clear the bits before exiting. */
 241:../Generated_Code/event_groups.c ****                                 if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 253              		.loc 1 241 0
 254 00e8 7B6A     		ldr	r3, [r7, #36]
 255 00ea 7A68     		ldr	r2, [r7, #4]
 256 00ec 1A40     		and	r2, r3
 257 00ee 7B68     		ldr	r3, [r7, #4]
 258 00f0 9A42     		cmp	r2, r3
 259 00f2 06D1     		bne	.L19
 242:../Generated_Code/event_groups.c ****                                 {
 243:../Generated_Code/event_groups.c ****                                         pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 260              		.loc 1 243 0
 261 00f4 3B6A     		ldr	r3, [r7, #32]
 262 00f6 1B68     		ldr	r3, [r3]
 263 00f8 7A68     		ldr	r2, [r7, #4]
 264 00fa D243     		mvn	r2, r2
 265 00fc 1A40     		and	r2, r3
 266 00fe 3B6A     		ldr	r3, [r7, #32]
 267 0100 1A60     		str	r2, [r3]
 268              	.L19:
 244:../Generated_Code/event_groups.c ****                                 }
 245:../Generated_Code/event_groups.c ****                                 else
 246:../Generated_Code/event_groups.c ****                                 {
 247:../Generated_Code/event_groups.c ****                                         mtCOVERAGE_TEST_MARKER();
 248:../Generated_Code/event_groups.c ****                                 }
 249:../Generated_Code/event_groups.c ****                         }
 250:../Generated_Code/event_groups.c ****                         taskEXIT_CRITICAL();
 269              		.loc 1 250 0
 270 0102 FFF7FEFF 		bl	vPortExitCritical
 251:../Generated_Code/event_groups.c **** 
 252:../Generated_Code/event_groups.c ****                         xTimeoutOccurred = pdTRUE;
 271              		.loc 1 252 0
 272 0106 0123     		mov	r3, #1
 273 0108 FB61     		str	r3, [r7, #28]
 274 010a 03E0     		b	.L16
 275              	.L18:
 253:../Generated_Code/event_groups.c ****                 }
 254:../Generated_Code/event_groups.c ****                 else
 255:../Generated_Code/event_groups.c ****                 {
 256:../Generated_Code/event_groups.c ****                         /* The task unblocked because the bits were set.  Clear the control
 257:../Generated_Code/event_groups.c ****                         bits before returning the value. */
 258:../Generated_Code/event_groups.c ****                         uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 276              		.loc 1 258 0
 277 010c 7B6A     		ldr	r3, [r7, #36]
 278 010e 1B02     		lsl	r3, r3, #8
 279 0110 1B0A     		lsr	r3, r3, #8
 280 0112 7B62     		str	r3, [r7, #36]
 281              	.L16:
 259:../Generated_Code/event_groups.c ****                 }
 260:../Generated_Code/event_groups.c ****         }
 261:../Generated_Code/event_groups.c **** 
 262:../Generated_Code/event_groups.c ****         traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
 263:../Generated_Code/event_groups.c ****         return uxReturn;
 282              		.loc 1 263 0
 283 0114 7B6A     		ldr	r3, [r7, #36]
 284              	.LBE3:
 264:../Generated_Code/event_groups.c **** }
 285              		.loc 1 264 0
 286 0116 181C     		mov	r0, r3
 287 0118 BD46     		mov	sp, r7
 288 011a 0AB0     		add	sp, sp, #40
 289              		@ sp needed for prologue
 290 011c 80BD     		pop	{r7, pc}
 291              		.cfi_endproc
 292              	.LFE5:
 294 011e C046     		.section	.text.xEventGroupWaitBits,"ax",%progbits
 295              		.align	2
 296              		.global	xEventGroupWaitBits
 297              		.code	16
 298              		.thumb_func
 300              	xEventGroupWaitBits:
 301              	.LFB6:
 265:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 266:../Generated_Code/event_groups.c **** 
 267:../Generated_Code/event_groups.c **** EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor,
 268:../Generated_Code/event_groups.c **** {
 302              		.loc 1 268 0
 303              		.cfi_startproc
 304 0000 80B5     		push	{r7, lr}
 305              	.LCFI6:
 306              		.cfi_def_cfa_offset 8
 307              		.cfi_offset 7, -8
 308              		.cfi_offset 14, -4
 309 0002 8CB0     		sub	sp, sp, #48
 310              	.LCFI7:
 311              		.cfi_def_cfa_offset 56
 312 0004 00AF     		add	r7, sp, #0
 313              	.LCFI8:
 314              		.cfi_def_cfa_register 7
 315 0006 F860     		str	r0, [r7, #12]
 316 0008 B960     		str	r1, [r7, #8]
 317 000a 7A60     		str	r2, [r7, #4]
 318 000c 3B60     		str	r3, [r7]
 319              	.LBB4:
 269:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 320              		.loc 1 269 0
 321 000e FB68     		ldr	r3, [r7, #12]
 322 0010 7B62     		str	r3, [r7, #36]
 270:../Generated_Code/event_groups.c **** EventBits_t uxReturn, uxControlBits = 0;
 323              		.loc 1 270 0
 324 0012 0023     		mov	r3, #0
 325 0014 BB62     		str	r3, [r7, #40]
 271:../Generated_Code/event_groups.c **** BaseType_t xWaitConditionMet, xAlreadyYielded;
 272:../Generated_Code/event_groups.c **** BaseType_t xTimeoutOccurred = pdFALSE;
 326              		.loc 1 272 0
 327 0016 0023     		mov	r3, #0
 328 0018 3B62     		str	r3, [r7, #32]
 273:../Generated_Code/event_groups.c **** 
 274:../Generated_Code/event_groups.c ****         /* Check the user is not attempting to wait on the bits used by the kernel
 275:../Generated_Code/event_groups.c ****         itself, and that at least one bit is being requested. */
 276:../Generated_Code/event_groups.c ****         configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 329              		.loc 1 276 0
 330 001a BB68     		ldr	r3, [r7, #8]
 331 001c 1B0E     		lsr	r3, r3, #24
 332 001e 1B06     		lsl	r3, r3, #24
 333 0020 01D0     		beq	.L22
 334              		.loc 1 276 0 is_stmt 0
 335              	@ 276 "../Generated_Code/event_groups.c" 1
 336 0022 72B6     		cpsid i
 337              	@ 0 "" 2
 338              		.code	16
 339              	.L23:
 340              		.loc 1 276 0
 341 0024 FEE7     		b	.L23
 342              	.L22:
 277:../Generated_Code/event_groups.c ****         configASSERT( uxBitsToWaitFor != 0 );
 343              		.loc 1 277 0 is_stmt 1
 344 0026 BB68     		ldr	r3, [r7, #8]
 345 0028 002B     		cmp	r3, #0
 346 002a 01D1     		bne	.L24
 347              		.loc 1 277 0 is_stmt 0
 348              	@ 277 "../Generated_Code/event_groups.c" 1
 349 002c 72B6     		cpsid i
 350              	@ 0 "" 2
 351              		.code	16
 352              	.L25:
 353              		.loc 1 277 0
 354 002e FEE7     		b	.L25
 355              	.L24:
 278:../Generated_Code/event_groups.c ****         #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 279:../Generated_Code/event_groups.c ****         {
 280:../Generated_Code/event_groups.c ****                 configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTick
 356              		.loc 1 280 0 is_stmt 1
 357 0030 FFF7FEFF 		bl	xTaskGetSchedulerState
 358 0034 031C     		mov	r3, r0
 359 0036 002B     		cmp	r3, #0
 360 0038 04D1     		bne	.L26
 361              		.loc 1 280 0 is_stmt 0
 362 003a BB6B     		ldr	r3, [r7, #56]
 363 003c 002B     		cmp	r3, #0
 364 003e 01D0     		beq	.L26
 365              		.loc 1 280 0
 366 0040 0123     		mov	r3, #1
 367 0042 00E0     		b	.L27
 368              	.L26:
 369              		.loc 1 280 0
 370 0044 0023     		mov	r3, #0
 371              	.L27:
 372              		.loc 1 280 0
 373 0046 002B     		cmp	r3, #0
 374 0048 01D0     		beq	.L28
 375              		.loc 1 280 0
 376              	@ 280 "../Generated_Code/event_groups.c" 1
 377 004a 72B6     		cpsid i
 378              	@ 0 "" 2
 379              		.code	16
 380              	.L29:
 381              		.loc 1 280 0
 382 004c FEE7     		b	.L29
 383              	.L28:
 281:../Generated_Code/event_groups.c ****         }
 282:../Generated_Code/event_groups.c ****         #endif
 283:../Generated_Code/event_groups.c **** 
 284:../Generated_Code/event_groups.c ****         vTaskSuspendAll();
 384              		.loc 1 284 0 is_stmt 1
 385 004e FFF7FEFF 		bl	vTaskSuspendAll
 386              	.LBB5:
 285:../Generated_Code/event_groups.c ****         {
 286:../Generated_Code/event_groups.c ****                 const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 387              		.loc 1 286 0
 388 0052 7B6A     		ldr	r3, [r7, #36]
 389 0054 1B68     		ldr	r3, [r3]
 390 0056 FB61     		str	r3, [r7, #28]
 287:../Generated_Code/event_groups.c **** 
 288:../Generated_Code/event_groups.c ****                 /* Check to see if the wait condition is already met or not. */
 289:../Generated_Code/event_groups.c ****                 xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWai
 391              		.loc 1 289 0
 392 0058 F969     		ldr	r1, [r7, #28]
 393 005a BA68     		ldr	r2, [r7, #8]
 394 005c 3B68     		ldr	r3, [r7]
 395 005e 081C     		mov	r0, r1
 396 0060 111C     		mov	r1, r2
 397 0062 1A1C     		mov	r2, r3
 398 0064 FFF7FEFF 		bl	_ZL20prvTestWaitConditionmml
 399 0068 031C     		mov	r3, r0
 400 006a BB61     		str	r3, [r7, #24]
 290:../Generated_Code/event_groups.c **** 
 291:../Generated_Code/event_groups.c ****                 if( xWaitConditionMet != pdFALSE )
 401              		.loc 1 291 0
 402 006c BB69     		ldr	r3, [r7, #24]
 403 006e 002B     		cmp	r3, #0
 404 0070 0ED0     		beq	.L30
 292:../Generated_Code/event_groups.c ****                 {
 293:../Generated_Code/event_groups.c ****                         /* The wait condition has already been met so there is no need to
 294:../Generated_Code/event_groups.c ****                         block. */
 295:../Generated_Code/event_groups.c ****                         uxReturn = uxCurrentEventBits;
 405              		.loc 1 295 0
 406 0072 FB69     		ldr	r3, [r7, #28]
 407 0074 FB62     		str	r3, [r7, #44]
 296:../Generated_Code/event_groups.c ****                         xTicksToWait = ( TickType_t ) 0;
 408              		.loc 1 296 0
 409 0076 0023     		mov	r3, #0
 410 0078 BB63     		str	r3, [r7, #56]
 297:../Generated_Code/event_groups.c **** 
 298:../Generated_Code/event_groups.c ****                         /* Clear the wait bits if requested to do so. */
 299:../Generated_Code/event_groups.c ****                         if( xClearOnExit != pdFALSE )
 411              		.loc 1 299 0
 412 007a 7B68     		ldr	r3, [r7, #4]
 413 007c 002B     		cmp	r3, #0
 414 007e 2AD0     		beq	.L31
 300:../Generated_Code/event_groups.c ****                         {
 301:../Generated_Code/event_groups.c ****                                 pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 415              		.loc 1 301 0
 416 0080 7B6A     		ldr	r3, [r7, #36]
 417 0082 1B68     		ldr	r3, [r3]
 418 0084 BA68     		ldr	r2, [r7, #8]
 419 0086 D243     		mvn	r2, r2
 420 0088 1A40     		and	r2, r3
 421 008a 7B6A     		ldr	r3, [r7, #36]
 422 008c 1A60     		str	r2, [r3]
 423 008e 22E0     		b	.L31
 424              	.L30:
 302:../Generated_Code/event_groups.c ****                         }
 303:../Generated_Code/event_groups.c ****                         else
 304:../Generated_Code/event_groups.c ****                         {
 305:../Generated_Code/event_groups.c ****                                 mtCOVERAGE_TEST_MARKER();
 306:../Generated_Code/event_groups.c ****                         }
 307:../Generated_Code/event_groups.c ****                 }
 308:../Generated_Code/event_groups.c ****                 else if( xTicksToWait == ( TickType_t ) 0 )
 425              		.loc 1 308 0
 426 0090 BB6B     		ldr	r3, [r7, #56]
 427 0092 002B     		cmp	r3, #0
 428 0094 02D1     		bne	.L32
 309:../Generated_Code/event_groups.c ****                 {
 310:../Generated_Code/event_groups.c ****                         /* The wait condition has not been met, but no block time was
 311:../Generated_Code/event_groups.c ****                         specified, so just return the current value. */
 312:../Generated_Code/event_groups.c ****                         uxReturn = uxCurrentEventBits;
 429              		.loc 1 312 0
 430 0096 FB69     		ldr	r3, [r7, #28]
 431 0098 FB62     		str	r3, [r7, #44]
 432 009a 1CE0     		b	.L31
 433              	.L32:
 313:../Generated_Code/event_groups.c ****                 }
 314:../Generated_Code/event_groups.c ****                 else
 315:../Generated_Code/event_groups.c ****                 {
 316:../Generated_Code/event_groups.c ****                         /* The task is going to block to wait for its required bits to be
 317:../Generated_Code/event_groups.c ****                         set.  uxControlBits are used to remember the specified behaviour of
 318:../Generated_Code/event_groups.c ****                         this call to xEventGroupWaitBits() - for use when the event bits
 319:../Generated_Code/event_groups.c ****                         unblock the task. */
 320:../Generated_Code/event_groups.c ****                         if( xClearOnExit != pdFALSE )
 434              		.loc 1 320 0
 435 009c 7B68     		ldr	r3, [r7, #4]
 436 009e 002B     		cmp	r3, #0
 437 00a0 04D0     		beq	.L33
 321:../Generated_Code/event_groups.c ****                         {
 322:../Generated_Code/event_groups.c ****                                 uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 438              		.loc 1 322 0
 439 00a2 BB6A     		ldr	r3, [r7, #40]
 440 00a4 8022     		mov	r2, #128
 441 00a6 5204     		lsl	r2, r2, #17
 442 00a8 1343     		orr	r3, r2
 443 00aa BB62     		str	r3, [r7, #40]
 444              	.L33:
 323:../Generated_Code/event_groups.c ****                         }
 324:../Generated_Code/event_groups.c ****                         else
 325:../Generated_Code/event_groups.c ****                         {
 326:../Generated_Code/event_groups.c ****                                 mtCOVERAGE_TEST_MARKER();
 327:../Generated_Code/event_groups.c ****                         }
 328:../Generated_Code/event_groups.c **** 
 329:../Generated_Code/event_groups.c ****                         if( xWaitForAllBits != pdFALSE )
 445              		.loc 1 329 0
 446 00ac 3B68     		ldr	r3, [r7]
 447 00ae 002B     		cmp	r3, #0
 448 00b0 04D0     		beq	.L34
 330:../Generated_Code/event_groups.c ****                         {
 331:../Generated_Code/event_groups.c ****                                 uxControlBits |= eventWAIT_FOR_ALL_BITS;
 449              		.loc 1 331 0
 450 00b2 BB6A     		ldr	r3, [r7, #40]
 451 00b4 8022     		mov	r2, #128
 452 00b6 D204     		lsl	r2, r2, #19
 453 00b8 1343     		orr	r3, r2
 454 00ba BB62     		str	r3, [r7, #40]
 455              	.L34:
 332:../Generated_Code/event_groups.c ****                         }
 333:../Generated_Code/event_groups.c ****                         else
 334:../Generated_Code/event_groups.c ****                         {
 335:../Generated_Code/event_groups.c ****                                 mtCOVERAGE_TEST_MARKER();
 336:../Generated_Code/event_groups.c ****                         }
 337:../Generated_Code/event_groups.c **** 
 338:../Generated_Code/event_groups.c ****                         /* Store the bits that the calling task is waiting for in the
 339:../Generated_Code/event_groups.c ****                         task's event list item so the kernel knows when a match is
 340:../Generated_Code/event_groups.c ****                         found.  Then enter the blocked state. */
 341:../Generated_Code/event_groups.c ****                         vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( u
 456              		.loc 1 341 0
 457 00bc 7B6A     		ldr	r3, [r7, #36]
 458 00be 191D     		add	r1, r3, #4
 459 00c0 BA68     		ldr	r2, [r7, #8]
 460 00c2 BB6A     		ldr	r3, [r7, #40]
 461 00c4 1A43     		orr	r2, r3
 462 00c6 BB6B     		ldr	r3, [r7, #56]
 463 00c8 081C     		mov	r0, r1
 464 00ca 111C     		mov	r1, r2
 465 00cc 1A1C     		mov	r2, r3
 466 00ce FFF7FEFF 		bl	vTaskPlaceOnUnorderedEventList
 342:../Generated_Code/event_groups.c **** 
 343:../Generated_Code/event_groups.c ****                         /* This is obsolete as it will get set after the task unblocks, but
 344:../Generated_Code/event_groups.c ****                         some compilers mistakenly generate a warning about the variable
 345:../Generated_Code/event_groups.c ****                         being returned without being set if it is not done. */
 346:../Generated_Code/event_groups.c ****                         uxReturn = 0;
 467              		.loc 1 346 0
 468 00d2 0023     		mov	r3, #0
 469 00d4 FB62     		str	r3, [r7, #44]
 470              	.L31:
 471              	.LBE5:
 347:../Generated_Code/event_groups.c **** 
 348:../Generated_Code/event_groups.c ****                         traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
 349:../Generated_Code/event_groups.c ****                 }
 350:../Generated_Code/event_groups.c ****         }
 351:../Generated_Code/event_groups.c ****         xAlreadyYielded = xTaskResumeAll();
 472              		.loc 1 351 0
 473 00d6 FFF7FEFF 		bl	xTaskResumeAll
 474 00da 031C     		mov	r3, r0
 475 00dc 7B61     		str	r3, [r7, #20]
 352:../Generated_Code/event_groups.c **** 
 353:../Generated_Code/event_groups.c ****         if( xTicksToWait != ( TickType_t ) 0 )
 476              		.loc 1 353 0
 477 00de BB6B     		ldr	r3, [r7, #56]
 478 00e0 002B     		cmp	r3, #0
 479 00e2 33D0     		beq	.L35
 354:../Generated_Code/event_groups.c ****         {
 355:../Generated_Code/event_groups.c ****                 if( xAlreadyYielded == pdFALSE )
 480              		.loc 1 355 0
 481 00e4 7B69     		ldr	r3, [r7, #20]
 482 00e6 002B     		cmp	r3, #0
 483 00e8 01D1     		bne	.L36
 356:../Generated_Code/event_groups.c ****                 {
 357:../Generated_Code/event_groups.c ****                         portYIELD_WITHIN_API();
 484              		.loc 1 357 0
 485 00ea FFF7FEFF 		bl	vPortYieldFromISR
 486              	.L36:
 358:../Generated_Code/event_groups.c ****                 }
 359:../Generated_Code/event_groups.c ****                 else
 360:../Generated_Code/event_groups.c ****                 {
 361:../Generated_Code/event_groups.c ****                         mtCOVERAGE_TEST_MARKER();
 362:../Generated_Code/event_groups.c ****                 }
 363:../Generated_Code/event_groups.c **** 
 364:../Generated_Code/event_groups.c ****                 /* The task blocked to wait for its required bits to be set - at this
 365:../Generated_Code/event_groups.c ****                 point either the required bits were set or the block time expired.  If
 366:../Generated_Code/event_groups.c ****                 the required bits were set they will have been stored in the task's
 367:../Generated_Code/event_groups.c ****                 event list item, and they should now be retrieved then cleared. */
 368:../Generated_Code/event_groups.c ****                 uxReturn = uxTaskResetEventItemValue();
 487              		.loc 1 368 0
 488 00ee FFF7FEFF 		bl	uxTaskResetEventItemValue
 489 00f2 031C     		mov	r3, r0
 490 00f4 FB62     		str	r3, [r7, #44]
 369:../Generated_Code/event_groups.c **** 
 370:../Generated_Code/event_groups.c ****                 if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 491              		.loc 1 370 0
 492 00f6 FA6A     		ldr	r2, [r7, #44]
 493 00f8 8023     		mov	r3, #128
 494 00fa 9B04     		lsl	r3, r3, #18
 495 00fc 1340     		and	r3, r2
 496 00fe 21D1     		bne	.L37
 371:../Generated_Code/event_groups.c ****                 {
 372:../Generated_Code/event_groups.c ****                         taskENTER_CRITICAL();
 497              		.loc 1 372 0
 498 0100 FFF7FEFF 		bl	vPortEnterCritical
 373:../Generated_Code/event_groups.c ****                         {
 374:../Generated_Code/event_groups.c ****                                 /* The task timed out, just return the current event bit value. */
 375:../Generated_Code/event_groups.c ****                                 uxReturn = pxEventBits->uxEventBits;
 499              		.loc 1 375 0
 500 0104 7B6A     		ldr	r3, [r7, #36]
 501 0106 1B68     		ldr	r3, [r3]
 502 0108 FB62     		str	r3, [r7, #44]
 376:../Generated_Code/event_groups.c **** 
 377:../Generated_Code/event_groups.c ****                                 /* It is possible that the event bits were updated between this
 378:../Generated_Code/event_groups.c ****                                 task leaving the Blocked state and running again. */
 379:../Generated_Code/event_groups.c ****                                 if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBit
 503              		.loc 1 379 0
 504 010a F96A     		ldr	r1, [r7, #44]
 505 010c BA68     		ldr	r2, [r7, #8]
 506 010e 3B68     		ldr	r3, [r7]
 507 0110 081C     		mov	r0, r1
 508 0112 111C     		mov	r1, r2
 509 0114 1A1C     		mov	r2, r3
 510 0116 FFF7FEFF 		bl	_ZL20prvTestWaitConditionmml
 511 011a 031C     		mov	r3, r0
 512 011c 5A1E     		sub	r2, r3, #1
 513 011e 9341     		sbc	r3, r3, r2
 514 0120 DBB2     		uxtb	r3, r3
 515 0122 002B     		cmp	r3, #0
 516 0124 09D0     		beq	.L38
 380:../Generated_Code/event_groups.c ****                                 {
 381:../Generated_Code/event_groups.c ****                                         if( xClearOnExit != pdFALSE )
 517              		.loc 1 381 0
 518 0126 7B68     		ldr	r3, [r7, #4]
 519 0128 002B     		cmp	r3, #0
 520 012a 06D0     		beq	.L38
 382:../Generated_Code/event_groups.c ****                                         {
 383:../Generated_Code/event_groups.c ****                                                 pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 521              		.loc 1 383 0
 522 012c 7B6A     		ldr	r3, [r7, #36]
 523 012e 1B68     		ldr	r3, [r3]
 524 0130 BA68     		ldr	r2, [r7, #8]
 525 0132 D243     		mvn	r2, r2
 526 0134 1A40     		and	r2, r3
 527 0136 7B6A     		ldr	r3, [r7, #36]
 528 0138 1A60     		str	r2, [r3]
 529              	.L38:
 384:../Generated_Code/event_groups.c ****                                         }
 385:../Generated_Code/event_groups.c ****                                         else
 386:../Generated_Code/event_groups.c ****                                         {
 387:../Generated_Code/event_groups.c ****                                                 mtCOVERAGE_TEST_MARKER();
 388:../Generated_Code/event_groups.c ****                                         }
 389:../Generated_Code/event_groups.c ****                                 }
 390:../Generated_Code/event_groups.c ****                                 else
 391:../Generated_Code/event_groups.c ****                                 {
 392:../Generated_Code/event_groups.c ****                                         mtCOVERAGE_TEST_MARKER();
 393:../Generated_Code/event_groups.c ****                                 }
 394:../Generated_Code/event_groups.c ****                         }
 395:../Generated_Code/event_groups.c ****                         taskEXIT_CRITICAL();
 530              		.loc 1 395 0
 531 013a FFF7FEFF 		bl	vPortExitCritical
 396:../Generated_Code/event_groups.c **** 
 397:../Generated_Code/event_groups.c ****                         xTimeoutOccurred = pdFALSE;
 532              		.loc 1 397 0
 533 013e 0023     		mov	r3, #0
 534 0140 3B62     		str	r3, [r7, #32]
 535 0142 03E0     		b	.L35
 536              	.L37:
 398:../Generated_Code/event_groups.c ****                 }
 399:../Generated_Code/event_groups.c ****                 else
 400:../Generated_Code/event_groups.c ****                 {
 401:../Generated_Code/event_groups.c ****                         /* The task unblocked because the bits were set.  Clear the control
 402:../Generated_Code/event_groups.c ****                         bits before returning the value. */
 403:../Generated_Code/event_groups.c ****                         uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 537              		.loc 1 403 0
 538 0144 FB6A     		ldr	r3, [r7, #44]
 539 0146 1B02     		lsl	r3, r3, #8
 540 0148 1B0A     		lsr	r3, r3, #8
 541 014a FB62     		str	r3, [r7, #44]
 542              	.L35:
 404:../Generated_Code/event_groups.c ****                 }
 405:../Generated_Code/event_groups.c ****         }
 406:../Generated_Code/event_groups.c ****         traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
 407:../Generated_Code/event_groups.c ****         return uxReturn;
 543              		.loc 1 407 0
 544 014c FB6A     		ldr	r3, [r7, #44]
 545              	.LBE4:
 408:../Generated_Code/event_groups.c **** }
 546              		.loc 1 408 0
 547 014e 181C     		mov	r0, r3
 548 0150 BD46     		mov	sp, r7
 549 0152 0CB0     		add	sp, sp, #48
 550              		@ sp needed for prologue
 551 0154 80BD     		pop	{r7, pc}
 552              		.cfi_endproc
 553              	.LFE6:
 555 0156 C046     		.section	.text.xEventGroupClearBits,"ax",%progbits
 556              		.align	2
 557              		.global	xEventGroupClearBits
 558              		.code	16
 559              		.thumb_func
 561              	xEventGroupClearBits:
 562              	.LFB7:
 409:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 410:../Generated_Code/event_groups.c **** 
 411:../Generated_Code/event_groups.c **** EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
 412:../Generated_Code/event_groups.c **** {
 563              		.loc 1 412 0
 564              		.cfi_startproc
 565 0000 80B5     		push	{r7, lr}
 566              	.LCFI9:
 567              		.cfi_def_cfa_offset 8
 568              		.cfi_offset 7, -8
 569              		.cfi_offset 14, -4
 570 0002 84B0     		sub	sp, sp, #16
 571              	.LCFI10:
 572              		.cfi_def_cfa_offset 24
 573 0004 00AF     		add	r7, sp, #0
 574              	.LCFI11:
 575              		.cfi_def_cfa_register 7
 576 0006 7860     		str	r0, [r7, #4]
 577 0008 3960     		str	r1, [r7]
 578              	.LBB6:
 413:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 579              		.loc 1 413 0
 580 000a 7B68     		ldr	r3, [r7, #4]
 581 000c FB60     		str	r3, [r7, #12]
 414:../Generated_Code/event_groups.c **** EventBits_t uxReturn;
 415:../Generated_Code/event_groups.c **** 
 416:../Generated_Code/event_groups.c ****         /* Check the user is not attempting to clear the bits used by the kernel
 417:../Generated_Code/event_groups.c ****         itself. */
 418:../Generated_Code/event_groups.c ****         configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 582              		.loc 1 418 0
 583 000e 3B68     		ldr	r3, [r7]
 584 0010 1B0E     		lsr	r3, r3, #24
 585 0012 1B06     		lsl	r3, r3, #24
 586 0014 01D0     		beq	.L41
 587              		.loc 1 418 0 is_stmt 0
 588              	@ 418 "../Generated_Code/event_groups.c" 1
 589 0016 72B6     		cpsid i
 590              	@ 0 "" 2
 591              		.code	16
 592              	.L42:
 593              		.loc 1 418 0
 594 0018 FEE7     		b	.L42
 595              	.L41:
 419:../Generated_Code/event_groups.c **** 
 420:../Generated_Code/event_groups.c ****         taskENTER_CRITICAL();
 596              		.loc 1 420 0 is_stmt 1
 597 001a FFF7FEFF 		bl	vPortEnterCritical
 421:../Generated_Code/event_groups.c ****         {
 422:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
 423:../Generated_Code/event_groups.c **** 
 424:../Generated_Code/event_groups.c ****                 /* The value returned is the event group value prior to the bits being
 425:../Generated_Code/event_groups.c ****                 cleared. */
 426:../Generated_Code/event_groups.c ****                 uxReturn = pxEventBits->uxEventBits;
 598              		.loc 1 426 0
 599 001e FB68     		ldr	r3, [r7, #12]
 600 0020 1B68     		ldr	r3, [r3]
 601 0022 BB60     		str	r3, [r7, #8]
 427:../Generated_Code/event_groups.c **** 
 428:../Generated_Code/event_groups.c ****                 /* Clear the bits. */
 429:../Generated_Code/event_groups.c ****                 pxEventBits->uxEventBits &= ~uxBitsToClear;
 602              		.loc 1 429 0
 603 0024 FB68     		ldr	r3, [r7, #12]
 604 0026 1B68     		ldr	r3, [r3]
 605 0028 3A68     		ldr	r2, [r7]
 606 002a D243     		mvn	r2, r2
 607 002c 1A40     		and	r2, r3
 608 002e FB68     		ldr	r3, [r7, #12]
 609 0030 1A60     		str	r2, [r3]
 430:../Generated_Code/event_groups.c ****         }
 431:../Generated_Code/event_groups.c ****         taskEXIT_CRITICAL();
 610              		.loc 1 431 0
 611 0032 FFF7FEFF 		bl	vPortExitCritical
 432:../Generated_Code/event_groups.c **** 
 433:../Generated_Code/event_groups.c ****         return uxReturn;
 612              		.loc 1 433 0
 613 0036 BB68     		ldr	r3, [r7, #8]
 614              	.LBE6:
 434:../Generated_Code/event_groups.c **** }
 615              		.loc 1 434 0
 616 0038 181C     		mov	r0, r3
 617 003a BD46     		mov	sp, r7
 618 003c 04B0     		add	sp, sp, #16
 619              		@ sp needed for prologue
 620 003e 80BD     		pop	{r7, pc}
 621              		.cfi_endproc
 622              	.LFE7:
 624              		.section	.text.xEventGroupClearBitsFromISR,"ax",%progbits
 625              		.align	2
 626              		.global	xEventGroupClearBitsFromISR
 627              		.code	16
 628              		.thumb_func
 630              	xEventGroupClearBitsFromISR:
 631              	.LFB8:
 435:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 436:../Generated_Code/event_groups.c **** 
 437:../Generated_Code/event_groups.c **** EventBits_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsTo
 438:../Generated_Code/event_groups.c **** {
 632              		.loc 1 438 0
 633              		.cfi_startproc
 634 0000 80B5     		push	{r7, lr}
 635              	.LCFI12:
 636              		.cfi_def_cfa_offset 8
 637              		.cfi_offset 7, -8
 638              		.cfi_offset 14, -4
 639 0002 86B0     		sub	sp, sp, #24
 640              	.LCFI13:
 641              		.cfi_def_cfa_offset 32
 642 0004 00AF     		add	r7, sp, #0
 643              	.LCFI14:
 644              		.cfi_def_cfa_register 7
 645 0006 7860     		str	r0, [r7, #4]
 646 0008 3960     		str	r1, [r7]
 647              	.LBB7:
 439:../Generated_Code/event_groups.c **** UBaseType_t uxSavedInterruptStatus;
 440:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 648              		.loc 1 440 0
 649 000a 7B68     		ldr	r3, [r7, #4]
 650 000c 7B61     		str	r3, [r7, #20]
 441:../Generated_Code/event_groups.c **** EventBits_t uxReturn;
 442:../Generated_Code/event_groups.c **** 
 443:../Generated_Code/event_groups.c ****         /* Check the user is not attempting to clear the bits used by the kernel
 444:../Generated_Code/event_groups.c ****         itself. */
 445:../Generated_Code/event_groups.c ****         configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 651              		.loc 1 445 0
 652 000e 3B68     		ldr	r3, [r7]
 653 0010 1B0E     		lsr	r3, r3, #24
 654 0012 1B06     		lsl	r3, r3, #24
 655 0014 01D0     		beq	.L45
 656              		.loc 1 445 0 is_stmt 0
 657              	@ 445 "../Generated_Code/event_groups.c" 1
 658 0016 72B6     		cpsid i
 659              	@ 0 "" 2
 660              		.code	16
 661              	.L46:
 662              		.loc 1 445 0
 663 0018 FEE7     		b	.L46
 664              	.L45:
 446:../Generated_Code/event_groups.c **** 
 447:../Generated_Code/event_groups.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 665              		.loc 1 447 0 is_stmt 1
 666 001a 0023     		mov	r3, #0
 667 001c 3B61     		str	r3, [r7, #16]
 668              	@ 447 "../Generated_Code/event_groups.c" 1
 669 001e 72B6     		cpsid i
 670              	@ 0 "" 2
 448:../Generated_Code/event_groups.c ****         {
 449:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
 450:../Generated_Code/event_groups.c **** 
 451:../Generated_Code/event_groups.c ****                 /* The value returned is the event group value prior to the bits being
 452:../Generated_Code/event_groups.c ****                 cleared. */
 453:../Generated_Code/event_groups.c ****                 uxReturn = pxEventBits->uxEventBits;
 671              		.loc 1 453 0
 672              		.code	16
 673 0020 7B69     		ldr	r3, [r7, #20]
 674 0022 1B68     		ldr	r3, [r3]
 675 0024 FB60     		str	r3, [r7, #12]
 454:../Generated_Code/event_groups.c **** 
 455:../Generated_Code/event_groups.c ****                 /* Clear the bits. */
 456:../Generated_Code/event_groups.c ****                 pxEventBits->uxEventBits &= ~uxBitsToClear;
 676              		.loc 1 456 0
 677 0026 7B69     		ldr	r3, [r7, #20]
 678 0028 1B68     		ldr	r3, [r3]
 679 002a 3A68     		ldr	r2, [r7]
 680 002c D243     		mvn	r2, r2
 681 002e 1A40     		and	r2, r3
 682 0030 7B69     		ldr	r3, [r7, #20]
 683 0032 1A60     		str	r2, [r3]
 457:../Generated_Code/event_groups.c ****         }
 458:../Generated_Code/event_groups.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 684              		.loc 1 458 0
 685              	@ 458 "../Generated_Code/event_groups.c" 1
 686 0034 62B6     		cpsie i
 687              	@ 0 "" 2
 459:../Generated_Code/event_groups.c **** 
 460:../Generated_Code/event_groups.c ****         return uxReturn;
 688              		.loc 1 460 0
 689              		.code	16
 690 0036 FB68     		ldr	r3, [r7, #12]
 691              	.LBE7:
 461:../Generated_Code/event_groups.c **** }
 692              		.loc 1 461 0
 693 0038 181C     		mov	r0, r3
 694 003a BD46     		mov	sp, r7
 695 003c 06B0     		add	sp, sp, #24
 696              		@ sp needed for prologue
 697 003e 80BD     		pop	{r7, pc}
 698              		.cfi_endproc
 699              	.LFE8:
 701              		.section	.text.xEventGroupSetBits,"ax",%progbits
 702              		.align	2
 703              		.global	xEventGroupSetBits
 704              		.code	16
 705              		.thumb_func
 707              	xEventGroupSetBits:
 708              	.LFB9:
 462:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 463:../Generated_Code/event_groups.c **** 
 464:../Generated_Code/event_groups.c **** EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
 465:../Generated_Code/event_groups.c **** {
 709              		.loc 1 465 0
 710              		.cfi_startproc
 711 0000 80B5     		push	{r7, lr}
 712              	.LCFI15:
 713              		.cfi_def_cfa_offset 8
 714              		.cfi_offset 7, -8
 715              		.cfi_offset 14, -4
 716 0002 8CB0     		sub	sp, sp, #48
 717              	.LCFI16:
 718              		.cfi_def_cfa_offset 56
 719 0004 00AF     		add	r7, sp, #0
 720              	.LCFI17:
 721              		.cfi_def_cfa_register 7
 722 0006 7860     		str	r0, [r7, #4]
 723 0008 3960     		str	r1, [r7]
 724              	.LBB8:
 466:../Generated_Code/event_groups.c **** ListItem_t *pxListItem, *pxNext;
 467:../Generated_Code/event_groups.c **** ListItem_t const *pxListEnd;
 468:../Generated_Code/event_groups.c **** List_t *pxList;
 469:../Generated_Code/event_groups.c **** EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 725              		.loc 1 469 0
 726 000a 0023     		mov	r3, #0
 727 000c BB62     		str	r3, [r7, #40]
 470:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 728              		.loc 1 470 0
 729 000e 7B68     		ldr	r3, [r7, #4]
 730 0010 3B62     		str	r3, [r7, #32]
 471:../Generated_Code/event_groups.c **** BaseType_t xMatchFound = pdFALSE;
 731              		.loc 1 471 0
 732 0012 0023     		mov	r3, #0
 733 0014 7B62     		str	r3, [r7, #36]
 472:../Generated_Code/event_groups.c **** 
 473:../Generated_Code/event_groups.c ****         /* Check the user is not attempting to set the bits used by the kernel
 474:../Generated_Code/event_groups.c ****         itself. */
 475:../Generated_Code/event_groups.c ****         configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 734              		.loc 1 475 0
 735 0016 3B68     		ldr	r3, [r7]
 736 0018 1B0E     		lsr	r3, r3, #24
 737 001a 1B06     		lsl	r3, r3, #24
 738 001c 01D0     		beq	.L49
 739              		.loc 1 475 0 is_stmt 0
 740              	@ 475 "../Generated_Code/event_groups.c" 1
 741 001e 72B6     		cpsid i
 742              	@ 0 "" 2
 743              		.code	16
 744              	.L50:
 745              		.loc 1 475 0
 746 0020 FEE7     		b	.L50
 747              	.L49:
 476:../Generated_Code/event_groups.c **** 
 477:../Generated_Code/event_groups.c ****         pxList = &( pxEventBits->xTasksWaitingForBits );
 748              		.loc 1 477 0 is_stmt 1
 749 0022 3B6A     		ldr	r3, [r7, #32]
 750 0024 0433     		add	r3, r3, #4
 751 0026 FB61     		str	r3, [r7, #28]
 478:../Generated_Code/event_groups.c ****         pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is use
 752              		.loc 1 478 0
 753 0028 FB69     		ldr	r3, [r7, #28]
 754 002a 0833     		add	r3, r3, #8
 755 002c BB61     		str	r3, [r7, #24]
 479:../Generated_Code/event_groups.c ****         vTaskSuspendAll();
 756              		.loc 1 479 0
 757 002e FFF7FEFF 		bl	vTaskSuspendAll
 480:../Generated_Code/event_groups.c ****         {
 481:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
 482:../Generated_Code/event_groups.c **** 
 483:../Generated_Code/event_groups.c ****                 pxListItem = listGET_HEAD_ENTRY( pxList );
 758              		.loc 1 483 0
 759 0032 FB69     		ldr	r3, [r7, #28]
 760 0034 DB68     		ldr	r3, [r3, #12]
 761 0036 FB62     		str	r3, [r7, #44]
 484:../Generated_Code/event_groups.c **** 
 485:../Generated_Code/event_groups.c ****                 /* Set the bits. */
 486:../Generated_Code/event_groups.c ****                 pxEventBits->uxEventBits |= uxBitsToSet;
 762              		.loc 1 486 0
 763 0038 3B6A     		ldr	r3, [r7, #32]
 764 003a 1A68     		ldr	r2, [r3]
 765 003c 3B68     		ldr	r3, [r7]
 766 003e 1A43     		orr	r2, r3
 767 0040 3B6A     		ldr	r3, [r7, #32]
 768 0042 1A60     		str	r2, [r3]
 487:../Generated_Code/event_groups.c **** 
 488:../Generated_Code/event_groups.c ****                 /* See if the new bit value should unblock any tasks. */
 489:../Generated_Code/event_groups.c ****                 while( pxListItem != pxListEnd )
 769              		.loc 1 489 0
 770 0044 3DE0     		b	.L51
 771              	.L56:
 490:../Generated_Code/event_groups.c ****                 {
 491:../Generated_Code/event_groups.c ****                         pxNext = listGET_NEXT( pxListItem );
 772              		.loc 1 491 0
 773 0046 FB6A     		ldr	r3, [r7, #44]
 774 0048 5B68     		ldr	r3, [r3, #4]
 775 004a 7B61     		str	r3, [r7, #20]
 492:../Generated_Code/event_groups.c ****                         uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 776              		.loc 1 492 0
 777 004c FB6A     		ldr	r3, [r7, #44]
 778 004e 1B68     		ldr	r3, [r3]
 779 0050 3B61     		str	r3, [r7, #16]
 493:../Generated_Code/event_groups.c ****                         xMatchFound = pdFALSE;
 780              		.loc 1 493 0
 781 0052 0023     		mov	r3, #0
 782 0054 7B62     		str	r3, [r7, #36]
 494:../Generated_Code/event_groups.c **** 
 495:../Generated_Code/event_groups.c ****                         /* Split the bits waited for from the control bits. */
 496:../Generated_Code/event_groups.c ****                         uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 783              		.loc 1 496 0
 784 0056 3B69     		ldr	r3, [r7, #16]
 785 0058 1B0E     		lsr	r3, r3, #24
 786 005a 1B06     		lsl	r3, r3, #24
 787 005c FB60     		str	r3, [r7, #12]
 497:../Generated_Code/event_groups.c ****                         uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 788              		.loc 1 497 0
 789 005e 3B69     		ldr	r3, [r7, #16]
 790 0060 1B02     		lsl	r3, r3, #8
 791 0062 1B0A     		lsr	r3, r3, #8
 792 0064 3B61     		str	r3, [r7, #16]
 498:../Generated_Code/event_groups.c **** 
 499:../Generated_Code/event_groups.c ****                         if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 793              		.loc 1 499 0
 794 0066 FA68     		ldr	r2, [r7, #12]
 795 0068 8023     		mov	r3, #128
 796 006a DB04     		lsl	r3, r3, #19
 797 006c 1340     		and	r3, r2
 798 006e 07D1     		bne	.L52
 500:../Generated_Code/event_groups.c ****                         {
 501:../Generated_Code/event_groups.c ****                                 /* Just looking for single bit being set. */
 502:../Generated_Code/event_groups.c ****                                 if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t
 799              		.loc 1 502 0
 800 0070 3B6A     		ldr	r3, [r7, #32]
 801 0072 1B68     		ldr	r3, [r3]
 802 0074 3A69     		ldr	r2, [r7, #16]
 803 0076 1340     		and	r3, r2
 804 0078 0BD0     		beq	.L53
 503:../Generated_Code/event_groups.c ****                                 {
 504:../Generated_Code/event_groups.c ****                                         xMatchFound = pdTRUE;
 805              		.loc 1 504 0
 806 007a 0123     		mov	r3, #1
 807 007c 7B62     		str	r3, [r7, #36]
 808 007e 08E0     		b	.L53
 809              	.L52:
 505:../Generated_Code/event_groups.c ****                                 }
 506:../Generated_Code/event_groups.c ****                                 else
 507:../Generated_Code/event_groups.c ****                                 {
 508:../Generated_Code/event_groups.c ****                                         mtCOVERAGE_TEST_MARKER();
 509:../Generated_Code/event_groups.c ****                                 }
 510:../Generated_Code/event_groups.c ****                         }
 511:../Generated_Code/event_groups.c ****                         else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor 
 810              		.loc 1 511 0
 811 0080 3B6A     		ldr	r3, [r7, #32]
 812 0082 1B68     		ldr	r3, [r3]
 813 0084 3A69     		ldr	r2, [r7, #16]
 814 0086 1A40     		and	r2, r3
 815 0088 3B69     		ldr	r3, [r7, #16]
 816 008a 9A42     		cmp	r2, r3
 817 008c 01D1     		bne	.L53
 512:../Generated_Code/event_groups.c ****                         {
 513:../Generated_Code/event_groups.c ****                                 /* All bits are set. */
 514:../Generated_Code/event_groups.c ****                                 xMatchFound = pdTRUE;
 818              		.loc 1 514 0
 819 008e 0123     		mov	r3, #1
 820 0090 7B62     		str	r3, [r7, #36]
 821              	.L53:
 515:../Generated_Code/event_groups.c ****                         }
 516:../Generated_Code/event_groups.c ****                         else
 517:../Generated_Code/event_groups.c ****                         {
 518:../Generated_Code/event_groups.c ****                                 /* Need all bits to be set, but not all the bits were set. */
 519:../Generated_Code/event_groups.c ****                         }
 520:../Generated_Code/event_groups.c **** 
 521:../Generated_Code/event_groups.c ****                         if( xMatchFound != pdFALSE )
 822              		.loc 1 521 0
 823 0092 7B6A     		ldr	r3, [r7, #36]
 824 0094 002B     		cmp	r3, #0
 825 0096 12D0     		beq	.L54
 522:../Generated_Code/event_groups.c ****                         {
 523:../Generated_Code/event_groups.c ****                                 /* The bits match.  Should the bits be cleared on exit? */
 524:../Generated_Code/event_groups.c ****                                 if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBit
 826              		.loc 1 524 0
 827 0098 FA68     		ldr	r2, [r7, #12]
 828 009a 8023     		mov	r3, #128
 829 009c 5B04     		lsl	r3, r3, #17
 830 009e 1340     		and	r3, r2
 831 00a0 03D0     		beq	.L55
 525:../Generated_Code/event_groups.c ****                                 {
 526:../Generated_Code/event_groups.c ****                                         uxBitsToClear |= uxBitsWaitedFor;
 832              		.loc 1 526 0
 833 00a2 BA6A     		ldr	r2, [r7, #40]
 834 00a4 3B69     		ldr	r3, [r7, #16]
 835 00a6 1343     		orr	r3, r2
 836 00a8 BB62     		str	r3, [r7, #40]
 837              	.L55:
 527:../Generated_Code/event_groups.c ****                                 }
 528:../Generated_Code/event_groups.c ****                                 else
 529:../Generated_Code/event_groups.c ****                                 {
 530:../Generated_Code/event_groups.c ****                                         mtCOVERAGE_TEST_MARKER();
 531:../Generated_Code/event_groups.c ****                                 }
 532:../Generated_Code/event_groups.c **** 
 533:../Generated_Code/event_groups.c ****                                 /* Store the actual event flag value in the task's event list
 534:../Generated_Code/event_groups.c ****                                 item before removing the task from the event list.  The
 535:../Generated_Code/event_groups.c ****                                 eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
 536:../Generated_Code/event_groups.c ****                                 that is was unblocked due to its required bits matching, rather
 537:../Generated_Code/event_groups.c ****                                 than because it timed out. */
 538:../Generated_Code/event_groups.c ****                                 ( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits
 838              		.loc 1 538 0
 839 00aa 3B6A     		ldr	r3, [r7, #32]
 840 00ac 1B68     		ldr	r3, [r3]
 841 00ae 8022     		mov	r2, #128
 842 00b0 9204     		lsl	r2, r2, #18
 843 00b2 1343     		orr	r3, r2
 844 00b4 FA6A     		ldr	r2, [r7, #44]
 845 00b6 101C     		mov	r0, r2
 846 00b8 191C     		mov	r1, r3
 847 00ba FFF7FEFF 		bl	xTaskRemoveFromUnorderedEventList
 848              	.L54:
 539:../Generated_Code/event_groups.c ****                         }
 540:../Generated_Code/event_groups.c **** 
 541:../Generated_Code/event_groups.c ****                         /* Move onto the next list item.  Note pxListItem->pxNext is not
 542:../Generated_Code/event_groups.c ****                         used here as the list item may have been removed from the event list
 543:../Generated_Code/event_groups.c ****                         and inserted into the ready/pending reading list. */
 544:../Generated_Code/event_groups.c ****                         pxListItem = pxNext;
 849              		.loc 1 544 0
 850 00be 7B69     		ldr	r3, [r7, #20]
 851 00c0 FB62     		str	r3, [r7, #44]
 852              	.L51:
 489:../Generated_Code/event_groups.c ****                 while( pxListItem != pxListEnd )
 853              		.loc 1 489 0
 854 00c2 FA6A     		ldr	r2, [r7, #44]
 855 00c4 BB69     		ldr	r3, [r7, #24]
 856 00c6 D31A     		sub	r3, r2, r3
 857 00c8 5A1E     		sub	r2, r3, #1
 858 00ca 9341     		sbc	r3, r3, r2
 859 00cc DBB2     		uxtb	r3, r3
 860 00ce 002B     		cmp	r3, #0
 861 00d0 B9D1     		bne	.L56
 545:../Generated_Code/event_groups.c ****                 }
 546:../Generated_Code/event_groups.c **** 
 547:../Generated_Code/event_groups.c ****                 /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
 548:../Generated_Code/event_groups.c ****                 bit was set in the control word. */
 549:../Generated_Code/event_groups.c ****                 pxEventBits->uxEventBits &= ~uxBitsToClear;
 862              		.loc 1 549 0
 863 00d2 3B6A     		ldr	r3, [r7, #32]
 864 00d4 1B68     		ldr	r3, [r3]
 865 00d6 BA6A     		ldr	r2, [r7, #40]
 866 00d8 D243     		mvn	r2, r2
 867 00da 1A40     		and	r2, r3
 868 00dc 3B6A     		ldr	r3, [r7, #32]
 869 00de 1A60     		str	r2, [r3]
 550:../Generated_Code/event_groups.c ****         }
 551:../Generated_Code/event_groups.c ****         ( void ) xTaskResumeAll();
 870              		.loc 1 551 0
 871 00e0 FFF7FEFF 		bl	xTaskResumeAll
 552:../Generated_Code/event_groups.c **** 
 553:../Generated_Code/event_groups.c ****         return pxEventBits->uxEventBits;
 872              		.loc 1 553 0
 873 00e4 3B6A     		ldr	r3, [r7, #32]
 874 00e6 1B68     		ldr	r3, [r3]
 875              	.LBE8:
 554:../Generated_Code/event_groups.c **** }
 876              		.loc 1 554 0
 877 00e8 181C     		mov	r0, r3
 878 00ea BD46     		mov	sp, r7
 879 00ec 0CB0     		add	sp, sp, #48
 880              		@ sp needed for prologue
 881 00ee 80BD     		pop	{r7, pc}
 882              		.cfi_endproc
 883              	.LFE9:
 885              		.section	.text.vEventGroupDelete,"ax",%progbits
 886              		.align	2
 887              		.global	vEventGroupDelete
 888              		.code	16
 889              		.thumb_func
 891              	vEventGroupDelete:
 892              	.LFB10:
 555:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 556:../Generated_Code/event_groups.c **** 
 557:../Generated_Code/event_groups.c **** void vEventGroupDelete( EventGroupHandle_t xEventGroup )
 558:../Generated_Code/event_groups.c **** {
 893              		.loc 1 558 0
 894              		.cfi_startproc
 895 0000 80B5     		push	{r7, lr}
 896              	.LCFI18:
 897              		.cfi_def_cfa_offset 8
 898              		.cfi_offset 7, -8
 899              		.cfi_offset 14, -4
 900 0002 84B0     		sub	sp, sp, #16
 901              	.LCFI19:
 902              		.cfi_def_cfa_offset 24
 903 0004 00AF     		add	r7, sp, #0
 904              	.LCFI20:
 905              		.cfi_def_cfa_register 7
 906 0006 7860     		str	r0, [r7, #4]
 907              	.LBB9:
 559:../Generated_Code/event_groups.c **** EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 908              		.loc 1 559 0
 909 0008 7B68     		ldr	r3, [r7, #4]
 910 000a FB60     		str	r3, [r7, #12]
 560:../Generated_Code/event_groups.c **** const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 911              		.loc 1 560 0
 912 000c FB68     		ldr	r3, [r7, #12]
 913 000e 0433     		add	r3, r3, #4
 914 0010 BB60     		str	r3, [r7, #8]
 561:../Generated_Code/event_groups.c **** 
 562:../Generated_Code/event_groups.c ****         vTaskSuspendAll();
 915              		.loc 1 562 0
 916 0012 FFF7FEFF 		bl	vTaskSuspendAll
 563:../Generated_Code/event_groups.c ****         {
 564:../Generated_Code/event_groups.c ****                 traceEVENT_GROUP_DELETE( xEventGroup );
 565:../Generated_Code/event_groups.c **** 
 566:../Generated_Code/event_groups.c ****                 while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 917              		.loc 1 566 0
 918 0016 0FE0     		b	.L59
 919              	.L62:
 567:../Generated_Code/event_groups.c ****                 {
 568:../Generated_Code/event_groups.c ****                         /* Unblock the task, returning 0 as the event list is being deleted
 569:../Generated_Code/event_groups.c ****                         and     cannot therefore have any bits set. */
 570:../Generated_Code/event_groups.c ****                         configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &(
 920              		.loc 1 570 0
 921 0018 BB68     		ldr	r3, [r7, #8]
 922 001a DA68     		ldr	r2, [r3, #12]
 923 001c BB68     		ldr	r3, [r7, #8]
 924 001e 0833     		add	r3, r3, #8
 925 0020 9A42     		cmp	r2, r3
 926 0022 01D1     		bne	.L60
 927              		.loc 1 570 0 is_stmt 0
 928              	@ 570 "../Generated_Code/event_groups.c" 1
 929 0024 72B6     		cpsid i
 930              	@ 0 "" 2
 931              		.code	16
 932              	.L61:
 933              		.loc 1 570 0
 934 0026 FEE7     		b	.L61
 935              	.L60:
 571:../Generated_Code/event_groups.c ****                         ( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd
 936              		.loc 1 571 0 is_stmt 1
 937 0028 BB68     		ldr	r3, [r7, #8]
 938 002a DA68     		ldr	r2, [r3, #12]
 939 002c 8023     		mov	r3, #128
 940 002e 9B04     		lsl	r3, r3, #18
 941 0030 101C     		mov	r0, r2
 942 0032 191C     		mov	r1, r3
 943 0034 FFF7FEFF 		bl	xTaskRemoveFromUnorderedEventList
 944              	.L59:
 566:../Generated_Code/event_groups.c ****                 while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 945              		.loc 1 566 0
 946 0038 BB68     		ldr	r3, [r7, #8]
 947 003a 1B68     		ldr	r3, [r3]
 948 003c 5A1E     		sub	r2, r3, #1
 949 003e 9341     		sbc	r3, r3, r2
 950 0040 DBB2     		uxtb	r3, r3
 951 0042 002B     		cmp	r3, #0
 952 0044 E8D1     		bne	.L62
 572:../Generated_Code/event_groups.c ****                 }
 573:../Generated_Code/event_groups.c **** 
 574:../Generated_Code/event_groups.c ****                 vPortFree( pxEventBits );
 953              		.loc 1 574 0
 954 0046 FB68     		ldr	r3, [r7, #12]
 955 0048 181C     		mov	r0, r3
 956 004a FFF7FEFF 		bl	vPortFree
 575:../Generated_Code/event_groups.c ****         }
 576:../Generated_Code/event_groups.c ****         ( void ) xTaskResumeAll();
 957              		.loc 1 576 0
 958 004e FFF7FEFF 		bl	xTaskResumeAll
 959              	.LBE9:
 577:../Generated_Code/event_groups.c **** }
 960              		.loc 1 577 0
 961 0052 BD46     		mov	sp, r7
 962 0054 04B0     		add	sp, sp, #16
 963              		@ sp needed for prologue
 964 0056 80BD     		pop	{r7, pc}
 965              		.cfi_endproc
 966              	.LFE10:
 968              		.section	.text.vEventGroupSetBitsCallback,"ax",%progbits
 969              		.align	2
 970              		.global	vEventGroupSetBitsCallback
 971              		.code	16
 972              		.thumb_func
 974              	vEventGroupSetBitsCallback:
 975              	.LFB11:
 578:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 579:../Generated_Code/event_groups.c **** 
 580:../Generated_Code/event_groups.c **** /* For internal use only - execute a 'set bits' command that was pended from
 581:../Generated_Code/event_groups.c **** an interrupt. */
 582:../Generated_Code/event_groups.c **** void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
 583:../Generated_Code/event_groups.c **** {
 976              		.loc 1 583 0
 977              		.cfi_startproc
 978 0000 80B5     		push	{r7, lr}
 979              	.LCFI21:
 980              		.cfi_def_cfa_offset 8
 981              		.cfi_offset 7, -8
 982              		.cfi_offset 14, -4
 983 0002 82B0     		sub	sp, sp, #8
 984              	.LCFI22:
 985              		.cfi_def_cfa_offset 16
 986 0004 00AF     		add	r7, sp, #0
 987              	.LCFI23:
 988              		.cfi_def_cfa_register 7
 989 0006 7860     		str	r0, [r7, #4]
 990 0008 3960     		str	r1, [r7]
 584:../Generated_Code/event_groups.c ****         ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
 991              		.loc 1 584 0
 992 000a 7A68     		ldr	r2, [r7, #4]
 993 000c 3B68     		ldr	r3, [r7]
 994 000e 101C     		mov	r0, r2
 995 0010 191C     		mov	r1, r3
 996 0012 FFF7FEFF 		bl	xEventGroupSetBits
 585:../Generated_Code/event_groups.c **** }
 997              		.loc 1 585 0
 998 0016 BD46     		mov	sp, r7
 999 0018 02B0     		add	sp, sp, #8
 1000              		@ sp needed for prologue
 1001 001a 80BD     		pop	{r7, pc}
 1002              		.cfi_endproc
 1003              	.LFE11:
 1005              		.section	.text._ZL20prvTestWaitConditionmml,"ax",%progbits
 1006              		.align	2
 1007              		.code	16
 1008              		.thumb_func
 1010              	_ZL20prvTestWaitConditionmml:
 1011              	.LFB12:
 586:../Generated_Code/event_groups.c **** /*-----------------------------------------------------------*/
 587:../Generated_Code/event_groups.c **** 
 588:../Generated_Code/event_groups.c **** static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxB
 589:../Generated_Code/event_groups.c **** {
 1012              		.loc 1 589 0
 1013              		.cfi_startproc
 1014 0000 80B5     		push	{r7, lr}
 1015              	.LCFI24:
 1016              		.cfi_def_cfa_offset 8
 1017              		.cfi_offset 7, -8
 1018              		.cfi_offset 14, -4
 1019 0002 86B0     		sub	sp, sp, #24
 1020              	.LCFI25:
 1021              		.cfi_def_cfa_offset 32
 1022 0004 00AF     		add	r7, sp, #0
 1023              	.LCFI26:
 1024              		.cfi_def_cfa_register 7
 1025 0006 F860     		str	r0, [r7, #12]
 1026 0008 B960     		str	r1, [r7, #8]
 1027 000a 7A60     		str	r2, [r7, #4]
 1028              	.LBB10:
 590:../Generated_Code/event_groups.c **** BaseType_t xWaitConditionMet = pdFALSE;
 1029              		.loc 1 590 0
 1030 000c 0023     		mov	r3, #0
 1031 000e 7B61     		str	r3, [r7, #20]
 591:../Generated_Code/event_groups.c **** 
 592:../Generated_Code/event_groups.c ****         if( xWaitForAllBits == pdFALSE )
 1032              		.loc 1 592 0
 1033 0010 7B68     		ldr	r3, [r7, #4]
 1034 0012 002B     		cmp	r3, #0
 1035 0014 06D1     		bne	.L65
 593:../Generated_Code/event_groups.c ****         {
 594:../Generated_Code/event_groups.c ****                 /* Task only has to wait for one bit within uxBitsToWaitFor to be
 595:../Generated_Code/event_groups.c ****                 set.  Is one already set? */
 596:../Generated_Code/event_groups.c ****                 if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 1036              		.loc 1 596 0
 1037 0016 FB68     		ldr	r3, [r7, #12]
 1038 0018 BA68     		ldr	r2, [r7, #8]
 1039 001a 1340     		and	r3, r2
 1040 001c 0AD0     		beq	.L66
 597:../Generated_Code/event_groups.c ****                 {
 598:../Generated_Code/event_groups.c ****                         xWaitConditionMet = pdTRUE;
 1041              		.loc 1 598 0
 1042 001e 0123     		mov	r3, #1
 1043 0020 7B61     		str	r3, [r7, #20]
 1044 0022 07E0     		b	.L66
 1045              	.L65:
 599:../Generated_Code/event_groups.c ****                 }
 600:../Generated_Code/event_groups.c ****                 else
 601:../Generated_Code/event_groups.c ****                 {
 602:../Generated_Code/event_groups.c ****                         mtCOVERAGE_TEST_MARKER();
 603:../Generated_Code/event_groups.c ****                 }
 604:../Generated_Code/event_groups.c ****         }
 605:../Generated_Code/event_groups.c ****         else
 606:../Generated_Code/event_groups.c ****         {
 607:../Generated_Code/event_groups.c ****                 /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
 608:../Generated_Code/event_groups.c ****                 Are they set already? */
 609:../Generated_Code/event_groups.c ****                 if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 1046              		.loc 1 609 0
 1047 0024 FB68     		ldr	r3, [r7, #12]
 1048 0026 BA68     		ldr	r2, [r7, #8]
 1049 0028 1A40     		and	r2, r3
 1050 002a BB68     		ldr	r3, [r7, #8]
 1051 002c 9A42     		cmp	r2, r3
 1052 002e 01D1     		bne	.L66
 610:../Generated_Code/event_groups.c ****                 {
 611:../Generated_Code/event_groups.c ****                         xWaitConditionMet = pdTRUE;
 1053              		.loc 1 611 0
 1054 0030 0123     		mov	r3, #1
 1055 0032 7B61     		str	r3, [r7, #20]
 1056              	.L66:
 612:../Generated_Code/event_groups.c ****                 }
 613:../Generated_Code/event_groups.c ****                 else
 614:../Generated_Code/event_groups.c ****                 {
 615:../Generated_Code/event_groups.c ****                         mtCOVERAGE_TEST_MARKER();
 616:../Generated_Code/event_groups.c ****                 }
 617:../Generated_Code/event_groups.c ****         }
 618:../Generated_Code/event_groups.c **** 
 619:../Generated_Code/event_groups.c ****         return xWaitConditionMet;
 1057              		.loc 1 619 0
 1058 0034 7B69     		ldr	r3, [r7, #20]
 1059              	.LBE10:
 620:../Generated_Code/event_groups.c **** }
 1060              		.loc 1 620 0
 1061 0036 181C     		mov	r0, r3
 1062 0038 BD46     		mov	sp, r7
 1063 003a 06B0     		add	sp, sp, #24
 1064              		@ sp needed for prologue
 1065 003c 80BD     		pop	{r7, pc}
 1066              		.cfi_endproc
 1067              	.LFE12:
 1069 003e C046     		.text
 1070              	.Letext0:
 1071              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1072              		.file 3 "../Generated_Code/portmacro.h"
 1073              		.file 4 "../Generated_Code/list.h"
 1074              		.file 5 "../Generated_Code/event_groups.h"
DEFINED SYMBOLS
                            *ABS*:00000000 event_groups.c
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:18     .text.xEventGroupCreate:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:23     .text.xEventGroupCreate:00000000 xEventGroupCreate
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:72     .text.xEventGroupSync:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:77     .text.xEventGroupSync:00000000 xEventGroupSync
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:707    .text.xEventGroupSetBits:00000000 xEventGroupSetBits
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:295    .text.xEventGroupWaitBits:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:300    .text.xEventGroupWaitBits:00000000 xEventGroupWaitBits
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:1010   .text._ZL20prvTestWaitConditionmml:00000000 _ZL20prvTestWaitConditionmml
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:556    .text.xEventGroupClearBits:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:561    .text.xEventGroupClearBits:00000000 xEventGroupClearBits
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:625    .text.xEventGroupClearBitsFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:630    .text.xEventGroupClearBitsFromISR:00000000 xEventGroupClearBitsFromISR
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:702    .text.xEventGroupSetBits:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:886    .text.vEventGroupDelete:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:891    .text.vEventGroupDelete:00000000 vEventGroupDelete
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:969    .text.vEventGroupSetBitsCallback:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:974    .text.vEventGroupSetBitsCallback:00000000 vEventGroupSetBitsCallback
C:\Users\JH\AppData\Local\Temp\ccNgybit.s:1006   .text._ZL20prvTestWaitConditionmml:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
xTaskGetSchedulerState
vTaskSuspendAll
vTaskPlaceOnUnorderedEventList
xTaskResumeAll
vPortYieldFromISR
uxTaskResetEventItemValue
vPortEnterCritical
vPortExitCritical
xTaskRemoveFromUnorderedEventList
vPortFree
