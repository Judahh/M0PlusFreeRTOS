   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UTIL0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text._Z12UTIL0_strcpyPhjPKh,"ax",%progbits
  18              		.align	2
  19              		.global	_Z12UTIL0_strcpyPhjPKh
  20              		.code	16
  21              		.thumb_func
  23              	_Z12UTIL0_strcpyPhjPKh:
  24              	.LFB5:
  25              		.file 1 "../Generated_Code/UTIL0.c"
   1:../Generated_Code/UTIL0.c **** /* ###################################################################
   2:../Generated_Code/UTIL0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/UTIL0.c **** **     Filename    : UTIL0.c
   4:../Generated_Code/UTIL0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/UTIL0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/UTIL0.c **** **     Component   : Utility
   7:../Generated_Code/UTIL0.c **** **     Version     : Component 01.095, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/UTIL0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/UTIL0.c **** **     Date/Time   : 2014-04-05, 15:28, # CodeGen: 4
  10:../Generated_Code/UTIL0.c **** **     Abstract    :
  11:../Generated_Code/UTIL0.c **** **          Contains various utility functions.
  12:../Generated_Code/UTIL0.c **** **     Settings    :
  13:../Generated_Code/UTIL0.c **** **          Component name                                 : UTIL0
  14:../Generated_Code/UTIL0.c **** **     Contents    :
  15:../Generated_Code/UTIL0.c **** **         strcpy                  - void UTIL0_strcpy(byte *dst, size_t dstSize, const unsigned ch
  16:../Generated_Code/UTIL0.c **** **         strcat                  - void UTIL0_strcat(byte *dst, size_t dstSize, const unsigned ch
  17:../Generated_Code/UTIL0.c **** **         chcat                   - void UTIL0_chcat(byte *dst, size_t dstSize, byte ch);
  18:../Generated_Code/UTIL0.c **** **         Num8sToStr              - void UTIL0_Num8sToStr(byte *dst, size_t dstSize, signed char v
  19:../Generated_Code/UTIL0.c **** **         Num8uToStr              - void UTIL0_Num8uToStr(byte *dst, size_t dstSize, byte val);
  20:../Generated_Code/UTIL0.c **** **         Num16sToStr             - void UTIL0_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
  21:../Generated_Code/UTIL0.c **** **         Num16uToStr             - void UTIL0_Num16uToStr(byte *dst, size_t dstSize, word val);
  22:../Generated_Code/UTIL0.c **** **         Num32uToStr             - void UTIL0_Num32uToStr(byte *dst, size_t dstSize, dword val);
  23:../Generated_Code/UTIL0.c **** **         Num32sToStr             - void UTIL0_Num32sToStr(byte *dst, size_t dstSize, long val);
  24:../Generated_Code/UTIL0.c **** **         Num16sToStrFormatted    - void UTIL0_Num16sToStrFormatted(byte *dst, size_t dstSize, int
  25:../Generated_Code/UTIL0.c **** **         Num16uToStrFormatted    - void UTIL0_Num16uToStrFormatted(byte *dst, size_t dstSize, wor
  26:../Generated_Code/UTIL0.c **** **         Num32uToStrFormatted    - void UTIL0_Num32uToStrFormatted(byte *dst, size_t dstSize, dwo
  27:../Generated_Code/UTIL0.c **** **         Num32sToStrFormatted    - void UTIL0_Num32sToStrFormatted(byte *dst, size_t dstSize, lon
  28:../Generated_Code/UTIL0.c **** **         strcatNum8u             - void UTIL0_strcatNum8u(byte *dst, size_t dstSize, byte val);
  29:../Generated_Code/UTIL0.c **** **         strcatNum8s             - void UTIL0_strcatNum8s(byte *dst, size_t dstSize, signed char 
  30:../Generated_Code/UTIL0.c **** **         strcatNum16u            - void UTIL0_strcatNum16u(byte *dst, size_t dstSize, word val);
  31:../Generated_Code/UTIL0.c **** **         strcatNum16s            - void UTIL0_strcatNum16s(byte *dst, size_t dstSize, int16_t val
  32:../Generated_Code/UTIL0.c **** **         strcatNum32u            - void UTIL0_strcatNum32u(byte *dst, size_t dstSize, dword val);
  33:../Generated_Code/UTIL0.c **** **         strcatNum32s            - void UTIL0_strcatNum32s(byte *dst, size_t dstSize, long val);
  34:../Generated_Code/UTIL0.c **** **         strcatNum16uFormatted   - void UTIL0_strcatNum16uFormatted(byte *dst, size_t dstSize, wo
  35:../Generated_Code/UTIL0.c **** **         strcatNum16sFormatted   - void UTIL0_strcatNum16sFormatted(byte *dst, size_t dstSize, in
  36:../Generated_Code/UTIL0.c **** **         strcatNum32uFormatted   - void UTIL0_strcatNum32uFormatted(byte *dst, size_t dstSize, dw
  37:../Generated_Code/UTIL0.c **** **         strcatNum32sFormatted   - void UTIL0_strcatNum32sFormatted(byte *dst, size_t dstSize, lo
  38:../Generated_Code/UTIL0.c **** **         strcatNum8Hex           - void UTIL0_strcatNum8Hex(byte *dst, size_t dstSize, byte num);
  39:../Generated_Code/UTIL0.c **** **         strcatNum16Hex          - void UTIL0_strcatNum16Hex(byte *dst, size_t dstSize, word num)
  40:../Generated_Code/UTIL0.c **** **         strcatNum24Hex          - void UTIL0_strcatNum24Hex(byte *dst, size_t dstSize, dword num
  41:../Generated_Code/UTIL0.c **** **         strcatNum32Hex          - void UTIL0_strcatNum32Hex(byte *dst, size_t dstSize, dword num
  42:../Generated_Code/UTIL0.c **** **         strcatNum32sDotValue100 - void UTIL0_strcatNum32sDotValue100(byte *dst, size_t dstSize, 
  43:../Generated_Code/UTIL0.c **** **         IsLeapYear              - bool UTIL0_IsLeapYear(word year);
  44:../Generated_Code/UTIL0.c **** **         WeekDay                 - byte UTIL0_WeekDay(word year, byte month, byte day);
  45:../Generated_Code/UTIL0.c **** **         ReadEscapedName         - byte UTIL0_ReadEscapedName(const unsigned char *filename, byte
  46:../Generated_Code/UTIL0.c **** **         xatoi                   - byte UTIL0_xatoi(const unsigned char **str, int32_t *res);
  47:../Generated_Code/UTIL0.c **** **         ScanDate                - byte UTIL0_ScanDate(const unsigned char **str, byte *day, byte
  48:../Generated_Code/UTIL0.c **** **         ScanTime                - byte UTIL0_ScanTime(const unsigned char **str, byte *hour, byt
  49:../Generated_Code/UTIL0.c **** **         ScanDecimal8uNumber     - byte UTIL0_ScanDecimal8uNumber(const unsigned char **str, byte
  50:../Generated_Code/UTIL0.c **** **         ScanDecimal8sNumber     - byte UTIL0_ScanDecimal8sNumber(const unsigned char **str, sign
  51:../Generated_Code/UTIL0.c **** **         ScanDecimal16uNumber    - byte UTIL0_ScanDecimal16uNumber(const unsigned char **str, wor
  52:../Generated_Code/UTIL0.c **** **         ScanDecimal16sNumber    - byte UTIL0_ScanDecimal16sNumber(const unsigned char **str, int
  53:../Generated_Code/UTIL0.c **** **         ScanDecimal32uNumber    - byte UTIL0_ScanDecimal32uNumber(const unsigned char **str, uin
  54:../Generated_Code/UTIL0.c **** **         ScanDecimal32sNumber    - byte UTIL0_ScanDecimal32sNumber(const unsigned char **str, uin
  55:../Generated_Code/UTIL0.c **** **         ScanHex8uNumber         - byte UTIL0_ScanHex8uNumber(const unsigned char **str, byte *va
  56:../Generated_Code/UTIL0.c **** **         ScanHex8uNumberNoPrefix - byte UTIL0_ScanHex8uNumberNoPrefix(const unsigned char **str, 
  57:../Generated_Code/UTIL0.c **** **         ScanHex16uNumber        - byte UTIL0_ScanHex16uNumber(const unsigned char **str, word *v
  58:../Generated_Code/UTIL0.c **** **         ScanHex32uNumber        - byte UTIL0_ScanHex32uNumber(const unsigned char **str, uint32_
  59:../Generated_Code/UTIL0.c **** **         strcmp                  - int16_t UTIL0_strcmp(const char *, const char *);
  60:../Generated_Code/UTIL0.c **** **         strncmp                 - int16_t UTIL0_strncmp(const char *, const char *, size_t size)
  61:../Generated_Code/UTIL0.c **** **         strFind                 - int16_t UTIL0_strFind(byte *str, byte *subStr);
  62:../Generated_Code/UTIL0.c **** **         strtailcmp              - byte UTIL0_strtailcmp(byte *str, byte *tail);
  63:../Generated_Code/UTIL0.c **** **         strlen                  - word UTIL0_strlen(const char *);
  64:../Generated_Code/UTIL0.c **** **         strCutTail              - byte UTIL0_strCutTail(byte *str, byte *tail);
  65:../Generated_Code/UTIL0.c **** **
  66:../Generated_Code/UTIL0.c **** **     License   :  Open Source (LGPL)
  67:../Generated_Code/UTIL0.c **** **     Copyright : (c) Copyright Erich Styger, 2014, all rights reserved.
  68:../Generated_Code/UTIL0.c **** **     xatoi(): Copyright (C) 2010, ChaN, all right reserved. (see copyright notice and license at 
  69:../Generated_Code/UTIL0.c **** **     This an open source software implementing utility functions using Processor Expert.
  70:../Generated_Code/UTIL0.c **** **     This is a free software and is opened for education,  research and commercial developments u
  71:../Generated_Code/UTIL0.c **** **     * This is a free software and there is NO WARRANTY.
  72:../Generated_Code/UTIL0.c **** **     * No restriction on use. You can use, modify and redistribute it for
  73:../Generated_Code/UTIL0.c **** **       personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
  74:../Generated_Code/UTIL0.c **** **     * Redistributions of source code must retain the above copyright notice.
  75:../Generated_Code/UTIL0.c **** ** ###################################################################*/
  76:../Generated_Code/UTIL0.c **** /*!
  77:../Generated_Code/UTIL0.c **** ** @file UTIL0.c
  78:../Generated_Code/UTIL0.c **** ** @version 01.00
  79:../Generated_Code/UTIL0.c **** ** @brief
  80:../Generated_Code/UTIL0.c **** **          Contains various utility functions.
  81:../Generated_Code/UTIL0.c **** */         
  82:../Generated_Code/UTIL0.c **** /*!
  83:../Generated_Code/UTIL0.c **** **  @addtogroup UTIL0_module UTIL0 module documentation
  84:../Generated_Code/UTIL0.c **** **  @{
  85:../Generated_Code/UTIL0.c **** */         
  86:../Generated_Code/UTIL0.c **** 
  87:../Generated_Code/UTIL0.c **** /* MODULE UTIL0. */
  88:../Generated_Code/UTIL0.c **** 
  89:../Generated_Code/UTIL0.c **** #include "UTIL0.h"
  90:../Generated_Code/UTIL0.c **** 
  91:../Generated_Code/UTIL0.c **** /* Internal method prototypes */
  92:../Generated_Code/UTIL0.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill);
  93:../Generated_Code/UTIL0.c **** 
  94:../Generated_Code/UTIL0.c **** /*
  95:../Generated_Code/UTIL0.c **** ** ===================================================================
  96:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcpy (component Utility)
  97:../Generated_Code/UTIL0.c **** **     Description :
  98:../Generated_Code/UTIL0.c **** **         Same as normal strcpy, but safe as it does not write beyond
  99:../Generated_Code/UTIL0.c **** **         the buffer.
 100:../Generated_Code/UTIL0.c **** **     Parameters  :
 101:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 102:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 103:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 104:../Generated_Code/UTIL0.c **** **                           bytes).
 105:../Generated_Code/UTIL0.c **** **       * src             - Pointer to source string.
 106:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 107:../Generated_Code/UTIL0.c **** ** ===================================================================
 108:../Generated_Code/UTIL0.c **** */
 109:../Generated_Code/UTIL0.c **** /*!
 110:../Generated_Code/UTIL0.c ****   \brief copy the string src into dst. It performs the same task as strncpy, except
 111:../Generated_Code/UTIL0.c ****      - always terminates the result string.
 112:../Generated_Code/UTIL0.c ****      - does not zero out the remaining part in dst.
 113:../Generated_Code/UTIL0.c ****      Note: dstSize is the size of dst INCLUDING zero byte.
 114:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 115:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 116:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 117:../Generated_Code/UTIL0.c ****   \param[in] src The source string to copy
 118:../Generated_Code/UTIL0.c **** */
 119:../Generated_Code/UTIL0.c **** void UTIL0_strcpy(byte *dst, size_t dstSize, const unsigned char *src)
 120:../Generated_Code/UTIL0.c **** {
  26              		.loc 1 120 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 24
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39 0006 F860     		str	r0, [r7, #12]
  40 0008 B960     		str	r1, [r7, #8]
  41 000a 7A60     		str	r2, [r7, #4]
 121:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
  42              		.loc 1 121 0
  43 000c BB68     		ldr	r3, [r7, #8]
  44 000e 013B     		sub	r3, r3, #1
  45 0010 BB60     		str	r3, [r7, #8]
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  46              		.loc 1 122 0
  47 0012 0CE0     		b	.L2
  48              	.L5:
 123:../Generated_Code/UTIL0.c ****     *dst++ = *src++;
  49              		.loc 1 123 0
  50 0014 7B68     		ldr	r3, [r7, #4]
  51 0016 1A78     		ldrb	r2, [r3]
  52 0018 FB68     		ldr	r3, [r7, #12]
  53 001a 1A70     		strb	r2, [r3]
  54 001c FB68     		ldr	r3, [r7, #12]
  55 001e 0133     		add	r3, r3, #1
  56 0020 FB60     		str	r3, [r7, #12]
  57 0022 7B68     		ldr	r3, [r7, #4]
  58 0024 0133     		add	r3, r3, #1
  59 0026 7B60     		str	r3, [r7, #4]
 124:../Generated_Code/UTIL0.c ****     dstSize--;
  60              		.loc 1 124 0
  61 0028 BB68     		ldr	r3, [r7, #8]
  62 002a 013B     		sub	r3, r3, #1
  63 002c BB60     		str	r3, [r7, #8]
  64              	.L2:
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  65              		.loc 1 122 0
  66 002e BB68     		ldr	r3, [r7, #8]
  67 0030 002B     		cmp	r3, #0
  68 0032 05D0     		beq	.L3
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  69              		.loc 1 122 0 is_stmt 0
  70 0034 7B68     		ldr	r3, [r7, #4]
  71 0036 1B78     		ldrb	r3, [r3]
  72 0038 002B     		cmp	r3, #0
  73 003a 01D0     		beq	.L3
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  74              		.loc 1 122 0
  75 003c 0123     		mov	r3, #1
  76 003e 00E0     		b	.L4
  77              	.L3:
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  78              		.loc 1 122 0
  79 0040 0023     		mov	r3, #0
  80              	.L4:
 122:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
  81              		.loc 1 122 0
  82 0042 002B     		cmp	r3, #0
  83 0044 E6D1     		bne	.L5
 125:../Generated_Code/UTIL0.c ****   }
 126:../Generated_Code/UTIL0.c ****   *dst = '\0';
  84              		.loc 1 126 0 is_stmt 1
  85 0046 FB68     		ldr	r3, [r7, #12]
  86 0048 0022     		mov	r2, #0
  87 004a 1A70     		strb	r2, [r3]
 127:../Generated_Code/UTIL0.c **** }
  88              		.loc 1 127 0
  89 004c BD46     		mov	sp, r7
  90 004e 04B0     		add	sp, sp, #16
  91              		@ sp needed for prologue
  92 0050 80BD     		pop	{r7, pc}
  93              		.cfi_endproc
  94              	.LFE5:
  96 0052 C046     		.section	.text._Z12UTIL0_strcatPhjPKh,"ax",%progbits
  97              		.align	2
  98              		.global	_Z12UTIL0_strcatPhjPKh
  99              		.code	16
 100              		.thumb_func
 102              	_Z12UTIL0_strcatPhjPKh:
 103              	.LFB6:
 128:../Generated_Code/UTIL0.c **** 
 129:../Generated_Code/UTIL0.c **** /*
 130:../Generated_Code/UTIL0.c **** ** ===================================================================
 131:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcat (component Utility)
 132:../Generated_Code/UTIL0.c **** **     Description :
 133:../Generated_Code/UTIL0.c **** **         Same as normal strcat, but safe as it does not write beyond
 134:../Generated_Code/UTIL0.c **** **         the buffer.
 135:../Generated_Code/UTIL0.c **** **     Parameters  :
 136:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 137:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 138:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 139:../Generated_Code/UTIL0.c **** **                           bytes).
 140:../Generated_Code/UTIL0.c **** **       * src             - Pointer to source string.
 141:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 142:../Generated_Code/UTIL0.c **** ** ===================================================================
 143:../Generated_Code/UTIL0.c **** */
 144:../Generated_Code/UTIL0.c **** /*!
 145:../Generated_Code/UTIL0.c ****   \brief Concat the string src into dst. Always terminates the result string.
 146:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 147:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 148:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 149:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 150:../Generated_Code/UTIL0.c ****   \param[in] src The source string to add
 151:../Generated_Code/UTIL0.c ****   */
 152:../Generated_Code/UTIL0.c **** void UTIL0_strcat(byte *dst, size_t dstSize, const unsigned char *src)
 153:../Generated_Code/UTIL0.c **** {
 104              		.loc 1 153 0
 105              		.cfi_startproc
 106 0000 80B5     		push	{r7, lr}
 107              	.LCFI3:
 108              		.cfi_def_cfa_offset 8
 109              		.cfi_offset 7, -8
 110              		.cfi_offset 14, -4
 111 0002 84B0     		sub	sp, sp, #16
 112              	.LCFI4:
 113              		.cfi_def_cfa_offset 24
 114 0004 00AF     		add	r7, sp, #0
 115              	.LCFI5:
 116              		.cfi_def_cfa_register 7
 117 0006 F860     		str	r0, [r7, #12]
 118 0008 B960     		str	r1, [r7, #8]
 119 000a 7A60     		str	r2, [r7, #4]
 154:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 120              		.loc 1 154 0
 121 000c BB68     		ldr	r3, [r7, #8]
 122 000e 013B     		sub	r3, r3, #1
 123 0010 BB60     		str	r3, [r7, #8]
 155:../Generated_Code/UTIL0.c ****   /* point to the end of the source */
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 124              		.loc 1 156 0
 125 0012 05E0     		b	.L7
 126              	.L10:
 157:../Generated_Code/UTIL0.c ****     dst++;
 127              		.loc 1 157 0
 128 0014 FB68     		ldr	r3, [r7, #12]
 129 0016 0133     		add	r3, r3, #1
 130 0018 FB60     		str	r3, [r7, #12]
 158:../Generated_Code/UTIL0.c ****     dstSize--;
 131              		.loc 1 158 0
 132 001a BB68     		ldr	r3, [r7, #8]
 133 001c 013B     		sub	r3, r3, #1
 134 001e BB60     		str	r3, [r7, #8]
 135              	.L7:
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 136              		.loc 1 156 0
 137 0020 BB68     		ldr	r3, [r7, #8]
 138 0022 002B     		cmp	r3, #0
 139 0024 05D0     		beq	.L8
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 140              		.loc 1 156 0 is_stmt 0
 141 0026 FB68     		ldr	r3, [r7, #12]
 142 0028 1B78     		ldrb	r3, [r3]
 143 002a 002B     		cmp	r3, #0
 144 002c 01D0     		beq	.L8
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 145              		.loc 1 156 0
 146 002e 0123     		mov	r3, #1
 147 0030 00E0     		b	.L9
 148              	.L8:
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 149              		.loc 1 156 0
 150 0032 0023     		mov	r3, #0
 151              	.L9:
 156:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 152              		.loc 1 156 0
 153 0034 002B     		cmp	r3, #0
 154 0036 EDD1     		bne	.L10
 159:../Generated_Code/UTIL0.c ****   }
 160:../Generated_Code/UTIL0.c ****   /* copy the src in the destination */
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 155              		.loc 1 161 0 is_stmt 1
 156 0038 0CE0     		b	.L11
 157              	.L14:
 162:../Generated_Code/UTIL0.c ****     *dst++ = *src++;
 158              		.loc 1 162 0
 159 003a 7B68     		ldr	r3, [r7, #4]
 160 003c 1A78     		ldrb	r2, [r3]
 161 003e FB68     		ldr	r3, [r7, #12]
 162 0040 1A70     		strb	r2, [r3]
 163 0042 FB68     		ldr	r3, [r7, #12]
 164 0044 0133     		add	r3, r3, #1
 165 0046 FB60     		str	r3, [r7, #12]
 166 0048 7B68     		ldr	r3, [r7, #4]
 167 004a 0133     		add	r3, r3, #1
 168 004c 7B60     		str	r3, [r7, #4]
 163:../Generated_Code/UTIL0.c ****     dstSize--;
 169              		.loc 1 163 0
 170 004e BB68     		ldr	r3, [r7, #8]
 171 0050 013B     		sub	r3, r3, #1
 172 0052 BB60     		str	r3, [r7, #8]
 173              	.L11:
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 174              		.loc 1 161 0
 175 0054 BB68     		ldr	r3, [r7, #8]
 176 0056 002B     		cmp	r3, #0
 177 0058 05D0     		beq	.L12
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 178              		.loc 1 161 0 is_stmt 0
 179 005a 7B68     		ldr	r3, [r7, #4]
 180 005c 1B78     		ldrb	r3, [r3]
 181 005e 002B     		cmp	r3, #0
 182 0060 01D0     		beq	.L12
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 183              		.loc 1 161 0
 184 0062 0123     		mov	r3, #1
 185 0064 00E0     		b	.L13
 186              	.L12:
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 187              		.loc 1 161 0
 188 0066 0023     		mov	r3, #0
 189              	.L13:
 161:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *src != '\0') {
 190              		.loc 1 161 0
 191 0068 002B     		cmp	r3, #0
 192 006a E6D1     		bne	.L14
 164:../Generated_Code/UTIL0.c ****   }
 165:../Generated_Code/UTIL0.c ****   /* terminate the string */
 166:../Generated_Code/UTIL0.c ****   *dst = '\0';
 193              		.loc 1 166 0 is_stmt 1
 194 006c FB68     		ldr	r3, [r7, #12]
 195 006e 0022     		mov	r2, #0
 196 0070 1A70     		strb	r2, [r3]
 167:../Generated_Code/UTIL0.c **** }
 197              		.loc 1 167 0
 198 0072 BD46     		mov	sp, r7
 199 0074 04B0     		add	sp, sp, #16
 200              		@ sp needed for prologue
 201 0076 80BD     		pop	{r7, pc}
 202              		.cfi_endproc
 203              	.LFE6:
 205              		.section	.text._Z11UTIL0_chcatPhjh,"ax",%progbits
 206              		.align	2
 207              		.global	_Z11UTIL0_chcatPhjh
 208              		.code	16
 209              		.thumb_func
 211              	_Z11UTIL0_chcatPhjh:
 212              	.LFB7:
 168:../Generated_Code/UTIL0.c **** 
 169:../Generated_Code/UTIL0.c **** /*
 170:../Generated_Code/UTIL0.c **** ** ===================================================================
 171:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_chcat (component Utility)
 172:../Generated_Code/UTIL0.c **** **     Description :
 173:../Generated_Code/UTIL0.c **** **         Adds a single character to a zero byte terminated buffer. It
 174:../Generated_Code/UTIL0.c **** **         cares about buffer overflow.
 175:../Generated_Code/UTIL0.c **** **     Parameters  :
 176:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 177:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 178:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 179:../Generated_Code/UTIL0.c **** **                           bytes).
 180:../Generated_Code/UTIL0.c **** **         ch              - character to append
 181:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 182:../Generated_Code/UTIL0.c **** ** ===================================================================
 183:../Generated_Code/UTIL0.c **** */
 184:../Generated_Code/UTIL0.c **** void UTIL0_chcat(byte *dst, size_t dstSize, byte ch)
 185:../Generated_Code/UTIL0.c **** {
 213              		.loc 1 185 0
 214              		.cfi_startproc
 215 0000 80B5     		push	{r7, lr}
 216              	.LCFI6:
 217              		.cfi_def_cfa_offset 8
 218              		.cfi_offset 7, -8
 219              		.cfi_offset 14, -4
 220 0002 84B0     		sub	sp, sp, #16
 221              	.LCFI7:
 222              		.cfi_def_cfa_offset 24
 223 0004 00AF     		add	r7, sp, #0
 224              	.LCFI8:
 225              		.cfi_def_cfa_register 7
 226 0006 F860     		str	r0, [r7, #12]
 227 0008 B960     		str	r1, [r7, #8]
 228 000a FB1D     		add	r3, r7, #7
 229 000c 1A70     		strb	r2, [r3]
 186:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 230              		.loc 1 186 0
 231 000e BB68     		ldr	r3, [r7, #8]
 232 0010 013B     		sub	r3, r3, #1
 233 0012 BB60     		str	r3, [r7, #8]
 187:../Generated_Code/UTIL0.c ****   /* point to the end of the source */
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 234              		.loc 1 188 0
 235 0014 05E0     		b	.L16
 236              	.L19:
 189:../Generated_Code/UTIL0.c ****     dst++;
 237              		.loc 1 189 0
 238 0016 FB68     		ldr	r3, [r7, #12]
 239 0018 0133     		add	r3, r3, #1
 240 001a FB60     		str	r3, [r7, #12]
 190:../Generated_Code/UTIL0.c ****     dstSize--;
 241              		.loc 1 190 0
 242 001c BB68     		ldr	r3, [r7, #8]
 243 001e 013B     		sub	r3, r3, #1
 244 0020 BB60     		str	r3, [r7, #8]
 245              	.L16:
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 246              		.loc 1 188 0
 247 0022 BB68     		ldr	r3, [r7, #8]
 248 0024 002B     		cmp	r3, #0
 249 0026 05D0     		beq	.L17
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 250              		.loc 1 188 0 is_stmt 0
 251 0028 FB68     		ldr	r3, [r7, #12]
 252 002a 1B78     		ldrb	r3, [r3]
 253 002c 002B     		cmp	r3, #0
 254 002e 01D0     		beq	.L17
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 255              		.loc 1 188 0
 256 0030 0123     		mov	r3, #1
 257 0032 00E0     		b	.L18
 258              	.L17:
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 259              		.loc 1 188 0
 260 0034 0023     		mov	r3, #0
 261              	.L18:
 188:../Generated_Code/UTIL0.c ****   while (dstSize > 0 && *dst != '\0') {
 262              		.loc 1 188 0
 263 0036 002B     		cmp	r3, #0
 264 0038 EDD1     		bne	.L19
 191:../Generated_Code/UTIL0.c ****   }
 192:../Generated_Code/UTIL0.c ****   /* copy the ch in the destination */
 193:../Generated_Code/UTIL0.c ****   if (dstSize > 0) {
 265              		.loc 1 193 0 is_stmt 1
 266 003a BB68     		ldr	r3, [r7, #8]
 267 003c 002B     		cmp	r3, #0
 268 003e 06D0     		beq	.L20
 194:../Generated_Code/UTIL0.c ****     *dst++ = ch;
 269              		.loc 1 194 0
 270 0040 FB68     		ldr	r3, [r7, #12]
 271 0042 FA1D     		add	r2, r7, #7
 272 0044 1278     		ldrb	r2, [r2]
 273 0046 1A70     		strb	r2, [r3]
 274 0048 FB68     		ldr	r3, [r7, #12]
 275 004a 0133     		add	r3, r3, #1
 276 004c FB60     		str	r3, [r7, #12]
 277              	.L20:
 195:../Generated_Code/UTIL0.c ****   }
 196:../Generated_Code/UTIL0.c ****   /* terminate the string */
 197:../Generated_Code/UTIL0.c ****   *dst = '\0';
 278              		.loc 1 197 0
 279 004e FB68     		ldr	r3, [r7, #12]
 280 0050 0022     		mov	r2, #0
 281 0052 1A70     		strb	r2, [r3]
 198:../Generated_Code/UTIL0.c **** }
 282              		.loc 1 198 0
 283 0054 BD46     		mov	sp, r7
 284 0056 04B0     		add	sp, sp, #16
 285              		@ sp needed for prologue
 286 0058 80BD     		pop	{r7, pc}
 287              		.cfi_endproc
 288              	.LFE7:
 290 005a C046     		.section	.text._Z16UTIL0_Num8uToStrPhjh,"ax",%progbits
 291              		.align	2
 292              		.global	_Z16UTIL0_Num8uToStrPhjh
 293              		.code	16
 294              		.thumb_func
 296              	_Z16UTIL0_Num8uToStrPhjh:
 297              	.LFB8:
 199:../Generated_Code/UTIL0.c **** 
 200:../Generated_Code/UTIL0.c **** /*
 201:../Generated_Code/UTIL0.c **** ** ===================================================================
 202:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num8uToStr (component Utility)
 203:../Generated_Code/UTIL0.c **** **     Description :
 204:../Generated_Code/UTIL0.c **** **         Converts an unsigned 8bit value into a string.
 205:../Generated_Code/UTIL0.c **** **     Parameters  :
 206:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 207:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 208:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 209:../Generated_Code/UTIL0.c **** **                           bytes).
 210:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
 211:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 212:../Generated_Code/UTIL0.c **** ** ===================================================================
 213:../Generated_Code/UTIL0.c **** */
 214:../Generated_Code/UTIL0.c **** /*!
 215:../Generated_Code/UTIL0.c ****   \brief Converts an 8bit unsigned number into a string.
 216:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
 217:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 218:../Generated_Code/UTIL0.c ****   \param[in] val 8bit unsigned number to convert.
 219:../Generated_Code/UTIL0.c ****  */
 220:../Generated_Code/UTIL0.c **** void UTIL0_Num8uToStr(byte *dst, size_t dstSize, byte val)
 221:../Generated_Code/UTIL0.c **** {
 298              		.loc 1 221 0
 299              		.cfi_startproc
 300 0000 80B5     		push	{r7, lr}
 301              	.LCFI9:
 302              		.cfi_def_cfa_offset 8
 303              		.cfi_offset 7, -8
 304              		.cfi_offset 14, -4
 305 0002 84B0     		sub	sp, sp, #16
 306              	.LCFI10:
 307              		.cfi_def_cfa_offset 24
 308 0004 00AF     		add	r7, sp, #0
 309              	.LCFI11:
 310              		.cfi_def_cfa_register 7
 311 0006 F860     		str	r0, [r7, #12]
 312 0008 B960     		str	r1, [r7, #8]
 313 000a FB1D     		add	r3, r7, #7
 314 000c 1A70     		strb	r2, [r3]
 222:../Generated_Code/UTIL0.c ****   UTIL0_Num16uToStr(dst, dstSize, (uint16_t)val);
 315              		.loc 1 222 0
 316 000e FB1D     		add	r3, r7, #7
 317 0010 1B78     		ldrb	r3, [r3]
 318 0012 9BB2     		uxth	r3, r3
 319 0014 F968     		ldr	r1, [r7, #12]
 320 0016 BA68     		ldr	r2, [r7, #8]
 321 0018 081C     		mov	r0, r1
 322 001a 111C     		mov	r1, r2
 323 001c 1A1C     		mov	r2, r3
 324 001e FFF7FEFF 		bl	_Z17UTIL0_Num16uToStrPhjt
 223:../Generated_Code/UTIL0.c **** }
 325              		.loc 1 223 0
 326 0022 BD46     		mov	sp, r7
 327 0024 04B0     		add	sp, sp, #16
 328              		@ sp needed for prologue
 329 0026 80BD     		pop	{r7, pc}
 330              		.cfi_endproc
 331              	.LFE8:
 333              		.section	.text._Z16UTIL0_Num8sToStrPhja,"ax",%progbits
 334              		.align	2
 335              		.global	_Z16UTIL0_Num8sToStrPhja
 336              		.code	16
 337              		.thumb_func
 339              	_Z16UTIL0_Num8sToStrPhja:
 340              	.LFB9:
 224:../Generated_Code/UTIL0.c **** 
 225:../Generated_Code/UTIL0.c **** /*
 226:../Generated_Code/UTIL0.c **** ** ===================================================================
 227:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num8sToStr (component Utility)
 228:../Generated_Code/UTIL0.c **** **     Description :
 229:../Generated_Code/UTIL0.c **** **         Converts a signed 8bit value into a string.
 230:../Generated_Code/UTIL0.c **** **     Parameters  :
 231:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 232:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 233:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 234:../Generated_Code/UTIL0.c **** **                           bytes).
 235:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
 236:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 237:../Generated_Code/UTIL0.c **** ** ===================================================================
 238:../Generated_Code/UTIL0.c **** */
 239:../Generated_Code/UTIL0.c **** /*!
 240:../Generated_Code/UTIL0.c ****   \brief Converts an 8bit signed number into a string.
 241:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
 242:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 243:../Generated_Code/UTIL0.c ****   \param[in] val 8bit signed number to convert.
 244:../Generated_Code/UTIL0.c ****  */
 245:../Generated_Code/UTIL0.c **** void UTIL0_Num8sToStr(byte *dst, size_t dstSize, signed char val)
 246:../Generated_Code/UTIL0.c **** {
 341              		.loc 1 246 0
 342              		.cfi_startproc
 343 0000 80B5     		push	{r7, lr}
 344              	.LCFI12:
 345              		.cfi_def_cfa_offset 8
 346              		.cfi_offset 7, -8
 347              		.cfi_offset 14, -4
 348 0002 84B0     		sub	sp, sp, #16
 349              	.LCFI13:
 350              		.cfi_def_cfa_offset 24
 351 0004 00AF     		add	r7, sp, #0
 352              	.LCFI14:
 353              		.cfi_def_cfa_register 7
 354 0006 F860     		str	r0, [r7, #12]
 355 0008 B960     		str	r1, [r7, #8]
 356 000a FB1D     		add	r3, r7, #7
 357 000c 1A70     		strb	r2, [r3]
 247:../Generated_Code/UTIL0.c ****   UTIL0_Num16sToStr(dst, dstSize, (int16_t)val);
 358              		.loc 1 247 0
 359 000e FB1D     		add	r3, r7, #7
 360 0010 1B78     		ldrb	r3, [r3]
 361 0012 5BB2     		sxtb	r3, r3
 362 0014 9BB2     		uxth	r3, r3
 363 0016 F968     		ldr	r1, [r7, #12]
 364 0018 BA68     		ldr	r2, [r7, #8]
 365 001a 1BB2     		sxth	r3, r3
 366 001c 081C     		mov	r0, r1
 367 001e 111C     		mov	r1, r2
 368 0020 1A1C     		mov	r2, r3
 369 0022 FFF7FEFF 		bl	_Z17UTIL0_Num16sToStrPhjs
 248:../Generated_Code/UTIL0.c **** }
 370              		.loc 1 248 0
 371 0026 BD46     		mov	sp, r7
 372 0028 04B0     		add	sp, sp, #16
 373              		@ sp needed for prologue
 374 002a 80BD     		pop	{r7, pc}
 375              		.cfi_endproc
 376              	.LFE9:
 378              		.global	__aeabi_uidivmod
 379              		.global	__aeabi_uidiv
 380              		.section	.text._Z17UTIL0_Num16uToStrPhjt,"ax",%progbits
 381              		.align	2
 382              		.global	_Z17UTIL0_Num16uToStrPhjt
 383              		.code	16
 384              		.thumb_func
 386              	_Z17UTIL0_Num16uToStrPhjt:
 387              	.LFB10:
 249:../Generated_Code/UTIL0.c **** 
 250:../Generated_Code/UTIL0.c **** /*
 251:../Generated_Code/UTIL0.c **** ** ===================================================================
 252:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num16uToStr (component Utility)
 253:../Generated_Code/UTIL0.c **** **     Description :
 254:../Generated_Code/UTIL0.c **** **         Converts a signed 16bit value into a string.
 255:../Generated_Code/UTIL0.c **** **     Parameters  :
 256:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 257:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 258:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 259:../Generated_Code/UTIL0.c **** **                           bytes).
 260:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
 261:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 262:../Generated_Code/UTIL0.c **** ** ===================================================================
 263:../Generated_Code/UTIL0.c **** */
 264:../Generated_Code/UTIL0.c **** /*!
 265:../Generated_Code/UTIL0.c ****   \brief Converts a 16bit unsigned number into a string.
 266:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
 267:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 268:../Generated_Code/UTIL0.c ****   \param[in] val 16bit unsigned number to convert.
 269:../Generated_Code/UTIL0.c ****  */
 270:../Generated_Code/UTIL0.c **** void UTIL0_Num16uToStr(byte *dst, size_t dstSize, word val)
 271:../Generated_Code/UTIL0.c **** {
 388              		.loc 1 271 0
 389              		.cfi_startproc
 390 0000 90B5     		push	{r4, r7, lr}
 391              	.LCFI15:
 392              		.cfi_def_cfa_offset 12
 393              		.cfi_offset 4, -12
 394              		.cfi_offset 7, -8
 395              		.cfi_offset 14, -4
 396 0002 89B0     		sub	sp, sp, #36
 397              	.LCFI16:
 398              		.cfi_def_cfa_offset 48
 399 0004 00AF     		add	r7, sp, #0
 400              	.LCFI17:
 401              		.cfi_def_cfa_register 7
 402 0006 F860     		str	r0, [r7, #12]
 403 0008 B960     		str	r1, [r7, #8]
 404 000a BB1D     		add	r3, r7, #6
 405 000c 1A80     		strh	r2, [r3]
 406              	.LBB2:
 272:../Generated_Code/UTIL0.c ****   unsigned char *ptr = ((unsigned char *)dst);
 407              		.loc 1 272 0
 408 000e FB68     		ldr	r3, [r7, #12]
 409 0010 BB61     		str	r3, [r7, #24]
 273:../Generated_Code/UTIL0.c ****   unsigned char i=0, j;
 410              		.loc 1 273 0
 411 0012 3B1C     		mov	r3, r7
 412 0014 1F33     		add	r3, r3, #31
 413 0016 0022     		mov	r2, #0
 414 0018 1A70     		strb	r2, [r3]
 274:../Generated_Code/UTIL0.c ****   unsigned char tmp;
 275:../Generated_Code/UTIL0.c **** 
 276:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 415              		.loc 1 276 0
 416 001a BB68     		ldr	r3, [r7, #8]
 417 001c 013B     		sub	r3, r3, #1
 418 001e BB60     		str	r3, [r7, #8]
 277:../Generated_Code/UTIL0.c ****   if (val == 0 && dstSize > 0){
 419              		.loc 1 277 0
 420 0020 BB1D     		add	r3, r7, #6
 421 0022 1B88     		ldrh	r3, [r3]
 422 0024 002B     		cmp	r3, #0
 423 0026 38D1     		bne	.L25
 424              		.loc 1 277 0 is_stmt 0
 425 0028 BB68     		ldr	r3, [r7, #8]
 426 002a 002B     		cmp	r3, #0
 427 002c 35D0     		beq	.L25
 278:../Generated_Code/UTIL0.c ****     ptr[i++] = '0';
 428              		.loc 1 278 0 is_stmt 1
 429 002e 3B1C     		mov	r3, r7
 430 0030 1F33     		add	r3, r3, #31
 431 0032 1B78     		ldrb	r3, [r3]
 432 0034 BA69     		ldr	r2, [r7, #24]
 433 0036 D318     		add	r3, r2, r3
 434 0038 3022     		mov	r2, #48
 435 003a 1A70     		strb	r2, [r3]
 436 003c 3B1C     		mov	r3, r7
 437 003e 1F33     		add	r3, r3, #31
 438 0040 3A1C     		mov	r2, r7
 439 0042 1F32     		add	r2, r2, #31
 440 0044 1278     		ldrb	r2, [r2]
 441 0046 0132     		add	r2, r2, #1
 442 0048 1A70     		strb	r2, [r3]
 279:../Generated_Code/UTIL0.c ****     dstSize--;
 443              		.loc 1 279 0
 444 004a BB68     		ldr	r3, [r7, #8]
 445 004c 013B     		sub	r3, r3, #1
 446 004e BB60     		str	r3, [r7, #8]
 280:../Generated_Code/UTIL0.c ****   }
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 447              		.loc 1 281 0
 448 0050 23E0     		b	.L25
 449              	.L28:
 282:../Generated_Code/UTIL0.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 450              		.loc 1 282 0
 451 0052 3B1C     		mov	r3, r7
 452 0054 1F33     		add	r3, r3, #31
 453 0056 1B78     		ldrb	r3, [r3]
 454 0058 BA69     		ldr	r2, [r7, #24]
 455 005a D418     		add	r4, r2, r3
 456 005c BB1D     		add	r3, r7, #6
 457 005e 1B88     		ldrh	r3, [r3]
 458 0060 181C     		mov	r0, r3
 459 0062 0A21     		mov	r1, #10
 460 0064 FFF7FEFF 		bl	__aeabi_uidivmod
 461 0068 0B1C     		mov	r3, r1
 462 006a 9BB2     		uxth	r3, r3
 463 006c DBB2     		uxtb	r3, r3
 464 006e 3033     		add	r3, r3, #48
 465 0070 DBB2     		uxtb	r3, r3
 466 0072 2370     		strb	r3, [r4]
 467 0074 3B1C     		mov	r3, r7
 468 0076 1F33     		add	r3, r3, #31
 469 0078 3A1C     		mov	r2, r7
 470 007a 1F32     		add	r2, r2, #31
 471 007c 1278     		ldrb	r2, [r2]
 472 007e 0132     		add	r2, r2, #1
 473 0080 1A70     		strb	r2, [r3]
 283:../Generated_Code/UTIL0.c ****     dstSize--;
 474              		.loc 1 283 0
 475 0082 BB68     		ldr	r3, [r7, #8]
 476 0084 013B     		sub	r3, r3, #1
 477 0086 BB60     		str	r3, [r7, #8]
 284:../Generated_Code/UTIL0.c ****     val /= 10;
 478              		.loc 1 284 0
 479 0088 BC1D     		add	r4, r7, #6
 480 008a BB1D     		add	r3, r7, #6
 481 008c 1B88     		ldrh	r3, [r3]
 482 008e 181C     		mov	r0, r3
 483 0090 0A21     		mov	r1, #10
 484 0092 FFF7FEFF 		bl	__aeabi_uidiv
 485 0096 031C     		mov	r3, r0
 486 0098 2380     		strh	r3, [r4]
 487              	.L25:
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 488              		.loc 1 281 0
 489 009a BB1D     		add	r3, r7, #6
 490 009c 1B88     		ldrh	r3, [r3]
 491 009e 002B     		cmp	r3, #0
 492 00a0 04D0     		beq	.L26
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 493              		.loc 1 281 0 is_stmt 0
 494 00a2 BB68     		ldr	r3, [r7, #8]
 495 00a4 002B     		cmp	r3, #0
 496 00a6 01D0     		beq	.L26
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 497              		.loc 1 281 0
 498 00a8 0123     		mov	r3, #1
 499 00aa 00E0     		b	.L27
 500              	.L26:
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 501              		.loc 1 281 0
 502 00ac 0023     		mov	r3, #0
 503              	.L27:
 281:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 504              		.loc 1 281 0
 505 00ae 002B     		cmp	r3, #0
 506 00b0 CFD1     		bne	.L28
 285:../Generated_Code/UTIL0.c ****   }
 286:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 507              		.loc 1 286 0 is_stmt 1
 508 00b2 3B1C     		mov	r3, r7
 509 00b4 1E33     		add	r3, r3, #30
 510 00b6 0022     		mov	r2, #0
 511 00b8 1A70     		strb	r2, [r3]
 512 00ba 2EE0     		b	.L29
 513              	.L30:
 287:../Generated_Code/UTIL0.c ****     tmp = ptr[j];
 514              		.loc 1 287 0
 515 00bc 3B1C     		mov	r3, r7
 516 00be 1E33     		add	r3, r3, #30
 517 00c0 1B78     		ldrb	r3, [r3]
 518 00c2 BA69     		ldr	r2, [r7, #24]
 519 00c4 D218     		add	r2, r2, r3
 520 00c6 3B1C     		mov	r3, r7
 521 00c8 1733     		add	r3, r3, #23
 522 00ca 1278     		ldrb	r2, [r2]
 523 00cc 1A70     		strb	r2, [r3]
 288:../Generated_Code/UTIL0.c ****     ptr[j] = ptr[(i-j)-1];
 524              		.loc 1 288 0
 525 00ce 3B1C     		mov	r3, r7
 526 00d0 1E33     		add	r3, r3, #30
 527 00d2 1B78     		ldrb	r3, [r3]
 528 00d4 BA69     		ldr	r2, [r7, #24]
 529 00d6 D318     		add	r3, r2, r3
 530 00d8 3A1C     		mov	r2, r7
 531 00da 1F32     		add	r2, r2, #31
 532 00dc 1178     		ldrb	r1, [r2]
 533 00de 3A1C     		mov	r2, r7
 534 00e0 1E32     		add	r2, r2, #30
 535 00e2 1278     		ldrb	r2, [r2]
 536 00e4 8A1A     		sub	r2, r1, r2
 537 00e6 013A     		sub	r2, r2, #1
 538 00e8 B969     		ldr	r1, [r7, #24]
 539 00ea 8A18     		add	r2, r1, r2
 540 00ec 1278     		ldrb	r2, [r2]
 541 00ee 1A70     		strb	r2, [r3]
 289:../Generated_Code/UTIL0.c ****     ptr[(i-j)-1] = tmp;
 542              		.loc 1 289 0
 543 00f0 3B1C     		mov	r3, r7
 544 00f2 1F33     		add	r3, r3, #31
 545 00f4 1A78     		ldrb	r2, [r3]
 546 00f6 3B1C     		mov	r3, r7
 547 00f8 1E33     		add	r3, r3, #30
 548 00fa 1B78     		ldrb	r3, [r3]
 549 00fc D31A     		sub	r3, r2, r3
 550 00fe 013B     		sub	r3, r3, #1
 551 0100 BA69     		ldr	r2, [r7, #24]
 552 0102 D318     		add	r3, r2, r3
 553 0104 3A1C     		mov	r2, r7
 554 0106 1732     		add	r2, r2, #23
 555 0108 1278     		ldrb	r2, [r2]
 556 010a 1A70     		strb	r2, [r3]
 286:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 557              		.loc 1 286 0
 558 010c 3B1C     		mov	r3, r7
 559 010e 1E33     		add	r3, r3, #30
 560 0110 3A1C     		mov	r2, r7
 561 0112 1E32     		add	r2, r2, #30
 562 0114 1278     		ldrb	r2, [r2]
 563 0116 0132     		add	r2, r2, #1
 564 0118 1A70     		strb	r2, [r3]
 565              	.L29:
 286:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 566              		.loc 1 286 0 is_stmt 0
 567 011a 3B1C     		mov	r3, r7
 568 011c 1F33     		add	r3, r3, #31
 569 011e 1B78     		ldrb	r3, [r3]
 570 0120 5B08     		lsr	r3, r3, #1
 571 0122 DBB2     		uxtb	r3, r3
 572 0124 3A1C     		mov	r2, r7
 573 0126 1E32     		add	r2, r2, #30
 574 0128 1278     		ldrb	r2, [r2]
 575 012a 9A42     		cmp	r2, r3
 576 012c 9B41     		sbc	r3, r3, r3
 577 012e 5B42     		neg	r3, r3
 578 0130 DBB2     		uxtb	r3, r3
 579 0132 002B     		cmp	r3, #0
 580 0134 C2D1     		bne	.L30
 290:../Generated_Code/UTIL0.c ****   }
 291:../Generated_Code/UTIL0.c ****   ptr[i] = '\0';
 581              		.loc 1 291 0 is_stmt 1
 582 0136 3B1C     		mov	r3, r7
 583 0138 1F33     		add	r3, r3, #31
 584 013a 1B78     		ldrb	r3, [r3]
 585 013c BA69     		ldr	r2, [r7, #24]
 586 013e D318     		add	r3, r2, r3
 587 0140 0022     		mov	r2, #0
 588 0142 1A70     		strb	r2, [r3]
 589              	.LBE2:
 292:../Generated_Code/UTIL0.c **** }
 590              		.loc 1 292 0
 591 0144 BD46     		mov	sp, r7
 592 0146 09B0     		add	sp, sp, #36
 593              		@ sp needed for prologue
 594 0148 90BD     		pop	{r4, r7, pc}
 595              		.cfi_endproc
 596              	.LFE10:
 598 014a C046     		.section	.rodata
 599              		.align	2
 600              	.LC0:
 601 0000 2D333237 		.ascii	"-32768\000"
 601      363800
 602              		.global	__aeabi_idivmod
 603              		.global	__aeabi_idiv
 604              		.section	.text._Z17UTIL0_Num16sToStrPhjs,"ax",%progbits
 605              		.align	2
 606              		.global	_Z17UTIL0_Num16sToStrPhjs
 607              		.code	16
 608              		.thumb_func
 610              	_Z17UTIL0_Num16sToStrPhjs:
 611              	.LFB11:
 293:../Generated_Code/UTIL0.c **** 
 294:../Generated_Code/UTIL0.c **** /*
 295:../Generated_Code/UTIL0.c **** ** ===================================================================
 296:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num16sToStr (component Utility)
 297:../Generated_Code/UTIL0.c **** **     Description :
 298:../Generated_Code/UTIL0.c **** **         Converts a signed 16bit value into a string.
 299:../Generated_Code/UTIL0.c **** **     Parameters  :
 300:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 301:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 302:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 303:../Generated_Code/UTIL0.c **** **                           bytes).
 304:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
 305:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 306:../Generated_Code/UTIL0.c **** ** ===================================================================
 307:../Generated_Code/UTIL0.c **** */
 308:../Generated_Code/UTIL0.c **** /*!
 309:../Generated_Code/UTIL0.c ****   \brief Converts a 16bit signed number into a string.
 310:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
 311:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 312:../Generated_Code/UTIL0.c ****   \param[in] val 16bit signed number to convert.
 313:../Generated_Code/UTIL0.c ****  */
 314:../Generated_Code/UTIL0.c **** void UTIL0_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 315:../Generated_Code/UTIL0.c **** {
 612              		.loc 1 315 0
 613              		.cfi_startproc
 614 0000 90B5     		push	{r4, r7, lr}
 615              	.LCFI18:
 616              		.cfi_def_cfa_offset 12
 617              		.cfi_offset 4, -12
 618              		.cfi_offset 7, -8
 619              		.cfi_offset 14, -4
 620 0002 89B0     		sub	sp, sp, #36
 621              	.LCFI19:
 622              		.cfi_def_cfa_offset 48
 623 0004 00AF     		add	r7, sp, #0
 624              	.LCFI20:
 625              		.cfi_def_cfa_register 7
 626 0006 F860     		str	r0, [r7, #12]
 627 0008 B960     		str	r1, [r7, #8]
 628 000a BB1D     		add	r3, r7, #6
 629 000c 1A80     		strh	r2, [r3]
 630              	.LBB3:
 316:../Generated_Code/UTIL0.c ****   unsigned char *ptr =  ((unsigned char *)dst);
 631              		.loc 1 316 0
 632 000e FB68     		ldr	r3, [r7, #12]
 633 0010 BB61     		str	r3, [r7, #24]
 317:../Generated_Code/UTIL0.c ****   unsigned char i=0, j;
 634              		.loc 1 317 0
 635 0012 3B1C     		mov	r3, r7
 636 0014 1F33     		add	r3, r3, #31
 637 0016 0022     		mov	r2, #0
 638 0018 1A70     		strb	r2, [r3]
 318:../Generated_Code/UTIL0.c ****   unsigned char tmp;
 319:../Generated_Code/UTIL0.c ****   unsigned char sign = (unsigned char)(val < 0);
 639              		.loc 1 319 0
 640 001a BB1D     		add	r3, r7, #6
 641 001c 1B88     		ldrh	r3, [r3]
 642 001e DB0B     		lsr	r3, r3, #15
 643 0020 DAB2     		uxtb	r2, r3
 644 0022 3B1C     		mov	r3, r7
 645 0024 1733     		add	r3, r3, #23
 646 0026 1A70     		strb	r2, [r3]
 320:../Generated_Code/UTIL0.c **** 
 321:../Generated_Code/UTIL0.c ****   if (val==(int16_t)(0x8000)) { /* special case 0x8000/-32768: prevent overflow below. */
 647              		.loc 1 321 0
 648 0028 BB1D     		add	r3, r7, #6
 649 002a 0021     		mov	r1, #0
 650 002c 5A5E     		ldrsh	r2, [r3, r1]
 651 002e 664B     		ldr	r3, .L43
 652 0030 9A42     		cmp	r2, r3
 653 0032 08D1     		bne	.L32
 322:../Generated_Code/UTIL0.c ****     UTIL0_strcpy(dst, dstSize, (unsigned char*)"-32768");
 654              		.loc 1 322 0
 655 0034 F968     		ldr	r1, [r7, #12]
 656 0036 BA68     		ldr	r2, [r7, #8]
 657 0038 644B     		ldr	r3, .L43+4
 658 003a 081C     		mov	r0, r1
 659 003c 111C     		mov	r1, r2
 660 003e 1A1C     		mov	r2, r3
 661 0040 FFF7FEFF 		bl	_Z12UTIL0_strcpyPhjPKh
 323:../Generated_Code/UTIL0.c ****     return;
 662              		.loc 1 323 0
 663 0044 BCE0     		b	.L31
 664              	.L32:
 324:../Generated_Code/UTIL0.c ****   }
 325:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 665              		.loc 1 325 0
 666 0046 BB68     		ldr	r3, [r7, #8]
 667 0048 013B     		sub	r3, r3, #1
 668 004a BB60     		str	r3, [r7, #8]
 326:../Generated_Code/UTIL0.c ****   if (sign) {
 669              		.loc 1 326 0
 670 004c 3B1C     		mov	r3, r7
 671 004e 1733     		add	r3, r3, #23
 672 0050 1B78     		ldrb	r3, [r3]
 673 0052 002B     		cmp	r3, #0
 674 0054 05D0     		beq	.L34
 327:../Generated_Code/UTIL0.c ****     val = -val;
 675              		.loc 1 327 0
 676 0056 BB1D     		add	r3, r7, #6
 677 0058 1B88     		ldrh	r3, [r3]
 678 005a 5B42     		neg	r3, r3
 679 005c 9AB2     		uxth	r2, r3
 680 005e BB1D     		add	r3, r7, #6
 681 0060 1A80     		strh	r2, [r3]
 682              	.L34:
 328:../Generated_Code/UTIL0.c ****   }
 329:../Generated_Code/UTIL0.c ****   if (val == 0 && dstSize > 0){
 683              		.loc 1 329 0
 684 0062 BB1D     		add	r3, r7, #6
 685 0064 0022     		mov	r2, #0
 686 0066 9B5E     		ldrsh	r3, [r3, r2]
 687 0068 002B     		cmp	r3, #0
 688 006a 3AD1     		bne	.L36
 689              		.loc 1 329 0 is_stmt 0
 690 006c BB68     		ldr	r3, [r7, #8]
 691 006e 002B     		cmp	r3, #0
 692 0070 37D0     		beq	.L36
 330:../Generated_Code/UTIL0.c ****     ptr[i++] = '0';
 693              		.loc 1 330 0 is_stmt 1
 694 0072 3B1C     		mov	r3, r7
 695 0074 1F33     		add	r3, r3, #31
 696 0076 1B78     		ldrb	r3, [r3]
 697 0078 BA69     		ldr	r2, [r7, #24]
 698 007a D318     		add	r3, r2, r3
 699 007c 3022     		mov	r2, #48
 700 007e 1A70     		strb	r2, [r3]
 701 0080 3B1C     		mov	r3, r7
 702 0082 1F33     		add	r3, r3, #31
 703 0084 3A1C     		mov	r2, r7
 704 0086 1F32     		add	r2, r2, #31
 705 0088 1278     		ldrb	r2, [r2]
 706 008a 0132     		add	r2, r2, #1
 707 008c 1A70     		strb	r2, [r3]
 331:../Generated_Code/UTIL0.c ****     dstSize--;
 708              		.loc 1 331 0
 709 008e BB68     		ldr	r3, [r7, #8]
 710 0090 013B     		sub	r3, r3, #1
 711 0092 BB60     		str	r3, [r7, #8]
 332:../Generated_Code/UTIL0.c ****   }
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 712              		.loc 1 333 0
 713 0094 25E0     		b	.L36
 714              	.L39:
 334:../Generated_Code/UTIL0.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 715              		.loc 1 334 0
 716 0096 3B1C     		mov	r3, r7
 717 0098 1F33     		add	r3, r3, #31
 718 009a 1B78     		ldrb	r3, [r3]
 719 009c BA69     		ldr	r2, [r7, #24]
 720 009e D418     		add	r4, r2, r3
 721 00a0 BB1D     		add	r3, r7, #6
 722 00a2 0021     		mov	r1, #0
 723 00a4 5B5E     		ldrsh	r3, [r3, r1]
 724 00a6 181C     		mov	r0, r3
 725 00a8 0A21     		mov	r1, #10
 726 00aa FFF7FEFF 		bl	__aeabi_idivmod
 727 00ae 0B1C     		mov	r3, r1
 728 00b0 9BB2     		uxth	r3, r3
 729 00b2 DBB2     		uxtb	r3, r3
 730 00b4 3033     		add	r3, r3, #48
 731 00b6 DBB2     		uxtb	r3, r3
 732 00b8 2370     		strb	r3, [r4]
 733 00ba 3B1C     		mov	r3, r7
 734 00bc 1F33     		add	r3, r3, #31
 735 00be 3A1C     		mov	r2, r7
 736 00c0 1F32     		add	r2, r2, #31
 737 00c2 1278     		ldrb	r2, [r2]
 738 00c4 0132     		add	r2, r2, #1
 739 00c6 1A70     		strb	r2, [r3]
 335:../Generated_Code/UTIL0.c ****     dstSize--;
 740              		.loc 1 335 0
 741 00c8 BB68     		ldr	r3, [r7, #8]
 742 00ca 013B     		sub	r3, r3, #1
 743 00cc BB60     		str	r3, [r7, #8]
 336:../Generated_Code/UTIL0.c ****     val /= 10;
 744              		.loc 1 336 0
 745 00ce BC1D     		add	r4, r7, #6
 746 00d0 BB1D     		add	r3, r7, #6
 747 00d2 0022     		mov	r2, #0
 748 00d4 9B5E     		ldrsh	r3, [r3, r2]
 749 00d6 181C     		mov	r0, r3
 750 00d8 0A21     		mov	r1, #10
 751 00da FFF7FEFF 		bl	__aeabi_idiv
 752 00de 031C     		mov	r3, r0
 753 00e0 2380     		strh	r3, [r4]
 754              	.L36:
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 755              		.loc 1 333 0
 756 00e2 BB1D     		add	r3, r7, #6
 757 00e4 0021     		mov	r1, #0
 758 00e6 5B5E     		ldrsh	r3, [r3, r1]
 759 00e8 002B     		cmp	r3, #0
 760 00ea 04DD     		ble	.L37
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 761              		.loc 1 333 0 is_stmt 0
 762 00ec BB68     		ldr	r3, [r7, #8]
 763 00ee 002B     		cmp	r3, #0
 764 00f0 01D0     		beq	.L37
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 765              		.loc 1 333 0
 766 00f2 0123     		mov	r3, #1
 767 00f4 00E0     		b	.L38
 768              	.L37:
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 769              		.loc 1 333 0
 770 00f6 0023     		mov	r3, #0
 771              	.L38:
 333:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 772              		.loc 1 333 0
 773 00f8 002B     		cmp	r3, #0
 774 00fa CCD1     		bne	.L39
 337:../Generated_Code/UTIL0.c ****   }
 338:../Generated_Code/UTIL0.c ****   if (sign && dstSize > 0){
 775              		.loc 1 338 0 is_stmt 1
 776 00fc 3B1C     		mov	r3, r7
 777 00fe 1733     		add	r3, r3, #23
 778 0100 1B78     		ldrb	r3, [r3]
 779 0102 002B     		cmp	r3, #0
 780 0104 13D0     		beq	.L40
 781              		.loc 1 338 0 is_stmt 0
 782 0106 BB68     		ldr	r3, [r7, #8]
 783 0108 002B     		cmp	r3, #0
 784 010a 10D0     		beq	.L40
 339:../Generated_Code/UTIL0.c ****     ptr[i++] = '-';
 785              		.loc 1 339 0 is_stmt 1
 786 010c 3B1C     		mov	r3, r7
 787 010e 1F33     		add	r3, r3, #31
 788 0110 1B78     		ldrb	r3, [r3]
 789 0112 BA69     		ldr	r2, [r7, #24]
 790 0114 D318     		add	r3, r2, r3
 791 0116 2D22     		mov	r2, #45
 792 0118 1A70     		strb	r2, [r3]
 793 011a 3B1C     		mov	r3, r7
 794 011c 1F33     		add	r3, r3, #31
 795 011e 3A1C     		mov	r2, r7
 796 0120 1F32     		add	r2, r2, #31
 797 0122 1278     		ldrb	r2, [r2]
 798 0124 0132     		add	r2, r2, #1
 799 0126 1A70     		strb	r2, [r3]
 340:../Generated_Code/UTIL0.c ****     dstSize--;
 800              		.loc 1 340 0
 801 0128 BB68     		ldr	r3, [r7, #8]
 802 012a 013B     		sub	r3, r3, #1
 803 012c BB60     		str	r3, [r7, #8]
 804              	.L40:
 341:../Generated_Code/UTIL0.c ****   }
 342:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 805              		.loc 1 342 0
 806 012e 3B1C     		mov	r3, r7
 807 0130 1E33     		add	r3, r3, #30
 808 0132 0022     		mov	r2, #0
 809 0134 1A70     		strb	r2, [r3]
 810 0136 2EE0     		b	.L41
 811              	.L42:
 343:../Generated_Code/UTIL0.c ****     tmp = ptr[j];
 812              		.loc 1 343 0
 813 0138 3B1C     		mov	r3, r7
 814 013a 1E33     		add	r3, r3, #30
 815 013c 1B78     		ldrb	r3, [r3]
 816 013e BA69     		ldr	r2, [r7, #24]
 817 0140 D218     		add	r2, r2, r3
 818 0142 3B1C     		mov	r3, r7
 819 0144 1633     		add	r3, r3, #22
 820 0146 1278     		ldrb	r2, [r2]
 821 0148 1A70     		strb	r2, [r3]
 344:../Generated_Code/UTIL0.c ****     ptr[j] = ptr[(i-j)-1];
 822              		.loc 1 344 0
 823 014a 3B1C     		mov	r3, r7
 824 014c 1E33     		add	r3, r3, #30
 825 014e 1B78     		ldrb	r3, [r3]
 826 0150 BA69     		ldr	r2, [r7, #24]
 827 0152 D318     		add	r3, r2, r3
 828 0154 3A1C     		mov	r2, r7
 829 0156 1F32     		add	r2, r2, #31
 830 0158 1178     		ldrb	r1, [r2]
 831 015a 3A1C     		mov	r2, r7
 832 015c 1E32     		add	r2, r2, #30
 833 015e 1278     		ldrb	r2, [r2]
 834 0160 8A1A     		sub	r2, r1, r2
 835 0162 013A     		sub	r2, r2, #1
 836 0164 B969     		ldr	r1, [r7, #24]
 837 0166 8A18     		add	r2, r1, r2
 838 0168 1278     		ldrb	r2, [r2]
 839 016a 1A70     		strb	r2, [r3]
 345:../Generated_Code/UTIL0.c ****     ptr[(i-j)-1] = tmp;
 840              		.loc 1 345 0
 841 016c 3B1C     		mov	r3, r7
 842 016e 1F33     		add	r3, r3, #31
 843 0170 1A78     		ldrb	r2, [r3]
 844 0172 3B1C     		mov	r3, r7
 845 0174 1E33     		add	r3, r3, #30
 846 0176 1B78     		ldrb	r3, [r3]
 847 0178 D31A     		sub	r3, r2, r3
 848 017a 013B     		sub	r3, r3, #1
 849 017c BA69     		ldr	r2, [r7, #24]
 850 017e D318     		add	r3, r2, r3
 851 0180 3A1C     		mov	r2, r7
 852 0182 1632     		add	r2, r2, #22
 853 0184 1278     		ldrb	r2, [r2]
 854 0186 1A70     		strb	r2, [r3]
 342:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 855              		.loc 1 342 0
 856 0188 3B1C     		mov	r3, r7
 857 018a 1E33     		add	r3, r3, #30
 858 018c 3A1C     		mov	r2, r7
 859 018e 1E32     		add	r2, r2, #30
 860 0190 1278     		ldrb	r2, [r2]
 861 0192 0132     		add	r2, r2, #1
 862 0194 1A70     		strb	r2, [r3]
 863              	.L41:
 342:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 864              		.loc 1 342 0 is_stmt 0
 865 0196 3B1C     		mov	r3, r7
 866 0198 1F33     		add	r3, r3, #31
 867 019a 1B78     		ldrb	r3, [r3]
 868 019c 5B08     		lsr	r3, r3, #1
 869 019e DBB2     		uxtb	r3, r3
 870 01a0 3A1C     		mov	r2, r7
 871 01a2 1E32     		add	r2, r2, #30
 872 01a4 1278     		ldrb	r2, [r2]
 873 01a6 9A42     		cmp	r2, r3
 874 01a8 9B41     		sbc	r3, r3, r3
 875 01aa 5B42     		neg	r3, r3
 876 01ac DBB2     		uxtb	r3, r3
 877 01ae 002B     		cmp	r3, #0
 878 01b0 C2D1     		bne	.L42
 346:../Generated_Code/UTIL0.c ****   }
 347:../Generated_Code/UTIL0.c ****   ptr[i] = '\0';
 879              		.loc 1 347 0 is_stmt 1
 880 01b2 3B1C     		mov	r3, r7
 881 01b4 1F33     		add	r3, r3, #31
 882 01b6 1B78     		ldrb	r3, [r3]
 883 01b8 BA69     		ldr	r2, [r7, #24]
 884 01ba D318     		add	r3, r2, r3
 885 01bc 0022     		mov	r2, #0
 886 01be 1A70     		strb	r2, [r3]
 887              	.L31:
 888              	.LBE3:
 348:../Generated_Code/UTIL0.c **** }
 889              		.loc 1 348 0
 890 01c0 BD46     		mov	sp, r7
 891 01c2 09B0     		add	sp, sp, #36
 892              		@ sp needed for prologue
 893 01c4 90BD     		pop	{r4, r7, pc}
 894              	.L44:
 895 01c6 C046     		.align	2
 896              	.L43:
 897 01c8 0080FFFF 		.word	-32768
 898 01cc 00000000 		.word	.LC0
 899              		.cfi_endproc
 900              	.LFE11:
 902              		.section	.text._ZL17ShiftRightAndFillPhhh,"ax",%progbits
 903              		.align	2
 904              		.code	16
 905              		.thumb_func
 907              	_ZL17ShiftRightAndFillPhhh:
 908              	.LFB12:
 349:../Generated_Code/UTIL0.c **** 
 350:../Generated_Code/UTIL0.c **** /*
 351:../Generated_Code/UTIL0.c **** ** ===================================================================
 352:../Generated_Code/UTIL0.c **** **     Method      :  ShiftRightAndFill (component Utility)
 353:../Generated_Code/UTIL0.c **** **
 354:../Generated_Code/UTIL0.c **** **     Description :
 355:../Generated_Code/UTIL0.c **** **         Moves the content of a string to the right and fills the space 
 356:../Generated_Code/UTIL0.c **** **         on the left side with a pattern
 357:../Generated_Code/UTIL0.c **** **         This method is internal. It is used by Processor Expert only.
 358:../Generated_Code/UTIL0.c **** ** ===================================================================
 359:../Generated_Code/UTIL0.c **** */
 360:../Generated_Code/UTIL0.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
 361:../Generated_Code/UTIL0.c **** {
 909              		.loc 1 361 0
 910              		.cfi_startproc
 911 0000 80B5     		push	{r7, lr}
 912              	.LCFI21:
 913              		.cfi_def_cfa_offset 8
 914              		.cfi_offset 7, -8
 915              		.cfi_offset 14, -4
 916 0002 84B0     		sub	sp, sp, #16
 917              	.LCFI22:
 918              		.cfi_def_cfa_offset 24
 919 0004 00AF     		add	r7, sp, #0
 920              	.LCFI23:
 921              		.cfi_def_cfa_register 7
 922 0006 7860     		str	r0, [r7, #4]
 923 0008 FB1C     		add	r3, r7, #3
 924 000a 1970     		strb	r1, [r3]
 925 000c BB1C     		add	r3, r7, #2
 926 000e 1A70     		strb	r2, [r3]
 927              	.LBB4:
 362:../Generated_Code/UTIL0.c ****   signed char i, j;
 363:../Generated_Code/UTIL0.c **** 
 364:../Generated_Code/UTIL0.c ****   j = 0;
 928              		.loc 1 364 0
 929 0010 3B1C     		mov	r3, r7
 930 0012 0E33     		add	r3, r3, #14
 931 0014 0022     		mov	r2, #0
 932 0016 1A70     		strb	r2, [r3]
 365:../Generated_Code/UTIL0.c ****   while(dst[j] != '\0') {
 933              		.loc 1 365 0
 934 0018 06E0     		b	.L46
 935              	.L47:
 366:../Generated_Code/UTIL0.c ****     j++;
 936              		.loc 1 366 0
 937 001a 3B1C     		mov	r3, r7
 938 001c 0E33     		add	r3, r3, #14
 939 001e 3A1C     		mov	r2, r7
 940 0020 0E32     		add	r2, r2, #14
 941 0022 1278     		ldrb	r2, [r2]
 942 0024 0132     		add	r2, r2, #1
 943 0026 1A70     		strb	r2, [r3]
 944              	.L46:
 365:../Generated_Code/UTIL0.c ****   while(dst[j] != '\0') {
 945              		.loc 1 365 0
 946 0028 3B1C     		mov	r3, r7
 947 002a 0E33     		add	r3, r3, #14
 948 002c 1B78     		ldrb	r3, [r3]
 949 002e 5BB2     		sxtb	r3, r3
 950 0030 7A68     		ldr	r2, [r7, #4]
 951 0032 D318     		add	r3, r2, r3
 952 0034 1B78     		ldrb	r3, [r3]
 953 0036 5A1E     		sub	r2, r3, #1
 954 0038 9341     		sbc	r3, r3, r2
 955 003a DBB2     		uxtb	r3, r3
 956 003c 002B     		cmp	r3, #0
 957 003e ECD1     		bne	.L47
 367:../Generated_Code/UTIL0.c ****   }
 368:../Generated_Code/UTIL0.c ****   i = (signed char)nofFill;
 958              		.loc 1 368 0
 959 0040 3B1C     		mov	r3, r7
 960 0042 0F33     		add	r3, r3, #15
 961 0044 BA1C     		add	r2, r7, #2
 962 0046 1278     		ldrb	r2, [r2]
 963 0048 1A70     		strb	r2, [r3]
 369:../Generated_Code/UTIL0.c ****   if (i==j) {
 964              		.loc 1 369 0
 965 004a 3A1C     		mov	r2, r7
 966 004c 0F32     		add	r2, r2, #15
 967 004e 3B1C     		mov	r3, r7
 968 0050 0E33     		add	r3, r3, #14
 969 0052 1278     		ldrb	r2, [r2]
 970 0054 52B2     		sxtb	r2, r2
 971 0056 1B78     		ldrb	r3, [r3]
 972 0058 5BB2     		sxtb	r3, r3
 973 005a 9A42     		cmp	r2, r3
 974 005c 49D0     		beq	.L45
 370:../Generated_Code/UTIL0.c ****     /* nothing to do, we are done */
 371:../Generated_Code/UTIL0.c ****   } else if (i>j) {
 975              		.loc 1 371 0
 976 005e 3A1C     		mov	r2, r7
 977 0060 0F32     		add	r2, r2, #15
 978 0062 3B1C     		mov	r3, r7
 979 0064 0E33     		add	r3, r3, #14
 980 0066 1278     		ldrb	r2, [r2]
 981 0068 52B2     		sxtb	r2, r2
 982 006a 1B78     		ldrb	r3, [r3]
 983 006c 5BB2     		sxtb	r3, r3
 984 006e 9A42     		cmp	r2, r3
 985 0070 3FDD     		ble	.L45
 372:../Generated_Code/UTIL0.c ****     while (j>=0) {
 986              		.loc 1 372 0
 987 0072 1BE0     		b	.L49
 988              	.L50:
 373:../Generated_Code/UTIL0.c ****       dst[i] = dst[j];
 989              		.loc 1 373 0
 990 0074 3B1C     		mov	r3, r7
 991 0076 0F33     		add	r3, r3, #15
 992 0078 1B78     		ldrb	r3, [r3]
 993 007a 5BB2     		sxtb	r3, r3
 994 007c 7A68     		ldr	r2, [r7, #4]
 995 007e D318     		add	r3, r2, r3
 996 0080 3A1C     		mov	r2, r7
 997 0082 0E32     		add	r2, r2, #14
 998 0084 1278     		ldrb	r2, [r2]
 999 0086 52B2     		sxtb	r2, r2
 1000 0088 7968     		ldr	r1, [r7, #4]
 1001 008a 8A18     		add	r2, r1, r2
 1002 008c 1278     		ldrb	r2, [r2]
 1003 008e 1A70     		strb	r2, [r3]
 374:../Generated_Code/UTIL0.c ****       i--; j--;
 1004              		.loc 1 374 0
 1005 0090 3B1C     		mov	r3, r7
 1006 0092 0F33     		add	r3, r3, #15
 1007 0094 3A1C     		mov	r2, r7
 1008 0096 0F32     		add	r2, r2, #15
 1009 0098 1278     		ldrb	r2, [r2]
 1010 009a 013A     		sub	r2, r2, #1
 1011 009c 1A70     		strb	r2, [r3]
 1012 009e 3B1C     		mov	r3, r7
 1013 00a0 0E33     		add	r3, r3, #14
 1014 00a2 3A1C     		mov	r2, r7
 1015 00a4 0E32     		add	r2, r2, #14
 1016 00a6 1278     		ldrb	r2, [r2]
 1017 00a8 013A     		sub	r2, r2, #1
 1018 00aa 1A70     		strb	r2, [r3]
 1019              	.L49:
 372:../Generated_Code/UTIL0.c ****     while (j>=0) {
 1020              		.loc 1 372 0
 1021 00ac 3B1C     		mov	r3, r7
 1022 00ae 0E33     		add	r3, r3, #14
 1023 00b0 1B78     		ldrb	r3, [r3]
 1024 00b2 DB43     		mvn	r3, r3
 1025 00b4 DBB2     		uxtb	r3, r3
 1026 00b6 DB09     		lsr	r3, r3, #7
 1027 00b8 DBB2     		uxtb	r3, r3
 1028 00ba 002B     		cmp	r3, #0
 1029 00bc DAD1     		bne	.L50
 375:../Generated_Code/UTIL0.c ****     }
 376:../Generated_Code/UTIL0.c ****     while(i>=0) {
 1030              		.loc 1 376 0
 1031 00be 0FE0     		b	.L51
 1032              	.L52:
 377:../Generated_Code/UTIL0.c ****       dst[i] = fill;
 1033              		.loc 1 377 0
 1034 00c0 3B1C     		mov	r3, r7
 1035 00c2 0F33     		add	r3, r3, #15
 1036 00c4 1B78     		ldrb	r3, [r3]
 1037 00c6 5BB2     		sxtb	r3, r3
 1038 00c8 7A68     		ldr	r2, [r7, #4]
 1039 00ca D318     		add	r3, r2, r3
 1040 00cc FA1C     		add	r2, r7, #3
 1041 00ce 1278     		ldrb	r2, [r2]
 1042 00d0 1A70     		strb	r2, [r3]
 378:../Generated_Code/UTIL0.c ****       i--;
 1043              		.loc 1 378 0
 1044 00d2 3B1C     		mov	r3, r7
 1045 00d4 0F33     		add	r3, r3, #15
 1046 00d6 3A1C     		mov	r2, r7
 1047 00d8 0F32     		add	r2, r2, #15
 1048 00da 1278     		ldrb	r2, [r2]
 1049 00dc 013A     		sub	r2, r2, #1
 1050 00de 1A70     		strb	r2, [r3]
 1051              	.L51:
 376:../Generated_Code/UTIL0.c ****     while(i>=0) {
 1052              		.loc 1 376 0
 1053 00e0 3B1C     		mov	r3, r7
 1054 00e2 0F33     		add	r3, r3, #15
 1055 00e4 1B78     		ldrb	r3, [r3]
 1056 00e6 DB43     		mvn	r3, r3
 1057 00e8 DBB2     		uxtb	r3, r3
 1058 00ea DB09     		lsr	r3, r3, #7
 1059 00ec DBB2     		uxtb	r3, r3
 1060 00ee 002B     		cmp	r3, #0
 1061 00f0 E6D1     		bne	.L52
 1062              	.L45:
 1063              	.LBE4:
 379:../Generated_Code/UTIL0.c ****     }
 380:../Generated_Code/UTIL0.c ****   } else {
 381:../Generated_Code/UTIL0.c ****     /* hmmm, not enough space, return what we have, do nothing */
 382:../Generated_Code/UTIL0.c ****   }
 383:../Generated_Code/UTIL0.c **** }
 1064              		.loc 1 383 0
 1065 00f2 BD46     		mov	sp, r7
 1066 00f4 04B0     		add	sp, sp, #16
 1067              		@ sp needed for prologue
 1068 00f6 80BD     		pop	{r7, pc}
 1069              		.cfi_endproc
 1070              	.LFE12:
 1072              		.section	.text._Z26UTIL0_Num16sToStrFormattedPhjsch,"ax",%progbits
 1073              		.align	2
 1074              		.global	_Z26UTIL0_Num16sToStrFormattedPhjsch
 1075              		.code	16
 1076              		.thumb_func
 1078              	_Z26UTIL0_Num16sToStrFormattedPhjsch:
 1079              	.LFB13:
 384:../Generated_Code/UTIL0.c **** 
 385:../Generated_Code/UTIL0.c **** /*
 386:../Generated_Code/UTIL0.c **** ** ===================================================================
 387:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num16sToStrFormatted (component Utility)
 388:../Generated_Code/UTIL0.c **** **     Description :
 389:../Generated_Code/UTIL0.c **** **         Converts a 16bit signed value to string.
 390:../Generated_Code/UTIL0.c **** **     Parameters  :
 391:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 392:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 393:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 394:../Generated_Code/UTIL0.c **** **                           bytes).
 395:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 396:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 397:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 398:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 399:../Generated_Code/UTIL0.c **** ** ===================================================================
 400:../Generated_Code/UTIL0.c **** */
 401:../Generated_Code/UTIL0.c **** /*!
 402:../Generated_Code/UTIL0.c ****   \brief Converts a 16bit signed number to a string, in a formatted way (like printf with "%0d").
 403:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 404:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 405:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 406:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 407:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 408:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit signed number to add
 409:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 410:../Generated_Code/UTIL0.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 411:../Generated_Code/UTIL0.c **** */
 412:../Generated_Code/UTIL0.c **** void UTIL0_Num16sToStrFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 413:../Generated_Code/UTIL0.c **** {
 1080              		.loc 1 413 0
 1081              		.cfi_startproc
 1082 0000 80B5     		push	{r7, lr}
 1083              	.LCFI24:
 1084              		.cfi_def_cfa_offset 8
 1085              		.cfi_offset 7, -8
 1086              		.cfi_offset 14, -4
 1087 0002 84B0     		sub	sp, sp, #16
 1088              	.LCFI25:
 1089              		.cfi_def_cfa_offset 24
 1090 0004 00AF     		add	r7, sp, #0
 1091              	.LCFI26:
 1092              		.cfi_def_cfa_register 7
 1093 0006 F860     		str	r0, [r7, #12]
 1094 0008 B960     		str	r1, [r7, #8]
 1095 000a 111C     		mov	r1, r2
 1096 000c 1A1C     		mov	r2, r3
 1097 000e BB1D     		add	r3, r7, #6
 1098 0010 1980     		strh	r1, [r3]
 1099 0012 7B1D     		add	r3, r7, #5
 1100 0014 1A70     		strb	r2, [r3]
 414:../Generated_Code/UTIL0.c ****   UTIL0_Num16sToStr(dst, dstSize, val);
 1101              		.loc 1 414 0
 1102 0016 F968     		ldr	r1, [r7, #12]
 1103 0018 BA68     		ldr	r2, [r7, #8]
 1104 001a BB1D     		add	r3, r7, #6
 1105 001c 0020     		mov	r0, #0
 1106 001e 1B5E     		ldrsh	r3, [r3, r0]
 1107 0020 081C     		mov	r0, r1
 1108 0022 111C     		mov	r1, r2
 1109 0024 1A1C     		mov	r2, r3
 1110 0026 FFF7FEFF 		bl	_Z17UTIL0_Num16sToStrPhjs
 415:../Generated_Code/UTIL0.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1111              		.loc 1 415 0
 1112 002a F968     		ldr	r1, [r7, #12]
 1113 002c 7B1D     		add	r3, r7, #5
 1114 002e 1A78     		ldrb	r2, [r3]
 1115 0030 3B1C     		mov	r3, r7
 1116 0032 1833     		add	r3, r3, #24
 1117 0034 1B78     		ldrb	r3, [r3]
 1118 0036 081C     		mov	r0, r1
 1119 0038 111C     		mov	r1, r2
 1120 003a 1A1C     		mov	r2, r3
 1121 003c FFF7FEFF 		bl	_ZL17ShiftRightAndFillPhhh
 416:../Generated_Code/UTIL0.c **** }
 1122              		.loc 1 416 0
 1123 0040 BD46     		mov	sp, r7
 1124 0042 04B0     		add	sp, sp, #16
 1125              		@ sp needed for prologue
 1126 0044 80BD     		pop	{r7, pc}
 1127              		.cfi_endproc
 1128              	.LFE13:
 1130 0046 C046     		.section	.text._Z26UTIL0_Num16uToStrFormattedPhjtch,"ax",%progbits
 1131              		.align	2
 1132              		.global	_Z26UTIL0_Num16uToStrFormattedPhjtch
 1133              		.code	16
 1134              		.thumb_func
 1136              	_Z26UTIL0_Num16uToStrFormattedPhjtch:
 1137              	.LFB14:
 417:../Generated_Code/UTIL0.c **** 
 418:../Generated_Code/UTIL0.c **** /*
 419:../Generated_Code/UTIL0.c **** ** ===================================================================
 420:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num16uToStrFormatted (component Utility)
 421:../Generated_Code/UTIL0.c **** **     Description :
 422:../Generated_Code/UTIL0.c **** **         Converts a 16bit unsigned value to string.
 423:../Generated_Code/UTIL0.c **** **     Parameters  :
 424:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 425:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 426:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 427:../Generated_Code/UTIL0.c **** **                           bytes).
 428:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 429:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 430:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 431:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 432:../Generated_Code/UTIL0.c **** ** ===================================================================
 433:../Generated_Code/UTIL0.c **** */
 434:../Generated_Code/UTIL0.c **** /*!
 435:../Generated_Code/UTIL0.c ****   \brief Converts a 16bit unsigned number to a string, in a formatted way (like printf with "%0d").
 436:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 437:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 438:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 439:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 440:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 441:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit unsigned number to add
 442:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 443:../Generated_Code/UTIL0.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 444:../Generated_Code/UTIL0.c **** */
 445:../Generated_Code/UTIL0.c **** void UTIL0_Num16uToStrFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 446:../Generated_Code/UTIL0.c **** {
 1138              		.loc 1 446 0
 1139              		.cfi_startproc
 1140 0000 80B5     		push	{r7, lr}
 1141              	.LCFI27:
 1142              		.cfi_def_cfa_offset 8
 1143              		.cfi_offset 7, -8
 1144              		.cfi_offset 14, -4
 1145 0002 84B0     		sub	sp, sp, #16
 1146              	.LCFI28:
 1147              		.cfi_def_cfa_offset 24
 1148 0004 00AF     		add	r7, sp, #0
 1149              	.LCFI29:
 1150              		.cfi_def_cfa_register 7
 1151 0006 F860     		str	r0, [r7, #12]
 1152 0008 B960     		str	r1, [r7, #8]
 1153 000a 111C     		mov	r1, r2
 1154 000c 1A1C     		mov	r2, r3
 1155 000e BB1D     		add	r3, r7, #6
 1156 0010 1980     		strh	r1, [r3]
 1157 0012 7B1D     		add	r3, r7, #5
 1158 0014 1A70     		strb	r2, [r3]
 447:../Generated_Code/UTIL0.c ****   UTIL0_Num16uToStr(dst, dstSize, val);
 1159              		.loc 1 447 0
 1160 0016 F968     		ldr	r1, [r7, #12]
 1161 0018 BA68     		ldr	r2, [r7, #8]
 1162 001a BB1D     		add	r3, r7, #6
 1163 001c 1B88     		ldrh	r3, [r3]
 1164 001e 081C     		mov	r0, r1
 1165 0020 111C     		mov	r1, r2
 1166 0022 1A1C     		mov	r2, r3
 1167 0024 FFF7FEFF 		bl	_Z17UTIL0_Num16uToStrPhjt
 448:../Generated_Code/UTIL0.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1168              		.loc 1 448 0
 1169 0028 F968     		ldr	r1, [r7, #12]
 1170 002a 7B1D     		add	r3, r7, #5
 1171 002c 1A78     		ldrb	r2, [r3]
 1172 002e 3B1C     		mov	r3, r7
 1173 0030 1833     		add	r3, r3, #24
 1174 0032 1B78     		ldrb	r3, [r3]
 1175 0034 081C     		mov	r0, r1
 1176 0036 111C     		mov	r1, r2
 1177 0038 1A1C     		mov	r2, r3
 1178 003a FFF7FEFF 		bl	_ZL17ShiftRightAndFillPhhh
 449:../Generated_Code/UTIL0.c **** }
 1179              		.loc 1 449 0
 1180 003e BD46     		mov	sp, r7
 1181 0040 04B0     		add	sp, sp, #16
 1182              		@ sp needed for prologue
 1183 0042 80BD     		pop	{r7, pc}
 1184              		.cfi_endproc
 1185              	.LFE14:
 1187              		.section	.text._Z26UTIL0_Num32uToStrFormattedPhjmch,"ax",%progbits
 1188              		.align	2
 1189              		.global	_Z26UTIL0_Num32uToStrFormattedPhjmch
 1190              		.code	16
 1191              		.thumb_func
 1193              	_Z26UTIL0_Num32uToStrFormattedPhjmch:
 1194              	.LFB15:
 450:../Generated_Code/UTIL0.c **** 
 451:../Generated_Code/UTIL0.c **** /*
 452:../Generated_Code/UTIL0.c **** ** ===================================================================
 453:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num32uToStrFormatted (component Utility)
 454:../Generated_Code/UTIL0.c **** **     Description :
 455:../Generated_Code/UTIL0.c **** **         Converts a 32bit unsigned value to string.
 456:../Generated_Code/UTIL0.c **** **     Parameters  :
 457:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 458:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 459:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 460:../Generated_Code/UTIL0.c **** **                           bytes).
 461:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 462:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 463:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 464:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 465:../Generated_Code/UTIL0.c **** ** ===================================================================
 466:../Generated_Code/UTIL0.c **** */
 467:../Generated_Code/UTIL0.c **** /*!
 468:../Generated_Code/UTIL0.c ****   \brief Converts a 32bit unsigned number to a string, in a formatted way (like printf with "%0d").
 469:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 470:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 471:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 472:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 473:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 474:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit unsigned number to add
 475:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 476:../Generated_Code/UTIL0.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 477:../Generated_Code/UTIL0.c **** */
 478:../Generated_Code/UTIL0.c **** void UTIL0_Num32uToStrFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 479:../Generated_Code/UTIL0.c **** {
 1195              		.loc 1 479 0
 1196              		.cfi_startproc
 1197 0000 80B5     		push	{r7, lr}
 1198              	.LCFI30:
 1199              		.cfi_def_cfa_offset 8
 1200              		.cfi_offset 7, -8
 1201              		.cfi_offset 14, -4
 1202 0002 84B0     		sub	sp, sp, #16
 1203              	.LCFI31:
 1204              		.cfi_def_cfa_offset 24
 1205 0004 00AF     		add	r7, sp, #0
 1206              	.LCFI32:
 1207              		.cfi_def_cfa_register 7
 1208 0006 F860     		str	r0, [r7, #12]
 1209 0008 B960     		str	r1, [r7, #8]
 1210 000a 7A60     		str	r2, [r7, #4]
 1211 000c 1A1C     		mov	r2, r3
 1212 000e FB1C     		add	r3, r7, #3
 1213 0010 1A70     		strb	r2, [r3]
 480:../Generated_Code/UTIL0.c ****   UTIL0_Num32uToStr(dst, dstSize, val);
 1214              		.loc 1 480 0
 1215 0012 F968     		ldr	r1, [r7, #12]
 1216 0014 BA68     		ldr	r2, [r7, #8]
 1217 0016 7B68     		ldr	r3, [r7, #4]
 1218 0018 081C     		mov	r0, r1
 1219 001a 111C     		mov	r1, r2
 1220 001c 1A1C     		mov	r2, r3
 1221 001e FFF7FEFF 		bl	_Z17UTIL0_Num32uToStrPhjm
 481:../Generated_Code/UTIL0.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1222              		.loc 1 481 0
 1223 0022 F968     		ldr	r1, [r7, #12]
 1224 0024 FB1C     		add	r3, r7, #3
 1225 0026 1A78     		ldrb	r2, [r3]
 1226 0028 3B1C     		mov	r3, r7
 1227 002a 1833     		add	r3, r3, #24
 1228 002c 1B78     		ldrb	r3, [r3]
 1229 002e 081C     		mov	r0, r1
 1230 0030 111C     		mov	r1, r2
 1231 0032 1A1C     		mov	r2, r3
 1232 0034 FFF7FEFF 		bl	_ZL17ShiftRightAndFillPhhh
 482:../Generated_Code/UTIL0.c **** }
 1233              		.loc 1 482 0
 1234 0038 BD46     		mov	sp, r7
 1235 003a 04B0     		add	sp, sp, #16
 1236              		@ sp needed for prologue
 1237 003c 80BD     		pop	{r7, pc}
 1238              		.cfi_endproc
 1239              	.LFE15:
 1241 003e C046     		.section	.text._Z26UTIL0_Num32sToStrFormattedPhjlch,"ax",%progbits
 1242              		.align	2
 1243              		.global	_Z26UTIL0_Num32sToStrFormattedPhjlch
 1244              		.code	16
 1245              		.thumb_func
 1247              	_Z26UTIL0_Num32sToStrFormattedPhjlch:
 1248              	.LFB16:
 483:../Generated_Code/UTIL0.c **** 
 484:../Generated_Code/UTIL0.c **** /*
 485:../Generated_Code/UTIL0.c **** ** ===================================================================
 486:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num32sToStrFormatted (component Utility)
 487:../Generated_Code/UTIL0.c **** **     Description :
 488:../Generated_Code/UTIL0.c **** **         Converts a 32bit signed value to string.
 489:../Generated_Code/UTIL0.c **** **     Parameters  :
 490:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 491:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 492:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 493:../Generated_Code/UTIL0.c **** **                           bytes).
 494:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 495:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 496:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 497:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 498:../Generated_Code/UTIL0.c **** ** ===================================================================
 499:../Generated_Code/UTIL0.c **** */
 500:../Generated_Code/UTIL0.c **** /*!
 501:../Generated_Code/UTIL0.c ****   \brief Converts a 32bit signed number to a string, in a formatted way (like printf with "%0d").
 502:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 503:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 504:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 505:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 506:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 507:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit signed number to add
 508:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 509:../Generated_Code/UTIL0.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 510:../Generated_Code/UTIL0.c **** */
 511:../Generated_Code/UTIL0.c **** void UTIL0_Num32sToStrFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 512:../Generated_Code/UTIL0.c **** {
 1249              		.loc 1 512 0
 1250              		.cfi_startproc
 1251 0000 80B5     		push	{r7, lr}
 1252              	.LCFI33:
 1253              		.cfi_def_cfa_offset 8
 1254              		.cfi_offset 7, -8
 1255              		.cfi_offset 14, -4
 1256 0002 84B0     		sub	sp, sp, #16
 1257              	.LCFI34:
 1258              		.cfi_def_cfa_offset 24
 1259 0004 00AF     		add	r7, sp, #0
 1260              	.LCFI35:
 1261              		.cfi_def_cfa_register 7
 1262 0006 F860     		str	r0, [r7, #12]
 1263 0008 B960     		str	r1, [r7, #8]
 1264 000a 7A60     		str	r2, [r7, #4]
 1265 000c 1A1C     		mov	r2, r3
 1266 000e FB1C     		add	r3, r7, #3
 1267 0010 1A70     		strb	r2, [r3]
 513:../Generated_Code/UTIL0.c ****   UTIL0_Num32sToStr(dst, dstSize, val);
 1268              		.loc 1 513 0
 1269 0012 F968     		ldr	r1, [r7, #12]
 1270 0014 BA68     		ldr	r2, [r7, #8]
 1271 0016 7B68     		ldr	r3, [r7, #4]
 1272 0018 081C     		mov	r0, r1
 1273 001a 111C     		mov	r1, r2
 1274 001c 1A1C     		mov	r2, r3
 1275 001e FFF7FEFF 		bl	_Z17UTIL0_Num32sToStrPhjl
 514:../Generated_Code/UTIL0.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1276              		.loc 1 514 0
 1277 0022 F968     		ldr	r1, [r7, #12]
 1278 0024 FB1C     		add	r3, r7, #3
 1279 0026 1A78     		ldrb	r2, [r3]
 1280 0028 3B1C     		mov	r3, r7
 1281 002a 1833     		add	r3, r3, #24
 1282 002c 1B78     		ldrb	r3, [r3]
 1283 002e 081C     		mov	r0, r1
 1284 0030 111C     		mov	r1, r2
 1285 0032 1A1C     		mov	r2, r3
 1286 0034 FFF7FEFF 		bl	_ZL17ShiftRightAndFillPhhh
 515:../Generated_Code/UTIL0.c **** }
 1287              		.loc 1 515 0
 1288 0038 BD46     		mov	sp, r7
 1289 003a 04B0     		add	sp, sp, #16
 1290              		@ sp needed for prologue
 1291 003c 80BD     		pop	{r7, pc}
 1292              		.cfi_endproc
 1293              	.LFE16:
 1295 003e C046     		.section	.text._Z17UTIL0_strcatNum8uPhjh,"ax",%progbits
 1296              		.align	2
 1297              		.global	_Z17UTIL0_strcatNum8uPhjh
 1298              		.code	16
 1299              		.thumb_func
 1301              	_Z17UTIL0_strcatNum8uPhjh:
 1302              	.LFB17:
 516:../Generated_Code/UTIL0.c **** 
 517:../Generated_Code/UTIL0.c **** /*
 518:../Generated_Code/UTIL0.c **** ** ===================================================================
 519:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum8u (component Utility)
 520:../Generated_Code/UTIL0.c **** **     Description :
 521:../Generated_Code/UTIL0.c **** **         Appends a 8bit unsigned value to a string buffer.
 522:../Generated_Code/UTIL0.c **** **     Parameters  :
 523:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 524:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 525:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 526:../Generated_Code/UTIL0.c **** **                           bytes).
 527:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 528:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 529:../Generated_Code/UTIL0.c **** ** ===================================================================
 530:../Generated_Code/UTIL0.c **** */
 531:../Generated_Code/UTIL0.c **** /*!
 532:../Generated_Code/UTIL0.c ****   \brief appends a 8bit unsigned number to a string. Always terminates the result string.
 533:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 534:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 535:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 536:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 537:../Generated_Code/UTIL0.c ****   \param[in] val The 8bit unsigned number to add
 538:../Generated_Code/UTIL0.c ****   */
 539:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum8u(byte *dst, size_t dstSize, byte val)
 540:../Generated_Code/UTIL0.c **** {
 1303              		.loc 1 540 0
 1304              		.cfi_startproc
 1305 0000 80B5     		push	{r7, lr}
 1306              	.LCFI36:
 1307              		.cfi_def_cfa_offset 8
 1308              		.cfi_offset 7, -8
 1309              		.cfi_offset 14, -4
 1310 0002 86B0     		sub	sp, sp, #24
 1311              	.LCFI37:
 1312              		.cfi_def_cfa_offset 32
 1313 0004 00AF     		add	r7, sp, #0
 1314              	.LCFI38:
 1315              		.cfi_def_cfa_register 7
 1316 0006 F860     		str	r0, [r7, #12]
 1317 0008 B960     		str	r1, [r7, #8]
 1318 000a FB1D     		add	r3, r7, #7
 1319 000c 1A70     		strb	r2, [r3]
 1320              	.LBB5:
 541:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("256")]; /* maximum buffer size we need */
 542:../Generated_Code/UTIL0.c **** 
 543:../Generated_Code/UTIL0.c ****   UTIL0_Num8uToStr(buf, sizeof(buf), val);
 1321              		.loc 1 543 0
 1322 000e 3A1C     		mov	r2, r7
 1323 0010 1432     		add	r2, r2, #20
 1324 0012 FB1D     		add	r3, r7, #7
 1325 0014 1B78     		ldrb	r3, [r3]
 1326 0016 101C     		mov	r0, r2
 1327 0018 0421     		mov	r1, #4
 1328 001a 1A1C     		mov	r2, r3
 1329 001c FFF7FEFF 		bl	_Z16UTIL0_Num8uToStrPhjh
 544:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1330              		.loc 1 544 0
 1331 0020 F968     		ldr	r1, [r7, #12]
 1332 0022 BA68     		ldr	r2, [r7, #8]
 1333 0024 3B1C     		mov	r3, r7
 1334 0026 1433     		add	r3, r3, #20
 1335 0028 081C     		mov	r0, r1
 1336 002a 111C     		mov	r1, r2
 1337 002c 1A1C     		mov	r2, r3
 1338 002e FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1339              	.LBE5:
 545:../Generated_Code/UTIL0.c **** }
 1340              		.loc 1 545 0
 1341 0032 BD46     		mov	sp, r7
 1342 0034 06B0     		add	sp, sp, #24
 1343              		@ sp needed for prologue
 1344 0036 80BD     		pop	{r7, pc}
 1345              		.cfi_endproc
 1346              	.LFE17:
 1348              		.section	.text._Z17UTIL0_strcatNum8sPhja,"ax",%progbits
 1349              		.align	2
 1350              		.global	_Z17UTIL0_strcatNum8sPhja
 1351              		.code	16
 1352              		.thumb_func
 1354              	_Z17UTIL0_strcatNum8sPhja:
 1355              	.LFB18:
 546:../Generated_Code/UTIL0.c **** 
 547:../Generated_Code/UTIL0.c **** /*
 548:../Generated_Code/UTIL0.c **** ** ===================================================================
 549:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum8s (component Utility)
 550:../Generated_Code/UTIL0.c **** **     Description :
 551:../Generated_Code/UTIL0.c **** **         Appends a 8bit signed value to a string buffer.
 552:../Generated_Code/UTIL0.c **** **     Parameters  :
 553:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 554:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 555:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 556:../Generated_Code/UTIL0.c **** **                           bytes).
 557:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 558:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 559:../Generated_Code/UTIL0.c **** ** ===================================================================
 560:../Generated_Code/UTIL0.c **** */
 561:../Generated_Code/UTIL0.c **** /*!
 562:../Generated_Code/UTIL0.c ****   \brief appends a 8bit signed number to a string. Always terminates the result string.
 563:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 564:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 565:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 566:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 567:../Generated_Code/UTIL0.c ****   \param[in] val The 8bit signed number to add
 568:../Generated_Code/UTIL0.c ****   */
 569:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum8s(byte *dst, size_t dstSize, signed char val)
 570:../Generated_Code/UTIL0.c **** {
 1356              		.loc 1 570 0
 1357              		.cfi_startproc
 1358 0000 80B5     		push	{r7, lr}
 1359              	.LCFI39:
 1360              		.cfi_def_cfa_offset 8
 1361              		.cfi_offset 7, -8
 1362              		.cfi_offset 14, -4
 1363 0002 86B0     		sub	sp, sp, #24
 1364              	.LCFI40:
 1365              		.cfi_def_cfa_offset 32
 1366 0004 00AF     		add	r7, sp, #0
 1367              	.LCFI41:
 1368              		.cfi_def_cfa_register 7
 1369 0006 F860     		str	r0, [r7, #12]
 1370 0008 B960     		str	r1, [r7, #8]
 1371 000a FB1D     		add	r3, r7, #7
 1372 000c 1A70     		strb	r2, [r3]
 1373              	.LBB6:
 571:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */
 572:../Generated_Code/UTIL0.c **** 
 573:../Generated_Code/UTIL0.c ****   UTIL0_Num8sToStr(buf, sizeof(buf), val);
 1374              		.loc 1 573 0
 1375 000e 3A1C     		mov	r2, r7
 1376 0010 1032     		add	r2, r2, #16
 1377 0012 FB1D     		add	r3, r7, #7
 1378 0014 1B78     		ldrb	r3, [r3]
 1379 0016 5BB2     		sxtb	r3, r3
 1380 0018 101C     		mov	r0, r2
 1381 001a 0521     		mov	r1, #5
 1382 001c 1A1C     		mov	r2, r3
 1383 001e FFF7FEFF 		bl	_Z16UTIL0_Num8sToStrPhja
 574:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1384              		.loc 1 574 0
 1385 0022 F968     		ldr	r1, [r7, #12]
 1386 0024 BA68     		ldr	r2, [r7, #8]
 1387 0026 3B1C     		mov	r3, r7
 1388 0028 1033     		add	r3, r3, #16
 1389 002a 081C     		mov	r0, r1
 1390 002c 111C     		mov	r1, r2
 1391 002e 1A1C     		mov	r2, r3
 1392 0030 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1393              	.LBE6:
 575:../Generated_Code/UTIL0.c **** }
 1394              		.loc 1 575 0
 1395 0034 BD46     		mov	sp, r7
 1396 0036 06B0     		add	sp, sp, #24
 1397              		@ sp needed for prologue
 1398 0038 80BD     		pop	{r7, pc}
 1399              		.cfi_endproc
 1400              	.LFE18:
 1402 003a C046     		.section	.text._Z18UTIL0_strcatNum16uPhjt,"ax",%progbits
 1403              		.align	2
 1404              		.global	_Z18UTIL0_strcatNum16uPhjt
 1405              		.code	16
 1406              		.thumb_func
 1408              	_Z18UTIL0_strcatNum16uPhjt:
 1409              	.LFB19:
 576:../Generated_Code/UTIL0.c **** 
 577:../Generated_Code/UTIL0.c **** /*
 578:../Generated_Code/UTIL0.c **** ** ===================================================================
 579:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum16u (component Utility)
 580:../Generated_Code/UTIL0.c **** **     Description :
 581:../Generated_Code/UTIL0.c **** **         Appends a 16bit unsigned value to a string buffer.
 582:../Generated_Code/UTIL0.c **** **     Parameters  :
 583:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 584:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 585:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 586:../Generated_Code/UTIL0.c **** **                           bytes).
 587:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 588:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 589:../Generated_Code/UTIL0.c **** ** ===================================================================
 590:../Generated_Code/UTIL0.c **** */
 591:../Generated_Code/UTIL0.c **** /*!
 592:../Generated_Code/UTIL0.c ****   \brief appends a 16bit unsigned number to a string. Always terminates the result string.
 593:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 594:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 595:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 596:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 597:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit unsigned number to add
 598:../Generated_Code/UTIL0.c ****   */
 599:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum16u(byte *dst, size_t dstSize, word val)
 600:../Generated_Code/UTIL0.c **** {
 1410              		.loc 1 600 0
 1411              		.cfi_startproc
 1412 0000 80B5     		push	{r7, lr}
 1413              	.LCFI42:
 1414              		.cfi_def_cfa_offset 8
 1415              		.cfi_offset 7, -8
 1416              		.cfi_offset 14, -4
 1417 0002 86B0     		sub	sp, sp, #24
 1418              	.LCFI43:
 1419              		.cfi_def_cfa_offset 32
 1420 0004 00AF     		add	r7, sp, #0
 1421              	.LCFI44:
 1422              		.cfi_def_cfa_register 7
 1423 0006 F860     		str	r0, [r7, #12]
 1424 0008 B960     		str	r1, [r7, #8]
 1425 000a BB1D     		add	r3, r7, #6
 1426 000c 1A80     		strh	r2, [r3]
 1427              	.LBB7:
 601:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 602:../Generated_Code/UTIL0.c **** 
 603:../Generated_Code/UTIL0.c ****   UTIL0_Num16uToStr(buf, sizeof(buf), val);
 1428              		.loc 1 603 0
 1429 000e 3A1C     		mov	r2, r7
 1430 0010 1032     		add	r2, r2, #16
 1431 0012 BB1D     		add	r3, r7, #6
 1432 0014 1B88     		ldrh	r3, [r3]
 1433 0016 101C     		mov	r0, r2
 1434 0018 0621     		mov	r1, #6
 1435 001a 1A1C     		mov	r2, r3
 1436 001c FFF7FEFF 		bl	_Z17UTIL0_Num16uToStrPhjt
 604:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1437              		.loc 1 604 0
 1438 0020 F968     		ldr	r1, [r7, #12]
 1439 0022 BA68     		ldr	r2, [r7, #8]
 1440 0024 3B1C     		mov	r3, r7
 1441 0026 1033     		add	r3, r3, #16
 1442 0028 081C     		mov	r0, r1
 1443 002a 111C     		mov	r1, r2
 1444 002c 1A1C     		mov	r2, r3
 1445 002e FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1446              	.LBE7:
 605:../Generated_Code/UTIL0.c **** }
 1447              		.loc 1 605 0
 1448 0032 BD46     		mov	sp, r7
 1449 0034 06B0     		add	sp, sp, #24
 1450              		@ sp needed for prologue
 1451 0036 80BD     		pop	{r7, pc}
 1452              		.cfi_endproc
 1453              	.LFE19:
 1455              		.section	.text._Z18UTIL0_strcatNum16sPhjs,"ax",%progbits
 1456              		.align	2
 1457              		.global	_Z18UTIL0_strcatNum16sPhjs
 1458              		.code	16
 1459              		.thumb_func
 1461              	_Z18UTIL0_strcatNum16sPhjs:
 1462              	.LFB20:
 606:../Generated_Code/UTIL0.c **** 
 607:../Generated_Code/UTIL0.c **** /*
 608:../Generated_Code/UTIL0.c **** ** ===================================================================
 609:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum16s (component Utility)
 610:../Generated_Code/UTIL0.c **** **     Description :
 611:../Generated_Code/UTIL0.c **** **         Appends a 16bit signed value to a string buffer.
 612:../Generated_Code/UTIL0.c **** **     Parameters  :
 613:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 614:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 615:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 616:../Generated_Code/UTIL0.c **** **                           bytes).
 617:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 618:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 619:../Generated_Code/UTIL0.c **** ** ===================================================================
 620:../Generated_Code/UTIL0.c **** */
 621:../Generated_Code/UTIL0.c **** /*!
 622:../Generated_Code/UTIL0.c ****   \brief appends a 16bit signed number to a string. Always terminates the result string.
 623:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 624:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 625:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 626:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 627:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit signed number to add
 628:../Generated_Code/UTIL0.c ****   */
 629:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum16s(byte *dst, size_t dstSize, int16_t val)
 630:../Generated_Code/UTIL0.c **** {
 1463              		.loc 1 630 0
 1464              		.cfi_startproc
 1465 0000 80B5     		push	{r7, lr}
 1466              	.LCFI45:
 1467              		.cfi_def_cfa_offset 8
 1468              		.cfi_offset 7, -8
 1469              		.cfi_offset 14, -4
 1470 0002 86B0     		sub	sp, sp, #24
 1471              	.LCFI46:
 1472              		.cfi_def_cfa_offset 32
 1473 0004 00AF     		add	r7, sp, #0
 1474              	.LCFI47:
 1475              		.cfi_def_cfa_register 7
 1476 0006 F860     		str	r0, [r7, #12]
 1477 0008 B960     		str	r1, [r7, #8]
 1478 000a BB1D     		add	r3, r7, #6
 1479 000c 1A80     		strh	r2, [r3]
 1480              	.LBB8:
 631:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 632:../Generated_Code/UTIL0.c **** 
 633:../Generated_Code/UTIL0.c ****   UTIL0_Num16sToStr(buf, sizeof(buf), val);
 1481              		.loc 1 633 0
 1482 000e 3A1C     		mov	r2, r7
 1483 0010 1032     		add	r2, r2, #16
 1484 0012 BB1D     		add	r3, r7, #6
 1485 0014 0021     		mov	r1, #0
 1486 0016 5B5E     		ldrsh	r3, [r3, r1]
 1487 0018 101C     		mov	r0, r2
 1488 001a 0721     		mov	r1, #7
 1489 001c 1A1C     		mov	r2, r3
 1490 001e FFF7FEFF 		bl	_Z17UTIL0_Num16sToStrPhjs
 634:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1491              		.loc 1 634 0
 1492 0022 F968     		ldr	r1, [r7, #12]
 1493 0024 BA68     		ldr	r2, [r7, #8]
 1494 0026 3B1C     		mov	r3, r7
 1495 0028 1033     		add	r3, r3, #16
 1496 002a 081C     		mov	r0, r1
 1497 002c 111C     		mov	r1, r2
 1498 002e 1A1C     		mov	r2, r3
 1499 0030 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1500              	.LBE8:
 635:../Generated_Code/UTIL0.c **** }
 1501              		.loc 1 635 0
 1502 0034 BD46     		mov	sp, r7
 1503 0036 06B0     		add	sp, sp, #24
 1504              		@ sp needed for prologue
 1505 0038 80BD     		pop	{r7, pc}
 1506              		.cfi_endproc
 1507              	.LFE20:
 1509 003a C046     		.section	.text._Z27UTIL0_strcatNum16uFormattedPhjtch,"ax",%progbits
 1510              		.align	2
 1511              		.global	_Z27UTIL0_strcatNum16uFormattedPhjtch
 1512              		.code	16
 1513              		.thumb_func
 1515              	_Z27UTIL0_strcatNum16uFormattedPhjtch:
 1516              	.LFB21:
 636:../Generated_Code/UTIL0.c **** 
 637:../Generated_Code/UTIL0.c **** /*
 638:../Generated_Code/UTIL0.c **** ** ===================================================================
 639:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum16uFormatted (component Utility)
 640:../Generated_Code/UTIL0.c **** **     Description :
 641:../Generated_Code/UTIL0.c **** **         Appends a 16bit unsigned value to a string buffer in a
 642:../Generated_Code/UTIL0.c **** **         formatted way.
 643:../Generated_Code/UTIL0.c **** **     Parameters  :
 644:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 645:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 646:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 647:../Generated_Code/UTIL0.c **** **                           bytes).
 648:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 649:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 650:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 651:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 652:../Generated_Code/UTIL0.c **** ** ===================================================================
 653:../Generated_Code/UTIL0.c **** */
 654:../Generated_Code/UTIL0.c **** /*!
 655:../Generated_Code/UTIL0.c ****   \brief appends a 16bit unsigned number to a string, in a formatted way (like printf with "%0d".
 656:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 657:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 658:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 659:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 660:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 661:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit unsigned number to add
 662:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character
 663:../Generated_Code/UTIL0.c ****   \param[in] nofFill Number of fill characters
 664:../Generated_Code/UTIL0.c ****   */
 665:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum16uFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 666:../Generated_Code/UTIL0.c **** {
 1517              		.loc 1 666 0
 1518              		.cfi_startproc
 1519 0000 90B5     		push	{r4, r7, lr}
 1520              	.LCFI48:
 1521              		.cfi_def_cfa_offset 12
 1522              		.cfi_offset 4, -12
 1523              		.cfi_offset 7, -8
 1524              		.cfi_offset 14, -4
 1525 0002 89B0     		sub	sp, sp, #36
 1526              	.LCFI49:
 1527              		.cfi_def_cfa_offset 48
 1528 0004 02AF     		add	r7, sp, #8
 1529              	.LCFI50:
 1530              		.cfi_def_cfa 7, 40
 1531 0006 F860     		str	r0, [r7, #12]
 1532 0008 B960     		str	r1, [r7, #8]
 1533 000a 111C     		mov	r1, r2
 1534 000c 1A1C     		mov	r2, r3
 1535 000e BB1D     		add	r3, r7, #6
 1536 0010 1980     		strh	r1, [r3]
 1537 0012 7B1D     		add	r3, r7, #5
 1538 0014 1A70     		strb	r2, [r3]
 1539              	.LBB9:
 667:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 668:../Generated_Code/UTIL0.c **** 
 669:../Generated_Code/UTIL0.c ****   UTIL0_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1540              		.loc 1 669 0
 1541 0016 381C     		mov	r0, r7
 1542 0018 1030     		add	r0, r0, #16
 1543 001a B968     		ldr	r1, [r7, #8]
 1544 001c BB1D     		add	r3, r7, #6
 1545 001e 1A88     		ldrh	r2, [r3]
 1546 0020 7B1D     		add	r3, r7, #5
 1547 0022 1B78     		ldrb	r3, [r3]
 1548 0024 3C1C     		mov	r4, r7
 1549 0026 2834     		add	r4, r4, #40
 1550 0028 2478     		ldrb	r4, [r4]
 1551 002a 0094     		str	r4, [sp]
 1552 002c FFF7FEFF 		bl	_Z26UTIL0_Num16uToStrFormattedPhjtch
 670:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1553              		.loc 1 670 0
 1554 0030 F968     		ldr	r1, [r7, #12]
 1555 0032 BA68     		ldr	r2, [r7, #8]
 1556 0034 3B1C     		mov	r3, r7
 1557 0036 1033     		add	r3, r3, #16
 1558 0038 081C     		mov	r0, r1
 1559 003a 111C     		mov	r1, r2
 1560 003c 1A1C     		mov	r2, r3
 1561 003e FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1562              	.LBE9:
 671:../Generated_Code/UTIL0.c **** }
 1563              		.loc 1 671 0
 1564 0042 BD46     		mov	sp, r7
 1565 0044 07B0     		add	sp, sp, #28
 1566              		@ sp needed for prologue
 1567 0046 90BD     		pop	{r4, r7, pc}
 1568              		.cfi_endproc
 1569              	.LFE21:
 1571              		.section	.text._Z27UTIL0_strcatNum16sFormattedPhjsch,"ax",%progbits
 1572              		.align	2
 1573              		.global	_Z27UTIL0_strcatNum16sFormattedPhjsch
 1574              		.code	16
 1575              		.thumb_func
 1577              	_Z27UTIL0_strcatNum16sFormattedPhjsch:
 1578              	.LFB22:
 672:../Generated_Code/UTIL0.c **** 
 673:../Generated_Code/UTIL0.c **** /*
 674:../Generated_Code/UTIL0.c **** ** ===================================================================
 675:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum16sFormatted (component Utility)
 676:../Generated_Code/UTIL0.c **** **     Description :
 677:../Generated_Code/UTIL0.c **** **         Appends a 16bit signed value to a string buffer in a
 678:../Generated_Code/UTIL0.c **** **         formatted way.
 679:../Generated_Code/UTIL0.c **** **     Parameters  :
 680:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 681:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 682:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 683:../Generated_Code/UTIL0.c **** **                           bytes).
 684:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 685:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 686:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 687:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 688:../Generated_Code/UTIL0.c **** ** ===================================================================
 689:../Generated_Code/UTIL0.c **** */
 690:../Generated_Code/UTIL0.c **** /*!
 691:../Generated_Code/UTIL0.c ****   \brief appends a 16bit signed number to a string, in a formatted way (like printf with "%0d".
 692:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 693:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 694:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 695:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 696:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 697:../Generated_Code/UTIL0.c ****   \param[in] val The 16bit signed number to add
 698:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character
 699:../Generated_Code/UTIL0.c ****   \param[in] nofFill Number of fill characters
 700:../Generated_Code/UTIL0.c ****   */
 701:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum16sFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 702:../Generated_Code/UTIL0.c **** {
 1579              		.loc 1 702 0
 1580              		.cfi_startproc
 1581 0000 90B5     		push	{r4, r7, lr}
 1582              	.LCFI51:
 1583              		.cfi_def_cfa_offset 12
 1584              		.cfi_offset 4, -12
 1585              		.cfi_offset 7, -8
 1586              		.cfi_offset 14, -4
 1587 0002 89B0     		sub	sp, sp, #36
 1588              	.LCFI52:
 1589              		.cfi_def_cfa_offset 48
 1590 0004 02AF     		add	r7, sp, #8
 1591              	.LCFI53:
 1592              		.cfi_def_cfa 7, 40
 1593 0006 F860     		str	r0, [r7, #12]
 1594 0008 B960     		str	r1, [r7, #8]
 1595 000a 111C     		mov	r1, r2
 1596 000c 1A1C     		mov	r2, r3
 1597 000e BB1D     		add	r3, r7, #6
 1598 0010 1980     		strh	r1, [r3]
 1599 0012 7B1D     		add	r3, r7, #5
 1600 0014 1A70     		strb	r2, [r3]
 1601              	.LBB10:
 703:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 704:../Generated_Code/UTIL0.c **** 
 705:../Generated_Code/UTIL0.c ****   UTIL0_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1602              		.loc 1 705 0
 1603 0016 381C     		mov	r0, r7
 1604 0018 1030     		add	r0, r0, #16
 1605 001a B968     		ldr	r1, [r7, #8]
 1606 001c BB1D     		add	r3, r7, #6
 1607 001e 0024     		mov	r4, #0
 1608 0020 1A5F     		ldrsh	r2, [r3, r4]
 1609 0022 7B1D     		add	r3, r7, #5
 1610 0024 1B78     		ldrb	r3, [r3]
 1611 0026 3C1C     		mov	r4, r7
 1612 0028 2834     		add	r4, r4, #40
 1613 002a 2478     		ldrb	r4, [r4]
 1614 002c 0094     		str	r4, [sp]
 1615 002e FFF7FEFF 		bl	_Z26UTIL0_Num16sToStrFormattedPhjsch
 706:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1616              		.loc 1 706 0
 1617 0032 F968     		ldr	r1, [r7, #12]
 1618 0034 BA68     		ldr	r2, [r7, #8]
 1619 0036 3B1C     		mov	r3, r7
 1620 0038 1033     		add	r3, r3, #16
 1621 003a 081C     		mov	r0, r1
 1622 003c 111C     		mov	r1, r2
 1623 003e 1A1C     		mov	r2, r3
 1624 0040 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1625              	.LBE10:
 707:../Generated_Code/UTIL0.c **** }
 1626              		.loc 1 707 0
 1627 0044 BD46     		mov	sp, r7
 1628 0046 07B0     		add	sp, sp, #28
 1629              		@ sp needed for prologue
 1630 0048 90BD     		pop	{r4, r7, pc}
 1631              		.cfi_endproc
 1632              	.LFE22:
 1634 004a C046     		.section	.text._Z27UTIL0_strcatNum32uFormattedPhjmch,"ax",%progbits
 1635              		.align	2
 1636              		.global	_Z27UTIL0_strcatNum32uFormattedPhjmch
 1637              		.code	16
 1638              		.thumb_func
 1640              	_Z27UTIL0_strcatNum32uFormattedPhjmch:
 1641              	.LFB23:
 708:../Generated_Code/UTIL0.c **** 
 709:../Generated_Code/UTIL0.c **** /*
 710:../Generated_Code/UTIL0.c **** ** ===================================================================
 711:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32uFormatted (component Utility)
 712:../Generated_Code/UTIL0.c **** **     Description :
 713:../Generated_Code/UTIL0.c **** **         Appends a 32bit unsigned value to a string buffer in a
 714:../Generated_Code/UTIL0.c **** **         formatted way.
 715:../Generated_Code/UTIL0.c **** **     Parameters  :
 716:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 717:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 718:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 719:../Generated_Code/UTIL0.c **** **                           bytes).
 720:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 721:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 722:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 723:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 724:../Generated_Code/UTIL0.c **** ** ===================================================================
 725:../Generated_Code/UTIL0.c **** */
 726:../Generated_Code/UTIL0.c **** /*!
 727:../Generated_Code/UTIL0.c ****   \brief appends a 32bit unsigned number to a string, in a formatted way (like printf with "%0d".
 728:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 729:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 730:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 731:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 732:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 733:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit unsigned number to add
 734:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character
 735:../Generated_Code/UTIL0.c ****   \param[in] nofFill Number of fill characters
 736:../Generated_Code/UTIL0.c ****   */
 737:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32uFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 738:../Generated_Code/UTIL0.c **** {
 1642              		.loc 1 738 0
 1643              		.cfi_startproc
 1644 0000 90B5     		push	{r4, r7, lr}
 1645              	.LCFI54:
 1646              		.cfi_def_cfa_offset 12
 1647              		.cfi_offset 4, -12
 1648              		.cfi_offset 7, -8
 1649              		.cfi_offset 14, -4
 1650 0002 8BB0     		sub	sp, sp, #44
 1651              	.LCFI55:
 1652              		.cfi_def_cfa_offset 56
 1653 0004 02AF     		add	r7, sp, #8
 1654              	.LCFI56:
 1655              		.cfi_def_cfa 7, 48
 1656 0006 F860     		str	r0, [r7, #12]
 1657 0008 B960     		str	r1, [r7, #8]
 1658 000a 7A60     		str	r2, [r7, #4]
 1659 000c 1A1C     		mov	r2, r3
 1660 000e FB1C     		add	r3, r7, #3
 1661 0010 1A70     		strb	r2, [r3]
 1662              	.LBB11:
 739:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 740:../Generated_Code/UTIL0.c **** 
 741:../Generated_Code/UTIL0.c ****   UTIL0_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1663              		.loc 1 741 0
 1664 0012 381C     		mov	r0, r7
 1665 0014 1430     		add	r0, r0, #20
 1666 0016 B968     		ldr	r1, [r7, #8]
 1667 0018 7A68     		ldr	r2, [r7, #4]
 1668 001a FB1C     		add	r3, r7, #3
 1669 001c 1B78     		ldrb	r3, [r3]
 1670 001e 3C1C     		mov	r4, r7
 1671 0020 3034     		add	r4, r4, #48
 1672 0022 2478     		ldrb	r4, [r4]
 1673 0024 0094     		str	r4, [sp]
 1674 0026 FFF7FEFF 		bl	_Z26UTIL0_Num32uToStrFormattedPhjmch
 742:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1675              		.loc 1 742 0
 1676 002a F968     		ldr	r1, [r7, #12]
 1677 002c BA68     		ldr	r2, [r7, #8]
 1678 002e 3B1C     		mov	r3, r7
 1679 0030 1433     		add	r3, r3, #20
 1680 0032 081C     		mov	r0, r1
 1681 0034 111C     		mov	r1, r2
 1682 0036 1A1C     		mov	r2, r3
 1683 0038 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1684              	.LBE11:
 743:../Generated_Code/UTIL0.c **** }
 1685              		.loc 1 743 0
 1686 003c BD46     		mov	sp, r7
 1687 003e 09B0     		add	sp, sp, #36
 1688              		@ sp needed for prologue
 1689 0040 90BD     		pop	{r4, r7, pc}
 1690              		.cfi_endproc
 1691              	.LFE23:
 1693 0042 C046     		.section	.text._Z27UTIL0_strcatNum32sFormattedPhjlch,"ax",%progbits
 1694              		.align	2
 1695              		.global	_Z27UTIL0_strcatNum32sFormattedPhjlch
 1696              		.code	16
 1697              		.thumb_func
 1699              	_Z27UTIL0_strcatNum32sFormattedPhjlch:
 1700              	.LFB24:
 744:../Generated_Code/UTIL0.c **** 
 745:../Generated_Code/UTIL0.c **** /*
 746:../Generated_Code/UTIL0.c **** ** ===================================================================
 747:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32sFormatted (component Utility)
 748:../Generated_Code/UTIL0.c **** **     Description :
 749:../Generated_Code/UTIL0.c **** **         Appends a 32bit signed value to a string buffer in a
 750:../Generated_Code/UTIL0.c **** **         formatted way.
 751:../Generated_Code/UTIL0.c **** **     Parameters  :
 752:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 753:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 754:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 755:../Generated_Code/UTIL0.c **** **                           bytes).
 756:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 757:../Generated_Code/UTIL0.c **** **         fill            - Fill character
 758:../Generated_Code/UTIL0.c **** **         nofFill         - Number of fill characters
 759:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 760:../Generated_Code/UTIL0.c **** ** ===================================================================
 761:../Generated_Code/UTIL0.c **** */
 762:../Generated_Code/UTIL0.c **** /*!
 763:../Generated_Code/UTIL0.c ****   \brief appends a 32bit signed number to a string, in a formatted way (like printf with "%0d".
 764:../Generated_Code/UTIL0.c ****      Always terminates the result string.
 765:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 766:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 767:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 768:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 769:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit signed number to add
 770:../Generated_Code/UTIL0.c ****   \param[in] fill Fill character
 771:../Generated_Code/UTIL0.c ****   \param[in] nofFill Number of fill characters
 772:../Generated_Code/UTIL0.c ****   */
 773:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32sFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 774:../Generated_Code/UTIL0.c **** {
 1701              		.loc 1 774 0
 1702              		.cfi_startproc
 1703 0000 90B5     		push	{r4, r7, lr}
 1704              	.LCFI57:
 1705              		.cfi_def_cfa_offset 12
 1706              		.cfi_offset 4, -12
 1707              		.cfi_offset 7, -8
 1708              		.cfi_offset 14, -4
 1709 0002 8BB0     		sub	sp, sp, #44
 1710              	.LCFI58:
 1711              		.cfi_def_cfa_offset 56
 1712 0004 02AF     		add	r7, sp, #8
 1713              	.LCFI59:
 1714              		.cfi_def_cfa 7, 48
 1715 0006 F860     		str	r0, [r7, #12]
 1716 0008 B960     		str	r1, [r7, #8]
 1717 000a 7A60     		str	r2, [r7, #4]
 1718 000c 1A1C     		mov	r2, r3
 1719 000e FB1C     		add	r3, r7, #3
 1720 0010 1A70     		strb	r2, [r3]
 1721              	.LBB12:
 775:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 776:../Generated_Code/UTIL0.c **** 
 777:../Generated_Code/UTIL0.c ****   UTIL0_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1722              		.loc 1 777 0
 1723 0012 381C     		mov	r0, r7
 1724 0014 1430     		add	r0, r0, #20
 1725 0016 B968     		ldr	r1, [r7, #8]
 1726 0018 7A68     		ldr	r2, [r7, #4]
 1727 001a FB1C     		add	r3, r7, #3
 1728 001c 1B78     		ldrb	r3, [r3]
 1729 001e 3C1C     		mov	r4, r7
 1730 0020 3034     		add	r4, r4, #48
 1731 0022 2478     		ldrb	r4, [r4]
 1732 0024 0094     		str	r4, [sp]
 1733 0026 FFF7FEFF 		bl	_Z26UTIL0_Num32sToStrFormattedPhjlch
 778:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1734              		.loc 1 778 0
 1735 002a F968     		ldr	r1, [r7, #12]
 1736 002c BA68     		ldr	r2, [r7, #8]
 1737 002e 3B1C     		mov	r3, r7
 1738 0030 1433     		add	r3, r3, #20
 1739 0032 081C     		mov	r0, r1
 1740 0034 111C     		mov	r1, r2
 1741 0036 1A1C     		mov	r2, r3
 1742 0038 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1743              	.LBE12:
 779:../Generated_Code/UTIL0.c **** }
 1744              		.loc 1 779 0
 1745 003c BD46     		mov	sp, r7
 1746 003e 09B0     		add	sp, sp, #36
 1747              		@ sp needed for prologue
 1748 0040 90BD     		pop	{r4, r7, pc}
 1749              		.cfi_endproc
 1750              	.LFE24:
 1752 0042 C046     		.section	.text._Z19UTIL0_strcatNum8HexPhjh,"ax",%progbits
 1753              		.align	2
 1754              		.global	_Z19UTIL0_strcatNum8HexPhjh
 1755              		.code	16
 1756              		.thumb_func
 1758              	_Z19UTIL0_strcatNum8HexPhjh:
 1759              	.LFB25:
 780:../Generated_Code/UTIL0.c **** 
 781:../Generated_Code/UTIL0.c **** /*
 782:../Generated_Code/UTIL0.c **** ** ===================================================================
 783:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum8Hex (component Utility)
 784:../Generated_Code/UTIL0.c **** **     Description :
 785:../Generated_Code/UTIL0.c **** **         Appends a 8bit unsigned value to a buffer as hex number
 786:../Generated_Code/UTIL0.c **** **         (without a 0x prefix).
 787:../Generated_Code/UTIL0.c **** **     Parameters  :
 788:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 789:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 790:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 791:../Generated_Code/UTIL0.c **** **                           bytes).
 792:../Generated_Code/UTIL0.c **** **         num             - Value to convert.
 793:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 794:../Generated_Code/UTIL0.c **** ** ===================================================================
 795:../Generated_Code/UTIL0.c **** */
 796:../Generated_Code/UTIL0.c **** /*!
 797:../Generated_Code/UTIL0.c ****   \brief Adds a 8bit number as hex value to a string.
 798:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 799:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 800:../Generated_Code/UTIL0.c ****   \param[in] num The 8bit number to add
 801:../Generated_Code/UTIL0.c ****   */
 802:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum8Hex(byte *dst, size_t dstSize, byte num)
 803:../Generated_Code/UTIL0.c **** {
 1760              		.loc 1 803 0
 1761              		.cfi_startproc
 1762 0000 80B5     		push	{r7, lr}
 1763              	.LCFI60:
 1764              		.cfi_def_cfa_offset 8
 1765              		.cfi_offset 7, -8
 1766              		.cfi_offset 14, -4
 1767 0002 86B0     		sub	sp, sp, #24
 1768              	.LCFI61:
 1769              		.cfi_def_cfa_offset 32
 1770 0004 00AF     		add	r7, sp, #0
 1771              	.LCFI62:
 1772              		.cfi_def_cfa_register 7
 1773 0006 F860     		str	r0, [r7, #12]
 1774 0008 B960     		str	r1, [r7, #8]
 1775 000a FB1D     		add	r3, r7, #7
 1776 000c 1A70     		strb	r2, [r3]
 1777              	.LBB13:
 804:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
 805:../Generated_Code/UTIL0.c ****   unsigned char hex;
 806:../Generated_Code/UTIL0.c **** 
 807:../Generated_Code/UTIL0.c ****   buf[2] = '\0';
 1778              		.loc 1 807 0
 1779 000e 3B1C     		mov	r3, r7
 1780 0010 1433     		add	r3, r3, #20
 1781 0012 0022     		mov	r2, #0
 1782 0014 9A70     		strb	r2, [r3, #2]
 808:../Generated_Code/UTIL0.c ****   hex = (char)(num & 0x0F);
 1783              		.loc 1 808 0
 1784 0016 3B1C     		mov	r3, r7
 1785 0018 1733     		add	r3, r3, #23
 1786 001a FA1D     		add	r2, r7, #7
 1787 001c 1178     		ldrb	r1, [r2]
 1788 001e 0F22     		mov	r2, #15
 1789 0020 0A40     		and	r2, r1
 1790 0022 1A70     		strb	r2, [r3]
 809:../Generated_Code/UTIL0.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1791              		.loc 1 809 0
 1792 0024 3B1C     		mov	r3, r7
 1793 0026 1733     		add	r3, r3, #23
 1794 0028 1B78     		ldrb	r3, [r3]
 1795 002a 092B     		cmp	r3, #9
 1796 002c 01D8     		bhi	.L66
 1797              		.loc 1 809 0 is_stmt 0
 1798 002e 3023     		mov	r3, #48
 1799 0030 00E0     		b	.L67
 1800              	.L66:
 1801              		.loc 1 809 0
 1802 0032 3723     		mov	r3, #55
 1803              	.L67:
 1804              		.loc 1 809 0
 1805 0034 3A1C     		mov	r2, r7
 1806 0036 1732     		add	r2, r2, #23
 1807 0038 1278     		ldrb	r2, [r2]
 1808 003a 9B18     		add	r3, r3, r2
 1809 003c DAB2     		uxtb	r2, r3
 1810 003e 3B1C     		mov	r3, r7
 1811 0040 1433     		add	r3, r3, #20
 1812 0042 5A70     		strb	r2, [r3, #1]
 810:../Generated_Code/UTIL0.c ****   hex = (char)((num>>4) & 0x0F);
 1813              		.loc 1 810 0 is_stmt 1
 1814 0044 3B1C     		mov	r3, r7
 1815 0046 1733     		add	r3, r3, #23
 1816 0048 FA1D     		add	r2, r7, #7
 1817 004a 1278     		ldrb	r2, [r2]
 1818 004c 1209     		lsr	r2, r2, #4
 1819 004e 1A70     		strb	r2, [r3]
 811:../Generated_Code/UTIL0.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1820              		.loc 1 811 0
 1821 0050 3B1C     		mov	r3, r7
 1822 0052 1733     		add	r3, r3, #23
 1823 0054 1B78     		ldrb	r3, [r3]
 1824 0056 092B     		cmp	r3, #9
 1825 0058 01D8     		bhi	.L68
 1826              		.loc 1 811 0 is_stmt 0
 1827 005a 3023     		mov	r3, #48
 1828 005c 00E0     		b	.L69
 1829              	.L68:
 1830              		.loc 1 811 0
 1831 005e 3723     		mov	r3, #55
 1832              	.L69:
 1833              		.loc 1 811 0
 1834 0060 3A1C     		mov	r2, r7
 1835 0062 1732     		add	r2, r2, #23
 1836 0064 1278     		ldrb	r2, [r2]
 1837 0066 9B18     		add	r3, r3, r2
 1838 0068 DAB2     		uxtb	r2, r3
 1839 006a 3B1C     		mov	r3, r7
 1840 006c 1433     		add	r3, r3, #20
 1841 006e 1A70     		strb	r2, [r3]
 812:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1842              		.loc 1 812 0 is_stmt 1
 1843 0070 F968     		ldr	r1, [r7, #12]
 1844 0072 BA68     		ldr	r2, [r7, #8]
 1845 0074 3B1C     		mov	r3, r7
 1846 0076 1433     		add	r3, r3, #20
 1847 0078 081C     		mov	r0, r1
 1848 007a 111C     		mov	r1, r2
 1849 007c 1A1C     		mov	r2, r3
 1850 007e FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1851              	.LBE13:
 813:../Generated_Code/UTIL0.c **** }
 1852              		.loc 1 813 0
 1853 0082 BD46     		mov	sp, r7
 1854 0084 06B0     		add	sp, sp, #24
 1855              		@ sp needed for prologue
 1856 0086 80BD     		pop	{r7, pc}
 1857              		.cfi_endproc
 1858              	.LFE25:
 1860              		.section	.text._Z20UTIL0_strcatNum16HexPhjt,"ax",%progbits
 1861              		.align	2
 1862              		.global	_Z20UTIL0_strcatNum16HexPhjt
 1863              		.code	16
 1864              		.thumb_func
 1866              	_Z20UTIL0_strcatNum16HexPhjt:
 1867              	.LFB26:
 814:../Generated_Code/UTIL0.c **** 
 815:../Generated_Code/UTIL0.c **** /*
 816:../Generated_Code/UTIL0.c **** ** ===================================================================
 817:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum16Hex (component Utility)
 818:../Generated_Code/UTIL0.c **** **     Description :
 819:../Generated_Code/UTIL0.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 820:../Generated_Code/UTIL0.c **** **         (without a 0x prefix).
 821:../Generated_Code/UTIL0.c **** **     Parameters  :
 822:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 823:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 824:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 825:../Generated_Code/UTIL0.c **** **                           bytes).
 826:../Generated_Code/UTIL0.c **** **         num             - Value to convert.
 827:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 828:../Generated_Code/UTIL0.c **** ** ===================================================================
 829:../Generated_Code/UTIL0.c **** */
 830:../Generated_Code/UTIL0.c **** /*!
 831:../Generated_Code/UTIL0.c ****   \brief Adds a 16bit number as hex value to a string.
 832:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 833:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 834:../Generated_Code/UTIL0.c ****   \param[in] num The 16bit number to add
 835:../Generated_Code/UTIL0.c ****   */
 836:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum16Hex(byte *dst, size_t dstSize, word num)
 837:../Generated_Code/UTIL0.c **** {
 1868              		.loc 1 837 0
 1869              		.cfi_startproc
 1870 0000 80B5     		push	{r7, lr}
 1871              	.LCFI63:
 1872              		.cfi_def_cfa_offset 8
 1873              		.cfi_offset 7, -8
 1874              		.cfi_offset 14, -4
 1875 0002 86B0     		sub	sp, sp, #24
 1876              	.LCFI64:
 1877              		.cfi_def_cfa_offset 32
 1878 0004 00AF     		add	r7, sp, #0
 1879              	.LCFI65:
 1880              		.cfi_def_cfa_register 7
 1881 0006 F860     		str	r0, [r7, #12]
 1882 0008 B960     		str	r1, [r7, #8]
 1883 000a BB1D     		add	r3, r7, #6
 1884 000c 1A80     		strh	r2, [r3]
 1885              	.LBB14:
 838:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
 839:../Generated_Code/UTIL0.c ****   unsigned char hex;
 840:../Generated_Code/UTIL0.c ****   int8_t i;
 841:../Generated_Code/UTIL0.c **** 
 842:../Generated_Code/UTIL0.c ****   buf[4] = '\0';
 1886              		.loc 1 842 0
 1887 000e 3B1C     		mov	r3, r7
 1888 0010 1033     		add	r3, r3, #16
 1889 0012 0022     		mov	r2, #0
 1890 0014 1A71     		strb	r2, [r3, #4]
 843:../Generated_Code/UTIL0.c ****   i = 3;
 1891              		.loc 1 843 0
 1892 0016 3B1C     		mov	r3, r7
 1893 0018 1733     		add	r3, r3, #23
 1894 001a 0322     		mov	r2, #3
 1895 001c 1A70     		strb	r2, [r3]
 1896              	.L73:
 844:../Generated_Code/UTIL0.c ****   do {
 845:../Generated_Code/UTIL0.c ****     hex = (char)(num & 0x0F);
 1897              		.loc 1 845 0
 1898 001e BB1D     		add	r3, r7, #6
 1899 0020 1B88     		ldrh	r3, [r3]
 1900 0022 D9B2     		uxtb	r1, r3
 1901 0024 3B1C     		mov	r3, r7
 1902 0026 1633     		add	r3, r3, #22
 1903 0028 0F22     		mov	r2, #15
 1904 002a 0A40     		and	r2, r1
 1905 002c 1A70     		strb	r2, [r3]
 846:../Generated_Code/UTIL0.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1906              		.loc 1 846 0
 1907 002e 3B1C     		mov	r3, r7
 1908 0030 1733     		add	r3, r3, #23
 1909 0032 0022     		mov	r2, #0
 1910 0034 9A56     		ldrsb	r2, [r3, r2]
 1911 0036 3B1C     		mov	r3, r7
 1912 0038 1633     		add	r3, r3, #22
 1913 003a 1B78     		ldrb	r3, [r3]
 1914 003c 092B     		cmp	r3, #9
 1915 003e 01D8     		bhi	.L71
 1916              		.loc 1 846 0 is_stmt 0
 1917 0040 3023     		mov	r3, #48
 1918 0042 00E0     		b	.L72
 1919              	.L71:
 1920              		.loc 1 846 0
 1921 0044 3723     		mov	r3, #55
 1922              	.L72:
 1923              		.loc 1 846 0
 1924 0046 391C     		mov	r1, r7
 1925 0048 1631     		add	r1, r1, #22
 1926 004a 0978     		ldrb	r1, [r1]
 1927 004c 5B18     		add	r3, r3, r1
 1928 004e D9B2     		uxtb	r1, r3
 1929 0050 3B1C     		mov	r3, r7
 1930 0052 1033     		add	r3, r3, #16
 1931 0054 9954     		strb	r1, [r3, r2]
 847:../Generated_Code/UTIL0.c ****     num >>= 4;                          /* next nibble */
 1932              		.loc 1 847 0 is_stmt 1
 1933 0056 BB1D     		add	r3, r7, #6
 1934 0058 1B88     		ldrh	r3, [r3]
 1935 005a 1A11     		asr	r2, r3, #4
 1936 005c BB1D     		add	r3, r7, #6
 1937 005e 1A80     		strh	r2, [r3]
 848:../Generated_Code/UTIL0.c ****     i--;
 1938              		.loc 1 848 0
 1939 0060 3B1C     		mov	r3, r7
 1940 0062 1733     		add	r3, r3, #23
 1941 0064 3A1C     		mov	r2, r7
 1942 0066 1732     		add	r2, r2, #23
 1943 0068 1278     		ldrb	r2, [r2]
 1944 006a 013A     		sub	r2, r2, #1
 1945 006c 1A70     		strb	r2, [r3]
 844:../Generated_Code/UTIL0.c ****   do {
 1946              		.loc 1 844 0
 1947 006e 3B1C     		mov	r3, r7
 1948 0070 1733     		add	r3, r3, #23
 1949 0072 1B78     		ldrb	r3, [r3]
 1950 0074 DB43     		mvn	r3, r3
 1951 0076 DBB2     		uxtb	r3, r3
 1952 0078 DB09     		lsr	r3, r3, #7
 1953 007a DBB2     		uxtb	r3, r3
 1954 007c 002B     		cmp	r3, #0
 1955 007e CED1     		bne	.L73
 849:../Generated_Code/UTIL0.c ****   } while (i>=0);
 850:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 1956              		.loc 1 850 0
 1957 0080 F968     		ldr	r1, [r7, #12]
 1958 0082 BA68     		ldr	r2, [r7, #8]
 1959 0084 3B1C     		mov	r3, r7
 1960 0086 1033     		add	r3, r3, #16
 1961 0088 081C     		mov	r0, r1
 1962 008a 111C     		mov	r1, r2
 1963 008c 1A1C     		mov	r2, r3
 1964 008e FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 1965              	.LBE14:
 851:../Generated_Code/UTIL0.c **** }
 1966              		.loc 1 851 0
 1967 0092 BD46     		mov	sp, r7
 1968 0094 06B0     		add	sp, sp, #24
 1969              		@ sp needed for prologue
 1970 0096 80BD     		pop	{r7, pc}
 1971              		.cfi_endproc
 1972              	.LFE26:
 1974              		.section	.text._Z20UTIL0_strcatNum24HexPhjm,"ax",%progbits
 1975              		.align	2
 1976              		.global	_Z20UTIL0_strcatNum24HexPhjm
 1977              		.code	16
 1978              		.thumb_func
 1980              	_Z20UTIL0_strcatNum24HexPhjm:
 1981              	.LFB27:
 852:../Generated_Code/UTIL0.c **** 
 853:../Generated_Code/UTIL0.c **** /*
 854:../Generated_Code/UTIL0.c **** ** ===================================================================
 855:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum24Hex (component Utility)
 856:../Generated_Code/UTIL0.c **** **     Description :
 857:../Generated_Code/UTIL0.c **** **         Appends a 32bit unsigned value to a buffer as hex number
 858:../Generated_Code/UTIL0.c **** **         (without a 0x prefix). Only 24bits are used.
 859:../Generated_Code/UTIL0.c **** **     Parameters  :
 860:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 861:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 862:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 863:../Generated_Code/UTIL0.c **** **                           bytes).
 864:../Generated_Code/UTIL0.c **** **         num             - Value to convert.
 865:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 866:../Generated_Code/UTIL0.c **** ** ===================================================================
 867:../Generated_Code/UTIL0.c **** */
 868:../Generated_Code/UTIL0.c **** /*!
 869:../Generated_Code/UTIL0.c ****   \brief Adds a 24bit number as hex value to a string.
 870:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 871:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 872:../Generated_Code/UTIL0.c ****   \param[in] num The 24bit number to add
 873:../Generated_Code/UTIL0.c ****   */
 874:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum24Hex(byte *dst, size_t dstSize, dword num)
 875:../Generated_Code/UTIL0.c **** {
 1982              		.loc 1 875 0
 1983              		.cfi_startproc
 1984 0000 80B5     		push	{r7, lr}
 1985              	.LCFI66:
 1986              		.cfi_def_cfa_offset 8
 1987              		.cfi_offset 7, -8
 1988              		.cfi_offset 14, -4
 1989 0002 88B0     		sub	sp, sp, #32
 1990              	.LCFI67:
 1991              		.cfi_def_cfa_offset 40
 1992 0004 00AF     		add	r7, sp, #0
 1993              	.LCFI68:
 1994              		.cfi_def_cfa_register 7
 1995 0006 F860     		str	r0, [r7, #12]
 1996 0008 B960     		str	r1, [r7, #8]
 1997 000a 7A60     		str	r2, [r7, #4]
 1998              	.LBB15:
 876:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
 877:../Generated_Code/UTIL0.c ****   unsigned char hex;
 878:../Generated_Code/UTIL0.c ****   int8_t i;
 879:../Generated_Code/UTIL0.c **** 
 880:../Generated_Code/UTIL0.c ****   buf[6] = '\0';
 1999              		.loc 1 880 0
 2000 000c 3B1C     		mov	r3, r7
 2001 000e 1433     		add	r3, r3, #20
 2002 0010 0022     		mov	r2, #0
 2003 0012 9A71     		strb	r2, [r3, #6]
 881:../Generated_Code/UTIL0.c ****   i = 5;
 2004              		.loc 1 881 0
 2005 0014 3B1C     		mov	r3, r7
 2006 0016 1F33     		add	r3, r3, #31
 2007 0018 0522     		mov	r2, #5
 2008 001a 1A70     		strb	r2, [r3]
 2009              	.L77:
 882:../Generated_Code/UTIL0.c ****   do {
 883:../Generated_Code/UTIL0.c ****     hex = (char)(num & 0x0F);
 2010              		.loc 1 883 0
 2011 001c 7B68     		ldr	r3, [r7, #4]
 2012 001e D9B2     		uxtb	r1, r3
 2013 0020 3B1C     		mov	r3, r7
 2014 0022 1E33     		add	r3, r3, #30
 2015 0024 0F22     		mov	r2, #15
 2016 0026 0A40     		and	r2, r1
 2017 0028 1A70     		strb	r2, [r3]
 884:../Generated_Code/UTIL0.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 2018              		.loc 1 884 0
 2019 002a 3B1C     		mov	r3, r7
 2020 002c 1F33     		add	r3, r3, #31
 2021 002e 0022     		mov	r2, #0
 2022 0030 9A56     		ldrsb	r2, [r3, r2]
 2023 0032 3B1C     		mov	r3, r7
 2024 0034 1E33     		add	r3, r3, #30
 2025 0036 1B78     		ldrb	r3, [r3]
 2026 0038 092B     		cmp	r3, #9
 2027 003a 01D8     		bhi	.L75
 2028              		.loc 1 884 0 is_stmt 0
 2029 003c 3023     		mov	r3, #48
 2030 003e 00E0     		b	.L76
 2031              	.L75:
 2032              		.loc 1 884 0
 2033 0040 3723     		mov	r3, #55
 2034              	.L76:
 2035              		.loc 1 884 0
 2036 0042 391C     		mov	r1, r7
 2037 0044 1E31     		add	r1, r1, #30
 2038 0046 0978     		ldrb	r1, [r1]
 2039 0048 5B18     		add	r3, r3, r1
 2040 004a D9B2     		uxtb	r1, r3
 2041 004c 3B1C     		mov	r3, r7
 2042 004e 1433     		add	r3, r3, #20
 2043 0050 9954     		strb	r1, [r3, r2]
 885:../Generated_Code/UTIL0.c ****     num >>= 4;                          /* next nibble */
 2044              		.loc 1 885 0 is_stmt 1
 2045 0052 7B68     		ldr	r3, [r7, #4]
 2046 0054 1B09     		lsr	r3, r3, #4
 2047 0056 7B60     		str	r3, [r7, #4]
 886:../Generated_Code/UTIL0.c ****     i--;
 2048              		.loc 1 886 0
 2049 0058 3B1C     		mov	r3, r7
 2050 005a 1F33     		add	r3, r3, #31
 2051 005c 3A1C     		mov	r2, r7
 2052 005e 1F32     		add	r2, r2, #31
 2053 0060 1278     		ldrb	r2, [r2]
 2054 0062 013A     		sub	r2, r2, #1
 2055 0064 1A70     		strb	r2, [r3]
 882:../Generated_Code/UTIL0.c ****   do {
 2056              		.loc 1 882 0
 2057 0066 3B1C     		mov	r3, r7
 2058 0068 1F33     		add	r3, r3, #31
 2059 006a 1B78     		ldrb	r3, [r3]
 2060 006c DB43     		mvn	r3, r3
 2061 006e DBB2     		uxtb	r3, r3
 2062 0070 DB09     		lsr	r3, r3, #7
 2063 0072 DBB2     		uxtb	r3, r3
 2064 0074 002B     		cmp	r3, #0
 2065 0076 D1D1     		bne	.L77
 887:../Generated_Code/UTIL0.c ****   } while (i>=0);
 888:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 2066              		.loc 1 888 0
 2067 0078 F968     		ldr	r1, [r7, #12]
 2068 007a BA68     		ldr	r2, [r7, #8]
 2069 007c 3B1C     		mov	r3, r7
 2070 007e 1433     		add	r3, r3, #20
 2071 0080 081C     		mov	r0, r1
 2072 0082 111C     		mov	r1, r2
 2073 0084 1A1C     		mov	r2, r3
 2074 0086 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 2075              	.LBE15:
 889:../Generated_Code/UTIL0.c **** }
 2076              		.loc 1 889 0
 2077 008a BD46     		mov	sp, r7
 2078 008c 08B0     		add	sp, sp, #32
 2079              		@ sp needed for prologue
 2080 008e 80BD     		pop	{r7, pc}
 2081              		.cfi_endproc
 2082              	.LFE27:
 2084              		.section	.text._Z20UTIL0_strcatNum32HexPhjm,"ax",%progbits
 2085              		.align	2
 2086              		.global	_Z20UTIL0_strcatNum32HexPhjm
 2087              		.code	16
 2088              		.thumb_func
 2090              	_Z20UTIL0_strcatNum32HexPhjm:
 2091              	.LFB28:
 890:../Generated_Code/UTIL0.c **** 
 891:../Generated_Code/UTIL0.c **** /*
 892:../Generated_Code/UTIL0.c **** ** ===================================================================
 893:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32Hex (component Utility)
 894:../Generated_Code/UTIL0.c **** **     Description :
 895:../Generated_Code/UTIL0.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 896:../Generated_Code/UTIL0.c **** **         (without a 0x prefix).
 897:../Generated_Code/UTIL0.c **** **     Parameters  :
 898:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 899:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 900:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 901:../Generated_Code/UTIL0.c **** **                           bytes).
 902:../Generated_Code/UTIL0.c **** **         num             - Value to convert.
 903:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 904:../Generated_Code/UTIL0.c **** ** ===================================================================
 905:../Generated_Code/UTIL0.c **** */
 906:../Generated_Code/UTIL0.c **** /*!
 907:../Generated_Code/UTIL0.c ****   \brief Adds a 32bit number as hex value to a string.
 908:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 909:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 910:../Generated_Code/UTIL0.c ****   \param[in] num The 32bit number to add
 911:../Generated_Code/UTIL0.c ****   */
 912:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32Hex(byte *dst, size_t dstSize, dword num)
 913:../Generated_Code/UTIL0.c **** {
 2092              		.loc 1 913 0
 2093              		.cfi_startproc
 2094 0000 80B5     		push	{r7, lr}
 2095              	.LCFI69:
 2096              		.cfi_def_cfa_offset 8
 2097              		.cfi_offset 7, -8
 2098              		.cfi_offset 14, -4
 2099 0002 88B0     		sub	sp, sp, #32
 2100              	.LCFI70:
 2101              		.cfi_def_cfa_offset 40
 2102 0004 00AF     		add	r7, sp, #0
 2103              	.LCFI71:
 2104              		.cfi_def_cfa_register 7
 2105 0006 F860     		str	r0, [r7, #12]
 2106 0008 B960     		str	r1, [r7, #8]
 2107 000a 7A60     		str	r2, [r7, #4]
 2108              	.LBB16:
 914:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
 915:../Generated_Code/UTIL0.c ****   unsigned char hex;
 916:../Generated_Code/UTIL0.c ****   int8_t i;
 917:../Generated_Code/UTIL0.c **** 
 918:../Generated_Code/UTIL0.c ****   buf[8] = '\0';
 2109              		.loc 1 918 0
 2110 000c 3B1C     		mov	r3, r7
 2111 000e 1433     		add	r3, r3, #20
 2112 0010 0022     		mov	r2, #0
 2113 0012 1A72     		strb	r2, [r3, #8]
 919:../Generated_Code/UTIL0.c ****   i = 7;
 2114              		.loc 1 919 0
 2115 0014 3B1C     		mov	r3, r7
 2116 0016 1F33     		add	r3, r3, #31
 2117 0018 0722     		mov	r2, #7
 2118 001a 1A70     		strb	r2, [r3]
 2119              	.L81:
 920:../Generated_Code/UTIL0.c ****   do {
 921:../Generated_Code/UTIL0.c ****     hex = (char)(num & 0x0F);
 2120              		.loc 1 921 0
 2121 001c 7B68     		ldr	r3, [r7, #4]
 2122 001e D9B2     		uxtb	r1, r3
 2123 0020 3B1C     		mov	r3, r7
 2124 0022 1E33     		add	r3, r3, #30
 2125 0024 0F22     		mov	r2, #15
 2126 0026 0A40     		and	r2, r1
 2127 0028 1A70     		strb	r2, [r3]
 922:../Generated_Code/UTIL0.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 2128              		.loc 1 922 0
 2129 002a 3B1C     		mov	r3, r7
 2130 002c 1F33     		add	r3, r3, #31
 2131 002e 0022     		mov	r2, #0
 2132 0030 9A56     		ldrsb	r2, [r3, r2]
 2133 0032 3B1C     		mov	r3, r7
 2134 0034 1E33     		add	r3, r3, #30
 2135 0036 1B78     		ldrb	r3, [r3]
 2136 0038 092B     		cmp	r3, #9
 2137 003a 01D8     		bhi	.L79
 2138              		.loc 1 922 0 is_stmt 0
 2139 003c 3023     		mov	r3, #48
 2140 003e 00E0     		b	.L80
 2141              	.L79:
 2142              		.loc 1 922 0
 2143 0040 3723     		mov	r3, #55
 2144              	.L80:
 2145              		.loc 1 922 0
 2146 0042 391C     		mov	r1, r7
 2147 0044 1E31     		add	r1, r1, #30
 2148 0046 0978     		ldrb	r1, [r1]
 2149 0048 5B18     		add	r3, r3, r1
 2150 004a D9B2     		uxtb	r1, r3
 2151 004c 3B1C     		mov	r3, r7
 2152 004e 1433     		add	r3, r3, #20
 2153 0050 9954     		strb	r1, [r3, r2]
 923:../Generated_Code/UTIL0.c ****     num >>= 4;                          /* next nibble */
 2154              		.loc 1 923 0 is_stmt 1
 2155 0052 7B68     		ldr	r3, [r7, #4]
 2156 0054 1B09     		lsr	r3, r3, #4
 2157 0056 7B60     		str	r3, [r7, #4]
 924:../Generated_Code/UTIL0.c ****     i--;
 2158              		.loc 1 924 0
 2159 0058 3B1C     		mov	r3, r7
 2160 005a 1F33     		add	r3, r3, #31
 2161 005c 3A1C     		mov	r2, r7
 2162 005e 1F32     		add	r2, r2, #31
 2163 0060 1278     		ldrb	r2, [r2]
 2164 0062 013A     		sub	r2, r2, #1
 2165 0064 1A70     		strb	r2, [r3]
 920:../Generated_Code/UTIL0.c ****   do {
 2166              		.loc 1 920 0
 2167 0066 3B1C     		mov	r3, r7
 2168 0068 1F33     		add	r3, r3, #31
 2169 006a 1B78     		ldrb	r3, [r3]
 2170 006c DB43     		mvn	r3, r3
 2171 006e DBB2     		uxtb	r3, r3
 2172 0070 DB09     		lsr	r3, r3, #7
 2173 0072 DBB2     		uxtb	r3, r3
 2174 0074 002B     		cmp	r3, #0
 2175 0076 D1D1     		bne	.L81
 925:../Generated_Code/UTIL0.c ****   } while (i>=0);
 926:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 2176              		.loc 1 926 0
 2177 0078 F968     		ldr	r1, [r7, #12]
 2178 007a BA68     		ldr	r2, [r7, #8]
 2179 007c 3B1C     		mov	r3, r7
 2180 007e 1433     		add	r3, r3, #20
 2181 0080 081C     		mov	r0, r1
 2182 0082 111C     		mov	r1, r2
 2183 0084 1A1C     		mov	r2, r3
 2184 0086 FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 2185              	.LBE16:
 927:../Generated_Code/UTIL0.c **** }
 2186              		.loc 1 927 0
 2187 008a BD46     		mov	sp, r7
 2188 008c 08B0     		add	sp, sp, #32
 2189              		@ sp needed for prologue
 2190 008e 80BD     		pop	{r7, pc}
 2191              		.cfi_endproc
 2192              	.LFE28:
 2194              		.section	.text._Z18UTIL0_strcatNum32sPhjl,"ax",%progbits
 2195              		.align	2
 2196              		.global	_Z18UTIL0_strcatNum32sPhjl
 2197              		.code	16
 2198              		.thumb_func
 2200              	_Z18UTIL0_strcatNum32sPhjl:
 2201              	.LFB29:
 928:../Generated_Code/UTIL0.c **** 
 929:../Generated_Code/UTIL0.c **** /*
 930:../Generated_Code/UTIL0.c **** ** ===================================================================
 931:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32s (component Utility)
 932:../Generated_Code/UTIL0.c **** **     Description :
 933:../Generated_Code/UTIL0.c **** **         Appends a 32bit signed value to a string buffer.
 934:../Generated_Code/UTIL0.c **** **     Parameters  :
 935:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 936:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 937:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 938:../Generated_Code/UTIL0.c **** **                           bytes).
 939:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 940:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 941:../Generated_Code/UTIL0.c **** ** ===================================================================
 942:../Generated_Code/UTIL0.c **** */
 943:../Generated_Code/UTIL0.c **** /*!
 944:../Generated_Code/UTIL0.c ****   \brief appends a 32bit (long) number to a string. Always terminates the result string.
 945:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 946:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 947:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 948:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 949:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit number to add
 950:../Generated_Code/UTIL0.c ****   */
 951:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32s(byte *dst, size_t dstSize, long val)
 952:../Generated_Code/UTIL0.c **** {
 2202              		.loc 1 952 0
 2203              		.cfi_startproc
 2204 0000 80B5     		push	{r7, lr}
 2205              	.LCFI72:
 2206              		.cfi_def_cfa_offset 8
 2207              		.cfi_offset 7, -8
 2208              		.cfi_offset 14, -4
 2209 0002 88B0     		sub	sp, sp, #32
 2210              	.LCFI73:
 2211              		.cfi_def_cfa_offset 40
 2212 0004 00AF     		add	r7, sp, #0
 2213              	.LCFI74:
 2214              		.cfi_def_cfa_register 7
 2215 0006 F860     		str	r0, [r7, #12]
 2216 0008 B960     		str	r1, [r7, #8]
 2217 000a 7A60     		str	r2, [r7, #4]
 2218              	.LBB17:
 953:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 954:../Generated_Code/UTIL0.c **** 
 955:../Generated_Code/UTIL0.c ****   UTIL0_Num32sToStr(buf, sizeof(buf), val);
 2219              		.loc 1 955 0
 2220 000c 3A1C     		mov	r2, r7
 2221 000e 1432     		add	r2, r2, #20
 2222 0010 7B68     		ldr	r3, [r7, #4]
 2223 0012 101C     		mov	r0, r2
 2224 0014 0C21     		mov	r1, #12
 2225 0016 1A1C     		mov	r2, r3
 2226 0018 FFF7FEFF 		bl	_Z17UTIL0_Num32sToStrPhjl
 956:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 2227              		.loc 1 956 0
 2228 001c F968     		ldr	r1, [r7, #12]
 2229 001e BA68     		ldr	r2, [r7, #8]
 2230 0020 3B1C     		mov	r3, r7
 2231 0022 1433     		add	r3, r3, #20
 2232 0024 081C     		mov	r0, r1
 2233 0026 111C     		mov	r1, r2
 2234 0028 1A1C     		mov	r2, r3
 2235 002a FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 2236              	.LBE17:
 957:../Generated_Code/UTIL0.c **** }
 2237              		.loc 1 957 0
 2238 002e BD46     		mov	sp, r7
 2239 0030 08B0     		add	sp, sp, #32
 2240              		@ sp needed for prologue
 2241 0032 80BD     		pop	{r7, pc}
 2242              		.cfi_endproc
 2243              	.LFE29:
 2245              		.section	.text._Z18UTIL0_strcatNum32uPhjm,"ax",%progbits
 2246              		.align	2
 2247              		.global	_Z18UTIL0_strcatNum32uPhjm
 2248              		.code	16
 2249              		.thumb_func
 2251              	_Z18UTIL0_strcatNum32uPhjm:
 2252              	.LFB30:
 958:../Generated_Code/UTIL0.c **** 
 959:../Generated_Code/UTIL0.c **** /*
 960:../Generated_Code/UTIL0.c **** ** ===================================================================
 961:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32u (component Utility)
 962:../Generated_Code/UTIL0.c **** **     Description :
 963:../Generated_Code/UTIL0.c **** **         Appends a 32bit signed value to a string buffer.
 964:../Generated_Code/UTIL0.c **** **     Parameters  :
 965:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 966:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 967:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 968:../Generated_Code/UTIL0.c **** **                           bytes).
 969:../Generated_Code/UTIL0.c **** **         val             - Value to convert.
 970:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
 971:../Generated_Code/UTIL0.c **** ** ===================================================================
 972:../Generated_Code/UTIL0.c **** */
 973:../Generated_Code/UTIL0.c **** /*!
 974:../Generated_Code/UTIL0.c ****   \brief appends a 32bit (unsigned long) number to a string. Always terminates the result string.
 975:../Generated_Code/UTIL0.c ****      Note: count is the size of dst INCLUDING zero byte.
 976:../Generated_Code/UTIL0.c ****      Precondition: src, dst != NULL
 977:../Generated_Code/UTIL0.c ****   \param[in,out] dst Start of buffer, where to append the number string
 978:../Generated_Code/UTIL0.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 979:../Generated_Code/UTIL0.c ****   \param[in] val The 32bit unsigned number to add
 980:../Generated_Code/UTIL0.c ****   */
 981:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32u(byte *dst, size_t dstSize, dword val)
 982:../Generated_Code/UTIL0.c **** {
 2253              		.loc 1 982 0
 2254              		.cfi_startproc
 2255 0000 80B5     		push	{r7, lr}
 2256              	.LCFI75:
 2257              		.cfi_def_cfa_offset 8
 2258              		.cfi_offset 7, -8
 2259              		.cfi_offset 14, -4
 2260 0002 88B0     		sub	sp, sp, #32
 2261              	.LCFI76:
 2262              		.cfi_def_cfa_offset 40
 2263 0004 00AF     		add	r7, sp, #0
 2264              	.LCFI77:
 2265              		.cfi_def_cfa_register 7
 2266 0006 F860     		str	r0, [r7, #12]
 2267 0008 B960     		str	r1, [r7, #8]
 2268 000a 7A60     		str	r2, [r7, #4]
 2269              	.LBB18:
 983:../Generated_Code/UTIL0.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 984:../Generated_Code/UTIL0.c **** 
 985:../Generated_Code/UTIL0.c ****   UTIL0_Num32uToStr(buf, sizeof(buf), val);
 2270              		.loc 1 985 0
 2271 000c 3A1C     		mov	r2, r7
 2272 000e 1432     		add	r2, r2, #20
 2273 0010 7B68     		ldr	r3, [r7, #4]
 2274 0012 101C     		mov	r0, r2
 2275 0014 0B21     		mov	r1, #11
 2276 0016 1A1C     		mov	r2, r3
 2277 0018 FFF7FEFF 		bl	_Z17UTIL0_Num32uToStrPhjm
 986:../Generated_Code/UTIL0.c ****   UTIL0_strcat(dst, dstSize, buf);
 2278              		.loc 1 986 0
 2279 001c F968     		ldr	r1, [r7, #12]
 2280 001e BA68     		ldr	r2, [r7, #8]
 2281 0020 3B1C     		mov	r3, r7
 2282 0022 1433     		add	r3, r3, #20
 2283 0024 081C     		mov	r0, r1
 2284 0026 111C     		mov	r1, r2
 2285 0028 1A1C     		mov	r2, r3
 2286 002a FFF7FEFF 		bl	_Z12UTIL0_strcatPhjPKh
 2287              	.LBE18:
 987:../Generated_Code/UTIL0.c **** }
 2288              		.loc 1 987 0
 2289 002e BD46     		mov	sp, r7
 2290 0030 08B0     		add	sp, sp, #32
 2291              		@ sp needed for prologue
 2292 0032 80BD     		pop	{r7, pc}
 2293              		.cfi_endproc
 2294              	.LFE30:
 2296              		.section	.rodata
 2297 0007 00       		.align	2
 2298              	.LC2:
 2299 0008 2D323134 		.ascii	"-2147483648\000"
 2299      37343833 
 2299      36343800 
 2300              		.section	.text._Z17UTIL0_Num32sToStrPhjl,"ax",%progbits
 2301              		.align	2
 2302              		.global	_Z17UTIL0_Num32sToStrPhjl
 2303              		.code	16
 2304              		.thumb_func
 2306              	_Z17UTIL0_Num32sToStrPhjl:
 2307              	.LFB31:
 988:../Generated_Code/UTIL0.c **** 
 989:../Generated_Code/UTIL0.c **** /*
 990:../Generated_Code/UTIL0.c **** ** ===================================================================
 991:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num32sToStr (component Utility)
 992:../Generated_Code/UTIL0.c **** **     Description :
 993:../Generated_Code/UTIL0.c **** **         Converts a signed 32bit value into a string.
 994:../Generated_Code/UTIL0.c **** **     Parameters  :
 995:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
 996:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
 997:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
 998:../Generated_Code/UTIL0.c **** **                           bytes).
 999:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
1000:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
1001:../Generated_Code/UTIL0.c **** ** ===================================================================
1002:../Generated_Code/UTIL0.c **** */
1003:../Generated_Code/UTIL0.c **** /*!
1004:../Generated_Code/UTIL0.c ****   \brief Converts a 32bit number to a string.
1005:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
1006:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
1007:../Generated_Code/UTIL0.c ****   \param[in] val 32bit signed number to convert.
1008:../Generated_Code/UTIL0.c ****  */
1009:../Generated_Code/UTIL0.c **** void UTIL0_Num32sToStr(byte *dst, size_t dstSize, long val)
1010:../Generated_Code/UTIL0.c **** {
 2308              		.loc 1 1010 0
 2309              		.cfi_startproc
 2310 0000 90B5     		push	{r4, r7, lr}
 2311              	.LCFI78:
 2312              		.cfi_def_cfa_offset 12
 2313              		.cfi_offset 4, -12
 2314              		.cfi_offset 7, -8
 2315              		.cfi_offset 14, -4
 2316 0002 89B0     		sub	sp, sp, #36
 2317              	.LCFI79:
 2318              		.cfi_def_cfa_offset 48
 2319 0004 00AF     		add	r7, sp, #0
 2320              	.LCFI80:
 2321              		.cfi_def_cfa_register 7
 2322 0006 F860     		str	r0, [r7, #12]
 2323 0008 B960     		str	r1, [r7, #8]
 2324 000a 7A60     		str	r2, [r7, #4]
 2325              	.LBB19:
1011:../Generated_Code/UTIL0.c ****   unsigned char *ptr = ((unsigned char *)dst);
 2326              		.loc 1 1011 0
 2327 000c FB68     		ldr	r3, [r7, #12]
 2328 000e BB61     		str	r3, [r7, #24]
1012:../Generated_Code/UTIL0.c ****   unsigned char i=0, j;
 2329              		.loc 1 1012 0
 2330 0010 3B1C     		mov	r3, r7
 2331 0012 1F33     		add	r3, r3, #31
 2332 0014 0022     		mov	r2, #0
 2333 0016 1A70     		strb	r2, [r3]
1013:../Generated_Code/UTIL0.c ****   unsigned char tmp;
1014:../Generated_Code/UTIL0.c ****   unsigned char sign = (unsigned char)(val < 0);
 2334              		.loc 1 1014 0
 2335 0018 7B68     		ldr	r3, [r7, #4]
 2336 001a DB0F     		lsr	r3, r3, #31
 2337 001c DAB2     		uxtb	r2, r3
 2338 001e 3B1C     		mov	r3, r7
 2339 0020 1733     		add	r3, r3, #23
 2340 0022 1A70     		strb	r2, [r3]
1015:../Generated_Code/UTIL0.c **** 
1016:../Generated_Code/UTIL0.c ****   if (val==(int32_t)(0x80000000)) { /* special case 0x80000000/-2147483648: prevent overflow below.
 2341              		.loc 1 1016 0
 2342 0024 7A68     		ldr	r2, [r7, #4]
 2343 0026 8023     		mov	r3, #128
 2344 0028 1B06     		lsl	r3, r3, #24
 2345 002a 9A42     		cmp	r2, r3
 2346 002c 08D1     		bne	.L85
1017:../Generated_Code/UTIL0.c ****     UTIL0_strcpy(dst, dstSize, (unsigned char*)"-2147483648");
 2347              		.loc 1 1017 0
 2348 002e F968     		ldr	r1, [r7, #12]
 2349 0030 BA68     		ldr	r2, [r7, #8]
 2350 0032 5D4B     		ldr	r3, .L96
 2351 0034 081C     		mov	r0, r1
 2352 0036 111C     		mov	r1, r2
 2353 0038 1A1C     		mov	r2, r3
 2354 003a FFF7FEFF 		bl	_Z12UTIL0_strcpyPhjPKh
1018:../Generated_Code/UTIL0.c ****     return;
 2355              		.loc 1 1018 0
 2356 003e AFE0     		b	.L84
 2357              	.L85:
1019:../Generated_Code/UTIL0.c ****   }
1020:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 2358              		.loc 1 1020 0
 2359 0040 BB68     		ldr	r3, [r7, #8]
 2360 0042 013B     		sub	r3, r3, #1
 2361 0044 BB60     		str	r3, [r7, #8]
1021:../Generated_Code/UTIL0.c ****   if (sign) {
 2362              		.loc 1 1021 0
 2363 0046 3B1C     		mov	r3, r7
 2364 0048 1733     		add	r3, r3, #23
 2365 004a 1B78     		ldrb	r3, [r3]
 2366 004c 002B     		cmp	r3, #0
 2367 004e 02D0     		beq	.L87
1022:../Generated_Code/UTIL0.c ****     val = -val;
 2368              		.loc 1 1022 0
 2369 0050 7B68     		ldr	r3, [r7, #4]
 2370 0052 5B42     		neg	r3, r3
 2371 0054 7B60     		str	r3, [r7, #4]
 2372              	.L87:
1023:../Generated_Code/UTIL0.c ****   }
1024:../Generated_Code/UTIL0.c ****   if (val == 0 && dstSize > 0){
 2373              		.loc 1 1024 0
 2374 0056 7B68     		ldr	r3, [r7, #4]
 2375 0058 002B     		cmp	r3, #0
 2376 005a 34D1     		bne	.L89
 2377              		.loc 1 1024 0 is_stmt 0
 2378 005c BB68     		ldr	r3, [r7, #8]
 2379 005e 002B     		cmp	r3, #0
 2380 0060 31D0     		beq	.L89
1025:../Generated_Code/UTIL0.c ****     ptr[i++] = '0';
 2381              		.loc 1 1025 0 is_stmt 1
 2382 0062 3B1C     		mov	r3, r7
 2383 0064 1F33     		add	r3, r3, #31
 2384 0066 1B78     		ldrb	r3, [r3]
 2385 0068 BA69     		ldr	r2, [r7, #24]
 2386 006a D318     		add	r3, r2, r3
 2387 006c 3022     		mov	r2, #48
 2388 006e 1A70     		strb	r2, [r3]
 2389 0070 3B1C     		mov	r3, r7
 2390 0072 1F33     		add	r3, r3, #31
 2391 0074 3A1C     		mov	r2, r7
 2392 0076 1F32     		add	r2, r2, #31
 2393 0078 1278     		ldrb	r2, [r2]
 2394 007a 0132     		add	r2, r2, #1
 2395 007c 1A70     		strb	r2, [r3]
1026:../Generated_Code/UTIL0.c ****     dstSize--;
 2396              		.loc 1 1026 0
 2397 007e BB68     		ldr	r3, [r7, #8]
 2398 0080 013B     		sub	r3, r3, #1
 2399 0082 BB60     		str	r3, [r7, #8]
1027:../Generated_Code/UTIL0.c ****   }
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2400              		.loc 1 1028 0
 2401 0084 1FE0     		b	.L89
 2402              	.L92:
1029:../Generated_Code/UTIL0.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2403              		.loc 1 1029 0
 2404 0086 3B1C     		mov	r3, r7
 2405 0088 1F33     		add	r3, r3, #31
 2406 008a 1B78     		ldrb	r3, [r3]
 2407 008c BA69     		ldr	r2, [r7, #24]
 2408 008e D418     		add	r4, r2, r3
 2409 0090 7B68     		ldr	r3, [r7, #4]
 2410 0092 181C     		mov	r0, r3
 2411 0094 0A21     		mov	r1, #10
 2412 0096 FFF7FEFF 		bl	__aeabi_idivmod
 2413 009a 0B1C     		mov	r3, r1
 2414 009c DBB2     		uxtb	r3, r3
 2415 009e 3033     		add	r3, r3, #48
 2416 00a0 DBB2     		uxtb	r3, r3
 2417 00a2 2370     		strb	r3, [r4]
 2418 00a4 3B1C     		mov	r3, r7
 2419 00a6 1F33     		add	r3, r3, #31
 2420 00a8 3A1C     		mov	r2, r7
 2421 00aa 1F32     		add	r2, r2, #31
 2422 00ac 1278     		ldrb	r2, [r2]
 2423 00ae 0132     		add	r2, r2, #1
 2424 00b0 1A70     		strb	r2, [r3]
1030:../Generated_Code/UTIL0.c ****     dstSize--;
 2425              		.loc 1 1030 0
 2426 00b2 BB68     		ldr	r3, [r7, #8]
 2427 00b4 013B     		sub	r3, r3, #1
 2428 00b6 BB60     		str	r3, [r7, #8]
1031:../Generated_Code/UTIL0.c ****     val /= 10;
 2429              		.loc 1 1031 0
 2430 00b8 7B68     		ldr	r3, [r7, #4]
 2431 00ba 181C     		mov	r0, r3
 2432 00bc 0A21     		mov	r1, #10
 2433 00be FFF7FEFF 		bl	__aeabi_idiv
 2434 00c2 031C     		mov	r3, r0
 2435 00c4 7B60     		str	r3, [r7, #4]
 2436              	.L89:
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2437              		.loc 1 1028 0
 2438 00c6 7B68     		ldr	r3, [r7, #4]
 2439 00c8 002B     		cmp	r3, #0
 2440 00ca 04DD     		ble	.L90
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2441              		.loc 1 1028 0 is_stmt 0
 2442 00cc BB68     		ldr	r3, [r7, #8]
 2443 00ce 002B     		cmp	r3, #0
 2444 00d0 01D0     		beq	.L90
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2445              		.loc 1 1028 0
 2446 00d2 0123     		mov	r3, #1
 2447 00d4 00E0     		b	.L91
 2448              	.L90:
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2449              		.loc 1 1028 0
 2450 00d6 0023     		mov	r3, #0
 2451              	.L91:
1028:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2452              		.loc 1 1028 0
 2453 00d8 002B     		cmp	r3, #0
 2454 00da D4D1     		bne	.L92
1032:../Generated_Code/UTIL0.c ****   }
1033:../Generated_Code/UTIL0.c ****   if (sign && dstSize > 0){
 2455              		.loc 1 1033 0 is_stmt 1
 2456 00dc 3B1C     		mov	r3, r7
 2457 00de 1733     		add	r3, r3, #23
 2458 00e0 1B78     		ldrb	r3, [r3]
 2459 00e2 002B     		cmp	r3, #0
 2460 00e4 13D0     		beq	.L93
 2461              		.loc 1 1033 0 is_stmt 0
 2462 00e6 BB68     		ldr	r3, [r7, #8]
 2463 00e8 002B     		cmp	r3, #0
 2464 00ea 10D0     		beq	.L93
1034:../Generated_Code/UTIL0.c ****     ptr[i++] = '-';
 2465              		.loc 1 1034 0 is_stmt 1
 2466 00ec 3B1C     		mov	r3, r7
 2467 00ee 1F33     		add	r3, r3, #31
 2468 00f0 1B78     		ldrb	r3, [r3]
 2469 00f2 BA69     		ldr	r2, [r7, #24]
 2470 00f4 D318     		add	r3, r2, r3
 2471 00f6 2D22     		mov	r2, #45
 2472 00f8 1A70     		strb	r2, [r3]
 2473 00fa 3B1C     		mov	r3, r7
 2474 00fc 1F33     		add	r3, r3, #31
 2475 00fe 3A1C     		mov	r2, r7
 2476 0100 1F32     		add	r2, r2, #31
 2477 0102 1278     		ldrb	r2, [r2]
 2478 0104 0132     		add	r2, r2, #1
 2479 0106 1A70     		strb	r2, [r3]
1035:../Generated_Code/UTIL0.c ****     dstSize--;
 2480              		.loc 1 1035 0
 2481 0108 BB68     		ldr	r3, [r7, #8]
 2482 010a 013B     		sub	r3, r3, #1
 2483 010c BB60     		str	r3, [r7, #8]
 2484              	.L93:
1036:../Generated_Code/UTIL0.c ****   }
1037:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2485              		.loc 1 1037 0
 2486 010e 3B1C     		mov	r3, r7
 2487 0110 1E33     		add	r3, r3, #30
 2488 0112 0022     		mov	r2, #0
 2489 0114 1A70     		strb	r2, [r3]
 2490 0116 2EE0     		b	.L94
 2491              	.L95:
1038:../Generated_Code/UTIL0.c ****     tmp = ptr[j];
 2492              		.loc 1 1038 0
 2493 0118 3B1C     		mov	r3, r7
 2494 011a 1E33     		add	r3, r3, #30
 2495 011c 1B78     		ldrb	r3, [r3]
 2496 011e BA69     		ldr	r2, [r7, #24]
 2497 0120 D218     		add	r2, r2, r3
 2498 0122 3B1C     		mov	r3, r7
 2499 0124 1633     		add	r3, r3, #22
 2500 0126 1278     		ldrb	r2, [r2]
 2501 0128 1A70     		strb	r2, [r3]
1039:../Generated_Code/UTIL0.c ****     ptr[j] = ptr[(i-j)-1];
 2502              		.loc 1 1039 0
 2503 012a 3B1C     		mov	r3, r7
 2504 012c 1E33     		add	r3, r3, #30
 2505 012e 1B78     		ldrb	r3, [r3]
 2506 0130 BA69     		ldr	r2, [r7, #24]
 2507 0132 D318     		add	r3, r2, r3
 2508 0134 3A1C     		mov	r2, r7
 2509 0136 1F32     		add	r2, r2, #31
 2510 0138 1178     		ldrb	r1, [r2]
 2511 013a 3A1C     		mov	r2, r7
 2512 013c 1E32     		add	r2, r2, #30
 2513 013e 1278     		ldrb	r2, [r2]
 2514 0140 8A1A     		sub	r2, r1, r2
 2515 0142 013A     		sub	r2, r2, #1
 2516 0144 B969     		ldr	r1, [r7, #24]
 2517 0146 8A18     		add	r2, r1, r2
 2518 0148 1278     		ldrb	r2, [r2]
 2519 014a 1A70     		strb	r2, [r3]
1040:../Generated_Code/UTIL0.c ****     ptr[(i-j)-1] = tmp;
 2520              		.loc 1 1040 0
 2521 014c 3B1C     		mov	r3, r7
 2522 014e 1F33     		add	r3, r3, #31
 2523 0150 1A78     		ldrb	r2, [r3]
 2524 0152 3B1C     		mov	r3, r7
 2525 0154 1E33     		add	r3, r3, #30
 2526 0156 1B78     		ldrb	r3, [r3]
 2527 0158 D31A     		sub	r3, r2, r3
 2528 015a 013B     		sub	r3, r3, #1
 2529 015c BA69     		ldr	r2, [r7, #24]
 2530 015e D318     		add	r3, r2, r3
 2531 0160 3A1C     		mov	r2, r7
 2532 0162 1632     		add	r2, r2, #22
 2533 0164 1278     		ldrb	r2, [r2]
 2534 0166 1A70     		strb	r2, [r3]
1037:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2535              		.loc 1 1037 0
 2536 0168 3B1C     		mov	r3, r7
 2537 016a 1E33     		add	r3, r3, #30
 2538 016c 3A1C     		mov	r2, r7
 2539 016e 1E32     		add	r2, r2, #30
 2540 0170 1278     		ldrb	r2, [r2]
 2541 0172 0132     		add	r2, r2, #1
 2542 0174 1A70     		strb	r2, [r3]
 2543              	.L94:
1037:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2544              		.loc 1 1037 0 is_stmt 0
 2545 0176 3B1C     		mov	r3, r7
 2546 0178 1F33     		add	r3, r3, #31
 2547 017a 1B78     		ldrb	r3, [r3]
 2548 017c 5B08     		lsr	r3, r3, #1
 2549 017e DBB2     		uxtb	r3, r3
 2550 0180 3A1C     		mov	r2, r7
 2551 0182 1E32     		add	r2, r2, #30
 2552 0184 1278     		ldrb	r2, [r2]
 2553 0186 9A42     		cmp	r2, r3
 2554 0188 9B41     		sbc	r3, r3, r3
 2555 018a 5B42     		neg	r3, r3
 2556 018c DBB2     		uxtb	r3, r3
 2557 018e 002B     		cmp	r3, #0
 2558 0190 C2D1     		bne	.L95
1041:../Generated_Code/UTIL0.c ****   }
1042:../Generated_Code/UTIL0.c ****   ptr[i] = '\0';
 2559              		.loc 1 1042 0 is_stmt 1
 2560 0192 3B1C     		mov	r3, r7
 2561 0194 1F33     		add	r3, r3, #31
 2562 0196 1B78     		ldrb	r3, [r3]
 2563 0198 BA69     		ldr	r2, [r7, #24]
 2564 019a D318     		add	r3, r2, r3
 2565 019c 0022     		mov	r2, #0
 2566 019e 1A70     		strb	r2, [r3]
 2567              	.L84:
 2568              	.LBE19:
1043:../Generated_Code/UTIL0.c **** }
 2569              		.loc 1 1043 0
 2570 01a0 BD46     		mov	sp, r7
 2571 01a2 09B0     		add	sp, sp, #36
 2572              		@ sp needed for prologue
 2573 01a4 90BD     		pop	{r4, r7, pc}
 2574              	.L97:
 2575 01a6 C046     		.align	2
 2576              	.L96:
 2577 01a8 08000000 		.word	.LC2
 2578              		.cfi_endproc
 2579              	.LFE31:
 2581              		.section	.text._Z17UTIL0_Num32uToStrPhjm,"ax",%progbits
 2582              		.align	2
 2583              		.global	_Z17UTIL0_Num32uToStrPhjm
 2584              		.code	16
 2585              		.thumb_func
 2587              	_Z17UTIL0_Num32uToStrPhjm:
 2588              	.LFB32:
1044:../Generated_Code/UTIL0.c **** 
1045:../Generated_Code/UTIL0.c **** /*
1046:../Generated_Code/UTIL0.c **** ** ===================================================================
1047:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_Num32uToStr (component Utility)
1048:../Generated_Code/UTIL0.c **** **     Description :
1049:../Generated_Code/UTIL0.c **** **         Converts an unsigned 32bit value into a string.
1050:../Generated_Code/UTIL0.c **** **     Parameters  :
1051:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1052:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
1053:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
1054:../Generated_Code/UTIL0.c **** **                           bytes).
1055:../Generated_Code/UTIL0.c **** **         val             - Value to be converted.
1056:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
1057:../Generated_Code/UTIL0.c **** ** ===================================================================
1058:../Generated_Code/UTIL0.c **** */
1059:../Generated_Code/UTIL0.c **** /*!
1060:../Generated_Code/UTIL0.c ****   \brief Converts a 32bit signed number to a string.
1061:../Generated_Code/UTIL0.c ****   \param[in,out] dst String buffer to store the number.
1062:../Generated_Code/UTIL0.c ****   \param[in] dstSize Size of the destination buffer in bytes.
1063:../Generated_Code/UTIL0.c ****   \param[in] val 32bit unsigned number to convert.
1064:../Generated_Code/UTIL0.c ****  */
1065:../Generated_Code/UTIL0.c **** void UTIL0_Num32uToStr(byte *dst, size_t dstSize, dword val)
1066:../Generated_Code/UTIL0.c **** {
 2589              		.loc 1 1066 0
 2590              		.cfi_startproc
 2591 0000 90B5     		push	{r4, r7, lr}
 2592              	.LCFI81:
 2593              		.cfi_def_cfa_offset 12
 2594              		.cfi_offset 4, -12
 2595              		.cfi_offset 7, -8
 2596              		.cfi_offset 14, -4
 2597 0002 89B0     		sub	sp, sp, #36
 2598              	.LCFI82:
 2599              		.cfi_def_cfa_offset 48
 2600 0004 00AF     		add	r7, sp, #0
 2601              	.LCFI83:
 2602              		.cfi_def_cfa_register 7
 2603 0006 F860     		str	r0, [r7, #12]
 2604 0008 B960     		str	r1, [r7, #8]
 2605 000a 7A60     		str	r2, [r7, #4]
 2606              	.LBB20:
1067:../Generated_Code/UTIL0.c ****   unsigned char *ptr = ((unsigned char *)dst);
 2607              		.loc 1 1067 0
 2608 000c FB68     		ldr	r3, [r7, #12]
 2609 000e BB61     		str	r3, [r7, #24]
1068:../Generated_Code/UTIL0.c ****   unsigned char i=0, j;
 2610              		.loc 1 1068 0
 2611 0010 3B1C     		mov	r3, r7
 2612 0012 1F33     		add	r3, r3, #31
 2613 0014 0022     		mov	r2, #0
 2614 0016 1A70     		strb	r2, [r3]
1069:../Generated_Code/UTIL0.c ****   unsigned char tmp;
1070:../Generated_Code/UTIL0.c **** 
1071:../Generated_Code/UTIL0.c ****   dstSize--; /* for zero byte */
 2615              		.loc 1 1071 0
 2616 0018 BB68     		ldr	r3, [r7, #8]
 2617 001a 013B     		sub	r3, r3, #1
 2618 001c BB60     		str	r3, [r7, #8]
1072:../Generated_Code/UTIL0.c ****   if (val == 0 && dstSize > 0){
 2619              		.loc 1 1072 0
 2620 001e 7B68     		ldr	r3, [r7, #4]
 2621 0020 002B     		cmp	r3, #0
 2622 0022 34D1     		bne	.L100
 2623              		.loc 1 1072 0 is_stmt 0
 2624 0024 BB68     		ldr	r3, [r7, #8]
 2625 0026 002B     		cmp	r3, #0
 2626 0028 31D0     		beq	.L100
1073:../Generated_Code/UTIL0.c ****     ptr[i++] = '0';
 2627              		.loc 1 1073 0 is_stmt 1
 2628 002a 3B1C     		mov	r3, r7
 2629 002c 1F33     		add	r3, r3, #31
 2630 002e 1B78     		ldrb	r3, [r3]
 2631 0030 BA69     		ldr	r2, [r7, #24]
 2632 0032 D318     		add	r3, r2, r3
 2633 0034 3022     		mov	r2, #48
 2634 0036 1A70     		strb	r2, [r3]
 2635 0038 3B1C     		mov	r3, r7
 2636 003a 1F33     		add	r3, r3, #31
 2637 003c 3A1C     		mov	r2, r7
 2638 003e 1F32     		add	r2, r2, #31
 2639 0040 1278     		ldrb	r2, [r2]
 2640 0042 0132     		add	r2, r2, #1
 2641 0044 1A70     		strb	r2, [r3]
1074:../Generated_Code/UTIL0.c ****     dstSize--;
 2642              		.loc 1 1074 0
 2643 0046 BB68     		ldr	r3, [r7, #8]
 2644 0048 013B     		sub	r3, r3, #1
 2645 004a BB60     		str	r3, [r7, #8]
1075:../Generated_Code/UTIL0.c ****   }
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2646              		.loc 1 1076 0
 2647 004c 1FE0     		b	.L100
 2648              	.L103:
1077:../Generated_Code/UTIL0.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2649              		.loc 1 1077 0
 2650 004e 3B1C     		mov	r3, r7
 2651 0050 1F33     		add	r3, r3, #31
 2652 0052 1B78     		ldrb	r3, [r3]
 2653 0054 BA69     		ldr	r2, [r7, #24]
 2654 0056 D418     		add	r4, r2, r3
 2655 0058 7B68     		ldr	r3, [r7, #4]
 2656 005a 181C     		mov	r0, r3
 2657 005c 0A21     		mov	r1, #10
 2658 005e FFF7FEFF 		bl	__aeabi_uidivmod
 2659 0062 0B1C     		mov	r3, r1
 2660 0064 DBB2     		uxtb	r3, r3
 2661 0066 3033     		add	r3, r3, #48
 2662 0068 DBB2     		uxtb	r3, r3
 2663 006a 2370     		strb	r3, [r4]
 2664 006c 3B1C     		mov	r3, r7
 2665 006e 1F33     		add	r3, r3, #31
 2666 0070 3A1C     		mov	r2, r7
 2667 0072 1F32     		add	r2, r2, #31
 2668 0074 1278     		ldrb	r2, [r2]
 2669 0076 0132     		add	r2, r2, #1
 2670 0078 1A70     		strb	r2, [r3]
1078:../Generated_Code/UTIL0.c ****     dstSize--;
 2671              		.loc 1 1078 0
 2672 007a BB68     		ldr	r3, [r7, #8]
 2673 007c 013B     		sub	r3, r3, #1
 2674 007e BB60     		str	r3, [r7, #8]
1079:../Generated_Code/UTIL0.c ****     val /= 10;
 2675              		.loc 1 1079 0
 2676 0080 7B68     		ldr	r3, [r7, #4]
 2677 0082 181C     		mov	r0, r3
 2678 0084 0A21     		mov	r1, #10
 2679 0086 FFF7FEFF 		bl	__aeabi_uidiv
 2680 008a 031C     		mov	r3, r0
 2681 008c 7B60     		str	r3, [r7, #4]
 2682              	.L100:
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2683              		.loc 1 1076 0
 2684 008e 7B68     		ldr	r3, [r7, #4]
 2685 0090 002B     		cmp	r3, #0
 2686 0092 04D0     		beq	.L101
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2687              		.loc 1 1076 0 is_stmt 0
 2688 0094 BB68     		ldr	r3, [r7, #8]
 2689 0096 002B     		cmp	r3, #0
 2690 0098 01D0     		beq	.L101
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2691              		.loc 1 1076 0
 2692 009a 0123     		mov	r3, #1
 2693 009c 00E0     		b	.L102
 2694              	.L101:
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2695              		.loc 1 1076 0
 2696 009e 0023     		mov	r3, #0
 2697              	.L102:
1076:../Generated_Code/UTIL0.c ****   while (val > 0 && dstSize > 0) {
 2698              		.loc 1 1076 0
 2699 00a0 002B     		cmp	r3, #0
 2700 00a2 D4D1     		bne	.L103
1080:../Generated_Code/UTIL0.c ****   }
1081:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2701              		.loc 1 1081 0 is_stmt 1
 2702 00a4 3B1C     		mov	r3, r7
 2703 00a6 1E33     		add	r3, r3, #30
 2704 00a8 0022     		mov	r2, #0
 2705 00aa 1A70     		strb	r2, [r3]
 2706 00ac 2EE0     		b	.L104
 2707              	.L105:
1082:../Generated_Code/UTIL0.c ****     tmp = ptr[j];
 2708              		.loc 1 1082 0
 2709 00ae 3B1C     		mov	r3, r7
 2710 00b0 1E33     		add	r3, r3, #30
 2711 00b2 1B78     		ldrb	r3, [r3]
 2712 00b4 BA69     		ldr	r2, [r7, #24]
 2713 00b6 D218     		add	r2, r2, r3
 2714 00b8 3B1C     		mov	r3, r7
 2715 00ba 1733     		add	r3, r3, #23
 2716 00bc 1278     		ldrb	r2, [r2]
 2717 00be 1A70     		strb	r2, [r3]
1083:../Generated_Code/UTIL0.c ****     ptr[j] = ptr[(i-j)-1];
 2718              		.loc 1 1083 0
 2719 00c0 3B1C     		mov	r3, r7
 2720 00c2 1E33     		add	r3, r3, #30
 2721 00c4 1B78     		ldrb	r3, [r3]
 2722 00c6 BA69     		ldr	r2, [r7, #24]
 2723 00c8 D318     		add	r3, r2, r3
 2724 00ca 3A1C     		mov	r2, r7
 2725 00cc 1F32     		add	r2, r2, #31
 2726 00ce 1178     		ldrb	r1, [r2]
 2727 00d0 3A1C     		mov	r2, r7
 2728 00d2 1E32     		add	r2, r2, #30
 2729 00d4 1278     		ldrb	r2, [r2]
 2730 00d6 8A1A     		sub	r2, r1, r2
 2731 00d8 013A     		sub	r2, r2, #1
 2732 00da B969     		ldr	r1, [r7, #24]
 2733 00dc 8A18     		add	r2, r1, r2
 2734 00de 1278     		ldrb	r2, [r2]
 2735 00e0 1A70     		strb	r2, [r3]
1084:../Generated_Code/UTIL0.c ****     ptr[(i-j)-1] = tmp;
 2736              		.loc 1 1084 0
 2737 00e2 3B1C     		mov	r3, r7
 2738 00e4 1F33     		add	r3, r3, #31
 2739 00e6 1A78     		ldrb	r2, [r3]
 2740 00e8 3B1C     		mov	r3, r7
 2741 00ea 1E33     		add	r3, r3, #30
 2742 00ec 1B78     		ldrb	r3, [r3]
 2743 00ee D31A     		sub	r3, r2, r3
 2744 00f0 013B     		sub	r3, r3, #1
 2745 00f2 BA69     		ldr	r2, [r7, #24]
 2746 00f4 D318     		add	r3, r2, r3
 2747 00f6 3A1C     		mov	r2, r7
 2748 00f8 1732     		add	r2, r2, #23
 2749 00fa 1278     		ldrb	r2, [r2]
 2750 00fc 1A70     		strb	r2, [r3]
1081:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2751              		.loc 1 1081 0
 2752 00fe 3B1C     		mov	r3, r7
 2753 0100 1E33     		add	r3, r3, #30
 2754 0102 3A1C     		mov	r2, r7
 2755 0104 1E32     		add	r2, r2, #30
 2756 0106 1278     		ldrb	r2, [r2]
 2757 0108 0132     		add	r2, r2, #1
 2758 010a 1A70     		strb	r2, [r3]
 2759              	.L104:
1081:../Generated_Code/UTIL0.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2760              		.loc 1 1081 0 is_stmt 0
 2761 010c 3B1C     		mov	r3, r7
 2762 010e 1F33     		add	r3, r3, #31
 2763 0110 1B78     		ldrb	r3, [r3]
 2764 0112 5B08     		lsr	r3, r3, #1
 2765 0114 DBB2     		uxtb	r3, r3
 2766 0116 3A1C     		mov	r2, r7
 2767 0118 1E32     		add	r2, r2, #30
 2768 011a 1278     		ldrb	r2, [r2]
 2769 011c 9A42     		cmp	r2, r3
 2770 011e 9B41     		sbc	r3, r3, r3
 2771 0120 5B42     		neg	r3, r3
 2772 0122 DBB2     		uxtb	r3, r3
 2773 0124 002B     		cmp	r3, #0
 2774 0126 C2D1     		bne	.L105
1085:../Generated_Code/UTIL0.c ****   }
1086:../Generated_Code/UTIL0.c ****   ptr[i] = '\0';
 2775              		.loc 1 1086 0 is_stmt 1
 2776 0128 3B1C     		mov	r3, r7
 2777 012a 1F33     		add	r3, r3, #31
 2778 012c 1B78     		ldrb	r3, [r3]
 2779 012e BA69     		ldr	r2, [r7, #24]
 2780 0130 D318     		add	r3, r2, r3
 2781 0132 0022     		mov	r2, #0
 2782 0134 1A70     		strb	r2, [r3]
 2783              	.LBE20:
1087:../Generated_Code/UTIL0.c **** }
 2784              		.loc 1 1087 0
 2785 0136 BD46     		mov	sp, r7
 2786 0138 09B0     		add	sp, sp, #36
 2787              		@ sp needed for prologue
 2788 013a 90BD     		pop	{r4, r7, pc}
 2789              		.cfi_endproc
 2790              	.LFE32:
 2792              		.section	.text._Z16UTIL0_IsLeapYeart,"ax",%progbits
 2793              		.align	2
 2794              		.global	_Z16UTIL0_IsLeapYeart
 2795              		.code	16
 2796              		.thumb_func
 2798              	_Z16UTIL0_IsLeapYeart:
 2799              	.LFB33:
1088:../Generated_Code/UTIL0.c **** 
1089:../Generated_Code/UTIL0.c **** /*
1090:../Generated_Code/UTIL0.c **** ** ===================================================================
1091:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_IsLeapYear (component Utility)
1092:../Generated_Code/UTIL0.c **** **     Description :
1093:../Generated_Code/UTIL0.c **** **         Returns true if a given year is a leap year
1094:../Generated_Code/UTIL0.c **** **     Parameters  :
1095:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1096:../Generated_Code/UTIL0.c **** **         year            - Year, in the YYYY format.
1097:../Generated_Code/UTIL0.c **** **     Returns     :
1098:../Generated_Code/UTIL0.c **** **         ---             - If the year is a leap year or not.
1099:../Generated_Code/UTIL0.c **** ** ===================================================================
1100:../Generated_Code/UTIL0.c **** */
1101:../Generated_Code/UTIL0.c **** bool UTIL0_IsLeapYear(word year)
1102:../Generated_Code/UTIL0.c **** {
 2800              		.loc 1 1102 0
 2801              		.cfi_startproc
 2802 0000 80B5     		push	{r7, lr}
 2803              	.LCFI84:
 2804              		.cfi_def_cfa_offset 8
 2805              		.cfi_offset 7, -8
 2806              		.cfi_offset 14, -4
 2807 0002 82B0     		sub	sp, sp, #8
 2808              	.LCFI85:
 2809              		.cfi_def_cfa_offset 16
 2810 0004 00AF     		add	r7, sp, #0
 2811              	.LCFI86:
 2812              		.cfi_def_cfa_register 7
 2813 0006 021C     		mov	r2, r0
 2814 0008 BB1D     		add	r3, r7, #6
 2815 000a 1A80     		strh	r2, [r3]
1103:../Generated_Code/UTIL0.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 2816              		.loc 1 1103 0
 2817 000c BB1D     		add	r3, r7, #6
 2818 000e 1A88     		ldrh	r2, [r3]
 2819 0010 0323     		mov	r3, #3
 2820 0012 1340     		and	r3, r2
 2821 0014 09D1     		bne	.L107
 2822              		.loc 1 1103 0 is_stmt 0
 2823 0016 BB1D     		add	r3, r7, #6
 2824 0018 1B88     		ldrh	r3, [r3]
 2825 001a 181C     		mov	r0, r3
 2826 001c 6421     		mov	r1, #100
 2827 001e FFF7FEFF 		bl	__aeabi_uidivmod
 2828 0022 0B1C     		mov	r3, r1
 2829 0024 9BB2     		uxth	r3, r3
 2830 0026 002B     		cmp	r3, #0
 2831 0028 0AD1     		bne	.L108
 2832              	.L107:
 2833              		.loc 1 1103 0
 2834 002a BB1D     		add	r3, r7, #6
 2835 002c 1B88     		ldrh	r3, [r3]
 2836 002e 181C     		mov	r0, r3
 2837 0030 C823     		mov	r3, #200
 2838 0032 5900     		lsl	r1, r3, #1
 2839 0034 FFF7FEFF 		bl	__aeabi_uidivmod
 2840 0038 0B1C     		mov	r3, r1
 2841 003a 9BB2     		uxth	r3, r3
 2842 003c 002B     		cmp	r3, #0
 2843 003e 01D1     		bne	.L109
 2844              	.L108:
 2845              		.loc 1 1103 0
 2846 0040 0123     		mov	r3, #1
 2847 0042 00E0     		b	.L110
 2848              	.L109:
 2849              		.loc 1 1103 0
 2850 0044 0023     		mov	r3, #0
 2851              	.L110:
1104:../Generated_Code/UTIL0.c **** }
 2852              		.loc 1 1104 0 is_stmt 1
 2853 0046 181C     		mov	r0, r3
 2854 0048 BD46     		mov	sp, r7
 2855 004a 02B0     		add	sp, sp, #8
 2856              		@ sp needed for prologue
 2857 004c 80BD     		pop	{r7, pc}
 2858              		.cfi_endproc
 2859              	.LFE33:
 2861 004e C046     		.section	.text._Z13UTIL0_WeekDaythh,"ax",%progbits
 2862              		.align	2
 2863              		.global	_Z13UTIL0_WeekDaythh
 2864              		.code	16
 2865              		.thumb_func
 2867              	_Z13UTIL0_WeekDaythh:
 2868              	.LFB34:
1105:../Generated_Code/UTIL0.c **** 
1106:../Generated_Code/UTIL0.c **** /*
1107:../Generated_Code/UTIL0.c **** ** ===================================================================
1108:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_WeekDay (component Utility)
1109:../Generated_Code/UTIL0.c **** **     Description :
1110:../Generated_Code/UTIL0.c **** **         Returns the weekday for a given date >= 1.Jan.1900
1111:../Generated_Code/UTIL0.c **** **     Parameters  :
1112:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1113:../Generated_Code/UTIL0.c **** **         year            - year in YYYY format
1114:../Generated_Code/UTIL0.c **** **         month           - month of the year (1: January, 2:
1115:../Generated_Code/UTIL0.c **** **                           February, etc)
1116:../Generated_Code/UTIL0.c **** **         day             - day of the moth (starting with 1)
1117:../Generated_Code/UTIL0.c **** **     Returns     :
1118:../Generated_Code/UTIL0.c **** **         ---             - Returns the weekday, 0 for Sunday, 1 for
1119:../Generated_Code/UTIL0.c **** **                           Monday, 2 for Tuesday, etc.
1120:../Generated_Code/UTIL0.c **** ** ===================================================================
1121:../Generated_Code/UTIL0.c **** */
1122:../Generated_Code/UTIL0.c **** byte UTIL0_WeekDay(word year, byte month, byte day)
1123:../Generated_Code/UTIL0.c **** {
 2869              		.loc 1 1123 0
 2870              		.cfi_startproc
 2871 0000 90B5     		push	{r4, r7, lr}
 2872              	.LCFI87:
 2873              		.cfi_def_cfa_offset 12
 2874              		.cfi_offset 4, -12
 2875              		.cfi_offset 7, -8
 2876              		.cfi_offset 14, -4
 2877 0002 85B0     		sub	sp, sp, #20
 2878              	.LCFI88:
 2879              		.cfi_def_cfa_offset 32
 2880 0004 00AF     		add	r7, sp, #0
 2881              	.LCFI89:
 2882              		.cfi_def_cfa_register 7
 2883 0006 BB1D     		add	r3, r7, #6
 2884 0008 1880     		strh	r0, [r3]
 2885 000a 7B1D     		add	r3, r7, #5
 2886 000c 1970     		strb	r1, [r3]
 2887 000e 3B1D     		add	r3, r7, #4
 2888 0010 1A70     		strb	r2, [r3]
 2889              	.LBB21:
1124:../Generated_Code/UTIL0.c ****   /* see http://klausler.com/new-dayofweek.html */
1125:../Generated_Code/UTIL0.c ****   static const byte skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
1126:../Generated_Code/UTIL0.c ****   word sum;
1127:../Generated_Code/UTIL0.c **** 
1128:../Generated_Code/UTIL0.c ****   sum = (word)(year-1900);
 2890              		.loc 1 1128 0
 2891 0012 3B1C     		mov	r3, r7
 2892 0014 0E33     		add	r3, r3, #14
 2893 0016 BA1D     		add	r2, r7, #6
 2894 0018 1288     		ldrh	r2, [r2]
 2895 001a 3549     		ldr	r1, .L118
 2896 001c 5218     		add	r2, r2, r1
 2897 001e 1A80     		strh	r2, [r3]
1129:../Generated_Code/UTIL0.c ****   sum += sum/4;
 2898              		.loc 1 1129 0
 2899 0020 3B1C     		mov	r3, r7
 2900 0022 0E33     		add	r3, r3, #14
 2901 0024 1B88     		ldrh	r3, [r3]
 2902 0026 9B08     		lsr	r3, r3, #2
 2903 0028 99B2     		uxth	r1, r3
 2904 002a 3B1C     		mov	r3, r7
 2905 002c 0E33     		add	r3, r3, #14
 2906 002e 3A1C     		mov	r2, r7
 2907 0030 0E32     		add	r2, r2, #14
 2908 0032 1288     		ldrh	r2, [r2]
 2909 0034 8A18     		add	r2, r1, r2
 2910 0036 1A80     		strh	r2, [r3]
1130:../Generated_Code/UTIL0.c ****   sum %= 7;
 2911              		.loc 1 1130 0
 2912 0038 3C1C     		mov	r4, r7
 2913 003a 0E34     		add	r4, r4, #14
 2914 003c 3B1C     		mov	r3, r7
 2915 003e 0E33     		add	r3, r3, #14
 2916 0040 1B88     		ldrh	r3, [r3]
 2917 0042 181C     		mov	r0, r3
 2918 0044 0721     		mov	r1, #7
 2919 0046 FFF7FEFF 		bl	__aeabi_uidivmod
 2920 004a 0B1C     		mov	r3, r1
 2921 004c 2380     		strh	r3, [r4]
1131:../Generated_Code/UTIL0.c ****   if (UTIL0_IsLeapYear(year) && (month==1 || month==2)) {
 2922              		.loc 1 1131 0
 2923 004e BB1D     		add	r3, r7, #6
 2924 0050 1B88     		ldrh	r3, [r3]
 2925 0052 181C     		mov	r0, r3
 2926 0054 FFF7FEFF 		bl	_Z16UTIL0_IsLeapYeart
 2927 0058 031C     		mov	r3, r0
 2928 005a 002B     		cmp	r3, #0
 2929 005c 09D0     		beq	.L113
 2930              		.loc 1 1131 0 is_stmt 0
 2931 005e 7B1D     		add	r3, r7, #5
 2932 0060 1B78     		ldrb	r3, [r3]
 2933 0062 012B     		cmp	r3, #1
 2934 0064 03D0     		beq	.L114
 2935              		.loc 1 1131 0
 2936 0066 7B1D     		add	r3, r7, #5
 2937 0068 1B78     		ldrb	r3, [r3]
 2938 006a 022B     		cmp	r3, #2
 2939 006c 01D1     		bne	.L113
 2940              	.L114:
 2941              		.loc 1 1131 0
 2942 006e 0123     		mov	r3, #1
 2943 0070 00E0     		b	.L115
 2944              	.L113:
 2945              		.loc 1 1131 0
 2946 0072 0023     		mov	r3, #0
 2947              	.L115:
 2948              		.loc 1 1131 0
 2949 0074 002B     		cmp	r3, #0
 2950 0076 06D0     		beq	.L116
1132:../Generated_Code/UTIL0.c ****     sum--;
 2951              		.loc 1 1132 0 is_stmt 1
 2952 0078 3B1C     		mov	r3, r7
 2953 007a 0E33     		add	r3, r3, #14
 2954 007c 3A1C     		mov	r2, r7
 2955 007e 0E32     		add	r2, r2, #14
 2956 0080 1288     		ldrh	r2, [r2]
 2957 0082 013A     		sub	r2, r2, #1
 2958 0084 1A80     		strh	r2, [r3]
 2959              	.L116:
1133:../Generated_Code/UTIL0.c ****   }
1134:../Generated_Code/UTIL0.c ****   sum += day;
 2960              		.loc 1 1134 0
 2961 0086 3B1D     		add	r3, r7, #4
 2962 0088 1B78     		ldrb	r3, [r3]
 2963 008a 99B2     		uxth	r1, r3
 2964 008c 3B1C     		mov	r3, r7
 2965 008e 0E33     		add	r3, r3, #14
 2966 0090 3A1C     		mov	r2, r7
 2967 0092 0E32     		add	r2, r2, #14
 2968 0094 1288     		ldrh	r2, [r2]
 2969 0096 8A18     		add	r2, r1, r2
 2970 0098 1A80     		strh	r2, [r3]
1135:../Generated_Code/UTIL0.c ****   sum %= 7;
 2971              		.loc 1 1135 0
 2972 009a 3C1C     		mov	r4, r7
 2973 009c 0E34     		add	r4, r4, #14
 2974 009e 3B1C     		mov	r3, r7
 2975 00a0 0E33     		add	r3, r3, #14
 2976 00a2 1B88     		ldrh	r3, [r3]
 2977 00a4 181C     		mov	r0, r3
 2978 00a6 0721     		mov	r1, #7
 2979 00a8 FFF7FEFF 		bl	__aeabi_uidivmod
 2980 00ac 0B1C     		mov	r3, r1
 2981 00ae 2380     		strh	r3, [r4]
1136:../Generated_Code/UTIL0.c ****   sum += skew[month-1];
 2982              		.loc 1 1136 0
 2983 00b0 7B1D     		add	r3, r7, #5
 2984 00b2 1B78     		ldrb	r3, [r3]
 2985 00b4 013B     		sub	r3, r3, #1
 2986 00b6 0F4A     		ldr	r2, .L118+4
 2987 00b8 D35C     		ldrb	r3, [r2, r3]
 2988 00ba 191C     		mov	r1, r3
 2989 00bc 3B1C     		mov	r3, r7
 2990 00be 0E33     		add	r3, r3, #14
 2991 00c0 3A1C     		mov	r2, r7
 2992 00c2 0E32     		add	r2, r2, #14
 2993 00c4 1288     		ldrh	r2, [r2]
 2994 00c6 8A18     		add	r2, r1, r2
 2995 00c8 1A80     		strh	r2, [r3]
1137:../Generated_Code/UTIL0.c ****   sum %= 7;
 2996              		.loc 1 1137 0
 2997 00ca 3C1C     		mov	r4, r7
 2998 00cc 0E34     		add	r4, r4, #14
 2999 00ce 3B1C     		mov	r3, r7
 3000 00d0 0E33     		add	r3, r3, #14
 3001 00d2 1B88     		ldrh	r3, [r3]
 3002 00d4 181C     		mov	r0, r3
 3003 00d6 0721     		mov	r1, #7
 3004 00d8 FFF7FEFF 		bl	__aeabi_uidivmod
 3005 00dc 0B1C     		mov	r3, r1
 3006 00de 2380     		strh	r3, [r4]
1138:../Generated_Code/UTIL0.c ****   return (byte)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
 3007              		.loc 1 1138 0
 3008 00e0 3B1C     		mov	r3, r7
 3009 00e2 0E33     		add	r3, r3, #14
 3010 00e4 1B88     		ldrh	r3, [r3]
 3011 00e6 DBB2     		uxtb	r3, r3
 3012              	.LBE21:
1139:../Generated_Code/UTIL0.c **** }
 3013              		.loc 1 1139 0
 3014 00e8 181C     		mov	r0, r3
 3015 00ea BD46     		mov	sp, r7
 3016 00ec 05B0     		add	sp, sp, #20
 3017              		@ sp needed for prologue
 3018 00ee 90BD     		pop	{r4, r7, pc}
 3019              	.L119:
 3020              		.align	2
 3021              	.L118:
 3022 00f0 94F8FFFF 		.word	-1900
 3023 00f4 00000000 		.word	_ZZ13UTIL0_WeekDaythhE4skew
 3024              		.cfi_endproc
 3025              	.LFE34:
 3027              		.section	.rodata
 3028              		.align	2
 3029              	.LC5:
 3030 0014 00       		.ascii	"\000"
 3031 0015 000000   		.section	.text._Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc,"ax",%progbits
 3032              		.align	2
 3033              		.global	_Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc
 3034              		.code	16
 3035              		.thumb_func
 3037              	_Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc:
 3038              	.LFB35:
1140:../Generated_Code/UTIL0.c **** 
1141:../Generated_Code/UTIL0.c **** /*
1142:../Generated_Code/UTIL0.c **** ** ===================================================================
1143:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ReadEscapedName (component Utility)
1144:../Generated_Code/UTIL0.c **** **     Description :
1145:../Generated_Code/UTIL0.c **** **         Scans an escaped name from a string. This is useful e.g. for
1146:../Generated_Code/UTIL0.c **** **         double quoted file names.
1147:../Generated_Code/UTIL0.c **** **     Parameters  :
1148:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1149:../Generated_Code/UTIL0.c **** **       * filename        - the name to be copied. Names may
1150:../Generated_Code/UTIL0.c **** **                           be in quoted format
1151:../Generated_Code/UTIL0.c **** **       * destname        - the destination of the copy.
1152:../Generated_Code/UTIL0.c **** **                           Names are not in quoted format. destname
1153:../Generated_Code/UTIL0.c **** **                           may be NULL to get the other return values
1154:../Generated_Code/UTIL0.c **** **                           only
1155:../Generated_Code/UTIL0.c **** **         maxlen          - length allocated for destname
1156:../Generated_Code/UTIL0.c **** **       * lenRead         - length read in filename to copy
1157:../Generated_Code/UTIL0.c **** **                           the whole name. Note that filenames maybe
1158:../Generated_Code/UTIL0.c **** **                           space terminated, so *lenRead <
1159:../Generated_Code/UTIL0.c **** **                           strlen(filename)
1160:../Generated_Code/UTIL0.c **** **         lenWritten      - the size written in destname.
1161:../Generated_Code/UTIL0.c **** **                           In case of overflows in destname,
1162:../Generated_Code/UTIL0.c **** **                           lenWritten is still increased but destname
1163:../Generated_Code/UTIL0.c **** **                           no longer written. The have the string
1164:../Generated_Code/UTIL0.c **** **                           length in these cases use strlen(destname)
1165:../Generated_Code/UTIL0.c **** **         terminators     - additional characters
1166:../Generated_Code/UTIL0.c **** **                           where a name should terminate. May be NULL
1167:../Generated_Code/UTIL0.c **** **     Returns     :
1168:../Generated_Code/UTIL0.c **** **         ---             - Error code
1169:../Generated_Code/UTIL0.c **** ** ===================================================================
1170:../Generated_Code/UTIL0.c **** */
1171:../Generated_Code/UTIL0.c **** byte UTIL0_ReadEscapedName(const unsigned char *filename, byte *destname, size_t maxlen, size_t *le
1172:../Generated_Code/UTIL0.c **** {
 3039              		.loc 1 1172 0
 3040              		.cfi_startproc
 3041 0000 80B5     		push	{r7, lr}
 3042              	.LCFI90:
 3043              		.cfi_def_cfa_offset 8
 3044              		.cfi_offset 7, -8
 3045              		.cfi_offset 14, -4
 3046 0002 88B0     		sub	sp, sp, #32
 3047              	.LCFI91:
 3048              		.cfi_def_cfa_offset 40
 3049 0004 00AF     		add	r7, sp, #0
 3050              	.LCFI92:
 3051              		.cfi_def_cfa_register 7
 3052 0006 F860     		str	r0, [r7, #12]
 3053 0008 B960     		str	r1, [r7, #8]
 3054 000a 7A60     		str	r2, [r7, #4]
 3055 000c 3B60     		str	r3, [r7]
 3056              	.LBB22:
1173:../Generated_Code/UTIL0.c ****   size_t lenCopied = 0, lenOverread = 0;
 3057              		.loc 1 1173 0
 3058 000e 0023     		mov	r3, #0
 3059 0010 FB61     		str	r3, [r7, #28]
 3060 0012 0023     		mov	r3, #0
 3061 0014 BB61     		str	r3, [r7, #24]
1174:../Generated_Code/UTIL0.c ****   bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a sec
 3062              		.loc 1 1174 0
 3063 0016 3B1C     		mov	r3, r7
 3064 0018 1733     		add	r3, r3, #23
 3065 001a 0022     		mov	r2, #0
 3066 001c 1A70     		strb	r2, [r3]
1175:../Generated_Code/UTIL0.c ****                               terminates the string. In !quoteMode a space or a '\0' may also termi
1176:../Generated_Code/UTIL0.c ****   bool res = ERR_OK;
 3067              		.loc 1 1176 0
 3068 001e 3B1C     		mov	r3, r7
 3069 0020 1633     		add	r3, r3, #22
 3070 0022 0022     		mov	r2, #0
 3071 0024 1A70     		strb	r2, [r3]
1177:../Generated_Code/UTIL0.c ****   #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')
1178:../Generated_Code/UTIL0.c **** 
1179:../Generated_Code/UTIL0.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
 3072              		.loc 1 1179 0
 3073 0026 FB68     		ldr	r3, [r7, #12]
 3074 0028 002B     		cmp	r3, #0
 3075 002a 05D0     		beq	.L121
 3076              		.loc 1 1179 0 is_stmt 0
 3077 002c BB68     		ldr	r3, [r7, #8]
 3078 002e 002B     		cmp	r3, #0
 3079 0030 04D0     		beq	.L122
 3080              		.loc 1 1179 0
 3081 0032 7B68     		ldr	r3, [r7, #4]
 3082 0034 002B     		cmp	r3, #0
 3083 0036 01D1     		bne	.L122
 3084              	.L121:
1180:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 3085              		.loc 1 1180 0 is_stmt 1
 3086 0038 1B23     		mov	r3, #27
 3087 003a 90E0     		b	.L123
 3088              	.L122:
1181:../Generated_Code/UTIL0.c ****   }
1182:../Generated_Code/UTIL0.c ****   if (filename[0] == '"') { /* translated mode */
 3089              		.loc 1 1182 0
 3090 003c FB68     		ldr	r3, [r7, #12]
 3091 003e 1B78     		ldrb	r3, [r3]
 3092 0040 222B     		cmp	r3, #34
 3093 0042 09D1     		bne	.L124
1183:../Generated_Code/UTIL0.c ****     filename++; /* overread '"' */
 3094              		.loc 1 1183 0
 3095 0044 FB68     		ldr	r3, [r7, #12]
 3096 0046 0133     		add	r3, r3, #1
 3097 0048 FB60     		str	r3, [r7, #12]
1184:../Generated_Code/UTIL0.c ****     lenOverread++;
 3098              		.loc 1 1184 0
 3099 004a BB69     		ldr	r3, [r7, #24]
 3100 004c 0133     		add	r3, r3, #1
 3101 004e BB61     		str	r3, [r7, #24]
1185:../Generated_Code/UTIL0.c ****     quoteMode=TRUE;
 3102              		.loc 1 1185 0
 3103 0050 3B1C     		mov	r3, r7
 3104 0052 1733     		add	r3, r3, #23
 3105 0054 0122     		mov	r2, #1
 3106 0056 1A70     		strb	r2, [r3]
 3107              	.L124:
1186:../Generated_Code/UTIL0.c ****   }
1187:../Generated_Code/UTIL0.c ****   if (terminators == NULL) {
 3108              		.loc 1 1187 0
 3109 0058 FB6A     		ldr	r3, [r7, #44]
 3110 005a 002B     		cmp	r3, #0
 3111 005c 01D1     		bne	.L125
1188:../Generated_Code/UTIL0.c ****     terminators = "";
 3112              		.loc 1 1188 0
 3113 005e 424B     		ldr	r3, .L140
 3114 0060 FB62     		str	r3, [r7, #44]
 3115              	.L125:
1189:../Generated_Code/UTIL0.c ****   }
1190:../Generated_Code/UTIL0.c ****   for (;;) {
1191:../Generated_Code/UTIL0.c ****     if (quoteMode) {
 3116              		.loc 1 1191 0
 3117 0062 3B1C     		mov	r3, r7
 3118 0064 1733     		add	r3, r3, #23
 3119 0066 1B78     		ldrb	r3, [r3]
 3120 0068 002B     		cmp	r3, #0
 3121 006a 16D0     		beq	.L126
1192:../Generated_Code/UTIL0.c ****       if (filename[0] == '"') {
 3122              		.loc 1 1192 0
 3123 006c FB68     		ldr	r3, [r7, #12]
 3124 006e 1B78     		ldrb	r3, [r3]
 3125 0070 222B     		cmp	r3, #34
 3126 0072 09D1     		bne	.L127
1193:../Generated_Code/UTIL0.c ****         filename++; /* overread '"' */
 3127              		.loc 1 1193 0
 3128 0074 FB68     		ldr	r3, [r7, #12]
 3129 0076 0133     		add	r3, r3, #1
 3130 0078 FB60     		str	r3, [r7, #12]
1194:../Generated_Code/UTIL0.c ****         lenOverread++;
 3131              		.loc 1 1194 0
 3132 007a BB69     		ldr	r3, [r7, #24]
 3133 007c 0133     		add	r3, r3, #1
 3134 007e BB61     		str	r3, [r7, #24]
1195:../Generated_Code/UTIL0.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
 3135              		.loc 1 1195 0
 3136 0080 FB68     		ldr	r3, [r7, #12]
 3137 0082 1B78     		ldrb	r3, [r3]
 3138 0084 222B     		cmp	r3, #34
 3139 0086 4FD1     		bne	.L138
 3140              	.L127:
1196:../Generated_Code/UTIL0.c ****           break; /* successfully finished with this name */
1197:../Generated_Code/UTIL0.c ****         } /* else we copy the second quote " */
1198:../Generated_Code/UTIL0.c ****       }
1199:../Generated_Code/UTIL0.c ****       if (filename[0] == '\0') { /* unexpected 0. stop */
 3141              		.loc 1 1199 0
 3142 0088 FB68     		ldr	r3, [r7, #12]
 3143 008a 1B78     		ldrb	r3, [r3]
 3144 008c 002B     		cmp	r3, #0
 3145 008e 2FD1     		bne	.L129
1200:../Generated_Code/UTIL0.c ****         res = ERR_FAILED;
 3146              		.loc 1 1200 0
 3147 0090 3B1C     		mov	r3, r7
 3148 0092 1633     		add	r3, r3, #22
 3149 0094 0122     		mov	r2, #1
 3150 0096 1A70     		strb	r2, [r3]
1201:../Generated_Code/UTIL0.c ****         break; /* error case: no terminating double quote (") was found */
 3151              		.loc 1 1201 0
 3152 0098 49E0     		b	.L128
 3153              	.L126:
1202:../Generated_Code/UTIL0.c ****       }
1203:../Generated_Code/UTIL0.c ****     } else { /* copy mode */
1204:../Generated_Code/UTIL0.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 3154              		.loc 1 1204 0
 3155 009a FB68     		ldr	r3, [r7, #12]
 3156 009c 1B78     		ldrb	r3, [r3]
 3157 009e 202B     		cmp	r3, #32
 3158 00a0 21D0     		beq	.L130
 3159              		.loc 1 1204 0 is_stmt 0
 3160 00a2 FB68     		ldr	r3, [r7, #12]
 3161 00a4 1B78     		ldrb	r3, [r3]
 3162 00a6 092B     		cmp	r3, #9
 3163 00a8 1DD0     		beq	.L130
 3164              		.loc 1 1204 0
 3165 00aa FB68     		ldr	r3, [r7, #12]
 3166 00ac 1B78     		ldrb	r3, [r3]
 3167 00ae 0A2B     		cmp	r3, #10
 3168 00b0 19D0     		beq	.L130
 3169              		.loc 1 1204 0
 3170 00b2 FB68     		ldr	r3, [r7, #12]
 3171 00b4 1B78     		ldrb	r3, [r3]
 3172 00b6 0B2B     		cmp	r3, #11
 3173 00b8 15D0     		beq	.L130
 3174              		.loc 1 1204 0
 3175 00ba FB68     		ldr	r3, [r7, #12]
 3176 00bc 1B78     		ldrb	r3, [r3]
 3177 00be 0C2B     		cmp	r3, #12
 3178 00c0 11D0     		beq	.L130
 3179              		.loc 1 1204 0
 3180 00c2 FB68     		ldr	r3, [r7, #12]
 3181 00c4 1B78     		ldrb	r3, [r3]
 3182 00c6 0D2B     		cmp	r3, #13
 3183 00c8 0DD0     		beq	.L130
 3184              		.loc 1 1204 0
 3185 00ca FB68     		ldr	r3, [r7, #12]
 3186 00cc 1B78     		ldrb	r3, [r3]
 3187 00ce 002B     		cmp	r3, #0
 3188 00d0 09D0     		beq	.L130
 3189              		.loc 1 1204 0
 3190 00d2 FB68     		ldr	r3, [r7, #12]
 3191 00d4 1B78     		ldrb	r3, [r3]
 3192 00d6 FA6A     		ldr	r2, [r7, #44]
 3193 00d8 101C     		mov	r0, r2
 3194 00da 191C     		mov	r1, r3
 3195 00dc FFF7FEFF 		bl	strchr
 3196 00e0 031C     		mov	r3, r0
 3197 00e2 002B     		cmp	r3, #0
 3198 00e4 01D0     		beq	.L131
 3199              	.L130:
 3200              		.loc 1 1204 0
 3201 00e6 0123     		mov	r3, #1
 3202 00e8 00E0     		b	.L132
 3203              	.L131:
 3204              		.loc 1 1204 0
 3205 00ea 0023     		mov	r3, #0
 3206              	.L132:
 3207              		.loc 1 1204 0
 3208 00ec 002B     		cmp	r3, #0
 3209 00ee 1DD1     		bne	.L139
 3210              	.L129:
1205:../Generated_Code/UTIL0.c ****         break;
1206:../Generated_Code/UTIL0.c ****       }
1207:../Generated_Code/UTIL0.c ****     }
1208:../Generated_Code/UTIL0.c ****     if (destname != NULL) {
 3211              		.loc 1 1208 0 is_stmt 1
 3212 00f0 BB68     		ldr	r3, [r7, #8]
 3213 00f2 002B     		cmp	r3, #0
 3214 00f4 11D0     		beq	.L133
1209:../Generated_Code/UTIL0.c ****       if (lenCopied + 1 < maxlen) {
 3215              		.loc 1 1209 0
 3216 00f6 FB69     		ldr	r3, [r7, #28]
 3217 00f8 5A1C     		add	r2, r3, #1
 3218 00fa 7B68     		ldr	r3, [r7, #4]
 3219 00fc 9A42     		cmp	r2, r3
 3220 00fe 07D2     		bcs	.L134
1210:../Generated_Code/UTIL0.c ****         destname[0] = filename[0];
 3221              		.loc 1 1210 0
 3222 0100 FB68     		ldr	r3, [r7, #12]
 3223 0102 1A78     		ldrb	r2, [r3]
 3224 0104 BB68     		ldr	r3, [r7, #8]
 3225 0106 1A70     		strb	r2, [r3]
1211:../Generated_Code/UTIL0.c ****         destname++;
 3226              		.loc 1 1211 0
 3227 0108 BB68     		ldr	r3, [r7, #8]
 3228 010a 0133     		add	r3, r3, #1
 3229 010c BB60     		str	r3, [r7, #8]
 3230 010e 04E0     		b	.L133
 3231              	.L134:
1212:../Generated_Code/UTIL0.c ****       } else {
1213:../Generated_Code/UTIL0.c ****         destname[0] = '\0'; /* terminate string */
 3232              		.loc 1 1213 0
 3233 0110 BB68     		ldr	r3, [r7, #8]
 3234 0112 0022     		mov	r2, #0
 3235 0114 1A70     		strb	r2, [r3]
1214:../Generated_Code/UTIL0.c ****         destname = NULL; /* avoid it to overwrite not allocated space */
 3236              		.loc 1 1214 0
 3237 0116 0023     		mov	r3, #0
 3238 0118 BB60     		str	r3, [r7, #8]
 3239              	.L133:
1215:../Generated_Code/UTIL0.c ****       }
1216:../Generated_Code/UTIL0.c ****     }
1217:../Generated_Code/UTIL0.c ****     lenCopied++;
 3240              		.loc 1 1217 0
 3241 011a FB69     		ldr	r3, [r7, #28]
 3242 011c 0133     		add	r3, r3, #1
 3243 011e FB61     		str	r3, [r7, #28]
1218:../Generated_Code/UTIL0.c ****     filename++;
 3244              		.loc 1 1218 0
 3245 0120 FB68     		ldr	r3, [r7, #12]
 3246 0122 0133     		add	r3, r3, #1
 3247 0124 FB60     		str	r3, [r7, #12]
1190:../Generated_Code/UTIL0.c ****   for (;;) {
 3248              		.loc 1 1190 0
 3249 0126 9CE7     		b	.L125
 3250              	.L138:
1196:../Generated_Code/UTIL0.c ****           break; /* successfully finished with this name */
 3251              		.loc 1 1196 0
 3252 0128 C046     		mov	r8, r8
 3253 012a 00E0     		b	.L128
 3254              	.L139:
1205:../Generated_Code/UTIL0.c ****         break;
 3255              		.loc 1 1205 0
 3256 012c C046     		mov	r8, r8
 3257              	.L128:
1219:../Generated_Code/UTIL0.c ****   }
1220:../Generated_Code/UTIL0.c ****   if (destname != NULL) {
 3258              		.loc 1 1220 0
 3259 012e BB68     		ldr	r3, [r7, #8]
 3260 0130 002B     		cmp	r3, #0
 3261 0132 02D0     		beq	.L135
1221:../Generated_Code/UTIL0.c ****     destname[0] = '\0';
 3262              		.loc 1 1221 0
 3263 0134 BB68     		ldr	r3, [r7, #8]
 3264 0136 0022     		mov	r2, #0
 3265 0138 1A70     		strb	r2, [r3]
 3266              	.L135:
1222:../Generated_Code/UTIL0.c ****   }
1223:../Generated_Code/UTIL0.c ****   if (lenRead != NULL) {
 3267              		.loc 1 1223 0
 3268 013a 3B68     		ldr	r3, [r7]
 3269 013c 002B     		cmp	r3, #0
 3270 013e 04D0     		beq	.L136
1224:../Generated_Code/UTIL0.c ****     *lenRead = lenCopied+lenOverread;
 3271              		.loc 1 1224 0
 3272 0140 FA69     		ldr	r2, [r7, #28]
 3273 0142 BB69     		ldr	r3, [r7, #24]
 3274 0144 D218     		add	r2, r2, r3
 3275 0146 3B68     		ldr	r3, [r7]
 3276 0148 1A60     		str	r2, [r3]
 3277              	.L136:
1225:../Generated_Code/UTIL0.c ****   }
1226:../Generated_Code/UTIL0.c ****   if (lenWritten != NULL) {
 3278              		.loc 1 1226 0
 3279 014a BB6A     		ldr	r3, [r7, #40]
 3280 014c 002B     		cmp	r3, #0
 3281 014e 03D0     		beq	.L137
1227:../Generated_Code/UTIL0.c ****     *lenWritten = lenCopied + 1; /* additionally a zero byte written */
 3282              		.loc 1 1227 0
 3283 0150 FB69     		ldr	r3, [r7, #28]
 3284 0152 5A1C     		add	r2, r3, #1
 3285 0154 BB6A     		ldr	r3, [r7, #40]
 3286 0156 1A60     		str	r2, [r3]
 3287              	.L137:
1228:../Generated_Code/UTIL0.c ****   }
1229:../Generated_Code/UTIL0.c ****   return res;
 3288              		.loc 1 1229 0
 3289 0158 3B1C     		mov	r3, r7
 3290 015a 1633     		add	r3, r3, #22
 3291 015c 1B78     		ldrb	r3, [r3]
 3292              	.L123:
 3293              	.LBE22:
1230:../Generated_Code/UTIL0.c **** }
 3294              		.loc 1 1230 0
 3295 015e 181C     		mov	r0, r3
 3296 0160 BD46     		mov	sp, r7
 3297 0162 08B0     		add	sp, sp, #32
 3298              		@ sp needed for prologue
 3299 0164 80BD     		pop	{r7, pc}
 3300              	.L141:
 3301 0166 C046     		.align	2
 3302              	.L140:
 3303 0168 14000000 		.word	.LC5
 3304              		.cfi_endproc
 3305              	.LFE35:
 3307              		.section	.text._Z11UTIL0_xatoiPPKhPl,"ax",%progbits
 3308              		.align	2
 3309              		.global	_Z11UTIL0_xatoiPPKhPl
 3310              		.code	16
 3311              		.thumb_func
 3313              	_Z11UTIL0_xatoiPPKhPl:
 3314              	.LFB36:
1231:../Generated_Code/UTIL0.c **** 
1232:../Generated_Code/UTIL0.c **** /*
1233:../Generated_Code/UTIL0.c **** ** ===================================================================
1234:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_xatoi (component Utility)
1235:../Generated_Code/UTIL0.c **** **     Description :
1236:../Generated_Code/UTIL0.c **** **         Custom atoi() (ascii to int) implementation by Elm Chan
1237:../Generated_Code/UTIL0.c **** **     Parameters  :
1238:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1239:../Generated_Code/UTIL0.c **** **       * str             - Pointer to string to scan. Returns until
1240:../Generated_Code/UTIL0.c **** **                           where it has scanned.
1241:../Generated_Code/UTIL0.c **** **       * res             - Pointer to where to store the result
1242:../Generated_Code/UTIL0.c **** **     Returns     :
1243:../Generated_Code/UTIL0.c **** **         ---             - Error code
1244:../Generated_Code/UTIL0.c **** ** ===================================================================
1245:../Generated_Code/UTIL0.c **** */
1246:../Generated_Code/UTIL0.c **** /*------------------------------------------------------------------------/
1247:../Generated_Code/UTIL0.c **** /  Universal string handler for user console interface
1248:../Generated_Code/UTIL0.c **** /-------------------------------------------------------------------------/
1249:../Generated_Code/UTIL0.c **** /
1250:../Generated_Code/UTIL0.c **** /  Copyright (C) 2010, ChaN, all right reserved.
1251:../Generated_Code/UTIL0.c **** /
1252:../Generated_Code/UTIL0.c **** / * This software is a free software and there is NO WARRANTY.
1253:../Generated_Code/UTIL0.c **** / * No restriction on use. You can use, modify and redistribute it for
1254:../Generated_Code/UTIL0.c **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
1255:../Generated_Code/UTIL0.c **** / * Redistributions of source code must retain the above copyright notice.
1256:../Generated_Code/UTIL0.c **** /
1257:../Generated_Code/UTIL0.c **** /-------------------------------------------------------------------------*/
1258:../Generated_Code/UTIL0.c **** #ifdef __HC12__
1259:../Generated_Code/UTIL0.c ****   #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
1260:../Generated_Code/UTIL0.c **** #endif
1261:../Generated_Code/UTIL0.c **** byte UTIL0_xatoi(const unsigned char **str, int32_t *res)
1262:../Generated_Code/UTIL0.c **** {
 3315              		.loc 1 1262 0
 3316              		.cfi_startproc
 3317 0000 80B5     		push	{r7, lr}
 3318              	.LCFI93:
 3319              		.cfi_def_cfa_offset 8
 3320              		.cfi_offset 7, -8
 3321              		.cfi_offset 14, -4
 3322 0002 84B0     		sub	sp, sp, #16
 3323              	.LCFI94:
 3324              		.cfi_def_cfa_offset 24
 3325 0004 00AF     		add	r7, sp, #0
 3326              	.LCFI95:
 3327              		.cfi_def_cfa_register 7
 3328 0006 7860     		str	r0, [r7, #4]
 3329 0008 3960     		str	r1, [r7]
 3330              	.LBB23:
1263:../Generated_Code/UTIL0.c **** /* 123 -5   0x3ff 0b1111 0377 3.25  w "
1264:../Generated_Code/UTIL0.c ****       ^                               1st call returns 123 and next ptr
1265:../Generated_Code/UTIL0.c ****          ^                            2nd call returns -5 and next ptr
1266:../Generated_Code/UTIL0.c ****                  ^                    3rd call returns 1023 and next ptr
1267:../Generated_Code/UTIL0.c ****                         ^             4th call returns 15 and next ptr
1268:../Generated_Code/UTIL0.c ****                              ^        5th call returns 255 and next ptr
1269:../Generated_Code/UTIL0.c ****                                ^      6th call returns 3 and next ptr, caller needs to read '.'
1270:../Generated_Code/UTIL0.c ****                                  ^    7th call returns 25 and next ptr
1271:../Generated_Code/UTIL0.c ****                                     ^ 8th call fails and returns ERR_FAILED
1272:../Generated_Code/UTIL0.c **** */
1273:../Generated_Code/UTIL0.c ****   uint32_t val;
1274:../Generated_Code/UTIL0.c ****   uint8_t c, r, s = 0;
 3331              		.loc 1 1274 0
 3332 000a 3B1C     		mov	r3, r7
 3333 000c 0933     		add	r3, r3, #9
 3334 000e 0022     		mov	r2, #0
 3335 0010 1A70     		strb	r2, [r3]
1275:../Generated_Code/UTIL0.c **** 
1276:../Generated_Code/UTIL0.c ****   *res = 0;
 3336              		.loc 1 1276 0
 3337 0012 3B68     		ldr	r3, [r7]
 3338 0014 0022     		mov	r2, #0
 3339 0016 1A60     		str	r2, [r3]
1277:../Generated_Code/UTIL0.c ****   while (**str==' ') {
 3340              		.loc 1 1277 0
 3341 0018 04E0     		b	.L143
 3342              	.L144:
1278:../Generated_Code/UTIL0.c ****     (*str)++;                          /* Skip leading spaces */
 3343              		.loc 1 1278 0
 3344 001a 7B68     		ldr	r3, [r7, #4]
 3345 001c 1B68     		ldr	r3, [r3]
 3346 001e 5A1C     		add	r2, r3, #1
 3347 0020 7B68     		ldr	r3, [r7, #4]
 3348 0022 1A60     		str	r2, [r3]
 3349              	.L143:
1277:../Generated_Code/UTIL0.c ****   while (**str==' ') {
 3350              		.loc 1 1277 0
 3351 0024 7B68     		ldr	r3, [r7, #4]
 3352 0026 1B68     		ldr	r3, [r3]
 3353 0028 1B78     		ldrb	r3, [r3]
 3354 002a 203B     		sub	r3, r3, #32
 3355 002c 5A42     		neg	r2, r3
 3356 002e 5341     		adc	r3, r3, r2
 3357 0030 DBB2     		uxtb	r3, r3
 3358 0032 002B     		cmp	r3, #0
 3359 0034 F1D1     		bne	.L144
1279:../Generated_Code/UTIL0.c ****   }
1280:../Generated_Code/UTIL0.c ****   c = **str;
 3360              		.loc 1 1280 0
 3361 0036 7B68     		ldr	r3, [r7, #4]
 3362 0038 1A68     		ldr	r2, [r3]
 3363 003a 3B1C     		mov	r3, r7
 3364 003c 0B33     		add	r3, r3, #11
 3365 003e 1278     		ldrb	r2, [r2]
 3366 0040 1A70     		strb	r2, [r3]
1281:../Generated_Code/UTIL0.c ****   if (c == '-') {                      /* negative? */
 3367              		.loc 1 1281 0
 3368 0042 3B1C     		mov	r3, r7
 3369 0044 0B33     		add	r3, r3, #11
 3370 0046 1B78     		ldrb	r3, [r3]
 3371 0048 2D2B     		cmp	r3, #45
 3372 004a 0ED1     		bne	.L145
1282:../Generated_Code/UTIL0.c ****     s = 1;
 3373              		.loc 1 1282 0
 3374 004c 3B1C     		mov	r3, r7
 3375 004e 0933     		add	r3, r3, #9
 3376 0050 0122     		mov	r2, #1
 3377 0052 1A70     		strb	r2, [r3]
1283:../Generated_Code/UTIL0.c ****     c = *(++(*str));
 3378              		.loc 1 1283 0
 3379 0054 7B68     		ldr	r3, [r7, #4]
 3380 0056 1B68     		ldr	r3, [r3]
 3381 0058 5A1C     		add	r2, r3, #1
 3382 005a 7B68     		ldr	r3, [r7, #4]
 3383 005c 1A60     		str	r2, [r3]
 3384 005e 7B68     		ldr	r3, [r7, #4]
 3385 0060 1A68     		ldr	r2, [r3]
 3386 0062 3B1C     		mov	r3, r7
 3387 0064 0B33     		add	r3, r3, #11
 3388 0066 1278     		ldrb	r2, [r2]
 3389 0068 1A70     		strb	r2, [r3]
 3390              	.L145:
1284:../Generated_Code/UTIL0.c ****   }
1285:../Generated_Code/UTIL0.c ****   if (c == '0') {
 3391              		.loc 1 1285 0
 3392 006a 3B1C     		mov	r3, r7
 3393 006c 0B33     		add	r3, r3, #11
 3394 006e 1B78     		ldrb	r3, [r3]
 3395 0070 302B     		cmp	r3, #48
 3396 0072 4FD1     		bne	.L146
1286:../Generated_Code/UTIL0.c ****     c = *(++(*str));
 3397              		.loc 1 1286 0
 3398 0074 7B68     		ldr	r3, [r7, #4]
 3399 0076 1B68     		ldr	r3, [r3]
 3400 0078 5A1C     		add	r2, r3, #1
 3401 007a 7B68     		ldr	r3, [r7, #4]
 3402 007c 1A60     		str	r2, [r3]
 3403 007e 7B68     		ldr	r3, [r7, #4]
 3404 0080 1A68     		ldr	r2, [r3]
 3405 0082 3B1C     		mov	r3, r7
 3406 0084 0B33     		add	r3, r3, #11
 3407 0086 1278     		ldrb	r2, [r2]
 3408 0088 1A70     		strb	r2, [r3]
1287:../Generated_Code/UTIL0.c ****     switch (c) {
 3409              		.loc 1 1287 0
 3410 008a 3B1C     		mov	r3, r7
 3411 008c 0B33     		add	r3, r3, #11
 3412 008e 1B78     		ldrb	r3, [r3]
 3413 0090 622B     		cmp	r3, #98
 3414 0092 11D0     		beq	.L148
 3415 0094 782B     		cmp	r3, #120
 3416 0096 20D1     		bne	.L167
 3417              	.L149:
1288:../Generated_Code/UTIL0.c ****       case 'x':                        /* hexadecimal */
1289:../Generated_Code/UTIL0.c ****         r = 16; c = *(++(*str));
 3418              		.loc 1 1289 0
 3419 0098 3B1C     		mov	r3, r7
 3420 009a 0A33     		add	r3, r3, #10
 3421 009c 1022     		mov	r2, #16
 3422 009e 1A70     		strb	r2, [r3]
 3423 00a0 7B68     		ldr	r3, [r7, #4]
 3424 00a2 1B68     		ldr	r3, [r3]
 3425 00a4 5A1C     		add	r2, r3, #1
 3426 00a6 7B68     		ldr	r3, [r7, #4]
 3427 00a8 1A60     		str	r2, [r3]
 3428 00aa 7B68     		ldr	r3, [r7, #4]
 3429 00ac 1A68     		ldr	r2, [r3]
 3430 00ae 3B1C     		mov	r3, r7
 3431 00b0 0B33     		add	r3, r3, #11
 3432 00b2 1278     		ldrb	r2, [r2]
 3433 00b4 1A70     		strb	r2, [r3]
1290:../Generated_Code/UTIL0.c ****         break;
 3434              		.loc 1 1290 0
 3435 00b6 3DE0     		b	.L156
 3436              	.L148:
1291:../Generated_Code/UTIL0.c ****       case 'b':                        /* binary */
1292:../Generated_Code/UTIL0.c ****         r = 2; c = *(++(*str));
 3437              		.loc 1 1292 0
 3438 00b8 3B1C     		mov	r3, r7
 3439 00ba 0A33     		add	r3, r3, #10
 3440 00bc 0222     		mov	r2, #2
 3441 00be 1A70     		strb	r2, [r3]
 3442 00c0 7B68     		ldr	r3, [r7, #4]
 3443 00c2 1B68     		ldr	r3, [r3]
 3444 00c4 5A1C     		add	r2, r3, #1
 3445 00c6 7B68     		ldr	r3, [r7, #4]
 3446 00c8 1A60     		str	r2, [r3]
 3447 00ca 7B68     		ldr	r3, [r7, #4]
 3448 00cc 1A68     		ldr	r2, [r3]
 3449 00ce 3B1C     		mov	r3, r7
 3450 00d0 0B33     		add	r3, r3, #11
 3451 00d2 1278     		ldrb	r2, [r2]
 3452 00d4 1A70     		strb	r2, [r3]
1293:../Generated_Code/UTIL0.c ****         break;
 3453              		.loc 1 1293 0
 3454 00d6 C046     		mov	r8, r8
 3455 00d8 2CE0     		b	.L156
 3456              	.L167:
1294:../Generated_Code/UTIL0.c ****       default:
1295:../Generated_Code/UTIL0.c ****         if (c <= ' ' || c == '.') {
 3457              		.loc 1 1295 0
 3458 00da 3B1C     		mov	r3, r7
 3459 00dc 0B33     		add	r3, r3, #11
 3460 00de 1B78     		ldrb	r3, [r3]
 3461 00e0 202B     		cmp	r3, #32
 3462 00e2 04D9     		bls	.L151
 3463              		.loc 1 1295 0 is_stmt 0
 3464 00e4 3B1C     		mov	r3, r7
 3465 00e6 0B33     		add	r3, r3, #11
 3466 00e8 1B78     		ldrb	r3, [r3]
 3467 00ea 2E2B     		cmp	r3, #46
 3468 00ec 01D1     		bne	.L152
 3469              	.L151:
1296:../Generated_Code/UTIL0.c ****           return ERR_OK;               /* single zero */
 3470              		.loc 1 1296 0 is_stmt 1
 3471 00ee 0023     		mov	r3, #0
 3472 00f0 83E0     		b	.L153
 3473              	.L152:
1297:../Generated_Code/UTIL0.c ****         }
1298:../Generated_Code/UTIL0.c ****         if (c < '0' || c > '9') {
 3474              		.loc 1 1298 0
 3475 00f2 3B1C     		mov	r3, r7
 3476 00f4 0B33     		add	r3, r3, #11
 3477 00f6 1B78     		ldrb	r3, [r3]
 3478 00f8 2F2B     		cmp	r3, #47
 3479 00fa 04D9     		bls	.L154
 3480              		.loc 1 1298 0 is_stmt 0
 3481 00fc 3B1C     		mov	r3, r7
 3482 00fe 0B33     		add	r3, r3, #11
 3483 0100 1B78     		ldrb	r3, [r3]
 3484 0102 392B     		cmp	r3, #57
 3485 0104 01D9     		bls	.L155
 3486              	.L154:
1299:../Generated_Code/UTIL0.c ****           return ERR_FAILED;           /* invalid char */
 3487              		.loc 1 1299 0 is_stmt 1
 3488 0106 1B23     		mov	r3, #27
 3489 0108 77E0     		b	.L153
 3490              	.L155:
1300:../Generated_Code/UTIL0.c ****         }
1301:../Generated_Code/UTIL0.c ****         r = 8;                         /* octal */
 3491              		.loc 1 1301 0
 3492 010a 3B1C     		mov	r3, r7
 3493 010c 0A33     		add	r3, r3, #10
 3494 010e 0822     		mov	r2, #8
 3495 0110 1A70     		strb	r2, [r3]
1302:../Generated_Code/UTIL0.c ****         break;
 3496              		.loc 1 1302 0
 3497 0112 0FE0     		b	.L156
 3498              	.L146:
1303:../Generated_Code/UTIL0.c ****     } /* switch */
1304:../Generated_Code/UTIL0.c ****   } else {
1305:../Generated_Code/UTIL0.c ****     if (c < '0' || c > '9') {
 3499              		.loc 1 1305 0
 3500 0114 3B1C     		mov	r3, r7
 3501 0116 0B33     		add	r3, r3, #11
 3502 0118 1B78     		ldrb	r3, [r3]
 3503 011a 2F2B     		cmp	r3, #47
 3504 011c 04D9     		bls	.L157
 3505              		.loc 1 1305 0 is_stmt 0
 3506 011e 3B1C     		mov	r3, r7
 3507 0120 0B33     		add	r3, r3, #11
 3508 0122 1B78     		ldrb	r3, [r3]
 3509 0124 392B     		cmp	r3, #57
 3510 0126 01D9     		bls	.L158
 3511              	.L157:
1306:../Generated_Code/UTIL0.c ****       return ERR_FAILED;               /* EOL or invalid char */
 3512              		.loc 1 1306 0 is_stmt 1
 3513 0128 1B23     		mov	r3, #27
 3514 012a 66E0     		b	.L153
 3515              	.L158:
1307:../Generated_Code/UTIL0.c ****     }
1308:../Generated_Code/UTIL0.c ****     r = 10;                            /* decimal */
 3516              		.loc 1 1308 0
 3517 012c 3B1C     		mov	r3, r7
 3518 012e 0A33     		add	r3, r3, #10
 3519 0130 0A22     		mov	r2, #10
 3520 0132 1A70     		strb	r2, [r3]
 3521              	.L156:
1309:../Generated_Code/UTIL0.c ****   }
1310:../Generated_Code/UTIL0.c ****   val = 0;
 3522              		.loc 1 1310 0
 3523 0134 0023     		mov	r3, #0
 3524 0136 FB60     		str	r3, [r7, #12]
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3525              		.loc 1 1311 0
 3526 0138 44E0     		b	.L159
 3527              	.L165:
1312:../Generated_Code/UTIL0.c ****     if (c >= 'a') c -= 0x20;
 3528              		.loc 1 1312 0
 3529 013a 3B1C     		mov	r3, r7
 3530 013c 0B33     		add	r3, r3, #11
 3531 013e 1B78     		ldrb	r3, [r3]
 3532 0140 602B     		cmp	r3, #96
 3533 0142 06D9     		bls	.L160
 3534              		.loc 1 1312 0 is_stmt 0
 3535 0144 3B1C     		mov	r3, r7
 3536 0146 0B33     		add	r3, r3, #11
 3537 0148 3A1C     		mov	r2, r7
 3538 014a 0B32     		add	r2, r2, #11
 3539 014c 1278     		ldrb	r2, [r2]
 3540 014e 203A     		sub	r2, r2, #32
 3541 0150 1A70     		strb	r2, [r3]
 3542              	.L160:
1313:../Generated_Code/UTIL0.c ****     c -= '0';
 3543              		.loc 1 1313 0 is_stmt 1
 3544 0152 3B1C     		mov	r3, r7
 3545 0154 0B33     		add	r3, r3, #11
 3546 0156 3A1C     		mov	r2, r7
 3547 0158 0B32     		add	r2, r2, #11
 3548 015a 1278     		ldrb	r2, [r2]
 3549 015c 303A     		sub	r2, r2, #48
 3550 015e 1A70     		strb	r2, [r3]
1314:../Generated_Code/UTIL0.c ****     if (c >= 17) {
 3551              		.loc 1 1314 0
 3552 0160 3B1C     		mov	r3, r7
 3553 0162 0B33     		add	r3, r3, #11
 3554 0164 1B78     		ldrb	r3, [r3]
 3555 0166 102B     		cmp	r3, #16
 3556 0168 0DD9     		bls	.L161
1315:../Generated_Code/UTIL0.c ****       c -= 7;
 3557              		.loc 1 1315 0
 3558 016a 3B1C     		mov	r3, r7
 3559 016c 0B33     		add	r3, r3, #11
 3560 016e 3A1C     		mov	r2, r7
 3561 0170 0B32     		add	r2, r2, #11
 3562 0172 1278     		ldrb	r2, [r2]
 3563 0174 073A     		sub	r2, r2, #7
 3564 0176 1A70     		strb	r2, [r3]
1316:../Generated_Code/UTIL0.c ****       if (c <= 9) return ERR_FAILED;   /* invalid char */
 3565              		.loc 1 1316 0
 3566 0178 3B1C     		mov	r3, r7
 3567 017a 0B33     		add	r3, r3, #11
 3568 017c 1B78     		ldrb	r3, [r3]
 3569 017e 092B     		cmp	r3, #9
 3570 0180 01D8     		bhi	.L161
 3571              		.loc 1 1316 0 is_stmt 0
 3572 0182 1B23     		mov	r3, #27
 3573 0184 39E0     		b	.L153
 3574              	.L161:
1317:../Generated_Code/UTIL0.c ****     }
1318:../Generated_Code/UTIL0.c ****     if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
 3575              		.loc 1 1318 0 is_stmt 1
 3576 0186 3A1C     		mov	r2, r7
 3577 0188 0B32     		add	r2, r2, #11
 3578 018a 3B1C     		mov	r3, r7
 3579 018c 0A33     		add	r3, r3, #10
 3580 018e 1278     		ldrb	r2, [r2]
 3581 0190 1B78     		ldrb	r3, [r3]
 3582 0192 9A42     		cmp	r2, r3
 3583 0194 01D3     		bcc	.L162
 3584              		.loc 1 1318 0 is_stmt 0
 3585 0196 1B23     		mov	r3, #27
 3586 0198 2FE0     		b	.L153
 3587              	.L162:
1319:../Generated_Code/UTIL0.c ****     val = val * r + c;
 3588              		.loc 1 1319 0 is_stmt 1
 3589 019a 3B1C     		mov	r3, r7
 3590 019c 0A33     		add	r3, r3, #10
 3591 019e 1B78     		ldrb	r3, [r3]
 3592 01a0 FA68     		ldr	r2, [r7, #12]
 3593 01a2 5A43     		mul	r2, r3
 3594 01a4 3B1C     		mov	r3, r7
 3595 01a6 0B33     		add	r3, r3, #11
 3596 01a8 1B78     		ldrb	r3, [r3]
 3597 01aa D318     		add	r3, r2, r3
 3598 01ac FB60     		str	r3, [r7, #12]
1320:../Generated_Code/UTIL0.c ****     c = *(++(*str));
 3599              		.loc 1 1320 0
 3600 01ae 7B68     		ldr	r3, [r7, #4]
 3601 01b0 1B68     		ldr	r3, [r3]
 3602 01b2 5A1C     		add	r2, r3, #1
 3603 01b4 7B68     		ldr	r3, [r7, #4]
 3604 01b6 1A60     		str	r2, [r3]
 3605 01b8 7B68     		ldr	r3, [r7, #4]
 3606 01ba 1A68     		ldr	r2, [r3]
 3607 01bc 3B1C     		mov	r3, r7
 3608 01be 0B33     		add	r3, r3, #11
 3609 01c0 1278     		ldrb	r2, [r2]
 3610 01c2 1A70     		strb	r2, [r3]
 3611              	.L159:
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3612              		.loc 1 1311 0
 3613 01c4 3B1C     		mov	r3, r7
 3614 01c6 0B33     		add	r3, r3, #11
 3615 01c8 1B78     		ldrb	r3, [r3]
 3616 01ca 202B     		cmp	r3, #32
 3617 01cc 06D9     		bls	.L163
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3618              		.loc 1 1311 0 is_stmt 0
 3619 01ce 3B1C     		mov	r3, r7
 3620 01d0 0B33     		add	r3, r3, #11
 3621 01d2 1B78     		ldrb	r3, [r3]
 3622 01d4 2E2B     		cmp	r3, #46
 3623 01d6 01D0     		beq	.L163
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3624              		.loc 1 1311 0
 3625 01d8 0123     		mov	r3, #1
 3626 01da 00E0     		b	.L164
 3627              	.L163:
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3628              		.loc 1 1311 0
 3629 01dc 0023     		mov	r3, #0
 3630              	.L164:
1311:../Generated_Code/UTIL0.c ****   while (c > ' ' && c != '.') {
 3631              		.loc 1 1311 0
 3632 01de 002B     		cmp	r3, #0
 3633 01e0 ABD1     		bne	.L165
1321:../Generated_Code/UTIL0.c ****   } /* while */
1322:../Generated_Code/UTIL0.c ****   if (s) val = 0 - val;                /* apply sign if needed */
 3634              		.loc 1 1322 0 is_stmt 1
 3635 01e2 3B1C     		mov	r3, r7
 3636 01e4 0933     		add	r3, r3, #9
 3637 01e6 1B78     		ldrb	r3, [r3]
 3638 01e8 002B     		cmp	r3, #0
 3639 01ea 02D0     		beq	.L166
 3640              		.loc 1 1322 0 is_stmt 0
 3641 01ec FB68     		ldr	r3, [r7, #12]
 3642 01ee 5B42     		neg	r3, r3
 3643 01f0 FB60     		str	r3, [r7, #12]
 3644              	.L166:
1323:../Generated_Code/UTIL0.c ****   *res = (long)val;
 3645              		.loc 1 1323 0 is_stmt 1
 3646 01f2 FA68     		ldr	r2, [r7, #12]
 3647 01f4 3B68     		ldr	r3, [r7]
 3648 01f6 1A60     		str	r2, [r3]
1324:../Generated_Code/UTIL0.c ****   return ERR_OK;
 3649              		.loc 1 1324 0
 3650 01f8 0023     		mov	r3, #0
 3651              	.L153:
 3652              	.LBE23:
1325:../Generated_Code/UTIL0.c **** }
 3653              		.loc 1 1325 0
 3654 01fa 181C     		mov	r0, r3
 3655 01fc BD46     		mov	sp, r7
 3656 01fe 04B0     		add	sp, sp, #16
 3657              		@ sp needed for prologue
 3658 0200 80BD     		pop	{r7, pc}
 3659              		.cfi_endproc
 3660              	.LFE36:
 3662 0202 C046     		.section	.text._Z14UTIL0_ScanDatePPKhPhS2_Pt,"ax",%progbits
 3663              		.align	2
 3664              		.global	_Z14UTIL0_ScanDatePPKhPhS2_Pt
 3665              		.code	16
 3666              		.thumb_func
 3668              	_Z14UTIL0_ScanDatePPKhPhS2_Pt:
 3669              	.LFB37:
1326:../Generated_Code/UTIL0.c **** #ifdef __HC12__
1327:../Generated_Code/UTIL0.c ****   #pragma MESSAGE DEFAULT C12056  /* message about SP debug info */
1328:../Generated_Code/UTIL0.c **** #endif
1329:../Generated_Code/UTIL0.c **** 
1330:../Generated_Code/UTIL0.c **** /*
1331:../Generated_Code/UTIL0.c **** ** ===================================================================
1332:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDate (component Utility)
1333:../Generated_Code/UTIL0.c **** **     Description :
1334:../Generated_Code/UTIL0.c **** **         Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For
1335:../Generated_Code/UTIL0.c **** **         yy it will expand it to 20yy.
1336:../Generated_Code/UTIL0.c **** **     Parameters  :
1337:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1338:../Generated_Code/UTIL0.c **** **       * str             - Pointer to the string to be scanned. The
1339:../Generated_Code/UTIL0.c **** **                           function advances the pointer.
1340:../Generated_Code/UTIL0.c **** **       * day             - Pointer to where to store the day value
1341:../Generated_Code/UTIL0.c **** **       * month           - Pointer to where to store the month
1342:../Generated_Code/UTIL0.c **** **                           value
1343:../Generated_Code/UTIL0.c **** **       * year            - Pointer to where to store the year value
1344:../Generated_Code/UTIL0.c **** **     Returns     :
1345:../Generated_Code/UTIL0.c **** **         ---             - Error code
1346:../Generated_Code/UTIL0.c **** ** ===================================================================
1347:../Generated_Code/UTIL0.c **** */
1348:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDate(const unsigned char **str, byte *day, byte *month, word *year)
1349:../Generated_Code/UTIL0.c **** {
 3670              		.loc 1 1349 0
 3671              		.cfi_startproc
 3672 0000 80B5     		push	{r7, lr}
 3673              	.LCFI96:
 3674              		.cfi_def_cfa_offset 8
 3675              		.cfi_offset 7, -8
 3676              		.cfi_offset 14, -4
 3677 0002 86B0     		sub	sp, sp, #24
 3678              	.LCFI97:
 3679              		.cfi_def_cfa_offset 32
 3680 0004 00AF     		add	r7, sp, #0
 3681              	.LCFI98:
 3682              		.cfi_def_cfa_register 7
 3683 0006 F860     		str	r0, [r7, #12]
 3684 0008 B960     		str	r1, [r7, #8]
 3685 000a 7A60     		str	r2, [r7, #4]
 3686 000c 3B60     		str	r3, [r7]
 3687              	.LBB24:
1350:../Generated_Code/UTIL0.c ****   /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is i
1351:../Generated_Code/UTIL0.c ****   const unsigned char *p;
1352:../Generated_Code/UTIL0.c **** 
1353:../Generated_Code/UTIL0.c ****   p = *str;
 3688              		.loc 1 1353 0
 3689 000e FB68     		ldr	r3, [r7, #12]
 3690 0010 1B68     		ldr	r3, [r3]
 3691 0012 7B61     		str	r3, [r7, #20]
1354:../Generated_Code/UTIL0.c ****   while(*p==' ') {
 3692              		.loc 1 1354 0
 3693 0014 02E0     		b	.L169
 3694              	.L170:
1355:../Generated_Code/UTIL0.c ****     p++; /* skip leading spaces */
 3695              		.loc 1 1355 0
 3696 0016 7B69     		ldr	r3, [r7, #20]
 3697 0018 0133     		add	r3, r3, #1
 3698 001a 7B61     		str	r3, [r7, #20]
 3699              	.L169:
1354:../Generated_Code/UTIL0.c ****   while(*p==' ') {
 3700              		.loc 1 1354 0
 3701 001c 7B69     		ldr	r3, [r7, #20]
 3702 001e 1B78     		ldrb	r3, [r3]
 3703 0020 203B     		sub	r3, r3, #32
 3704 0022 5A42     		neg	r2, r3
 3705 0024 5341     		adc	r3, r3, r2
 3706 0026 DBB2     		uxtb	r3, r3
 3707 0028 002B     		cmp	r3, #0
 3708 002a F4D1     		bne	.L170
1356:../Generated_Code/UTIL0.c ****   }
1357:../Generated_Code/UTIL0.c ****   if (   UTIL0_ScanDecimal8uNumber(&p, day)==ERR_OK
 3709              		.loc 1 1357 0
 3710 002c 3A1C     		mov	r2, r7
 3711 002e 1432     		add	r2, r2, #20
 3712 0030 BB68     		ldr	r3, [r7, #8]
 3713 0032 101C     		mov	r0, r2
 3714 0034 191C     		mov	r1, r3
 3715 0036 FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 3716 003a 031C     		mov	r3, r0
 3717 003c 002B     		cmp	r3, #0
 3718 003e 11D1     		bne	.L171
 3719              		.loc 1 1357 0 is_stmt 0
 3720 0040 BB68     		ldr	r3, [r7, #8]
 3721 0042 1B78     		ldrb	r3, [r3]
 3722 0044 002B     		cmp	r3, #0
 3723 0046 0DD0     		beq	.L171
 3724              		.loc 1 1357 0
 3725 0048 BB68     		ldr	r3, [r7, #8]
 3726 004a 1B78     		ldrb	r3, [r3]
 3727 004c 1F2B     		cmp	r3, #31
 3728 004e 09D8     		bhi	.L171
 3729              		.loc 1 1357 0
 3730 0050 7B69     		ldr	r3, [r7, #20]
 3731 0052 1B78     		ldrb	r3, [r3]
 3732 0054 2E2B     		cmp	r3, #46
 3733 0056 03D0     		beq	.L172
 3734              		.loc 1 1357 0
 3735 0058 7B69     		ldr	r3, [r7, #20]
 3736 005a 1B78     		ldrb	r3, [r3]
 3737 005c 2D2B     		cmp	r3, #45
 3738 005e 01D1     		bne	.L171
 3739              	.L172:
 3740              		.loc 1 1357 0
 3741 0060 0123     		mov	r3, #1
 3742 0062 00E0     		b	.L173
 3743              	.L171:
 3744              		.loc 1 1357 0
 3745 0064 0023     		mov	r3, #0
 3746              	.L173:
 3747              		.loc 1 1357 0
 3748 0066 002B     		cmp	r3, #0
 3749 0068 4DD0     		beq	.L174
1358:../Generated_Code/UTIL0.c ****       && *day > 0 && *day <= 31
1359:../Generated_Code/UTIL0.c ****       && (*p=='.' || *p=='-')
1360:../Generated_Code/UTIL0.c ****      )
1361:../Generated_Code/UTIL0.c ****   {
1362:../Generated_Code/UTIL0.c ****     p++;
 3750              		.loc 1 1362 0 is_stmt 1
 3751 006a 7B69     		ldr	r3, [r7, #20]
 3752 006c 0133     		add	r3, r3, #1
 3753 006e 7B61     		str	r3, [r7, #20]
1363:../Generated_Code/UTIL0.c ****     if (   UTIL0_ScanDecimal8uNumber(&p, month)==ERR_OK
 3754              		.loc 1 1363 0
 3755 0070 3A1C     		mov	r2, r7
 3756 0072 1432     		add	r2, r2, #20
 3757 0074 7B68     		ldr	r3, [r7, #4]
 3758 0076 101C     		mov	r0, r2
 3759 0078 191C     		mov	r1, r3
 3760 007a FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 3761 007e 031C     		mov	r3, r0
 3762 0080 002B     		cmp	r3, #0
 3763 0082 11D1     		bne	.L175
 3764              		.loc 1 1363 0 is_stmt 0
 3765 0084 7B68     		ldr	r3, [r7, #4]
 3766 0086 1B78     		ldrb	r3, [r3]
 3767 0088 002B     		cmp	r3, #0
 3768 008a 0DD0     		beq	.L175
 3769              		.loc 1 1363 0
 3770 008c 7B68     		ldr	r3, [r7, #4]
 3771 008e 1B78     		ldrb	r3, [r3]
 3772 0090 0C2B     		cmp	r3, #12
 3773 0092 09D8     		bhi	.L175
 3774              		.loc 1 1363 0
 3775 0094 7B69     		ldr	r3, [r7, #20]
 3776 0096 1B78     		ldrb	r3, [r3]
 3777 0098 2E2B     		cmp	r3, #46
 3778 009a 03D0     		beq	.L176
 3779              		.loc 1 1363 0
 3780 009c 7B69     		ldr	r3, [r7, #20]
 3781 009e 1B78     		ldrb	r3, [r3]
 3782 00a0 2D2B     		cmp	r3, #45
 3783 00a2 01D1     		bne	.L175
 3784              	.L176:
 3785              		.loc 1 1363 0
 3786 00a4 0123     		mov	r3, #1
 3787 00a6 00E0     		b	.L177
 3788              	.L175:
 3789              		.loc 1 1363 0
 3790 00a8 0023     		mov	r3, #0
 3791              	.L177:
 3792              		.loc 1 1363 0
 3793 00aa 002B     		cmp	r3, #0
 3794 00ac 2BD0     		beq	.L174
1364:../Generated_Code/UTIL0.c ****         && *month > 0 && *month <= 12
1365:../Generated_Code/UTIL0.c ****         && (*p=='.' || *p=='-')
1366:../Generated_Code/UTIL0.c ****        )
1367:../Generated_Code/UTIL0.c ****     {
1368:../Generated_Code/UTIL0.c ****       p++;
 3795              		.loc 1 1368 0 is_stmt 1
 3796 00ae 7B69     		ldr	r3, [r7, #20]
 3797 00b0 0133     		add	r3, r3, #1
 3798 00b2 7B61     		str	r3, [r7, #20]
1369:../Generated_Code/UTIL0.c ****       if (   UTIL0_ScanDecimal16uNumber(&p, year)==ERR_OK
 3799              		.loc 1 1369 0
 3800 00b4 3A1C     		mov	r2, r7
 3801 00b6 1432     		add	r2, r2, #20
 3802 00b8 3B68     		ldr	r3, [r7]
 3803 00ba 101C     		mov	r0, r2
 3804 00bc 191C     		mov	r1, r3
 3805 00be FFF7FEFF 		bl	_Z26UTIL0_ScanDecimal16uNumberPPKhPt
 3806 00c2 031C     		mov	r3, r0
 3807 00c4 002B     		cmp	r3, #0
 3808 00c6 0AD1     		bne	.L178
 3809              		.loc 1 1369 0 is_stmt 0
 3810 00c8 3B68     		ldr	r3, [r7]
 3811 00ca 1B88     		ldrh	r3, [r3]
 3812 00cc 002B     		cmp	r3, #0
 3813 00ce 06D0     		beq	.L178
 3814              		.loc 1 1369 0
 3815 00d0 3B68     		ldr	r3, [r7]
 3816 00d2 1A88     		ldrh	r2, [r3]
 3817 00d4 134B     		ldr	r3, .L183
 3818 00d6 9A42     		cmp	r2, r3
 3819 00d8 01D8     		bhi	.L178
 3820              		.loc 1 1369 0
 3821 00da 0123     		mov	r3, #1
 3822 00dc 00E0     		b	.L179
 3823              	.L178:
 3824              		.loc 1 1369 0
 3825 00de 0023     		mov	r3, #0
 3826              	.L179:
 3827              		.loc 1 1369 0
 3828 00e0 002B     		cmp	r3, #0
 3829 00e2 10D0     		beq	.L174
1370:../Generated_Code/UTIL0.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
1371:../Generated_Code/UTIL0.c ****          )
1372:../Generated_Code/UTIL0.c ****       {
1373:../Generated_Code/UTIL0.c ****         if (*year < 100) {
 3830              		.loc 1 1373 0 is_stmt 1
 3831 00e4 3B68     		ldr	r3, [r7]
 3832 00e6 1B88     		ldrh	r3, [r3]
 3833 00e8 632B     		cmp	r3, #99
 3834 00ea 07D8     		bhi	.L180
1374:../Generated_Code/UTIL0.c ****           *year += 2000; /* transform '10' into '2010' */
 3835              		.loc 1 1374 0
 3836 00ec 3B68     		ldr	r3, [r7]
 3837 00ee 1B88     		ldrh	r3, [r3]
 3838 00f0 FA22     		mov	r2, #250
 3839 00f2 D200     		lsl	r2, r2, #3
 3840 00f4 9B18     		add	r3, r3, r2
 3841 00f6 9AB2     		uxth	r2, r3
 3842 00f8 3B68     		ldr	r3, [r7]
 3843 00fa 1A80     		strh	r2, [r3]
 3844              	.L180:
1375:../Generated_Code/UTIL0.c ****         }
1376:../Generated_Code/UTIL0.c ****         *str = p; /* advance pointer for caller */
 3845              		.loc 1 1376 0
 3846 00fc 7A69     		ldr	r2, [r7, #20]
 3847 00fe FB68     		ldr	r3, [r7, #12]
 3848 0100 1A60     		str	r2, [r3]
1377:../Generated_Code/UTIL0.c ****         return ERR_OK;
 3849              		.loc 1 1377 0
 3850 0102 0023     		mov	r3, #0
 3851 0104 09E0     		b	.L182
 3852              	.L174:
1378:../Generated_Code/UTIL0.c ****       }
1379:../Generated_Code/UTIL0.c ****     }
1380:../Generated_Code/UTIL0.c ****   }
1381:../Generated_Code/UTIL0.c ****   *day = 0;
 3853              		.loc 1 1381 0
 3854 0106 BB68     		ldr	r3, [r7, #8]
 3855 0108 0022     		mov	r2, #0
 3856 010a 1A70     		strb	r2, [r3]
1382:../Generated_Code/UTIL0.c ****   *month = 0;
 3857              		.loc 1 1382 0
 3858 010c 7B68     		ldr	r3, [r7, #4]
 3859 010e 0022     		mov	r2, #0
 3860 0110 1A70     		strb	r2, [r3]
1383:../Generated_Code/UTIL0.c ****   *year = 0;
 3861              		.loc 1 1383 0
 3862 0112 3B68     		ldr	r3, [r7]
 3863 0114 0022     		mov	r2, #0
 3864 0116 1A80     		strh	r2, [r3]
1384:../Generated_Code/UTIL0.c ****   return ERR_FAILED; /* wrong format */
 3865              		.loc 1 1384 0
 3866 0118 1B23     		mov	r3, #27
 3867              	.L182:
 3868              	.LBE24:
1385:../Generated_Code/UTIL0.c **** }
 3869              		.loc 1 1385 0
 3870 011a 181C     		mov	r0, r3
 3871 011c BD46     		mov	sp, r7
 3872 011e 06B0     		add	sp, sp, #24
 3873              		@ sp needed for prologue
 3874 0120 80BD     		pop	{r7, pc}
 3875              	.L184:
 3876 0122 C046     		.align	2
 3877              	.L183:
 3878 0124 B80B0000 		.word	3000
 3879              		.cfi_endproc
 3880              	.LFE37:
 3882              		.section	.text._Z14UTIL0_ScanTimePPKhPhS2_S2_S2_,"ax",%progbits
 3883              		.align	2
 3884              		.global	_Z14UTIL0_ScanTimePPKhPhS2_S2_S2_
 3885              		.code	16
 3886              		.thumb_func
 3888              	_Z14UTIL0_ScanTimePPKhPhS2_S2_S2_:
 3889              	.LFB38:
1386:../Generated_Code/UTIL0.c **** 
1387:../Generated_Code/UTIL0.c **** /*
1388:../Generated_Code/UTIL0.c **** ** ===================================================================
1389:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanTime (component Utility)
1390:../Generated_Code/UTIL0.c **** **     Description :
1391:../Generated_Code/UTIL0.c **** **         Scans a time string in the format "hh:mm:ss,hh" with the
1392:../Generated_Code/UTIL0.c **** **         part for the ",hh" is optional.
1393:../Generated_Code/UTIL0.c **** **     Parameters  :
1394:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1395:../Generated_Code/UTIL0.c **** **         str             - Pointer to the string to be scanned. The
1396:../Generated_Code/UTIL0.c **** **                           function advances the pointer.
1397:../Generated_Code/UTIL0.c **** **       * hour            - Pointer to where to store the hour value
1398:../Generated_Code/UTIL0.c **** **       * minute          - Pointer to where to store the minute
1399:../Generated_Code/UTIL0.c **** **                           value
1400:../Generated_Code/UTIL0.c **** **       * second          - Pointer to where to store the second
1401:../Generated_Code/UTIL0.c **** **                           value
1402:../Generated_Code/UTIL0.c **** **       * hSecond         - Pointer to scans the hundreds of
1403:../Generated_Code/UTIL0.c **** **                           second part. If not present in string, zero
1404:../Generated_Code/UTIL0.c **** **                           is stored
1405:../Generated_Code/UTIL0.c **** **     Returns     :
1406:../Generated_Code/UTIL0.c **** **         ---             - Error code
1407:../Generated_Code/UTIL0.c **** ** ===================================================================
1408:../Generated_Code/UTIL0.c **** */
1409:../Generated_Code/UTIL0.c **** byte UTIL0_ScanTime(const unsigned char **str, byte *hour, byte *minute, byte *second, byte *hSecon
1410:../Generated_Code/UTIL0.c **** {
 3890              		.loc 1 1410 0
 3891              		.cfi_startproc
 3892 0000 80B5     		push	{r7, lr}
 3893              	.LCFI99:
 3894              		.cfi_def_cfa_offset 8
 3895              		.cfi_offset 7, -8
 3896              		.cfi_offset 14, -4
 3897 0002 86B0     		sub	sp, sp, #24
 3898              	.LCFI100:
 3899              		.cfi_def_cfa_offset 32
 3900 0004 00AF     		add	r7, sp, #0
 3901              	.LCFI101:
 3902              		.cfi_def_cfa_register 7
 3903 0006 F860     		str	r0, [r7, #12]
 3904 0008 B960     		str	r1, [r7, #8]
 3905 000a 7A60     		str	r2, [r7, #4]
 3906 000c 3B60     		str	r3, [r7]
 3907              	.LBB25:
1411:../Generated_Code/UTIL0.c ****   /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03
1412:../Generated_Code/UTIL0.c ****   const unsigned char *p;
1413:../Generated_Code/UTIL0.c ****   #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')
1414:../Generated_Code/UTIL0.c **** 
1415:../Generated_Code/UTIL0.c ****   *hour = 0;
 3908              		.loc 1 1415 0
 3909 000e BB68     		ldr	r3, [r7, #8]
 3910 0010 0022     		mov	r2, #0
 3911 0012 1A70     		strb	r2, [r3]
1416:../Generated_Code/UTIL0.c ****   *minute = 0;
 3912              		.loc 1 1416 0
 3913 0014 7B68     		ldr	r3, [r7, #4]
 3914 0016 0022     		mov	r2, #0
 3915 0018 1A70     		strb	r2, [r3]
1417:../Generated_Code/UTIL0.c ****   *second = 0;
 3916              		.loc 1 1417 0
 3917 001a 3B68     		ldr	r3, [r7]
 3918 001c 0022     		mov	r2, #0
 3919 001e 1A70     		strb	r2, [r3]
1418:../Generated_Code/UTIL0.c ****   *hSecond = 0;
 3920              		.loc 1 1418 0
 3921 0020 3B6A     		ldr	r3, [r7, #32]
 3922 0022 0022     		mov	r2, #0
 3923 0024 1A70     		strb	r2, [r3]
1419:../Generated_Code/UTIL0.c ****   p = *str;
 3924              		.loc 1 1419 0
 3925 0026 FB68     		ldr	r3, [r7, #12]
 3926 0028 1B68     		ldr	r3, [r3]
 3927 002a 7B61     		str	r3, [r7, #20]
1420:../Generated_Code/UTIL0.c ****   while(*p==' ') {
 3928              		.loc 1 1420 0
 3929 002c 02E0     		b	.L186
 3930              	.L187:
1421:../Generated_Code/UTIL0.c ****     p++; /* skip leading spaces */
 3931              		.loc 1 1421 0
 3932 002e 7B69     		ldr	r3, [r7, #20]
 3933 0030 0133     		add	r3, r3, #1
 3934 0032 7B61     		str	r3, [r7, #20]
 3935              	.L186:
1420:../Generated_Code/UTIL0.c ****   while(*p==' ') {
 3936              		.loc 1 1420 0
 3937 0034 7B69     		ldr	r3, [r7, #20]
 3938 0036 1B78     		ldrb	r3, [r3]
 3939 0038 203B     		sub	r3, r3, #32
 3940 003a 5A42     		neg	r2, r3
 3941 003c 5341     		adc	r3, r3, r2
 3942 003e DBB2     		uxtb	r3, r3
 3943 0040 002B     		cmp	r3, #0
 3944 0042 F4D1     		bne	.L187
1422:../Generated_Code/UTIL0.c ****   }
1423:../Generated_Code/UTIL0.c ****   if (   UTIL0_ScanDecimal8uNumber(&p, hour)==ERR_OK
 3945              		.loc 1 1423 0
 3946 0044 3A1C     		mov	r2, r7
 3947 0046 1432     		add	r2, r2, #20
 3948 0048 BB68     		ldr	r3, [r7, #8]
 3949 004a 101C     		mov	r0, r2
 3950 004c 191C     		mov	r1, r3
 3951 004e FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 3952 0052 031C     		mov	r3, r0
 3953 0054 002B     		cmp	r3, #0
 3954 0056 09D1     		bne	.L188
 3955              		.loc 1 1423 0 is_stmt 0
 3956 0058 BB68     		ldr	r3, [r7, #8]
 3957 005a 1B78     		ldrb	r3, [r3]
 3958 005c 182B     		cmp	r3, #24
 3959 005e 05D8     		bhi	.L188
 3960              		.loc 1 1423 0
 3961 0060 7B69     		ldr	r3, [r7, #20]
 3962 0062 1B78     		ldrb	r3, [r3]
 3963 0064 3A2B     		cmp	r3, #58
 3964 0066 01D1     		bne	.L188
 3965              		.loc 1 1423 0
 3966 0068 0123     		mov	r3, #1
 3967 006a 00E0     		b	.L189
 3968              	.L188:
 3969              		.loc 1 1423 0
 3970 006c 0023     		mov	r3, #0
 3971              	.L189:
 3972              		.loc 1 1423 0
 3973 006e 002B     		cmp	r3, #0
 3974 0070 00D1     		bne	.LCB3550
 3975 0072 88E0     		b	.L190	@long jump
 3976              	.LCB3550:
1424:../Generated_Code/UTIL0.c ****       && *hour <= 24
1425:../Generated_Code/UTIL0.c ****       && *p==':'
1426:../Generated_Code/UTIL0.c ****      )
1427:../Generated_Code/UTIL0.c ****   {
1428:../Generated_Code/UTIL0.c ****     p++; /* skip ':' */
 3977              		.loc 1 1428 0 is_stmt 1
 3978 0074 7B69     		ldr	r3, [r7, #20]
 3979 0076 0133     		add	r3, r3, #1
 3980 0078 7B61     		str	r3, [r7, #20]
1429:../Generated_Code/UTIL0.c ****     if (   UTIL0_ScanDecimal8uNumber(&p, minute)==ERR_OK
 3981              		.loc 1 1429 0
 3982 007a 3A1C     		mov	r2, r7
 3983 007c 1432     		add	r2, r2, #20
 3984 007e 7B68     		ldr	r3, [r7, #4]
 3985 0080 101C     		mov	r0, r2
 3986 0082 191C     		mov	r1, r3
 3987 0084 FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 3988 0088 031C     		mov	r3, r0
 3989 008a 002B     		cmp	r3, #0
 3990 008c 05D1     		bne	.L191
 3991              		.loc 1 1429 0 is_stmt 0
 3992 008e 7B68     		ldr	r3, [r7, #4]
 3993 0090 1B78     		ldrb	r3, [r3]
 3994 0092 3C2B     		cmp	r3, #60
 3995 0094 01D8     		bhi	.L191
 3996              		.loc 1 1429 0
 3997 0096 0123     		mov	r3, #1
 3998 0098 00E0     		b	.L192
 3999              	.L191:
 4000              		.loc 1 1429 0
 4001 009a 0023     		mov	r3, #0
 4002              	.L192:
 4003              		.loc 1 1429 0
 4004 009c 002B     		cmp	r3, #0
 4005 009e 00D1     		bne	.LCB3576
 4006 00a0 71E0     		b	.L190	@long jump
 4007              	.LCB3576:
1430:../Generated_Code/UTIL0.c ****         && *minute <= 60
1431:../Generated_Code/UTIL0.c ****        )
1432:../Generated_Code/UTIL0.c ****     {
1433:../Generated_Code/UTIL0.c ****       if (*p==':') { /* there is more after the minute */
 4008              		.loc 1 1433 0 is_stmt 1
 4009 00a2 7B69     		ldr	r3, [r7, #20]
 4010 00a4 1B78     		ldrb	r3, [r3]
 4011 00a6 3A2B     		cmp	r3, #58
 4012 00a8 60D1     		bne	.L193
1434:../Generated_Code/UTIL0.c ****         p++; /* skip ':' */
 4013              		.loc 1 1434 0
 4014 00aa 7B69     		ldr	r3, [r7, #20]
 4015 00ac 0133     		add	r3, r3, #1
 4016 00ae 7B61     		str	r3, [r7, #20]
1435:../Generated_Code/UTIL0.c ****         if (   UTIL0_ScanDecimal8uNumber(&p, second)==ERR_OK
 4017              		.loc 1 1435 0
 4018 00b0 3A1C     		mov	r2, r7
 4019 00b2 1432     		add	r2, r2, #20
 4020 00b4 3B68     		ldr	r3, [r7]
 4021 00b6 101C     		mov	r0, r2
 4022 00b8 191C     		mov	r1, r3
 4023 00ba FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 4024 00be 031C     		mov	r3, r0
 4025 00c0 002B     		cmp	r3, #0
 4026 00c2 05D1     		bne	.L194
 4027              		.loc 1 1435 0 is_stmt 0
 4028 00c4 3B68     		ldr	r3, [r7]
 4029 00c6 1B78     		ldrb	r3, [r3]
 4030 00c8 3C2B     		cmp	r3, #60
 4031 00ca 01D8     		bhi	.L194
 4032              		.loc 1 1435 0
 4033 00cc 0123     		mov	r3, #1
 4034 00ce 00E0     		b	.L195
 4035              	.L194:
 4036              		.loc 1 1435 0
 4037 00d0 0023     		mov	r3, #0
 4038              	.L195:
 4039              		.loc 1 1435 0
 4040 00d2 002B     		cmp	r3, #0
 4041 00d4 57D0     		beq	.L190
1436:../Generated_Code/UTIL0.c ****             && *second <= 60
1437:../Generated_Code/UTIL0.c ****            )
1438:../Generated_Code/UTIL0.c ****         {
1439:../Generated_Code/UTIL0.c ****           if (*p==',') { /* we do have either ",z" or ",hh" */
 4042              		.loc 1 1439 0 is_stmt 1
 4043 00d6 7B69     		ldr	r3, [r7, #20]
 4044 00d8 1B78     		ldrb	r3, [r3]
 4045 00da 2C2B     		cmp	r3, #44
 4046 00dc 41D1     		bne	.L196
1440:../Generated_Code/UTIL0.c ****             p++; /* skip ',' */
 4047              		.loc 1 1440 0
 4048 00de 7B69     		ldr	r3, [r7, #20]
 4049 00e0 0133     		add	r3, r3, #1
 4050 00e2 7B61     		str	r3, [r7, #20]
1441:../Generated_Code/UTIL0.c ****             if (SCAN_IS_DIGIT(*p)) {
 4051              		.loc 1 1441 0
 4052 00e4 7B69     		ldr	r3, [r7, #20]
 4053 00e6 1B78     		ldrb	r3, [r3]
 4054 00e8 2F2B     		cmp	r3, #47
 4055 00ea 38D9     		bls	.L197
 4056              		.loc 1 1441 0 is_stmt 0
 4057 00ec 7B69     		ldr	r3, [r7, #20]
 4058 00ee 1B78     		ldrb	r3, [r3]
 4059 00f0 392B     		cmp	r3, #57
 4060 00f2 34D8     		bhi	.L197
1442:../Generated_Code/UTIL0.c ****               if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
 4061              		.loc 1 1442 0 is_stmt 1
 4062 00f4 7B69     		ldr	r3, [r7, #20]
 4063 00f6 0133     		add	r3, r3, #1
 4064 00f8 1B78     		ldrb	r3, [r3]
 4065 00fa 2F2B     		cmp	r3, #47
 4066 00fc 1CD9     		bls	.L198
 4067              		.loc 1 1442 0 is_stmt 0
 4068 00fe 7B69     		ldr	r3, [r7, #20]
 4069 0100 0133     		add	r3, r3, #1
 4070 0102 1B78     		ldrb	r3, [r3]
 4071 0104 392B     		cmp	r3, #57
 4072 0106 17D8     		bhi	.L198
1443:../Generated_Code/UTIL0.c ****                 *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
 4073              		.loc 1 1443 0 is_stmt 1
 4074 0108 7B69     		ldr	r3, [r7, #20]
 4075 010a 1B78     		ldrb	r3, [r3]
 4076 010c 1A1C     		add	r2, r3, #0
 4077 010e 9200     		lsl	r2, r2, #2
 4078 0110 D318     		add	r3, r2, r3
 4079 0112 5B00     		lsl	r3, r3, #1
 4080 0114 DAB2     		uxtb	r2, r3
 4081 0116 7B69     		ldr	r3, [r7, #20]
 4082 0118 0133     		add	r3, r3, #1
 4083 011a 1B78     		ldrb	r3, [r3]
 4084 011c D318     		add	r3, r2, r3
 4085 011e DBB2     		uxtb	r3, r3
 4086 0120 103B     		sub	r3, r3, #16
 4087 0122 DAB2     		uxtb	r2, r3
 4088 0124 3B6A     		ldr	r3, [r7, #32]
 4089 0126 1A70     		strb	r2, [r3]
1444:../Generated_Code/UTIL0.c ****                 p++; p++;
 4090              		.loc 1 1444 0
 4091 0128 7B69     		ldr	r3, [r7, #20]
 4092 012a 0133     		add	r3, r3, #1
 4093 012c 7B61     		str	r3, [r7, #20]
 4094 012e 7B69     		ldr	r3, [r7, #20]
 4095 0130 0133     		add	r3, r3, #1
 4096 0132 7B61     		str	r3, [r7, #20]
1445:../Generated_Code/UTIL0.c ****                 return ERR_OK;
 4097              		.loc 1 1445 0
 4098 0134 0023     		mov	r3, #0
 4099 0136 27E0     		b	.L201
 4100              	.L198:
1446:../Generated_Code/UTIL0.c ****               } else { /* ,z format */
1447:../Generated_Code/UTIL0.c ****                 *hSecond = (uint8_t)((*p-'0')*10);
 4101              		.loc 1 1447 0
 4102 0138 7B69     		ldr	r3, [r7, #20]
 4103 013a 1B78     		ldrb	r3, [r3]
 4104 013c 1A1C     		add	r2, r3, #0
 4105 013e 9200     		lsl	r2, r2, #2
 4106 0140 D318     		add	r3, r2, r3
 4107 0142 5B00     		lsl	r3, r3, #1
 4108 0144 DBB2     		uxtb	r3, r3
 4109 0146 2033     		add	r3, r3, #32
 4110 0148 DAB2     		uxtb	r2, r3
 4111 014a 3B6A     		ldr	r3, [r7, #32]
 4112 014c 1A70     		strb	r2, [r3]
1448:../Generated_Code/UTIL0.c ****                 p++;
 4113              		.loc 1 1448 0
 4114 014e 7B69     		ldr	r3, [r7, #20]
 4115 0150 0133     		add	r3, r3, #1
 4116 0152 7B61     		str	r3, [r7, #20]
1449:../Generated_Code/UTIL0.c ****                 *str = p; /* advance pointer for caller */
 4117              		.loc 1 1449 0
 4118 0154 7A69     		ldr	r2, [r7, #20]
 4119 0156 FB68     		ldr	r3, [r7, #12]
 4120 0158 1A60     		str	r2, [r3]
1450:../Generated_Code/UTIL0.c ****                 return ERR_OK;
 4121              		.loc 1 1450 0
 4122 015a 0023     		mov	r3, #0
 4123 015c 14E0     		b	.L201
 4124              	.L197:
1451:../Generated_Code/UTIL0.c ****               }
1452:../Generated_Code/UTIL0.c ****             } else {
1453:../Generated_Code/UTIL0.c ****               return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
 4125              		.loc 1 1453 0
 4126 015e 1B23     		mov	r3, #27
 4127 0160 12E0     		b	.L201
 4128              	.L196:
1454:../Generated_Code/UTIL0.c ****             }
1455:../Generated_Code/UTIL0.c ****           }
1456:../Generated_Code/UTIL0.c ****           *str = p; /* advance pointer for caller */
 4129              		.loc 1 1456 0
 4130 0162 7A69     		ldr	r2, [r7, #20]
 4131 0164 FB68     		ldr	r3, [r7, #12]
 4132 0166 1A60     		str	r2, [r3]
1457:../Generated_Code/UTIL0.c ****           return ERR_OK;
 4133              		.loc 1 1457 0
 4134 0168 0023     		mov	r3, #0
 4135 016a 0DE0     		b	.L201
 4136              	.L193:
1458:../Generated_Code/UTIL0.c ****         }
1459:../Generated_Code/UTIL0.c ****       } else if (*p==' ' || *p=='\0') { /* nothing more after the minute? Assume zero seconds */
 4137              		.loc 1 1459 0
 4138 016c 7B69     		ldr	r3, [r7, #20]
 4139 016e 1B78     		ldrb	r3, [r3]
 4140 0170 202B     		cmp	r3, #32
 4141 0172 03D0     		beq	.L200
 4142              		.loc 1 1459 0 is_stmt 0
 4143 0174 7B69     		ldr	r3, [r7, #20]
 4144 0176 1B78     		ldrb	r3, [r3]
 4145 0178 002B     		cmp	r3, #0
 4146 017a 04D1     		bne	.L190
 4147              	.L200:
1460:../Generated_Code/UTIL0.c ****         *str = p; /* advance pointer for caller */
 4148              		.loc 1 1460 0 is_stmt 1
 4149 017c 7A69     		ldr	r2, [r7, #20]
 4150 017e FB68     		ldr	r3, [r7, #12]
 4151 0180 1A60     		str	r2, [r3]
1461:../Generated_Code/UTIL0.c ****         return ERR_OK;
 4152              		.loc 1 1461 0
 4153 0182 0023     		mov	r3, #0
 4154 0184 00E0     		b	.L201
 4155              	.L190:
1462:../Generated_Code/UTIL0.c ****       }
1463:../Generated_Code/UTIL0.c ****     }
1464:../Generated_Code/UTIL0.c ****   }
1465:../Generated_Code/UTIL0.c ****   return ERR_FAILED; /* wrong format */
 4156              		.loc 1 1465 0
 4157 0186 1B23     		mov	r3, #27
 4158              	.L201:
 4159              	.LBE25:
1466:../Generated_Code/UTIL0.c **** }
 4160              		.loc 1 1466 0
 4161 0188 181C     		mov	r0, r3
 4162 018a BD46     		mov	sp, r7
 4163 018c 06B0     		add	sp, sp, #24
 4164              		@ sp needed for prologue
 4165 018e 80BD     		pop	{r7, pc}
 4166              		.cfi_endproc
 4167              	.LFE38:
 4169              		.section	.text._Z25UTIL0_ScanDecimal8uNumberPPKhPh,"ax",%progbits
 4170              		.align	2
 4171              		.global	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 4172              		.code	16
 4173              		.thumb_func
 4175              	_Z25UTIL0_ScanDecimal8uNumberPPKhPh:
 4176              	.LFB39:
1467:../Generated_Code/UTIL0.c **** 
1468:../Generated_Code/UTIL0.c **** /*
1469:../Generated_Code/UTIL0.c **** ** ===================================================================
1470:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal8uNumber (component Utility)
1471:../Generated_Code/UTIL0.c **** **     Description :
1472:../Generated_Code/UTIL0.c **** **         Scans a decimal 8bit unsigned number
1473:../Generated_Code/UTIL0.c **** **     Parameters  :
1474:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1475:../Generated_Code/UTIL0.c **** **         str             - String to scan. It returns as well until
1476:../Generated_Code/UTIL0.c **** **                           where it has scanned
1477:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1478:../Generated_Code/UTIL0.c **** **     Returns     :
1479:../Generated_Code/UTIL0.c **** **         ---             - Error code
1480:../Generated_Code/UTIL0.c **** ** ===================================================================
1481:../Generated_Code/UTIL0.c **** */
1482:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal8uNumber(const unsigned char **str, byte *val)
1483:../Generated_Code/UTIL0.c **** {
 4177              		.loc 1 1483 0
 4178              		.cfi_startproc
 4179 0000 80B5     		push	{r7, lr}
 4180              	.LCFI102:
 4181              		.cfi_def_cfa_offset 8
 4182              		.cfi_offset 7, -8
 4183              		.cfi_offset 14, -4
 4184 0002 84B0     		sub	sp, sp, #16
 4185              	.LCFI103:
 4186              		.cfi_def_cfa_offset 24
 4187 0004 00AF     		add	r7, sp, #0
 4188              	.LCFI104:
 4189              		.cfi_def_cfa_register 7
 4190 0006 7860     		str	r0, [r7, #4]
 4191 0008 3960     		str	r1, [r7]
 4192              	.LBB26:
1484:../Generated_Code/UTIL0.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1485:../Generated_Code/UTIL0.c ****   #define _8_NOF_DIGITS  (3+1)
1486:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4193              		.loc 1 1486 0
 4194 000a 3B1C     		mov	r3, r7
 4195 000c 0F33     		add	r3, r3, #15
 4196 000e 0422     		mov	r2, #4
 4197 0010 1A70     		strb	r2, [r3]
1487:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4198              		.loc 1 1487 0
 4199 0012 7B68     		ldr	r3, [r7, #4]
 4200 0014 1B68     		ldr	r3, [r3]
 4201 0016 BB60     		str	r3, [r7, #8]
1488:../Generated_Code/UTIL0.c **** 
1489:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4202              		.loc 1 1489 0
 4203 0018 02E0     		b	.L203
 4204              	.L204:
1490:../Generated_Code/UTIL0.c ****     p++;
 4205              		.loc 1 1490 0
 4206 001a BB68     		ldr	r3, [r7, #8]
 4207 001c 0133     		add	r3, r3, #1
 4208 001e BB60     		str	r3, [r7, #8]
 4209              	.L203:
1489:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4210              		.loc 1 1489 0
 4211 0020 BB68     		ldr	r3, [r7, #8]
 4212 0022 1B78     		ldrb	r3, [r3]
 4213 0024 203B     		sub	r3, r3, #32
 4214 0026 5A42     		neg	r2, r3
 4215 0028 5341     		adc	r3, r3, r2
 4216 002a DBB2     		uxtb	r3, r3
 4217 002c 002B     		cmp	r3, #0
 4218 002e F4D1     		bne	.L204
1491:../Generated_Code/UTIL0.c ****   }
1492:../Generated_Code/UTIL0.c ****   *val = 0;
 4219              		.loc 1 1492 0
 4220 0030 3B68     		ldr	r3, [r7]
 4221 0032 0022     		mov	r2, #0
 4222 0034 1A70     		strb	r2, [r3]
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4223              		.loc 1 1493 0
 4224 0036 18E0     		b	.L205
 4225              	.L208:
1494:../Generated_Code/UTIL0.c ****     *val = (uint8_t)((*val)*10 + *p-'0');
 4226              		.loc 1 1494 0
 4227 0038 3B68     		ldr	r3, [r7]
 4228 003a 1B78     		ldrb	r3, [r3]
 4229 003c 1A1C     		add	r2, r3, #0
 4230 003e 9200     		lsl	r2, r2, #2
 4231 0040 D318     		add	r3, r2, r3
 4232 0042 5B00     		lsl	r3, r3, #1
 4233 0044 DAB2     		uxtb	r2, r3
 4234 0046 BB68     		ldr	r3, [r7, #8]
 4235 0048 1B78     		ldrb	r3, [r3]
 4236 004a D318     		add	r3, r2, r3
 4237 004c DBB2     		uxtb	r3, r3
 4238 004e 303B     		sub	r3, r3, #48
 4239 0050 DAB2     		uxtb	r2, r3
 4240 0052 3B68     		ldr	r3, [r7]
 4241 0054 1A70     		strb	r2, [r3]
1495:../Generated_Code/UTIL0.c ****     nofDigits--;
 4242              		.loc 1 1495 0
 4243 0056 3B1C     		mov	r3, r7
 4244 0058 0F33     		add	r3, r3, #15
 4245 005a 3A1C     		mov	r2, r7
 4246 005c 0F32     		add	r2, r2, #15
 4247 005e 1278     		ldrb	r2, [r2]
 4248 0060 013A     		sub	r2, r2, #1
 4249 0062 1A70     		strb	r2, [r3]
1496:../Generated_Code/UTIL0.c ****     p++;
 4250              		.loc 1 1496 0
 4251 0064 BB68     		ldr	r3, [r7, #8]
 4252 0066 0133     		add	r3, r3, #1
 4253 0068 BB60     		str	r3, [r7, #8]
 4254              	.L205:
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4255              		.loc 1 1493 0
 4256 006a BB68     		ldr	r3, [r7, #8]
 4257 006c 1B78     		ldrb	r3, [r3]
 4258 006e 2F2B     		cmp	r3, #47
 4259 0070 0AD9     		bls	.L206
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4260              		.loc 1 1493 0 is_stmt 0
 4261 0072 BB68     		ldr	r3, [r7, #8]
 4262 0074 1B78     		ldrb	r3, [r3]
 4263 0076 392B     		cmp	r3, #57
 4264 0078 06D8     		bhi	.L206
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4265              		.loc 1 1493 0
 4266 007a 3B1C     		mov	r3, r7
 4267 007c 0F33     		add	r3, r3, #15
 4268 007e 1B78     		ldrb	r3, [r3]
 4269 0080 002B     		cmp	r3, #0
 4270 0082 01D0     		beq	.L206
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4271              		.loc 1 1493 0
 4272 0084 0123     		mov	r3, #1
 4273 0086 00E0     		b	.L207
 4274              	.L206:
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4275              		.loc 1 1493 0
 4276 0088 0023     		mov	r3, #0
 4277              	.L207:
1493:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4278              		.loc 1 1493 0
 4279 008a 002B     		cmp	r3, #0
 4280 008c D4D1     		bne	.L208
1497:../Generated_Code/UTIL0.c ****   } /* while */
1498:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 4281              		.loc 1 1498 0 is_stmt 1
 4282 008e 3B1C     		mov	r3, r7
 4283 0090 0F33     		add	r3, r3, #15
 4284 0092 1B78     		ldrb	r3, [r3]
 4285 0094 002B     		cmp	r3, #0
 4286 0096 01D1     		bne	.L209
1499:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 4287              		.loc 1 1499 0
 4288 0098 0423     		mov	r3, #4
 4289 009a 0AE0     		b	.L210
 4290              	.L209:
1500:../Generated_Code/UTIL0.c ****   }
1501:../Generated_Code/UTIL0.c ****   if (nofDigits==_8_NOF_DIGITS) { /* no digits at all? */
 4291              		.loc 1 1501 0
 4292 009c 3B1C     		mov	r3, r7
 4293 009e 0F33     		add	r3, r3, #15
 4294 00a0 1B78     		ldrb	r3, [r3]
 4295 00a2 042B     		cmp	r3, #4
 4296 00a4 01D1     		bne	.L211
1502:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 4297              		.loc 1 1502 0
 4298 00a6 1B23     		mov	r3, #27
 4299 00a8 03E0     		b	.L210
 4300              	.L211:
1503:../Generated_Code/UTIL0.c ****   }
1504:../Generated_Code/UTIL0.c ****   *str = p;
 4301              		.loc 1 1504 0
 4302 00aa 7B68     		ldr	r3, [r7, #4]
 4303 00ac BA68     		ldr	r2, [r7, #8]
 4304 00ae 1A60     		str	r2, [r3]
1505:../Generated_Code/UTIL0.c ****   return ERR_OK;
 4305              		.loc 1 1505 0
 4306 00b0 0023     		mov	r3, #0
 4307              	.L210:
 4308              	.LBE26:
1506:../Generated_Code/UTIL0.c **** }
 4309              		.loc 1 1506 0
 4310 00b2 181C     		mov	r0, r3
 4311 00b4 BD46     		mov	sp, r7
 4312 00b6 04B0     		add	sp, sp, #16
 4313              		@ sp needed for prologue
 4314 00b8 80BD     		pop	{r7, pc}
 4315              		.cfi_endproc
 4316              	.LFE39:
 4318 00ba C046     		.section	.text._Z25UTIL0_ScanDecimal8sNumberPPKhPa,"ax",%progbits
 4319              		.align	2
 4320              		.global	_Z25UTIL0_ScanDecimal8sNumberPPKhPa
 4321              		.code	16
 4322              		.thumb_func
 4324              	_Z25UTIL0_ScanDecimal8sNumberPPKhPa:
 4325              	.LFB40:
1507:../Generated_Code/UTIL0.c **** 
1508:../Generated_Code/UTIL0.c **** /*
1509:../Generated_Code/UTIL0.c **** ** ===================================================================
1510:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal8sNumber (component Utility)
1511:../Generated_Code/UTIL0.c **** **     Description :
1512:../Generated_Code/UTIL0.c **** **         Scans a decimal 8bit signed number
1513:../Generated_Code/UTIL0.c **** **     Parameters  :
1514:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1515:../Generated_Code/UTIL0.c **** **         str             - String to scan. It returns as well until
1516:../Generated_Code/UTIL0.c **** **                           where it has scanned
1517:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1518:../Generated_Code/UTIL0.c **** **     Returns     :
1519:../Generated_Code/UTIL0.c **** **         ---             - Error code
1520:../Generated_Code/UTIL0.c **** ** ===================================================================
1521:../Generated_Code/UTIL0.c **** */
1522:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal8sNumber(const unsigned char **str, signed char *val)
1523:../Generated_Code/UTIL0.c **** {
 4326              		.loc 1 1523 0
 4327              		.cfi_startproc
 4328 0000 90B5     		push	{r4, r7, lr}
 4329              	.LCFI105:
 4330              		.cfi_def_cfa_offset 12
 4331              		.cfi_offset 4, -12
 4332              		.cfi_offset 7, -8
 4333              		.cfi_offset 14, -4
 4334 0002 87B0     		sub	sp, sp, #28
 4335              	.LCFI106:
 4336              		.cfi_def_cfa_offset 40
 4337 0004 00AF     		add	r7, sp, #0
 4338              	.LCFI107:
 4339              		.cfi_def_cfa_register 7
 4340 0006 7860     		str	r0, [r7, #4]
 4341 0008 3960     		str	r1, [r7]
 4342              	.LBB27:
1524:../Generated_Code/UTIL0.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1525:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4343              		.loc 1 1525 0
 4344 000a 7B68     		ldr	r3, [r7, #4]
 4345 000c 1B68     		ldr	r3, [r3]
 4346 000e 3B61     		str	r3, [r7, #16]
1526:../Generated_Code/UTIL0.c ****   bool isNeg;
1527:../Generated_Code/UTIL0.c ****   uint8_t val8u;
1528:../Generated_Code/UTIL0.c ****   uint8_t res;
1529:../Generated_Code/UTIL0.c **** 
1530:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4347              		.loc 1 1530 0
 4348 0010 02E0     		b	.L213
 4349              	.L214:
1531:../Generated_Code/UTIL0.c ****     p++;
 4350              		.loc 1 1531 0
 4351 0012 3B69     		ldr	r3, [r7, #16]
 4352 0014 0133     		add	r3, r3, #1
 4353 0016 3B61     		str	r3, [r7, #16]
 4354              	.L213:
1530:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4355              		.loc 1 1530 0
 4356 0018 3B69     		ldr	r3, [r7, #16]
 4357 001a 1B78     		ldrb	r3, [r3]
 4358 001c 203B     		sub	r3, r3, #32
 4359 001e 5A42     		neg	r2, r3
 4360 0020 5341     		adc	r3, r3, r2
 4361 0022 DBB2     		uxtb	r3, r3
 4362 0024 002B     		cmp	r3, #0
 4363 0026 F4D1     		bne	.L214
1532:../Generated_Code/UTIL0.c ****   }
1533:../Generated_Code/UTIL0.c ****   *val = 0;
 4364              		.loc 1 1533 0
 4365 0028 3B68     		ldr	r3, [r7]
 4366 002a 0022     		mov	r2, #0
 4367 002c 1A70     		strb	r2, [r3]
1534:../Generated_Code/UTIL0.c ****   if (*p=='-') {
 4368              		.loc 1 1534 0
 4369 002e 3B69     		ldr	r3, [r7, #16]
 4370 0030 1B78     		ldrb	r3, [r3]
 4371 0032 2D2B     		cmp	r3, #45
 4372 0034 07D1     		bne	.L215
1535:../Generated_Code/UTIL0.c ****     isNeg = TRUE;
 4373              		.loc 1 1535 0
 4374 0036 3B1C     		mov	r3, r7
 4375 0038 1733     		add	r3, r3, #23
 4376 003a 0122     		mov	r2, #1
 4377 003c 1A70     		strb	r2, [r3]
1536:../Generated_Code/UTIL0.c ****     p++; /* skip minus */
 4378              		.loc 1 1536 0
 4379 003e 3B69     		ldr	r3, [r7, #16]
 4380 0040 0133     		add	r3, r3, #1
 4381 0042 3B61     		str	r3, [r7, #16]
 4382 0044 03E0     		b	.L216
 4383              	.L215:
1537:../Generated_Code/UTIL0.c ****   } else {
1538:../Generated_Code/UTIL0.c ****     isNeg = FALSE;
 4384              		.loc 1 1538 0
 4385 0046 3B1C     		mov	r3, r7
 4386 0048 1733     		add	r3, r3, #23
 4387 004a 0022     		mov	r2, #0
 4388 004c 1A70     		strb	r2, [r3]
 4389              	.L216:
1539:../Generated_Code/UTIL0.c ****   }
1540:../Generated_Code/UTIL0.c ****   res = UTIL0_ScanDecimal8uNumber(&p, &val8u);
 4390              		.loc 1 1540 0
 4391 004e 3C1C     		mov	r4, r7
 4392 0050 1634     		add	r4, r4, #22
 4393 0052 3A1C     		mov	r2, r7
 4394 0054 1032     		add	r2, r2, #16
 4395 0056 3B1C     		mov	r3, r7
 4396 0058 0F33     		add	r3, r3, #15
 4397 005a 101C     		mov	r0, r2
 4398 005c 191C     		mov	r1, r3
 4399 005e FFF7FEFF 		bl	_Z25UTIL0_ScanDecimal8uNumberPPKhPh
 4400 0062 031C     		mov	r3, r0
 4401 0064 2370     		strb	r3, [r4]
1541:../Generated_Code/UTIL0.c ****   if (res != ERR_OK) {
 4402              		.loc 1 1541 0
 4403 0066 3B1C     		mov	r3, r7
 4404 0068 1633     		add	r3, r3, #22
 4405 006a 1B78     		ldrb	r3, [r3]
 4406 006c 002B     		cmp	r3, #0
 4407 006e 03D0     		beq	.L217
1542:../Generated_Code/UTIL0.c ****     return res;
 4408              		.loc 1 1542 0
 4409 0070 3B1C     		mov	r3, r7
 4410 0072 1633     		add	r3, r3, #22
 4411 0074 1B78     		ldrb	r3, [r3]
 4412 0076 17E0     		b	.L221
 4413              	.L217:
1543:../Generated_Code/UTIL0.c ****   }
1544:../Generated_Code/UTIL0.c ****   if (isNeg) {
 4414              		.loc 1 1544 0
 4415 0078 3B1C     		mov	r3, r7
 4416 007a 1733     		add	r3, r3, #23
 4417 007c 1B78     		ldrb	r3, [r3]
 4418 007e 002B     		cmp	r3, #0
 4419 0080 08D0     		beq	.L219
1545:../Generated_Code/UTIL0.c ****     *val = - (int8_t)val8u;
 4420              		.loc 1 1545 0
 4421 0082 3B1C     		mov	r3, r7
 4422 0084 0F33     		add	r3, r3, #15
 4423 0086 1B78     		ldrb	r3, [r3]
 4424 0088 5B42     		neg	r3, r3
 4425 008a DBB2     		uxtb	r3, r3
 4426 008c DAB2     		uxtb	r2, r3
 4427 008e 3B68     		ldr	r3, [r7]
 4428 0090 1A70     		strb	r2, [r3]
 4429 0092 05E0     		b	.L220
 4430              	.L219:
1546:../Generated_Code/UTIL0.c ****   } else {
1547:../Generated_Code/UTIL0.c ****     *val = (int8_t)val8u;
 4431              		.loc 1 1547 0
 4432 0094 3B1C     		mov	r3, r7
 4433 0096 0F33     		add	r3, r3, #15
 4434 0098 1B78     		ldrb	r3, [r3]
 4435 009a DAB2     		uxtb	r2, r3
 4436 009c 3B68     		ldr	r3, [r7]
 4437 009e 1A70     		strb	r2, [r3]
 4438              	.L220:
1548:../Generated_Code/UTIL0.c ****   }
1549:../Generated_Code/UTIL0.c ****   *str = p;
 4439              		.loc 1 1549 0
 4440 00a0 3A69     		ldr	r2, [r7, #16]
 4441 00a2 7B68     		ldr	r3, [r7, #4]
 4442 00a4 1A60     		str	r2, [r3]
1550:../Generated_Code/UTIL0.c ****   return ERR_OK;
 4443              		.loc 1 1550 0
 4444 00a6 0023     		mov	r3, #0
 4445              	.L221:
 4446              	.LBE27:
1551:../Generated_Code/UTIL0.c **** }
 4447              		.loc 1 1551 0
 4448 00a8 181C     		mov	r0, r3
 4449 00aa BD46     		mov	sp, r7
 4450 00ac 07B0     		add	sp, sp, #28
 4451              		@ sp needed for prologue
 4452 00ae 90BD     		pop	{r4, r7, pc}
 4453              		.cfi_endproc
 4454              	.LFE40:
 4456              		.section	.text._Z26UTIL0_ScanDecimal16uNumberPPKhPt,"ax",%progbits
 4457              		.align	2
 4458              		.global	_Z26UTIL0_ScanDecimal16uNumberPPKhPt
 4459              		.code	16
 4460              		.thumb_func
 4462              	_Z26UTIL0_ScanDecimal16uNumberPPKhPt:
 4463              	.LFB41:
1552:../Generated_Code/UTIL0.c **** 
1553:../Generated_Code/UTIL0.c **** /*
1554:../Generated_Code/UTIL0.c **** ** ===================================================================
1555:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal16uNumber (component Utility)
1556:../Generated_Code/UTIL0.c **** **     Description :
1557:../Generated_Code/UTIL0.c **** **         Scans a decimal 16bit unsigned number
1558:../Generated_Code/UTIL0.c **** **     Parameters  :
1559:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1560:../Generated_Code/UTIL0.c **** **         str             - String to scan. It returns as well until
1561:../Generated_Code/UTIL0.c **** **                           where it has scanned
1562:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1563:../Generated_Code/UTIL0.c **** **     Returns     :
1564:../Generated_Code/UTIL0.c **** **         ---             - Error code
1565:../Generated_Code/UTIL0.c **** ** ===================================================================
1566:../Generated_Code/UTIL0.c **** */
1567:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal16uNumber(const unsigned char **str, word *val)
1568:../Generated_Code/UTIL0.c **** {
 4464              		.loc 1 1568 0
 4465              		.cfi_startproc
 4466 0000 80B5     		push	{r7, lr}
 4467              	.LCFI108:
 4468              		.cfi_def_cfa_offset 8
 4469              		.cfi_offset 7, -8
 4470              		.cfi_offset 14, -4
 4471 0002 84B0     		sub	sp, sp, #16
 4472              	.LCFI109:
 4473              		.cfi_def_cfa_offset 24
 4474 0004 00AF     		add	r7, sp, #0
 4475              	.LCFI110:
 4476              		.cfi_def_cfa_register 7
 4477 0006 7860     		str	r0, [r7, #4]
 4478 0008 3960     		str	r1, [r7]
 4479              	.LBB28:
1569:../Generated_Code/UTIL0.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1570:../Generated_Code/UTIL0.c ****   #define _16_NOF_DIGITS  (5+1)
1571:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4480              		.loc 1 1571 0
 4481 000a 3B1C     		mov	r3, r7
 4482 000c 0F33     		add	r3, r3, #15
 4483 000e 0622     		mov	r2, #6
 4484 0010 1A70     		strb	r2, [r3]
1572:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4485              		.loc 1 1572 0
 4486 0012 7B68     		ldr	r3, [r7, #4]
 4487 0014 1B68     		ldr	r3, [r3]
 4488 0016 BB60     		str	r3, [r7, #8]
1573:../Generated_Code/UTIL0.c **** 
1574:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4489              		.loc 1 1574 0
 4490 0018 02E0     		b	.L223
 4491              	.L224:
1575:../Generated_Code/UTIL0.c ****     p++;
 4492              		.loc 1 1575 0
 4493 001a BB68     		ldr	r3, [r7, #8]
 4494 001c 0133     		add	r3, r3, #1
 4495 001e BB60     		str	r3, [r7, #8]
 4496              	.L223:
1574:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4497              		.loc 1 1574 0
 4498 0020 BB68     		ldr	r3, [r7, #8]
 4499 0022 1B78     		ldrb	r3, [r3]
 4500 0024 203B     		sub	r3, r3, #32
 4501 0026 5A42     		neg	r2, r3
 4502 0028 5341     		adc	r3, r3, r2
 4503 002a DBB2     		uxtb	r3, r3
 4504 002c 002B     		cmp	r3, #0
 4505 002e F4D1     		bne	.L224
1576:../Generated_Code/UTIL0.c ****   }
1577:../Generated_Code/UTIL0.c ****   *val = 0;
 4506              		.loc 1 1577 0
 4507 0030 3B68     		ldr	r3, [r7]
 4508 0032 0022     		mov	r2, #0
 4509 0034 1A80     		strh	r2, [r3]
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4510              		.loc 1 1578 0
 4511 0036 18E0     		b	.L225
 4512              	.L228:
1579:../Generated_Code/UTIL0.c ****     *val = (uint16_t)((*val)*10 + *p-'0');
 4513              		.loc 1 1579 0
 4514 0038 3B68     		ldr	r3, [r7]
 4515 003a 1B88     		ldrh	r3, [r3]
 4516 003c 1A1C     		add	r2, r3, #0
 4517 003e 9200     		lsl	r2, r2, #2
 4518 0040 D318     		add	r3, r2, r3
 4519 0042 5B00     		lsl	r3, r3, #1
 4520 0044 9AB2     		uxth	r2, r3
 4521 0046 BB68     		ldr	r3, [r7, #8]
 4522 0048 1B78     		ldrb	r3, [r3]
 4523 004a D318     		add	r3, r2, r3
 4524 004c 9BB2     		uxth	r3, r3
 4525 004e 303B     		sub	r3, r3, #48
 4526 0050 9AB2     		uxth	r2, r3
 4527 0052 3B68     		ldr	r3, [r7]
 4528 0054 1A80     		strh	r2, [r3]
1580:../Generated_Code/UTIL0.c ****     nofDigits--;
 4529              		.loc 1 1580 0
 4530 0056 3B1C     		mov	r3, r7
 4531 0058 0F33     		add	r3, r3, #15
 4532 005a 3A1C     		mov	r2, r7
 4533 005c 0F32     		add	r2, r2, #15
 4534 005e 1278     		ldrb	r2, [r2]
 4535 0060 013A     		sub	r2, r2, #1
 4536 0062 1A70     		strb	r2, [r3]
1581:../Generated_Code/UTIL0.c ****     p++;
 4537              		.loc 1 1581 0
 4538 0064 BB68     		ldr	r3, [r7, #8]
 4539 0066 0133     		add	r3, r3, #1
 4540 0068 BB60     		str	r3, [r7, #8]
 4541              	.L225:
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4542              		.loc 1 1578 0
 4543 006a BB68     		ldr	r3, [r7, #8]
 4544 006c 1B78     		ldrb	r3, [r3]
 4545 006e 2F2B     		cmp	r3, #47
 4546 0070 0AD9     		bls	.L226
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4547              		.loc 1 1578 0 is_stmt 0
 4548 0072 BB68     		ldr	r3, [r7, #8]
 4549 0074 1B78     		ldrb	r3, [r3]
 4550 0076 392B     		cmp	r3, #57
 4551 0078 06D8     		bhi	.L226
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4552              		.loc 1 1578 0
 4553 007a 3B1C     		mov	r3, r7
 4554 007c 0F33     		add	r3, r3, #15
 4555 007e 1B78     		ldrb	r3, [r3]
 4556 0080 002B     		cmp	r3, #0
 4557 0082 01D0     		beq	.L226
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4558              		.loc 1 1578 0
 4559 0084 0123     		mov	r3, #1
 4560 0086 00E0     		b	.L227
 4561              	.L226:
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4562              		.loc 1 1578 0
 4563 0088 0023     		mov	r3, #0
 4564              	.L227:
1578:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4565              		.loc 1 1578 0
 4566 008a 002B     		cmp	r3, #0
 4567 008c D4D1     		bne	.L228
1582:../Generated_Code/UTIL0.c ****   } /* while */
1583:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 4568              		.loc 1 1583 0 is_stmt 1
 4569 008e 3B1C     		mov	r3, r7
 4570 0090 0F33     		add	r3, r3, #15
 4571 0092 1B78     		ldrb	r3, [r3]
 4572 0094 002B     		cmp	r3, #0
 4573 0096 01D1     		bne	.L229
1584:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 4574              		.loc 1 1584 0
 4575 0098 0423     		mov	r3, #4
 4576 009a 0AE0     		b	.L230
 4577              	.L229:
1585:../Generated_Code/UTIL0.c ****   }
1586:../Generated_Code/UTIL0.c ****   if (nofDigits==_16_NOF_DIGITS) { /* no digits at all? */
 4578              		.loc 1 1586 0
 4579 009c 3B1C     		mov	r3, r7
 4580 009e 0F33     		add	r3, r3, #15
 4581 00a0 1B78     		ldrb	r3, [r3]
 4582 00a2 062B     		cmp	r3, #6
 4583 00a4 01D1     		bne	.L231
1587:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 4584              		.loc 1 1587 0
 4585 00a6 1B23     		mov	r3, #27
 4586 00a8 03E0     		b	.L230
 4587              	.L231:
1588:../Generated_Code/UTIL0.c ****   }
1589:../Generated_Code/UTIL0.c ****   *str = p;
 4588              		.loc 1 1589 0
 4589 00aa 7B68     		ldr	r3, [r7, #4]
 4590 00ac BA68     		ldr	r2, [r7, #8]
 4591 00ae 1A60     		str	r2, [r3]
1590:../Generated_Code/UTIL0.c ****   return ERR_OK;
 4592              		.loc 1 1590 0
 4593 00b0 0023     		mov	r3, #0
 4594              	.L230:
 4595              	.LBE28:
1591:../Generated_Code/UTIL0.c **** }
 4596              		.loc 1 1591 0
 4597 00b2 181C     		mov	r0, r3
 4598 00b4 BD46     		mov	sp, r7
 4599 00b6 04B0     		add	sp, sp, #16
 4600              		@ sp needed for prologue
 4601 00b8 80BD     		pop	{r7, pc}
 4602              		.cfi_endproc
 4603              	.LFE41:
 4605 00ba C046     		.section	.text._Z26UTIL0_ScanDecimal16sNumberPPKhPs,"ax",%progbits
 4606              		.align	2
 4607              		.global	_Z26UTIL0_ScanDecimal16sNumberPPKhPs
 4608              		.code	16
 4609              		.thumb_func
 4611              	_Z26UTIL0_ScanDecimal16sNumberPPKhPs:
 4612              	.LFB42:
1592:../Generated_Code/UTIL0.c **** 
1593:../Generated_Code/UTIL0.c **** /*
1594:../Generated_Code/UTIL0.c **** ** ===================================================================
1595:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal16sNumber (component Utility)
1596:../Generated_Code/UTIL0.c **** **     Description :
1597:../Generated_Code/UTIL0.c **** **         Scans a decimal 16bit signed number
1598:../Generated_Code/UTIL0.c **** **     Parameters  :
1599:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1600:../Generated_Code/UTIL0.c **** **         str             - String to scan. It returns as well until
1601:../Generated_Code/UTIL0.c **** **                           where it has scanned
1602:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1603:../Generated_Code/UTIL0.c **** **     Returns     :
1604:../Generated_Code/UTIL0.c **** **         ---             - Error code
1605:../Generated_Code/UTIL0.c **** ** ===================================================================
1606:../Generated_Code/UTIL0.c **** */
1607:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal16sNumber(const unsigned char **str, int16_t *val)
1608:../Generated_Code/UTIL0.c **** {
 4613              		.loc 1 1608 0
 4614              		.cfi_startproc
 4615 0000 90B5     		push	{r4, r7, lr}
 4616              	.LCFI111:
 4617              		.cfi_def_cfa_offset 12
 4618              		.cfi_offset 4, -12
 4619              		.cfi_offset 7, -8
 4620              		.cfi_offset 14, -4
 4621 0002 87B0     		sub	sp, sp, #28
 4622              	.LCFI112:
 4623              		.cfi_def_cfa_offset 40
 4624 0004 00AF     		add	r7, sp, #0
 4625              	.LCFI113:
 4626              		.cfi_def_cfa_register 7
 4627 0006 7860     		str	r0, [r7, #4]
 4628 0008 3960     		str	r1, [r7]
 4629              	.LBB29:
1609:../Generated_Code/UTIL0.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1610:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4630              		.loc 1 1610 0
 4631 000a 7B68     		ldr	r3, [r7, #4]
 4632 000c 1B68     		ldr	r3, [r3]
 4633 000e 3B61     		str	r3, [r7, #16]
1611:../Generated_Code/UTIL0.c ****   bool isNeg;
1612:../Generated_Code/UTIL0.c ****   uint16_t val16u;
1613:../Generated_Code/UTIL0.c ****   uint8_t res;
1614:../Generated_Code/UTIL0.c **** 
1615:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4634              		.loc 1 1615 0
 4635 0010 02E0     		b	.L233
 4636              	.L234:
1616:../Generated_Code/UTIL0.c ****     p++;
 4637              		.loc 1 1616 0
 4638 0012 3B69     		ldr	r3, [r7, #16]
 4639 0014 0133     		add	r3, r3, #1
 4640 0016 3B61     		str	r3, [r7, #16]
 4641              	.L233:
1615:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4642              		.loc 1 1615 0
 4643 0018 3B69     		ldr	r3, [r7, #16]
 4644 001a 1B78     		ldrb	r3, [r3]
 4645 001c 203B     		sub	r3, r3, #32
 4646 001e 5A42     		neg	r2, r3
 4647 0020 5341     		adc	r3, r3, r2
 4648 0022 DBB2     		uxtb	r3, r3
 4649 0024 002B     		cmp	r3, #0
 4650 0026 F4D1     		bne	.L234
1617:../Generated_Code/UTIL0.c ****   }
1618:../Generated_Code/UTIL0.c ****   *val = 0;
 4651              		.loc 1 1618 0
 4652 0028 3B68     		ldr	r3, [r7]
 4653 002a 0022     		mov	r2, #0
 4654 002c 1A80     		strh	r2, [r3]
1619:../Generated_Code/UTIL0.c ****   if (*p=='-') {
 4655              		.loc 1 1619 0
 4656 002e 3B69     		ldr	r3, [r7, #16]
 4657 0030 1B78     		ldrb	r3, [r3]
 4658 0032 2D2B     		cmp	r3, #45
 4659 0034 07D1     		bne	.L235
1620:../Generated_Code/UTIL0.c ****     isNeg = TRUE;
 4660              		.loc 1 1620 0
 4661 0036 3B1C     		mov	r3, r7
 4662 0038 1733     		add	r3, r3, #23
 4663 003a 0122     		mov	r2, #1
 4664 003c 1A70     		strb	r2, [r3]
1621:../Generated_Code/UTIL0.c ****     p++; /* skip minus */
 4665              		.loc 1 1621 0
 4666 003e 3B69     		ldr	r3, [r7, #16]
 4667 0040 0133     		add	r3, r3, #1
 4668 0042 3B61     		str	r3, [r7, #16]
 4669 0044 03E0     		b	.L236
 4670              	.L235:
1622:../Generated_Code/UTIL0.c ****   } else {
1623:../Generated_Code/UTIL0.c ****     isNeg = FALSE;
 4671              		.loc 1 1623 0
 4672 0046 3B1C     		mov	r3, r7
 4673 0048 1733     		add	r3, r3, #23
 4674 004a 0022     		mov	r2, #0
 4675 004c 1A70     		strb	r2, [r3]
 4676              	.L236:
1624:../Generated_Code/UTIL0.c ****   }
1625:../Generated_Code/UTIL0.c ****   res = UTIL0_ScanDecimal16uNumber(&p, (word*)&val16u);
 4677              		.loc 1 1625 0
 4678 004e 3C1C     		mov	r4, r7
 4679 0050 1634     		add	r4, r4, #22
 4680 0052 3A1C     		mov	r2, r7
 4681 0054 1032     		add	r2, r2, #16
 4682 0056 3B1C     		mov	r3, r7
 4683 0058 0E33     		add	r3, r3, #14
 4684 005a 101C     		mov	r0, r2
 4685 005c 191C     		mov	r1, r3
 4686 005e FFF7FEFF 		bl	_Z26UTIL0_ScanDecimal16uNumberPPKhPt
 4687 0062 031C     		mov	r3, r0
 4688 0064 2370     		strb	r3, [r4]
1626:../Generated_Code/UTIL0.c ****   if (res != ERR_OK) {
 4689              		.loc 1 1626 0
 4690 0066 3B1C     		mov	r3, r7
 4691 0068 1633     		add	r3, r3, #22
 4692 006a 1B78     		ldrb	r3, [r3]
 4693 006c 002B     		cmp	r3, #0
 4694 006e 03D0     		beq	.L237
1627:../Generated_Code/UTIL0.c ****     return res;
 4695              		.loc 1 1627 0
 4696 0070 3B1C     		mov	r3, r7
 4697 0072 1633     		add	r3, r3, #22
 4698 0074 1B78     		ldrb	r3, [r3]
 4699 0076 17E0     		b	.L241
 4700              	.L237:
1628:../Generated_Code/UTIL0.c ****   }
1629:../Generated_Code/UTIL0.c ****   if (isNeg) {
 4701              		.loc 1 1629 0
 4702 0078 3B1C     		mov	r3, r7
 4703 007a 1733     		add	r3, r3, #23
 4704 007c 1B78     		ldrb	r3, [r3]
 4705 007e 002B     		cmp	r3, #0
 4706 0080 08D0     		beq	.L239
1630:../Generated_Code/UTIL0.c ****     *val = - (int16_t)val16u;
 4707              		.loc 1 1630 0
 4708 0082 3B1C     		mov	r3, r7
 4709 0084 0E33     		add	r3, r3, #14
 4710 0086 1B88     		ldrh	r3, [r3]
 4711 0088 5B42     		neg	r3, r3
 4712 008a 9BB2     		uxth	r3, r3
 4713 008c 9AB2     		uxth	r2, r3
 4714 008e 3B68     		ldr	r3, [r7]
 4715 0090 1A80     		strh	r2, [r3]
 4716 0092 05E0     		b	.L240
 4717              	.L239:
1631:../Generated_Code/UTIL0.c ****   } else {
1632:../Generated_Code/UTIL0.c ****     *val = (int16_t)val16u;
 4718              		.loc 1 1632 0
 4719 0094 3B1C     		mov	r3, r7
 4720 0096 0E33     		add	r3, r3, #14
 4721 0098 1B88     		ldrh	r3, [r3]
 4722 009a 9AB2     		uxth	r2, r3
 4723 009c 3B68     		ldr	r3, [r7]
 4724 009e 1A80     		strh	r2, [r3]
 4725              	.L240:
1633:../Generated_Code/UTIL0.c ****   }
1634:../Generated_Code/UTIL0.c ****   *str = p;
 4726              		.loc 1 1634 0
 4727 00a0 3A69     		ldr	r2, [r7, #16]
 4728 00a2 7B68     		ldr	r3, [r7, #4]
 4729 00a4 1A60     		str	r2, [r3]
1635:../Generated_Code/UTIL0.c ****   return ERR_OK;
 4730              		.loc 1 1635 0
 4731 00a6 0023     		mov	r3, #0
 4732              	.L241:
 4733              	.LBE29:
1636:../Generated_Code/UTIL0.c **** }
 4734              		.loc 1 1636 0
 4735 00a8 181C     		mov	r0, r3
 4736 00aa BD46     		mov	sp, r7
 4737 00ac 07B0     		add	sp, sp, #28
 4738              		@ sp needed for prologue
 4739 00ae 90BD     		pop	{r4, r7, pc}
 4740              		.cfi_endproc
 4741              	.LFE42:
 4743              		.section	.text._Z26UTIL0_ScanDecimal32uNumberPPKhPm,"ax",%progbits
 4744              		.align	2
 4745              		.global	_Z26UTIL0_ScanDecimal32uNumberPPKhPm
 4746              		.code	16
 4747              		.thumb_func
 4749              	_Z26UTIL0_ScanDecimal32uNumberPPKhPm:
 4750              	.LFB43:
1637:../Generated_Code/UTIL0.c **** 
1638:../Generated_Code/UTIL0.c **** /*
1639:../Generated_Code/UTIL0.c **** ** ===================================================================
1640:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal32uNumber (component Utility)
1641:../Generated_Code/UTIL0.c **** **     Description :
1642:../Generated_Code/UTIL0.c **** **         Scans a decimal 32bit unsigned number
1643:../Generated_Code/UTIL0.c **** **     Parameters  :
1644:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1645:../Generated_Code/UTIL0.c **** **         str             - string to scan. It returns as well until
1646:../Generated_Code/UTIL0.c **** **                           where it has scanned
1647:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1648:../Generated_Code/UTIL0.c **** **     Returns     :
1649:../Generated_Code/UTIL0.c **** **         ---             - Error code
1650:../Generated_Code/UTIL0.c **** ** ===================================================================
1651:../Generated_Code/UTIL0.c **** */
1652:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal32uNumber(const unsigned char **str, uint32_t *val)
1653:../Generated_Code/UTIL0.c **** {
 4751              		.loc 1 1653 0
 4752              		.cfi_startproc
 4753 0000 80B5     		push	{r7, lr}
 4754              	.LCFI114:
 4755              		.cfi_def_cfa_offset 8
 4756              		.cfi_offset 7, -8
 4757              		.cfi_offset 14, -4
 4758 0002 84B0     		sub	sp, sp, #16
 4759              	.LCFI115:
 4760              		.cfi_def_cfa_offset 24
 4761 0004 00AF     		add	r7, sp, #0
 4762              	.LCFI116:
 4763              		.cfi_def_cfa_register 7
 4764 0006 7860     		str	r0, [r7, #4]
 4765 0008 3960     		str	r1, [r7]
 4766              	.LBB30:
1654:../Generated_Code/UTIL0.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1655:../Generated_Code/UTIL0.c ****   #define _32_NOF_DIGITS  (10+1)
1656:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4767              		.loc 1 1656 0
 4768 000a 3B1C     		mov	r3, r7
 4769 000c 0F33     		add	r3, r3, #15
 4770 000e 0B22     		mov	r2, #11
 4771 0010 1A70     		strb	r2, [r3]
1657:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4772              		.loc 1 1657 0
 4773 0012 7B68     		ldr	r3, [r7, #4]
 4774 0014 1B68     		ldr	r3, [r3]
 4775 0016 BB60     		str	r3, [r7, #8]
1658:../Generated_Code/UTIL0.c **** 
1659:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4776              		.loc 1 1659 0
 4777 0018 02E0     		b	.L243
 4778              	.L244:
1660:../Generated_Code/UTIL0.c ****     p++;
 4779              		.loc 1 1660 0
 4780 001a BB68     		ldr	r3, [r7, #8]
 4781 001c 0133     		add	r3, r3, #1
 4782 001e BB60     		str	r3, [r7, #8]
 4783              	.L243:
1659:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4784              		.loc 1 1659 0
 4785 0020 BB68     		ldr	r3, [r7, #8]
 4786 0022 1B78     		ldrb	r3, [r3]
 4787 0024 203B     		sub	r3, r3, #32
 4788 0026 5A42     		neg	r2, r3
 4789 0028 5341     		adc	r3, r3, r2
 4790 002a DBB2     		uxtb	r3, r3
 4791 002c 002B     		cmp	r3, #0
 4792 002e F4D1     		bne	.L244
1661:../Generated_Code/UTIL0.c ****   }
1662:../Generated_Code/UTIL0.c ****   *val = 0;
 4793              		.loc 1 1662 0
 4794 0030 3B68     		ldr	r3, [r7]
 4795 0032 0022     		mov	r2, #0
 4796 0034 1A60     		str	r2, [r3]
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4797              		.loc 1 1663 0
 4798 0036 17E0     		b	.L245
 4799              	.L248:
1664:../Generated_Code/UTIL0.c ****     *val = (uint32_t)((*val)*10 + *p-'0');
 4800              		.loc 1 1664 0
 4801 0038 3B68     		ldr	r3, [r7]
 4802 003a 1A68     		ldr	r2, [r3]
 4803 003c 131C     		mov	r3, r2
 4804 003e 9B00     		lsl	r3, r3, #2
 4805 0040 9B18     		add	r3, r3, r2
 4806 0042 5B00     		lsl	r3, r3, #1
 4807 0044 1A1C     		mov	r2, r3
 4808 0046 BB68     		ldr	r3, [r7, #8]
 4809 0048 1B78     		ldrb	r3, [r3]
 4810 004a D318     		add	r3, r2, r3
 4811 004c 1A1C     		mov	r2, r3
 4812 004e 303A     		sub	r2, r2, #48
 4813 0050 3B68     		ldr	r3, [r7]
 4814 0052 1A60     		str	r2, [r3]
1665:../Generated_Code/UTIL0.c ****     nofDigits--;
 4815              		.loc 1 1665 0
 4816 0054 3B1C     		mov	r3, r7
 4817 0056 0F33     		add	r3, r3, #15
 4818 0058 3A1C     		mov	r2, r7
 4819 005a 0F32     		add	r2, r2, #15
 4820 005c 1278     		ldrb	r2, [r2]
 4821 005e 013A     		sub	r2, r2, #1
 4822 0060 1A70     		strb	r2, [r3]
1666:../Generated_Code/UTIL0.c ****     p++;
 4823              		.loc 1 1666 0
 4824 0062 BB68     		ldr	r3, [r7, #8]
 4825 0064 0133     		add	r3, r3, #1
 4826 0066 BB60     		str	r3, [r7, #8]
 4827              	.L245:
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4828              		.loc 1 1663 0
 4829 0068 BB68     		ldr	r3, [r7, #8]
 4830 006a 1B78     		ldrb	r3, [r3]
 4831 006c 2F2B     		cmp	r3, #47
 4832 006e 0AD9     		bls	.L246
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4833              		.loc 1 1663 0 is_stmt 0
 4834 0070 BB68     		ldr	r3, [r7, #8]
 4835 0072 1B78     		ldrb	r3, [r3]
 4836 0074 392B     		cmp	r3, #57
 4837 0076 06D8     		bhi	.L246
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4838              		.loc 1 1663 0
 4839 0078 3B1C     		mov	r3, r7
 4840 007a 0F33     		add	r3, r3, #15
 4841 007c 1B78     		ldrb	r3, [r3]
 4842 007e 002B     		cmp	r3, #0
 4843 0080 01D0     		beq	.L246
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4844              		.loc 1 1663 0
 4845 0082 0123     		mov	r3, #1
 4846 0084 00E0     		b	.L247
 4847              	.L246:
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4848              		.loc 1 1663 0
 4849 0086 0023     		mov	r3, #0
 4850              	.L247:
1663:../Generated_Code/UTIL0.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4851              		.loc 1 1663 0
 4852 0088 002B     		cmp	r3, #0
 4853 008a D5D1     		bne	.L248
1667:../Generated_Code/UTIL0.c ****   } /* while */
1668:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 4854              		.loc 1 1668 0 is_stmt 1
 4855 008c 3B1C     		mov	r3, r7
 4856 008e 0F33     		add	r3, r3, #15
 4857 0090 1B78     		ldrb	r3, [r3]
 4858 0092 002B     		cmp	r3, #0
 4859 0094 01D1     		bne	.L249
1669:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 4860              		.loc 1 1669 0
 4861 0096 0423     		mov	r3, #4
 4862 0098 0AE0     		b	.L250
 4863              	.L249:
1670:../Generated_Code/UTIL0.c ****   }
1671:../Generated_Code/UTIL0.c ****   if (nofDigits==_32_NOF_DIGITS) { /* no digits at all? */
 4864              		.loc 1 1671 0
 4865 009a 3B1C     		mov	r3, r7
 4866 009c 0F33     		add	r3, r3, #15
 4867 009e 1B78     		ldrb	r3, [r3]
 4868 00a0 0B2B     		cmp	r3, #11
 4869 00a2 01D1     		bne	.L251
1672:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 4870              		.loc 1 1672 0
 4871 00a4 1B23     		mov	r3, #27
 4872 00a6 03E0     		b	.L250
 4873              	.L251:
1673:../Generated_Code/UTIL0.c ****   }
1674:../Generated_Code/UTIL0.c ****   *str = p;
 4874              		.loc 1 1674 0
 4875 00a8 7B68     		ldr	r3, [r7, #4]
 4876 00aa BA68     		ldr	r2, [r7, #8]
 4877 00ac 1A60     		str	r2, [r3]
1675:../Generated_Code/UTIL0.c ****   return ERR_OK;
 4878              		.loc 1 1675 0
 4879 00ae 0023     		mov	r3, #0
 4880              	.L250:
 4881              	.LBE30:
1676:../Generated_Code/UTIL0.c **** }
 4882              		.loc 1 1676 0
 4883 00b0 181C     		mov	r0, r3
 4884 00b2 BD46     		mov	sp, r7
 4885 00b4 04B0     		add	sp, sp, #16
 4886              		@ sp needed for prologue
 4887 00b6 80BD     		pop	{r7, pc}
 4888              		.cfi_endproc
 4889              	.LFE43:
 4891              		.section	.text._Z26UTIL0_ScanDecimal32sNumberPPKhPm,"ax",%progbits
 4892              		.align	2
 4893              		.global	_Z26UTIL0_ScanDecimal32sNumberPPKhPm
 4894              		.code	16
 4895              		.thumb_func
 4897              	_Z26UTIL0_ScanDecimal32sNumberPPKhPm:
 4898              	.LFB44:
1677:../Generated_Code/UTIL0.c **** 
1678:../Generated_Code/UTIL0.c **** /*
1679:../Generated_Code/UTIL0.c **** ** ===================================================================
1680:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanDecimal32sNumber (component Utility)
1681:../Generated_Code/UTIL0.c **** **     Description :
1682:../Generated_Code/UTIL0.c **** **         Scans a decimal 32bit signed number
1683:../Generated_Code/UTIL0.c **** **     Parameters  :
1684:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1685:../Generated_Code/UTIL0.c **** **         str             - string to scan. It returns as well until
1686:../Generated_Code/UTIL0.c **** **                           where it has scanned
1687:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1688:../Generated_Code/UTIL0.c **** **     Returns     :
1689:../Generated_Code/UTIL0.c **** **         ---             - Error code
1690:../Generated_Code/UTIL0.c **** ** ===================================================================
1691:../Generated_Code/UTIL0.c **** */
1692:../Generated_Code/UTIL0.c **** byte UTIL0_ScanDecimal32sNumber(const unsigned char **str, uint32_t *val)
1693:../Generated_Code/UTIL0.c **** {
 4899              		.loc 1 1693 0
 4900              		.cfi_startproc
 4901 0000 90B5     		push	{r4, r7, lr}
 4902              	.LCFI117:
 4903              		.cfi_def_cfa_offset 12
 4904              		.cfi_offset 4, -12
 4905              		.cfi_offset 7, -8
 4906              		.cfi_offset 14, -4
 4907 0002 87B0     		sub	sp, sp, #28
 4908              	.LCFI118:
 4909              		.cfi_def_cfa_offset 40
 4910 0004 00AF     		add	r7, sp, #0
 4911              	.LCFI119:
 4912              		.cfi_def_cfa_register 7
 4913 0006 7860     		str	r0, [r7, #4]
 4914 0008 3960     		str	r1, [r7]
 4915              	.LBB31:
1694:../Generated_Code/UTIL0.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1695:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 4916              		.loc 1 1695 0
 4917 000a 7B68     		ldr	r3, [r7, #4]
 4918 000c 1B68     		ldr	r3, [r3]
 4919 000e 3B61     		str	r3, [r7, #16]
1696:../Generated_Code/UTIL0.c ****   bool isNeg;
1697:../Generated_Code/UTIL0.c ****   uint32_t val32u;
1698:../Generated_Code/UTIL0.c ****   uint8_t res;
1699:../Generated_Code/UTIL0.c **** 
1700:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4920              		.loc 1 1700 0
 4921 0010 02E0     		b	.L253
 4922              	.L254:
1701:../Generated_Code/UTIL0.c ****     p++;
 4923              		.loc 1 1701 0
 4924 0012 3B69     		ldr	r3, [r7, #16]
 4925 0014 0133     		add	r3, r3, #1
 4926 0016 3B61     		str	r3, [r7, #16]
 4927              	.L253:
1700:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 4928              		.loc 1 1700 0
 4929 0018 3B69     		ldr	r3, [r7, #16]
 4930 001a 1B78     		ldrb	r3, [r3]
 4931 001c 203B     		sub	r3, r3, #32
 4932 001e 5A42     		neg	r2, r3
 4933 0020 5341     		adc	r3, r3, r2
 4934 0022 DBB2     		uxtb	r3, r3
 4935 0024 002B     		cmp	r3, #0
 4936 0026 F4D1     		bne	.L254
1702:../Generated_Code/UTIL0.c ****   }
1703:../Generated_Code/UTIL0.c ****   *val = 0;
 4937              		.loc 1 1703 0
 4938 0028 3B68     		ldr	r3, [r7]
 4939 002a 0022     		mov	r2, #0
 4940 002c 1A60     		str	r2, [r3]
1704:../Generated_Code/UTIL0.c ****   if (*p=='-') {
 4941              		.loc 1 1704 0
 4942 002e 3B69     		ldr	r3, [r7, #16]
 4943 0030 1B78     		ldrb	r3, [r3]
 4944 0032 2D2B     		cmp	r3, #45
 4945 0034 07D1     		bne	.L255
1705:../Generated_Code/UTIL0.c ****     isNeg = TRUE;
 4946              		.loc 1 1705 0
 4947 0036 3B1C     		mov	r3, r7
 4948 0038 1733     		add	r3, r3, #23
 4949 003a 0122     		mov	r2, #1
 4950 003c 1A70     		strb	r2, [r3]
1706:../Generated_Code/UTIL0.c ****     p++; /* skip minus */
 4951              		.loc 1 1706 0
 4952 003e 3B69     		ldr	r3, [r7, #16]
 4953 0040 0133     		add	r3, r3, #1
 4954 0042 3B61     		str	r3, [r7, #16]
 4955 0044 03E0     		b	.L256
 4956              	.L255:
1707:../Generated_Code/UTIL0.c ****   } else {
1708:../Generated_Code/UTIL0.c ****     isNeg = FALSE;
 4957              		.loc 1 1708 0
 4958 0046 3B1C     		mov	r3, r7
 4959 0048 1733     		add	r3, r3, #23
 4960 004a 0022     		mov	r2, #0
 4961 004c 1A70     		strb	r2, [r3]
 4962              	.L256:
1709:../Generated_Code/UTIL0.c ****   }
1710:../Generated_Code/UTIL0.c ****   res = UTIL0_ScanDecimal32uNumber(&p, &val32u);
 4963              		.loc 1 1710 0
 4964 004e 3C1C     		mov	r4, r7
 4965 0050 1634     		add	r4, r4, #22
 4966 0052 3A1C     		mov	r2, r7
 4967 0054 1032     		add	r2, r2, #16
 4968 0056 3B1C     		mov	r3, r7
 4969 0058 0C33     		add	r3, r3, #12
 4970 005a 101C     		mov	r0, r2
 4971 005c 191C     		mov	r1, r3
 4972 005e FFF7FEFF 		bl	_Z26UTIL0_ScanDecimal32uNumberPPKhPm
 4973 0062 031C     		mov	r3, r0
 4974 0064 2370     		strb	r3, [r4]
1711:../Generated_Code/UTIL0.c ****   if (res != ERR_OK) {
 4975              		.loc 1 1711 0
 4976 0066 3B1C     		mov	r3, r7
 4977 0068 1633     		add	r3, r3, #22
 4978 006a 1B78     		ldrb	r3, [r3]
 4979 006c 002B     		cmp	r3, #0
 4980 006e 03D0     		beq	.L257
1712:../Generated_Code/UTIL0.c ****     return res;
 4981              		.loc 1 1712 0
 4982 0070 3B1C     		mov	r3, r7
 4983 0072 1633     		add	r3, r3, #22
 4984 0074 1B78     		ldrb	r3, [r3]
 4985 0076 11E0     		b	.L261
 4986              	.L257:
1713:../Generated_Code/UTIL0.c ****   }
1714:../Generated_Code/UTIL0.c ****   if (isNeg) {
 4987              		.loc 1 1714 0
 4988 0078 3B1C     		mov	r3, r7
 4989 007a 1733     		add	r3, r3, #23
 4990 007c 1B78     		ldrb	r3, [r3]
 4991 007e 002B     		cmp	r3, #0
 4992 0080 05D0     		beq	.L259
1715:../Generated_Code/UTIL0.c ****     *val = (uint32_t)(-(int32_t)val32u);
 4993              		.loc 1 1715 0
 4994 0082 FB68     		ldr	r3, [r7, #12]
 4995 0084 5B42     		neg	r3, r3
 4996 0086 1A1C     		mov	r2, r3
 4997 0088 3B68     		ldr	r3, [r7]
 4998 008a 1A60     		str	r2, [r3]
 4999 008c 02E0     		b	.L260
 5000              	.L259:
1716:../Generated_Code/UTIL0.c ****   } else {
1717:../Generated_Code/UTIL0.c ****     *val = val32u;
 5001              		.loc 1 1717 0
 5002 008e FA68     		ldr	r2, [r7, #12]
 5003 0090 3B68     		ldr	r3, [r7]
 5004 0092 1A60     		str	r2, [r3]
 5005              	.L260:
1718:../Generated_Code/UTIL0.c ****   }
1719:../Generated_Code/UTIL0.c ****   *str = p;
 5006              		.loc 1 1719 0
 5007 0094 3A69     		ldr	r2, [r7, #16]
 5008 0096 7B68     		ldr	r3, [r7, #4]
 5009 0098 1A60     		str	r2, [r3]
1720:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5010              		.loc 1 1720 0
 5011 009a 0023     		mov	r3, #0
 5012              	.L261:
 5013              	.LBE31:
1721:../Generated_Code/UTIL0.c **** }
 5014              		.loc 1 1721 0
 5015 009c 181C     		mov	r0, r3
 5016 009e BD46     		mov	sp, r7
 5017 00a0 07B0     		add	sp, sp, #28
 5018              		@ sp needed for prologue
 5019 00a2 90BD     		pop	{r4, r7, pc}
 5020              		.cfi_endproc
 5021              	.LFE44:
 5023              		.section	.text._ZL16PreScanHexNumberPPKh,"ax",%progbits
 5024              		.align	2
 5025              		.code	16
 5026              		.thumb_func
 5028              	_ZL16PreScanHexNumberPPKh:
 5029              	.LFB45:
1722:../Generated_Code/UTIL0.c **** 
1723:../Generated_Code/UTIL0.c **** /*
1724:../Generated_Code/UTIL0.c **** ** ===================================================================
1725:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcmp (component Utility)
1726:../Generated_Code/UTIL0.c **** **     Description :
1727:../Generated_Code/UTIL0.c **** **         Wrapper to the standard strcmp() routine
1728:../Generated_Code/UTIL0.c **** **     Parameters  :
1729:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1730:../Generated_Code/UTIL0.c **** **       * str1            - Pointer to string
1731:../Generated_Code/UTIL0.c **** **       * str2            - Pointer to string
1732:../Generated_Code/UTIL0.c **** **     Returns     :
1733:../Generated_Code/UTIL0.c **** **         ---             - Returns zero if the two strings are the
1734:../Generated_Code/UTIL0.c **** **                           same
1735:../Generated_Code/UTIL0.c **** ** ===================================================================
1736:../Generated_Code/UTIL0.c **** */
1737:../Generated_Code/UTIL0.c **** /***
1738:../Generated_Code/UTIL0.c **** int16_t UTIL0_strcmp(const char *, const char *)
1739:../Generated_Code/UTIL0.c **** {
1740:../Generated_Code/UTIL0.c ****   Method is implemented as macro in the header file as wrapper to the standard strcmp() function
1741:../Generated_Code/UTIL0.c **** }
1742:../Generated_Code/UTIL0.c **** */
1743:../Generated_Code/UTIL0.c **** 
1744:../Generated_Code/UTIL0.c **** /*
1745:../Generated_Code/UTIL0.c **** ** ===================================================================
1746:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strncmp (component Utility)
1747:../Generated_Code/UTIL0.c **** **     Description :
1748:../Generated_Code/UTIL0.c **** **         Wrapper to the standard strncmp() routine
1749:../Generated_Code/UTIL0.c **** **     Parameters  :
1750:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1751:../Generated_Code/UTIL0.c **** **       * str1            - Pointer to string
1752:../Generated_Code/UTIL0.c **** **       * str2            - Pointer to string
1753:../Generated_Code/UTIL0.c **** **         size            - 
1754:../Generated_Code/UTIL0.c **** **     Returns     :
1755:../Generated_Code/UTIL0.c **** **         ---             - Returns zero if the two strings are the
1756:../Generated_Code/UTIL0.c **** **                           same
1757:../Generated_Code/UTIL0.c **** ** ===================================================================
1758:../Generated_Code/UTIL0.c **** */
1759:../Generated_Code/UTIL0.c **** /***
1760:../Generated_Code/UTIL0.c **** int16_t UTIL0_strncmp(const char *, const char *, size_t size)
1761:../Generated_Code/UTIL0.c **** {
1762:../Generated_Code/UTIL0.c ****   /Method is implemented as macro in the header file as wrapper to the standard strncmp() function
1763:../Generated_Code/UTIL0.c **** }
1764:../Generated_Code/UTIL0.c **** */
1765:../Generated_Code/UTIL0.c **** 
1766:../Generated_Code/UTIL0.c **** /*
1767:../Generated_Code/UTIL0.c **** ** ===================================================================
1768:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strlen (component Utility)
1769:../Generated_Code/UTIL0.c **** **     Description :
1770:../Generated_Code/UTIL0.c **** **         Wrapper to the standard strlen() function.
1771:../Generated_Code/UTIL0.c **** **     Parameters  :
1772:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1773:../Generated_Code/UTIL0.c **** **         str             - 
1774:../Generated_Code/UTIL0.c **** **     Returns     :
1775:../Generated_Code/UTIL0.c **** **         ---             - size of strinig
1776:../Generated_Code/UTIL0.c **** ** ===================================================================
1777:../Generated_Code/UTIL0.c **** */
1778:../Generated_Code/UTIL0.c **** /***
1779:../Generated_Code/UTIL0.c **** word UTIL0_strlen(const char *)
1780:../Generated_Code/UTIL0.c **** {
1781:../Generated_Code/UTIL0.c ****   Method is implemented as macro in the header file as wrapper to the standard strlen() function
1782:../Generated_Code/UTIL0.c **** }
1783:../Generated_Code/UTIL0.c **** */
1784:../Generated_Code/UTIL0.c **** 
1785:../Generated_Code/UTIL0.c **** static byte PreScanHexNumber(const unsigned char **str)
1786:../Generated_Code/UTIL0.c **** {
 5030              		.loc 1 1786 0
 5031              		.cfi_startproc
 5032 0000 80B5     		push	{r7, lr}
 5033              	.LCFI120:
 5034              		.cfi_def_cfa_offset 8
 5035              		.cfi_offset 7, -8
 5036              		.cfi_offset 14, -4
 5037 0002 84B0     		sub	sp, sp, #16
 5038              	.LCFI121:
 5039              		.cfi_def_cfa_offset 24
 5040 0004 00AF     		add	r7, sp, #0
 5041              	.LCFI122:
 5042              		.cfi_def_cfa_register 7
 5043 0006 7860     		str	r0, [r7, #4]
 5044              	.LBB32:
1787:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 5045              		.loc 1 1787 0
 5046 0008 7B68     		ldr	r3, [r7, #4]
 5047 000a 1B68     		ldr	r3, [r3]
 5048 000c FB60     		str	r3, [r7, #12]
1788:../Generated_Code/UTIL0.c **** 
1789:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 5049              		.loc 1 1789 0
 5050 000e 02E0     		b	.L263
 5051              	.L264:
1790:../Generated_Code/UTIL0.c ****     p++; /* skip space */
 5052              		.loc 1 1790 0
 5053 0010 FB68     		ldr	r3, [r7, #12]
 5054 0012 0133     		add	r3, r3, #1
 5055 0014 FB60     		str	r3, [r7, #12]
 5056              	.L263:
1789:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 5057              		.loc 1 1789 0
 5058 0016 FB68     		ldr	r3, [r7, #12]
 5059 0018 1B78     		ldrb	r3, [r3]
 5060 001a 203B     		sub	r3, r3, #32
 5061 001c 5A42     		neg	r2, r3
 5062 001e 5341     		adc	r3, r3, r2
 5063 0020 DBB2     		uxtb	r3, r3
 5064 0022 002B     		cmp	r3, #0
 5065 0024 F4D1     		bne	.L264
1791:../Generated_Code/UTIL0.c ****   }
1792:../Generated_Code/UTIL0.c ****   if (*p!='0') { /* must start with 0x */
 5066              		.loc 1 1792 0
 5067 0026 FB68     		ldr	r3, [r7, #12]
 5068 0028 1B78     		ldrb	r3, [r3]
 5069 002a 302B     		cmp	r3, #48
 5070 002c 01D0     		beq	.L265
1793:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 5071              		.loc 1 1793 0
 5072 002e 1B23     		mov	r3, #27
 5073 0030 0FE0     		b	.L266
 5074              	.L265:
1794:../Generated_Code/UTIL0.c ****   }
1795:../Generated_Code/UTIL0.c ****   p++; /* skip '0' */
 5075              		.loc 1 1795 0
 5076 0032 FB68     		ldr	r3, [r7, #12]
 5077 0034 0133     		add	r3, r3, #1
 5078 0036 FB60     		str	r3, [r7, #12]
1796:../Generated_Code/UTIL0.c ****   if (*p!='x') { /* must start with 0x */
 5079              		.loc 1 1796 0
 5080 0038 FB68     		ldr	r3, [r7, #12]
 5081 003a 1B78     		ldrb	r3, [r3]
 5082 003c 782B     		cmp	r3, #120
 5083 003e 01D0     		beq	.L267
1797:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 5084              		.loc 1 1797 0
 5085 0040 1B23     		mov	r3, #27
 5086 0042 06E0     		b	.L266
 5087              	.L267:
1798:../Generated_Code/UTIL0.c ****   }
1799:../Generated_Code/UTIL0.c ****   p++; /* skip 'x' */
 5088              		.loc 1 1799 0
 5089 0044 FB68     		ldr	r3, [r7, #12]
 5090 0046 0133     		add	r3, r3, #1
 5091 0048 FB60     		str	r3, [r7, #12]
1800:../Generated_Code/UTIL0.c ****   *str = p;
 5092              		.loc 1 1800 0
 5093 004a 7B68     		ldr	r3, [r7, #4]
 5094 004c FA68     		ldr	r2, [r7, #12]
 5095 004e 1A60     		str	r2, [r3]
1801:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5096              		.loc 1 1801 0
 5097 0050 0023     		mov	r3, #0
 5098              	.L266:
 5099              	.LBE32:
1802:../Generated_Code/UTIL0.c **** }
 5100              		.loc 1 1802 0
 5101 0052 181C     		mov	r0, r3
 5102 0054 BD46     		mov	sp, r7
 5103 0056 04B0     		add	sp, sp, #16
 5104              		@ sp needed for prologue
 5105 0058 80BD     		pop	{r7, pc}
 5106              		.cfi_endproc
 5107              	.LFE45:
 5109 005a C046     		.section	.text._ZL8HexToDecPPKhPh,"ax",%progbits
 5110              		.align	2
 5111              		.code	16
 5112              		.thumb_func
 5114              	_ZL8HexToDecPPKhPh:
 5115              	.LFB46:
1803:../Generated_Code/UTIL0.c **** 
1804:../Generated_Code/UTIL0.c **** static byte HexToDec(const unsigned char **p, unsigned char *val) {
 5116              		.loc 1 1804 0
 5117              		.cfi_startproc
 5118 0000 80B5     		push	{r7, lr}
 5119              	.LCFI123:
 5120              		.cfi_def_cfa_offset 8
 5121              		.cfi_offset 7, -8
 5122              		.cfi_offset 14, -4
 5123 0002 84B0     		sub	sp, sp, #16
 5124              	.LCFI124:
 5125              		.cfi_def_cfa_offset 24
 5126 0004 00AF     		add	r7, sp, #0
 5127              	.LCFI125:
 5128              		.cfi_def_cfa_register 7
 5129 0006 7860     		str	r0, [r7, #4]
 5130 0008 3960     		str	r1, [r7]
 5131              	.LBB33:
1805:../Generated_Code/UTIL0.c ****   /* convert a hexadecimal character into a decimal value */
1806:../Generated_Code/UTIL0.c ****   unsigned char ch = **p;
 5132              		.loc 1 1806 0
 5133 000a 7B68     		ldr	r3, [r7, #4]
 5134 000c 1A68     		ldr	r2, [r3]
 5135 000e 3B1C     		mov	r3, r7
 5136 0010 0F33     		add	r3, r3, #15
 5137 0012 1278     		ldrb	r2, [r2]
 5138 0014 1A70     		strb	r2, [r3]
1807:../Generated_Code/UTIL0.c **** 
1808:../Generated_Code/UTIL0.c ****   if (ch>='0' && ch<='9') {
 5139              		.loc 1 1808 0
 5140 0016 3B1C     		mov	r3, r7
 5141 0018 0F33     		add	r3, r3, #15
 5142 001a 1B78     		ldrb	r3, [r3]
 5143 001c 2F2B     		cmp	r3, #47
 5144 001e 12D9     		bls	.L269
 5145              		.loc 1 1808 0 is_stmt 0
 5146 0020 3B1C     		mov	r3, r7
 5147 0022 0F33     		add	r3, r3, #15
 5148 0024 1B78     		ldrb	r3, [r3]
 5149 0026 392B     		cmp	r3, #57
 5150 0028 0DD8     		bhi	.L269
1809:../Generated_Code/UTIL0.c ****     *val = (unsigned char)(ch-'0');
 5151              		.loc 1 1809 0 is_stmt 1
 5152 002a 3B1C     		mov	r3, r7
 5153 002c 0F33     		add	r3, r3, #15
 5154 002e 1B78     		ldrb	r3, [r3]
 5155 0030 303B     		sub	r3, r3, #48
 5156 0032 DAB2     		uxtb	r2, r3
 5157 0034 3B68     		ldr	r3, [r7]
 5158 0036 1A70     		strb	r2, [r3]
1810:../Generated_Code/UTIL0.c ****     (*p)++;
 5159              		.loc 1 1810 0
 5160 0038 7B68     		ldr	r3, [r7, #4]
 5161 003a 1B68     		ldr	r3, [r3]
 5162 003c 5A1C     		add	r2, r3, #1
 5163 003e 7B68     		ldr	r3, [r7, #4]
 5164 0040 1A60     		str	r2, [r3]
1811:../Generated_Code/UTIL0.c ****     return ERR_OK;
 5165              		.loc 1 1811 0
 5166 0042 0023     		mov	r3, #0
 5167 0044 30E0     		b	.L270
 5168              	.L269:
1812:../Generated_Code/UTIL0.c ****   } else if (ch>='a' && ch<='f') {
 5169              		.loc 1 1812 0
 5170 0046 3B1C     		mov	r3, r7
 5171 0048 0F33     		add	r3, r3, #15
 5172 004a 1B78     		ldrb	r3, [r3]
 5173 004c 602B     		cmp	r3, #96
 5174 004e 12D9     		bls	.L271
 5175              		.loc 1 1812 0 is_stmt 0
 5176 0050 3B1C     		mov	r3, r7
 5177 0052 0F33     		add	r3, r3, #15
 5178 0054 1B78     		ldrb	r3, [r3]
 5179 0056 662B     		cmp	r3, #102
 5180 0058 0DD8     		bhi	.L271
1813:../Generated_Code/UTIL0.c ****     *val = (unsigned char)(ch-'a'+10);
 5181              		.loc 1 1813 0 is_stmt 1
 5182 005a 3B1C     		mov	r3, r7
 5183 005c 0F33     		add	r3, r3, #15
 5184 005e 1B78     		ldrb	r3, [r3]
 5185 0060 573B     		sub	r3, r3, #87
 5186 0062 DAB2     		uxtb	r2, r3
 5187 0064 3B68     		ldr	r3, [r7]
 5188 0066 1A70     		strb	r2, [r3]
1814:../Generated_Code/UTIL0.c ****     (*p)++;
 5189              		.loc 1 1814 0
 5190 0068 7B68     		ldr	r3, [r7, #4]
 5191 006a 1B68     		ldr	r3, [r3]
 5192 006c 5A1C     		add	r2, r3, #1
 5193 006e 7B68     		ldr	r3, [r7, #4]
 5194 0070 1A60     		str	r2, [r3]
1815:../Generated_Code/UTIL0.c ****     return ERR_OK;
 5195              		.loc 1 1815 0
 5196 0072 0023     		mov	r3, #0
 5197 0074 18E0     		b	.L270
 5198              	.L271:
1816:../Generated_Code/UTIL0.c ****   } else if (ch>='A' && ch<='F') {
 5199              		.loc 1 1816 0
 5200 0076 3B1C     		mov	r3, r7
 5201 0078 0F33     		add	r3, r3, #15
 5202 007a 1B78     		ldrb	r3, [r3]
 5203 007c 402B     		cmp	r3, #64
 5204 007e 12D9     		bls	.L272
 5205              		.loc 1 1816 0 is_stmt 0
 5206 0080 3B1C     		mov	r3, r7
 5207 0082 0F33     		add	r3, r3, #15
 5208 0084 1B78     		ldrb	r3, [r3]
 5209 0086 462B     		cmp	r3, #70
 5210 0088 0DD8     		bhi	.L272
1817:../Generated_Code/UTIL0.c ****     *val = (unsigned char)(ch-'A'+10);
 5211              		.loc 1 1817 0 is_stmt 1
 5212 008a 3B1C     		mov	r3, r7
 5213 008c 0F33     		add	r3, r3, #15
 5214 008e 1B78     		ldrb	r3, [r3]
 5215 0090 373B     		sub	r3, r3, #55
 5216 0092 DAB2     		uxtb	r2, r3
 5217 0094 3B68     		ldr	r3, [r7]
 5218 0096 1A70     		strb	r2, [r3]
1818:../Generated_Code/UTIL0.c ****     (*p)++;
 5219              		.loc 1 1818 0
 5220 0098 7B68     		ldr	r3, [r7, #4]
 5221 009a 1B68     		ldr	r3, [r3]
 5222 009c 5A1C     		add	r2, r3, #1
 5223 009e 7B68     		ldr	r3, [r7, #4]
 5224 00a0 1A60     		str	r2, [r3]
1819:../Generated_Code/UTIL0.c ****     return ERR_OK;
 5225              		.loc 1 1819 0
 5226 00a2 0023     		mov	r3, #0
 5227 00a4 00E0     		b	.L270
 5228              	.L272:
1820:../Generated_Code/UTIL0.c ****   }
1821:../Generated_Code/UTIL0.c ****   return ERR_FAILED;
 5229              		.loc 1 1821 0
 5230 00a6 1B23     		mov	r3, #27
 5231              	.L270:
 5232              	.LBE33:
1822:../Generated_Code/UTIL0.c **** }
 5233              		.loc 1 1822 0
 5234 00a8 181C     		mov	r0, r3
 5235 00aa BD46     		mov	sp, r7
 5236 00ac 04B0     		add	sp, sp, #16
 5237              		@ sp needed for prologue
 5238 00ae 80BD     		pop	{r7, pc}
 5239              		.cfi_endproc
 5240              	.LFE46:
 5242              		.section	.text._Z22UTIL0_ScanHex32uNumberPPKhPm,"ax",%progbits
 5243              		.align	2
 5244              		.global	_Z22UTIL0_ScanHex32uNumberPPKhPm
 5245              		.code	16
 5246              		.thumb_func
 5248              	_Z22UTIL0_ScanHex32uNumberPPKhPm:
 5249              	.LFB47:
1823:../Generated_Code/UTIL0.c **** 
1824:../Generated_Code/UTIL0.c **** /*
1825:../Generated_Code/UTIL0.c **** ** ===================================================================
1826:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanHex32uNumber (component Utility)
1827:../Generated_Code/UTIL0.c **** **     Description :
1828:../Generated_Code/UTIL0.c **** **         Scans a hexadecimal 32bit number, starting with 0x
1829:../Generated_Code/UTIL0.c **** **     Parameters  :
1830:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1831:../Generated_Code/UTIL0.c **** **         str             - String to scan, starting with 0x. It
1832:../Generated_Code/UTIL0.c **** **                           returns as well until where it has scanned
1833:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1834:../Generated_Code/UTIL0.c **** **     Returns     :
1835:../Generated_Code/UTIL0.c **** **         ---             - Error code
1836:../Generated_Code/UTIL0.c **** ** ===================================================================
1837:../Generated_Code/UTIL0.c **** */
1838:../Generated_Code/UTIL0.c **** byte UTIL0_ScanHex32uNumber(const unsigned char **str, uint32_t *val)
1839:../Generated_Code/UTIL0.c **** {
 5250              		.loc 1 1839 0
 5251              		.cfi_startproc
 5252 0000 80B5     		push	{r7, lr}
 5253              	.LCFI126:
 5254              		.cfi_def_cfa_offset 8
 5255              		.cfi_offset 7, -8
 5256              		.cfi_offset 14, -4
 5257 0002 86B0     		sub	sp, sp, #24
 5258              	.LCFI127:
 5259              		.cfi_def_cfa_offset 32
 5260 0004 00AF     		add	r7, sp, #0
 5261              	.LCFI128:
 5262              		.cfi_def_cfa_register 7
 5263 0006 7860     		str	r0, [r7, #4]
 5264 0008 3960     		str	r1, [r7]
 5265              	.LBB34:
1840:../Generated_Code/UTIL0.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1841:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
 5266              		.loc 1 1841 0
 5267 000a 3B1C     		mov	r3, r7
 5268 000c 1733     		add	r3, r3, #23
 5269 000e 0922     		mov	r2, #9
 5270 0010 1A70     		strb	r2, [r3]
1842:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 5271              		.loc 1 1842 0
 5272 0012 7B68     		ldr	r3, [r7, #4]
 5273 0014 1B68     		ldr	r3, [r3]
 5274 0016 3B61     		str	r3, [r7, #16]
1843:../Generated_Code/UTIL0.c ****   byte v;
1844:../Generated_Code/UTIL0.c **** 
1845:../Generated_Code/UTIL0.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5275              		.loc 1 1845 0
 5276 0018 3B1C     		mov	r3, r7
 5277 001a 1033     		add	r3, r3, #16
 5278 001c 181C     		mov	r0, r3
 5279 001e FFF7FEFF 		bl	_ZL16PreScanHexNumberPPKh
 5280 0022 031C     		mov	r3, r0
 5281 0024 5A1E     		sub	r2, r3, #1
 5282 0026 9341     		sbc	r3, r3, r2
 5283 0028 DBB2     		uxtb	r3, r3
 5284 002a 002B     		cmp	r3, #0
 5285 002c 01D0     		beq	.L274
1846:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 5286              		.loc 1 1846 0
 5287 002e 1B23     		mov	r3, #27
 5288 0030 33E0     		b	.L281
 5289              	.L274:
1847:../Generated_Code/UTIL0.c ****   }
1848:../Generated_Code/UTIL0.c ****   *val = 0;
 5290              		.loc 1 1848 0
 5291 0032 3B68     		ldr	r3, [r7]
 5292 0034 0022     		mov	r2, #0
 5293 0036 1A60     		str	r2, [r3]
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5294              		.loc 1 1849 0
 5295 0038 0FE0     		b	.L276
 5296              	.L279:
1850:../Generated_Code/UTIL0.c ****     *val = (uint32_t)((*val)*16 + v);
 5297              		.loc 1 1850 0
 5298 003a 3B68     		ldr	r3, [r7]
 5299 003c 1B68     		ldr	r3, [r3]
 5300 003e 1A01     		lsl	r2, r3, #4
 5301 0040 3B1C     		mov	r3, r7
 5302 0042 0F33     		add	r3, r3, #15
 5303 0044 1B78     		ldrb	r3, [r3]
 5304 0046 D218     		add	r2, r2, r3
 5305 0048 3B68     		ldr	r3, [r7]
 5306 004a 1A60     		str	r2, [r3]
1851:../Generated_Code/UTIL0.c ****     nofDigits--;
 5307              		.loc 1 1851 0
 5308 004c 3B1C     		mov	r3, r7
 5309 004e 1733     		add	r3, r3, #23
 5310 0050 3A1C     		mov	r2, r7
 5311 0052 1732     		add	r2, r2, #23
 5312 0054 1278     		ldrb	r2, [r2]
 5313 0056 013A     		sub	r2, r2, #1
 5314 0058 1A70     		strb	r2, [r3]
 5315              	.L276:
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5316              		.loc 1 1849 0
 5317 005a 3A1C     		mov	r2, r7
 5318 005c 1032     		add	r2, r2, #16
 5319 005e 3B1C     		mov	r3, r7
 5320 0060 0F33     		add	r3, r3, #15
 5321 0062 101C     		mov	r0, r2
 5322 0064 191C     		mov	r1, r3
 5323 0066 FFF7FEFF 		bl	_ZL8HexToDecPPKhPh
 5324 006a 031C     		mov	r3, r0
 5325 006c 002B     		cmp	r3, #0
 5326 006e 06D1     		bne	.L277
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5327              		.loc 1 1849 0 is_stmt 0
 5328 0070 3B1C     		mov	r3, r7
 5329 0072 1733     		add	r3, r3, #23
 5330 0074 1B78     		ldrb	r3, [r3]
 5331 0076 002B     		cmp	r3, #0
 5332 0078 01D0     		beq	.L277
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5333              		.loc 1 1849 0
 5334 007a 0123     		mov	r3, #1
 5335 007c 00E0     		b	.L278
 5336              	.L277:
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5337              		.loc 1 1849 0
 5338 007e 0023     		mov	r3, #0
 5339              	.L278:
1849:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5340              		.loc 1 1849 0
 5341 0080 002B     		cmp	r3, #0
 5342 0082 DAD1     		bne	.L279
1852:../Generated_Code/UTIL0.c ****   } /* while */
1853:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 5343              		.loc 1 1853 0 is_stmt 1
 5344 0084 3B1C     		mov	r3, r7
 5345 0086 1733     		add	r3, r3, #23
 5346 0088 1B78     		ldrb	r3, [r3]
 5347 008a 002B     		cmp	r3, #0
 5348 008c 01D1     		bne	.L280
1854:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 5349              		.loc 1 1854 0
 5350 008e 0423     		mov	r3, #4
 5351 0090 03E0     		b	.L281
 5352              	.L280:
1855:../Generated_Code/UTIL0.c ****   }
1856:../Generated_Code/UTIL0.c ****   *str = p;
 5353              		.loc 1 1856 0
 5354 0092 3A69     		ldr	r2, [r7, #16]
 5355 0094 7B68     		ldr	r3, [r7, #4]
 5356 0096 1A60     		str	r2, [r3]
1857:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5357              		.loc 1 1857 0
 5358 0098 0023     		mov	r3, #0
 5359              	.L281:
 5360              	.LBE34:
1858:../Generated_Code/UTIL0.c **** }
 5361              		.loc 1 1858 0
 5362 009a 181C     		mov	r0, r3
 5363 009c BD46     		mov	sp, r7
 5364 009e 06B0     		add	sp, sp, #24
 5365              		@ sp needed for prologue
 5366 00a0 80BD     		pop	{r7, pc}
 5367              		.cfi_endproc
 5368              	.LFE47:
 5370 00a2 C046     		.section	.text._Z22UTIL0_ScanHex16uNumberPPKhPt,"ax",%progbits
 5371              		.align	2
 5372              		.global	_Z22UTIL0_ScanHex16uNumberPPKhPt
 5373              		.code	16
 5374              		.thumb_func
 5376              	_Z22UTIL0_ScanHex16uNumberPPKhPt:
 5377              	.LFB48:
1859:../Generated_Code/UTIL0.c **** 
1860:../Generated_Code/UTIL0.c **** /*
1861:../Generated_Code/UTIL0.c **** ** ===================================================================
1862:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanHex16uNumber (component Utility)
1863:../Generated_Code/UTIL0.c **** **     Description :
1864:../Generated_Code/UTIL0.c **** **         Scans a hexadecimal 16bit number, starting with 0x
1865:../Generated_Code/UTIL0.c **** **     Parameters  :
1866:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1867:../Generated_Code/UTIL0.c **** **         str             - String to scan, starting with 0x.. It
1868:../Generated_Code/UTIL0.c **** **                           returns as well until where it has scanned
1869:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1870:../Generated_Code/UTIL0.c **** **     Returns     :
1871:../Generated_Code/UTIL0.c **** **         ---             - Error code
1872:../Generated_Code/UTIL0.c **** ** ===================================================================
1873:../Generated_Code/UTIL0.c **** */
1874:../Generated_Code/UTIL0.c **** byte UTIL0_ScanHex16uNumber(const unsigned char **str, word *val)
1875:../Generated_Code/UTIL0.c **** {
 5378              		.loc 1 1875 0
 5379              		.cfi_startproc
 5380 0000 80B5     		push	{r7, lr}
 5381              	.LCFI129:
 5382              		.cfi_def_cfa_offset 8
 5383              		.cfi_offset 7, -8
 5384              		.cfi_offset 14, -4
 5385 0002 86B0     		sub	sp, sp, #24
 5386              	.LCFI130:
 5387              		.cfi_def_cfa_offset 32
 5388 0004 00AF     		add	r7, sp, #0
 5389              	.LCFI131:
 5390              		.cfi_def_cfa_register 7
 5391 0006 7860     		str	r0, [r7, #4]
 5392 0008 3960     		str	r1, [r7]
 5393              	.LBB35:
1876:../Generated_Code/UTIL0.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1877:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
 5394              		.loc 1 1877 0
 5395 000a 3B1C     		mov	r3, r7
 5396 000c 1733     		add	r3, r3, #23
 5397 000e 0522     		mov	r2, #5
 5398 0010 1A70     		strb	r2, [r3]
1878:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 5399              		.loc 1 1878 0
 5400 0012 7B68     		ldr	r3, [r7, #4]
 5401 0014 1B68     		ldr	r3, [r3]
 5402 0016 3B61     		str	r3, [r7, #16]
1879:../Generated_Code/UTIL0.c ****   byte v;
1880:../Generated_Code/UTIL0.c **** 
1881:../Generated_Code/UTIL0.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5403              		.loc 1 1881 0
 5404 0018 3B1C     		mov	r3, r7
 5405 001a 1033     		add	r3, r3, #16
 5406 001c 181C     		mov	r0, r3
 5407 001e FFF7FEFF 		bl	_ZL16PreScanHexNumberPPKh
 5408 0022 031C     		mov	r3, r0
 5409 0024 5A1E     		sub	r2, r3, #1
 5410 0026 9341     		sbc	r3, r3, r2
 5411 0028 DBB2     		uxtb	r3, r3
 5412 002a 002B     		cmp	r3, #0
 5413 002c 01D0     		beq	.L283
1882:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 5414              		.loc 1 1882 0
 5415 002e 1B23     		mov	r3, #27
 5416 0030 35E0     		b	.L290
 5417              	.L283:
1883:../Generated_Code/UTIL0.c ****   }
1884:../Generated_Code/UTIL0.c ****   *val = 0;
 5418              		.loc 1 1884 0
 5419 0032 3B68     		ldr	r3, [r7]
 5420 0034 0022     		mov	r2, #0
 5421 0036 1A80     		strh	r2, [r3]
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5422              		.loc 1 1885 0
 5423 0038 11E0     		b	.L285
 5424              	.L288:
1886:../Generated_Code/UTIL0.c ****     *val = (uint16_t)((*val)*16 + v);
 5425              		.loc 1 1886 0
 5426 003a 3B68     		ldr	r3, [r7]
 5427 003c 1B88     		ldrh	r3, [r3]
 5428 003e 1B01     		lsl	r3, r3, #4
 5429 0040 9AB2     		uxth	r2, r3
 5430 0042 3B1C     		mov	r3, r7
 5431 0044 0F33     		add	r3, r3, #15
 5432 0046 1B78     		ldrb	r3, [r3]
 5433 0048 D318     		add	r3, r2, r3
 5434 004a 9AB2     		uxth	r2, r3
 5435 004c 3B68     		ldr	r3, [r7]
 5436 004e 1A80     		strh	r2, [r3]
1887:../Generated_Code/UTIL0.c ****     nofDigits--;
 5437              		.loc 1 1887 0
 5438 0050 3B1C     		mov	r3, r7
 5439 0052 1733     		add	r3, r3, #23
 5440 0054 3A1C     		mov	r2, r7
 5441 0056 1732     		add	r2, r2, #23
 5442 0058 1278     		ldrb	r2, [r2]
 5443 005a 013A     		sub	r2, r2, #1
 5444 005c 1A70     		strb	r2, [r3]
 5445              	.L285:
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5446              		.loc 1 1885 0
 5447 005e 3A1C     		mov	r2, r7
 5448 0060 1032     		add	r2, r2, #16
 5449 0062 3B1C     		mov	r3, r7
 5450 0064 0F33     		add	r3, r3, #15
 5451 0066 101C     		mov	r0, r2
 5452 0068 191C     		mov	r1, r3
 5453 006a FFF7FEFF 		bl	_ZL8HexToDecPPKhPh
 5454 006e 031C     		mov	r3, r0
 5455 0070 002B     		cmp	r3, #0
 5456 0072 06D1     		bne	.L286
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5457              		.loc 1 1885 0 is_stmt 0
 5458 0074 3B1C     		mov	r3, r7
 5459 0076 1733     		add	r3, r3, #23
 5460 0078 1B78     		ldrb	r3, [r3]
 5461 007a 002B     		cmp	r3, #0
 5462 007c 01D0     		beq	.L286
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5463              		.loc 1 1885 0
 5464 007e 0123     		mov	r3, #1
 5465 0080 00E0     		b	.L287
 5466              	.L286:
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5467              		.loc 1 1885 0
 5468 0082 0023     		mov	r3, #0
 5469              	.L287:
1885:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5470              		.loc 1 1885 0
 5471 0084 002B     		cmp	r3, #0
 5472 0086 D8D1     		bne	.L288
1888:../Generated_Code/UTIL0.c ****   } /* while */
1889:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 5473              		.loc 1 1889 0 is_stmt 1
 5474 0088 3B1C     		mov	r3, r7
 5475 008a 1733     		add	r3, r3, #23
 5476 008c 1B78     		ldrb	r3, [r3]
 5477 008e 002B     		cmp	r3, #0
 5478 0090 01D1     		bne	.L289
1890:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 5479              		.loc 1 1890 0
 5480 0092 0423     		mov	r3, #4
 5481 0094 03E0     		b	.L290
 5482              	.L289:
1891:../Generated_Code/UTIL0.c ****   }
1892:../Generated_Code/UTIL0.c ****   *str = p;
 5483              		.loc 1 1892 0
 5484 0096 3A69     		ldr	r2, [r7, #16]
 5485 0098 7B68     		ldr	r3, [r7, #4]
 5486 009a 1A60     		str	r2, [r3]
1893:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5487              		.loc 1 1893 0
 5488 009c 0023     		mov	r3, #0
 5489              	.L290:
 5490              	.LBE35:
1894:../Generated_Code/UTIL0.c **** }
 5491              		.loc 1 1894 0
 5492 009e 181C     		mov	r0, r3
 5493 00a0 BD46     		mov	sp, r7
 5494 00a2 06B0     		add	sp, sp, #24
 5495              		@ sp needed for prologue
 5496 00a4 80BD     		pop	{r7, pc}
 5497              		.cfi_endproc
 5498              	.LFE48:
 5500 00a6 C046     		.section	.text._Z21UTIL0_ScanHex8uNumberPPKhPh,"ax",%progbits
 5501              		.align	2
 5502              		.global	_Z21UTIL0_ScanHex8uNumberPPKhPh
 5503              		.code	16
 5504              		.thumb_func
 5506              	_Z21UTIL0_ScanHex8uNumberPPKhPh:
 5507              	.LFB49:
1895:../Generated_Code/UTIL0.c **** 
1896:../Generated_Code/UTIL0.c **** /*
1897:../Generated_Code/UTIL0.c **** ** ===================================================================
1898:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanHex8uNumber (component Utility)
1899:../Generated_Code/UTIL0.c **** **     Description :
1900:../Generated_Code/UTIL0.c **** **         Scans a hexadecimal 8bit number, starting with 0x
1901:../Generated_Code/UTIL0.c **** **     Parameters  :
1902:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1903:../Generated_Code/UTIL0.c **** **         str             - String to scan, starting with 0x. It
1904:../Generated_Code/UTIL0.c **** **                           returns as well until where it has scanned
1905:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1906:../Generated_Code/UTIL0.c **** **     Returns     :
1907:../Generated_Code/UTIL0.c **** **         ---             - Error code
1908:../Generated_Code/UTIL0.c **** ** ===================================================================
1909:../Generated_Code/UTIL0.c **** */
1910:../Generated_Code/UTIL0.c **** byte UTIL0_ScanHex8uNumber(const unsigned char **str, byte *val)
1911:../Generated_Code/UTIL0.c **** {
 5508              		.loc 1 1911 0
 5509              		.cfi_startproc
 5510 0000 80B5     		push	{r7, lr}
 5511              	.LCFI132:
 5512              		.cfi_def_cfa_offset 8
 5513              		.cfi_offset 7, -8
 5514              		.cfi_offset 14, -4
 5515 0002 86B0     		sub	sp, sp, #24
 5516              	.LCFI133:
 5517              		.cfi_def_cfa_offset 32
 5518 0004 00AF     		add	r7, sp, #0
 5519              	.LCFI134:
 5520              		.cfi_def_cfa_register 7
 5521 0006 7860     		str	r0, [r7, #4]
 5522 0008 3960     		str	r1, [r7]
 5523              	.LBB36:
1912:../Generated_Code/UTIL0.c ****   /* scans a hex number with 0x, and stops at any non-number. Number can have any preceding zeros o
1913:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
 5524              		.loc 1 1913 0
 5525 000a 3B1C     		mov	r3, r7
 5526 000c 1733     		add	r3, r3, #23
 5527 000e 0322     		mov	r2, #3
 5528 0010 1A70     		strb	r2, [r3]
1914:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 5529              		.loc 1 1914 0
 5530 0012 7B68     		ldr	r3, [r7, #4]
 5531 0014 1B68     		ldr	r3, [r3]
 5532 0016 3B61     		str	r3, [r7, #16]
1915:../Generated_Code/UTIL0.c ****   byte v;
1916:../Generated_Code/UTIL0.c **** 
1917:../Generated_Code/UTIL0.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5533              		.loc 1 1917 0
 5534 0018 3B1C     		mov	r3, r7
 5535 001a 1033     		add	r3, r3, #16
 5536 001c 181C     		mov	r0, r3
 5537 001e FFF7FEFF 		bl	_ZL16PreScanHexNumberPPKh
 5538 0022 031C     		mov	r3, r0
 5539 0024 5A1E     		sub	r2, r3, #1
 5540 0026 9341     		sbc	r3, r3, r2
 5541 0028 DBB2     		uxtb	r3, r3
 5542 002a 002B     		cmp	r3, #0
 5543 002c 01D0     		beq	.L292
1918:../Generated_Code/UTIL0.c ****     return ERR_FAILED;
 5544              		.loc 1 1918 0
 5545 002e 1B23     		mov	r3, #27
 5546 0030 35E0     		b	.L299
 5547              	.L292:
1919:../Generated_Code/UTIL0.c ****   }
1920:../Generated_Code/UTIL0.c ****   *val = 0;
 5548              		.loc 1 1920 0
 5549 0032 3B68     		ldr	r3, [r7]
 5550 0034 0022     		mov	r2, #0
 5551 0036 1A70     		strb	r2, [r3]
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5552              		.loc 1 1921 0
 5553 0038 11E0     		b	.L294
 5554              	.L297:
1922:../Generated_Code/UTIL0.c ****     *val = (uint8_t)((*val)*16 + v);
 5555              		.loc 1 1922 0
 5556 003a 3B68     		ldr	r3, [r7]
 5557 003c 1B78     		ldrb	r3, [r3]
 5558 003e 1B01     		lsl	r3, r3, #4
 5559 0040 DAB2     		uxtb	r2, r3
 5560 0042 3B1C     		mov	r3, r7
 5561 0044 0F33     		add	r3, r3, #15
 5562 0046 1B78     		ldrb	r3, [r3]
 5563 0048 D318     		add	r3, r2, r3
 5564 004a DAB2     		uxtb	r2, r3
 5565 004c 3B68     		ldr	r3, [r7]
 5566 004e 1A70     		strb	r2, [r3]
1923:../Generated_Code/UTIL0.c ****     nofDigits--;
 5567              		.loc 1 1923 0
 5568 0050 3B1C     		mov	r3, r7
 5569 0052 1733     		add	r3, r3, #23
 5570 0054 3A1C     		mov	r2, r7
 5571 0056 1732     		add	r2, r2, #23
 5572 0058 1278     		ldrb	r2, [r2]
 5573 005a 013A     		sub	r2, r2, #1
 5574 005c 1A70     		strb	r2, [r3]
 5575              	.L294:
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5576              		.loc 1 1921 0
 5577 005e 3A1C     		mov	r2, r7
 5578 0060 1032     		add	r2, r2, #16
 5579 0062 3B1C     		mov	r3, r7
 5580 0064 0F33     		add	r3, r3, #15
 5581 0066 101C     		mov	r0, r2
 5582 0068 191C     		mov	r1, r3
 5583 006a FFF7FEFF 		bl	_ZL8HexToDecPPKhPh
 5584 006e 031C     		mov	r3, r0
 5585 0070 002B     		cmp	r3, #0
 5586 0072 06D1     		bne	.L295
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5587              		.loc 1 1921 0 is_stmt 0
 5588 0074 3B1C     		mov	r3, r7
 5589 0076 1733     		add	r3, r3, #23
 5590 0078 1B78     		ldrb	r3, [r3]
 5591 007a 002B     		cmp	r3, #0
 5592 007c 01D0     		beq	.L295
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5593              		.loc 1 1921 0
 5594 007e 0123     		mov	r3, #1
 5595 0080 00E0     		b	.L296
 5596              	.L295:
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5597              		.loc 1 1921 0
 5598 0082 0023     		mov	r3, #0
 5599              	.L296:
1921:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5600              		.loc 1 1921 0
 5601 0084 002B     		cmp	r3, #0
 5602 0086 D8D1     		bne	.L297
1924:../Generated_Code/UTIL0.c ****   } /* while */
1925:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 5603              		.loc 1 1925 0 is_stmt 1
 5604 0088 3B1C     		mov	r3, r7
 5605 008a 1733     		add	r3, r3, #23
 5606 008c 1B78     		ldrb	r3, [r3]
 5607 008e 002B     		cmp	r3, #0
 5608 0090 01D1     		bne	.L298
1926:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 5609              		.loc 1 1926 0
 5610 0092 0423     		mov	r3, #4
 5611 0094 03E0     		b	.L299
 5612              	.L298:
1927:../Generated_Code/UTIL0.c ****   }
1928:../Generated_Code/UTIL0.c ****   *str = p;
 5613              		.loc 1 1928 0
 5614 0096 3A69     		ldr	r2, [r7, #16]
 5615 0098 7B68     		ldr	r3, [r7, #4]
 5616 009a 1A60     		str	r2, [r3]
1929:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5617              		.loc 1 1929 0
 5618 009c 0023     		mov	r3, #0
 5619              	.L299:
 5620              	.LBE36:
1930:../Generated_Code/UTIL0.c **** }
 5621              		.loc 1 1930 0
 5622 009e 181C     		mov	r0, r3
 5623 00a0 BD46     		mov	sp, r7
 5624 00a2 06B0     		add	sp, sp, #24
 5625              		@ sp needed for prologue
 5626 00a4 80BD     		pop	{r7, pc}
 5627              		.cfi_endproc
 5628              	.LFE49:
 5630 00a6 C046     		.section	.text._Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh,"ax",%progbits
 5631              		.align	2
 5632              		.global	_Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh
 5633              		.code	16
 5634              		.thumb_func
 5636              	_Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh:
 5637              	.LFB50:
1931:../Generated_Code/UTIL0.c **** 
1932:../Generated_Code/UTIL0.c **** /*
1933:../Generated_Code/UTIL0.c **** ** ===================================================================
1934:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_ScanHex8uNumberNoPrefix (component Utility)
1935:../Generated_Code/UTIL0.c **** **     Description :
1936:../Generated_Code/UTIL0.c **** **         Scans a hexadecimal 8bit number, without 0x
1937:../Generated_Code/UTIL0.c **** **     Parameters  :
1938:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1939:../Generated_Code/UTIL0.c **** **         str             - String to scan, starting with 0x. It
1940:../Generated_Code/UTIL0.c **** **                           returns as well until where it has scanned
1941:../Generated_Code/UTIL0.c **** **       * val             - Pointer to value
1942:../Generated_Code/UTIL0.c **** **     Returns     :
1943:../Generated_Code/UTIL0.c **** **         ---             - Error code
1944:../Generated_Code/UTIL0.c **** ** ===================================================================
1945:../Generated_Code/UTIL0.c **** */
1946:../Generated_Code/UTIL0.c **** byte UTIL0_ScanHex8uNumberNoPrefix(const unsigned char **str, byte *val)
1947:../Generated_Code/UTIL0.c **** {
 5638              		.loc 1 1947 0
 5639              		.cfi_startproc
 5640 0000 80B5     		push	{r7, lr}
 5641              	.LCFI135:
 5642              		.cfi_def_cfa_offset 8
 5643              		.cfi_offset 7, -8
 5644              		.cfi_offset 14, -4
 5645 0002 86B0     		sub	sp, sp, #24
 5646              	.LCFI136:
 5647              		.cfi_def_cfa_offset 32
 5648 0004 00AF     		add	r7, sp, #0
 5649              	.LCFI137:
 5650              		.cfi_def_cfa_register 7
 5651 0006 7860     		str	r0, [r7, #4]
 5652 0008 3960     		str	r1, [r7]
 5653              	.LBB37:
1948:../Generated_Code/UTIL0.c ****   /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zero
1949:../Generated_Code/UTIL0.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
 5654              		.loc 1 1949 0
 5655 000a 3B1C     		mov	r3, r7
 5656 000c 1733     		add	r3, r3, #23
 5657 000e 0322     		mov	r2, #3
 5658 0010 1A70     		strb	r2, [r3]
1950:../Generated_Code/UTIL0.c ****   const unsigned char *p = *str;
 5659              		.loc 1 1950 0
 5660 0012 7B68     		ldr	r3, [r7, #4]
 5661 0014 1B68     		ldr	r3, [r3]
 5662 0016 3B61     		str	r3, [r7, #16]
1951:../Generated_Code/UTIL0.c ****   byte v;
1952:../Generated_Code/UTIL0.c **** 
1953:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 5663              		.loc 1 1953 0
 5664 0018 02E0     		b	.L301
 5665              	.L302:
1954:../Generated_Code/UTIL0.c ****     p++; /* skip space */
 5666              		.loc 1 1954 0
 5667 001a 3B69     		ldr	r3, [r7, #16]
 5668 001c 0133     		add	r3, r3, #1
 5669 001e 3B61     		str	r3, [r7, #16]
 5670              	.L301:
1953:../Generated_Code/UTIL0.c ****   while(*p==' ') { /* skip leading spaces */
 5671              		.loc 1 1953 0
 5672 0020 3B69     		ldr	r3, [r7, #16]
 5673 0022 1B78     		ldrb	r3, [r3]
 5674 0024 203B     		sub	r3, r3, #32
 5675 0026 5A42     		neg	r2, r3
 5676 0028 5341     		adc	r3, r3, r2
 5677 002a DBB2     		uxtb	r3, r3
 5678 002c 002B     		cmp	r3, #0
 5679 002e F4D1     		bne	.L302
1955:../Generated_Code/UTIL0.c ****   }
1956:../Generated_Code/UTIL0.c ****   *val = 0;
 5680              		.loc 1 1956 0
 5681 0030 3B68     		ldr	r3, [r7]
 5682 0032 0022     		mov	r2, #0
 5683 0034 1A70     		strb	r2, [r3]
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5684              		.loc 1 1957 0
 5685 0036 11E0     		b	.L303
 5686              	.L306:
1958:../Generated_Code/UTIL0.c ****     *val = (uint8_t)((*val)*16 + v);
 5687              		.loc 1 1958 0
 5688 0038 3B68     		ldr	r3, [r7]
 5689 003a 1B78     		ldrb	r3, [r3]
 5690 003c 1B01     		lsl	r3, r3, #4
 5691 003e DAB2     		uxtb	r2, r3
 5692 0040 3B1C     		mov	r3, r7
 5693 0042 0F33     		add	r3, r3, #15
 5694 0044 1B78     		ldrb	r3, [r3]
 5695 0046 D318     		add	r3, r2, r3
 5696 0048 DAB2     		uxtb	r2, r3
 5697 004a 3B68     		ldr	r3, [r7]
 5698 004c 1A70     		strb	r2, [r3]
1959:../Generated_Code/UTIL0.c ****     nofDigits--;
 5699              		.loc 1 1959 0
 5700 004e 3B1C     		mov	r3, r7
 5701 0050 1733     		add	r3, r3, #23
 5702 0052 3A1C     		mov	r2, r7
 5703 0054 1732     		add	r2, r2, #23
 5704 0056 1278     		ldrb	r2, [r2]
 5705 0058 013A     		sub	r2, r2, #1
 5706 005a 1A70     		strb	r2, [r3]
 5707              	.L303:
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5708              		.loc 1 1957 0
 5709 005c 3A1C     		mov	r2, r7
 5710 005e 1032     		add	r2, r2, #16
 5711 0060 3B1C     		mov	r3, r7
 5712 0062 0F33     		add	r3, r3, #15
 5713 0064 101C     		mov	r0, r2
 5714 0066 191C     		mov	r1, r3
 5715 0068 FFF7FEFF 		bl	_ZL8HexToDecPPKhPh
 5716 006c 031C     		mov	r3, r0
 5717 006e 002B     		cmp	r3, #0
 5718 0070 06D1     		bne	.L304
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5719              		.loc 1 1957 0 is_stmt 0
 5720 0072 3B1C     		mov	r3, r7
 5721 0074 1733     		add	r3, r3, #23
 5722 0076 1B78     		ldrb	r3, [r3]
 5723 0078 002B     		cmp	r3, #0
 5724 007a 01D0     		beq	.L304
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5725              		.loc 1 1957 0
 5726 007c 0123     		mov	r3, #1
 5727 007e 00E0     		b	.L305
 5728              	.L304:
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5729              		.loc 1 1957 0
 5730 0080 0023     		mov	r3, #0
 5731              	.L305:
1957:../Generated_Code/UTIL0.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 5732              		.loc 1 1957 0
 5733 0082 002B     		cmp	r3, #0
 5734 0084 D8D1     		bne	.L306
1960:../Generated_Code/UTIL0.c ****   } /* while */
1961:../Generated_Code/UTIL0.c ****   if (nofDigits==0) {
 5735              		.loc 1 1961 0 is_stmt 1
 5736 0086 3B1C     		mov	r3, r7
 5737 0088 1733     		add	r3, r3, #23
 5738 008a 1B78     		ldrb	r3, [r3]
 5739 008c 002B     		cmp	r3, #0
 5740 008e 01D1     		bne	.L307
1962:../Generated_Code/UTIL0.c ****     return ERR_OVERFLOW;
 5741              		.loc 1 1962 0
 5742 0090 0423     		mov	r3, #4
 5743 0092 03E0     		b	.L309
 5744              	.L307:
1963:../Generated_Code/UTIL0.c ****   }
1964:../Generated_Code/UTIL0.c ****   *str = p;
 5745              		.loc 1 1964 0
 5746 0094 3A69     		ldr	r2, [r7, #16]
 5747 0096 7B68     		ldr	r3, [r7, #4]
 5748 0098 1A60     		str	r2, [r3]
1965:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5749              		.loc 1 1965 0
 5750 009a 0023     		mov	r3, #0
 5751              	.L309:
 5752              	.LBE37:
1966:../Generated_Code/UTIL0.c **** }
 5753              		.loc 1 1966 0
 5754 009c 181C     		mov	r0, r3
 5755 009e BD46     		mov	sp, r7
 5756 00a0 06B0     		add	sp, sp, #24
 5757              		@ sp needed for prologue
 5758 00a2 80BD     		pop	{r7, pc}
 5759              		.cfi_endproc
 5760              	.LFE50:
 5762              		.section	.text._Z16UTIL0_strtailcmpPhS_,"ax",%progbits
 5763              		.align	2
 5764              		.global	_Z16UTIL0_strtailcmpPhS_
 5765              		.code	16
 5766              		.thumb_func
 5768              	_Z16UTIL0_strtailcmpPhS_:
 5769              	.LFB51:
1967:../Generated_Code/UTIL0.c **** 
1968:../Generated_Code/UTIL0.c **** /*
1969:../Generated_Code/UTIL0.c **** ** ===================================================================
1970:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strtailcmp (component Utility)
1971:../Generated_Code/UTIL0.c **** **     Description :
1972:../Generated_Code/UTIL0.c **** **         Compares the tail of a string and returns 0 if it matches, 1
1973:../Generated_Code/UTIL0.c **** **         otherwise
1974:../Generated_Code/UTIL0.c **** **     Parameters  :
1975:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
1976:../Generated_Code/UTIL0.c **** **       * str             - Pointer to string. This string is compared
1977:../Generated_Code/UTIL0.c **** **                           if it contains the tail.
1978:../Generated_Code/UTIL0.c **** **       * tail            - Pointer to tail string.
1979:../Generated_Code/UTIL0.c **** **     Returns     :
1980:../Generated_Code/UTIL0.c **** **         ---             - returns 0 if tail matches, -1 otherwise
1981:../Generated_Code/UTIL0.c **** ** ===================================================================
1982:../Generated_Code/UTIL0.c **** */
1983:../Generated_Code/UTIL0.c **** byte UTIL0_strtailcmp(byte *str, byte *tail)
1984:../Generated_Code/UTIL0.c **** {
 5770              		.loc 1 1984 0
 5771              		.cfi_startproc
 5772 0000 80B5     		push	{r7, lr}
 5773              	.LCFI138:
 5774              		.cfi_def_cfa_offset 8
 5775              		.cfi_offset 7, -8
 5776              		.cfi_offset 14, -4
 5777 0002 84B0     		sub	sp, sp, #16
 5778              	.LCFI139:
 5779              		.cfi_def_cfa_offset 24
 5780 0004 00AF     		add	r7, sp, #0
 5781              	.LCFI140:
 5782              		.cfi_def_cfa_register 7
 5783 0006 7860     		str	r0, [r7, #4]
 5784 0008 3960     		str	r1, [r7]
 5785              	.LBB38:
1985:../Generated_Code/UTIL0.c ****   int i, j;
1986:../Generated_Code/UTIL0.c **** 
1987:../Generated_Code/UTIL0.c ****   i = (int)UTIL0_strlen((char*)str);
 5786              		.loc 1 1987 0
 5787 000a 7B68     		ldr	r3, [r7, #4]
 5788 000c 181C     		mov	r0, r3
 5789 000e FFF7FEFF 		bl	strlen
 5790 0012 031C     		mov	r3, r0
 5791 0014 FB60     		str	r3, [r7, #12]
1988:../Generated_Code/UTIL0.c ****   j = (int)UTIL0_strlen((char*)tail);
 5792              		.loc 1 1988 0
 5793 0016 3B68     		ldr	r3, [r7]
 5794 0018 181C     		mov	r0, r3
 5795 001a FFF7FEFF 		bl	strlen
 5796 001e 031C     		mov	r3, r0
 5797 0020 BB60     		str	r3, [r7, #8]
1989:../Generated_Code/UTIL0.c ****   if (j>i) { /* str is smaller than tail */
 5798              		.loc 1 1989 0
 5799 0022 BA68     		ldr	r2, [r7, #8]
 5800 0024 FB68     		ldr	r3, [r7, #12]
 5801 0026 9A42     		cmp	r2, r3
 5802 0028 0CDD     		ble	.L315
1990:../Generated_Code/UTIL0.c ****     return 1; /* cannot match */
 5803              		.loc 1 1990 0
 5804 002a 0123     		mov	r3, #1
 5805 002c 1AE0     		b	.L312
 5806              	.L314:
1991:../Generated_Code/UTIL0.c ****   }
1992:../Generated_Code/UTIL0.c ****   /* compare strings */
1993:../Generated_Code/UTIL0.c ****   while(str[i]==tail[j]) {
1994:../Generated_Code/UTIL0.c ****     i--;
 5807              		.loc 1 1994 0
 5808 002e FB68     		ldr	r3, [r7, #12]
 5809 0030 013B     		sub	r3, r3, #1
 5810 0032 FB60     		str	r3, [r7, #12]
1995:../Generated_Code/UTIL0.c ****     j--;
 5811              		.loc 1 1995 0
 5812 0034 BB68     		ldr	r3, [r7, #8]
 5813 0036 013B     		sub	r3, r3, #1
 5814 0038 BB60     		str	r3, [r7, #8]
1996:../Generated_Code/UTIL0.c ****     if (j<0) {
 5815              		.loc 1 1996 0
 5816 003a BB68     		ldr	r3, [r7, #8]
 5817 003c 002B     		cmp	r3, #0
 5818 003e 02DA     		bge	.L313
1997:../Generated_Code/UTIL0.c ****       return 0; /* match */
 5819              		.loc 1 1997 0
 5820 0040 0023     		mov	r3, #0
 5821 0042 0FE0     		b	.L312
 5822              	.L315:
1993:../Generated_Code/UTIL0.c ****   while(str[i]==tail[j]) {
 5823              		.loc 1 1993 0
 5824 0044 C046     		mov	r8, r8
 5825              	.L313:
1993:../Generated_Code/UTIL0.c ****   while(str[i]==tail[j]) {
 5826              		.loc 1 1993 0 is_stmt 0
 5827 0046 FB68     		ldr	r3, [r7, #12]
 5828 0048 7A68     		ldr	r2, [r7, #4]
 5829 004a D318     		add	r3, r2, r3
 5830 004c 1A78     		ldrb	r2, [r3]
 5831 004e BB68     		ldr	r3, [r7, #8]
 5832 0050 3968     		ldr	r1, [r7]
 5833 0052 CB18     		add	r3, r1, r3
 5834 0054 1B78     		ldrb	r3, [r3]
 5835 0056 D31A     		sub	r3, r2, r3
 5836 0058 5A42     		neg	r2, r3
 5837 005a 5341     		adc	r3, r3, r2
 5838 005c DBB2     		uxtb	r3, r3
 5839 005e 002B     		cmp	r3, #0
 5840 0060 E5D1     		bne	.L314
1998:../Generated_Code/UTIL0.c ****     }
1999:../Generated_Code/UTIL0.c ****   }
2000:../Generated_Code/UTIL0.c ****   return 1; /* !=0 means no match */
 5841              		.loc 1 2000 0 is_stmt 1
 5842 0062 0123     		mov	r3, #1
 5843              	.L312:
 5844              	.LBE38:
2001:../Generated_Code/UTIL0.c **** }
 5845              		.loc 1 2001 0
 5846 0064 181C     		mov	r0, r3
 5847 0066 BD46     		mov	sp, r7
 5848 0068 04B0     		add	sp, sp, #16
 5849              		@ sp needed for prologue
 5850 006a 80BD     		pop	{r7, pc}
 5851              		.cfi_endproc
 5852              	.LFE51:
 5854              		.section	.text._Z16UTIL0_strCutTailPhS_,"ax",%progbits
 5855              		.align	2
 5856              		.global	_Z16UTIL0_strCutTailPhS_
 5857              		.code	16
 5858              		.thumb_func
 5860              	_Z16UTIL0_strCutTailPhS_:
 5861              	.LFB52:
2002:../Generated_Code/UTIL0.c **** 
2003:../Generated_Code/UTIL0.c **** /*
2004:../Generated_Code/UTIL0.c **** ** ===================================================================
2005:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strCutTail (component Utility)
2006:../Generated_Code/UTIL0.c **** **     Description :
2007:../Generated_Code/UTIL0.c **** **         Removes a tailing substring from a string. The string passed
2008:../Generated_Code/UTIL0.c **** **         will be modified (the tail is cut by writing a zero byte to
2009:../Generated_Code/UTIL0.c **** **         the string!)
2010:../Generated_Code/UTIL0.c **** **     Parameters  :
2011:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
2012:../Generated_Code/UTIL0.c **** **       * str             - Pointer to string where to remove the tail
2013:../Generated_Code/UTIL0.c **** **       * tail            - Pointer to substring to remove
2014:../Generated_Code/UTIL0.c **** **     Returns     :
2015:../Generated_Code/UTIL0.c **** **         ---             - Error code, ERR_OK if no error, otherwise
2016:../Generated_Code/UTIL0.c **** **                           ERR_FAIL if tail is not found
2017:../Generated_Code/UTIL0.c **** ** ===================================================================
2018:../Generated_Code/UTIL0.c **** */
2019:../Generated_Code/UTIL0.c **** byte UTIL0_strCutTail(byte *str, byte *tail)
2020:../Generated_Code/UTIL0.c **** {
 5862              		.loc 1 2020 0
 5863              		.cfi_startproc
 5864 0000 80B5     		push	{r7, lr}
 5865              	.LCFI141:
 5866              		.cfi_def_cfa_offset 8
 5867              		.cfi_offset 7, -8
 5868              		.cfi_offset 14, -4
 5869 0002 84B0     		sub	sp, sp, #16
 5870              	.LCFI142:
 5871              		.cfi_def_cfa_offset 24
 5872 0004 00AF     		add	r7, sp, #0
 5873              	.LCFI143:
 5874              		.cfi_def_cfa_register 7
 5875 0006 7860     		str	r0, [r7, #4]
 5876 0008 3960     		str	r1, [r7]
 5877              	.LBB39:
2021:../Generated_Code/UTIL0.c ****   /* cut the tail from the string */
2022:../Generated_Code/UTIL0.c ****   size_t strLen, tailLen;
2023:../Generated_Code/UTIL0.c **** 
2024:../Generated_Code/UTIL0.c ****   if (UTIL0_strtailcmp(str, tail)!=0) { /* check if tail is present */
 5878              		.loc 1 2024 0
 5879 000a 7A68     		ldr	r2, [r7, #4]
 5880 000c 3B68     		ldr	r3, [r7]
 5881 000e 101C     		mov	r0, r2
 5882 0010 191C     		mov	r1, r3
 5883 0012 FFF7FEFF 		bl	_Z16UTIL0_strtailcmpPhS_
 5884 0016 031C     		mov	r3, r0
 5885 0018 5A1E     		sub	r2, r3, #1
 5886 001a 9341     		sbc	r3, r3, r2
 5887 001c DBB2     		uxtb	r3, r3
 5888 001e 002B     		cmp	r3, #0
 5889 0020 01D0     		beq	.L317
2025:../Generated_Code/UTIL0.c ****     return ERR_FAILED; /* tail not found */
 5890              		.loc 1 2025 0
 5891 0022 1B23     		mov	r3, #27
 5892 0024 13E0     		b	.L318
 5893              	.L317:
2026:../Generated_Code/UTIL0.c ****   }
2027:../Generated_Code/UTIL0.c ****   tailLen = UTIL0_strlen((char*)tail);
 5894              		.loc 1 2027 0
 5895 0026 3B68     		ldr	r3, [r7]
 5896 0028 181C     		mov	r0, r3
 5897 002a FFF7FEFF 		bl	strlen
 5898 002e 031C     		mov	r3, r0
 5899 0030 FB60     		str	r3, [r7, #12]
2028:../Generated_Code/UTIL0.c ****   strLen = UTIL0_strlen((char*)str);
 5900              		.loc 1 2028 0
 5901 0032 7B68     		ldr	r3, [r7, #4]
 5902 0034 181C     		mov	r0, r3
 5903 0036 FFF7FEFF 		bl	strlen
 5904 003a 031C     		mov	r3, r0
 5905 003c BB60     		str	r3, [r7, #8]
2029:../Generated_Code/UTIL0.c ****   /* write \0 to cut the tail */
2030:../Generated_Code/UTIL0.c ****   str[strLen-tailLen] = '\0';
 5906              		.loc 1 2030 0
 5907 003e BA68     		ldr	r2, [r7, #8]
 5908 0040 FB68     		ldr	r3, [r7, #12]
 5909 0042 D31A     		sub	r3, r2, r3
 5910 0044 7A68     		ldr	r2, [r7, #4]
 5911 0046 D318     		add	r3, r2, r3
 5912 0048 0022     		mov	r2, #0
 5913 004a 1A70     		strb	r2, [r3]
2031:../Generated_Code/UTIL0.c ****   return ERR_OK;
 5914              		.loc 1 2031 0
 5915 004c 0023     		mov	r3, #0
 5916              	.L318:
 5917              	.LBE39:
2032:../Generated_Code/UTIL0.c **** }
 5918              		.loc 1 2032 0
 5919 004e 181C     		mov	r0, r3
 5920 0050 BD46     		mov	sp, r7
 5921 0052 04B0     		add	sp, sp, #16
 5922              		@ sp needed for prologue
 5923 0054 80BD     		pop	{r7, pc}
 5924              		.cfi_endproc
 5925              	.LFE52:
 5927 0056 C046     		.section	.text._Z29UTIL0_strcatNum32sDotValue100Phjl,"ax",%progbits
 5928              		.align	2
 5929              		.global	_Z29UTIL0_strcatNum32sDotValue100Phjl
 5930              		.code	16
 5931              		.thumb_func
 5933              	_Z29UTIL0_strcatNum32sDotValue100Phjl:
 5934              	.LFB53:
2033:../Generated_Code/UTIL0.c **** 
2034:../Generated_Code/UTIL0.c **** /*
2035:../Generated_Code/UTIL0.c **** ** ===================================================================
2036:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strcatNum32sDotValue100 (component Utility)
2037:../Generated_Code/UTIL0.c **** **     Description :
2038:../Generated_Code/UTIL0.c **** **         Appends a 32bit signed value to a buffer. The value is in
2039:../Generated_Code/UTIL0.c **** **         1/100 units.  For example for the value -13456 it will
2040:../Generated_Code/UTIL0.c **** **         append the string "-134.56"
2041:../Generated_Code/UTIL0.c **** **     Parameters  :
2042:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
2043:../Generated_Code/UTIL0.c **** **       * dst             - Pointer to destination string
2044:../Generated_Code/UTIL0.c **** **         dstSize         - Size of the destination buffer (in
2045:../Generated_Code/UTIL0.c **** **                           bytes).
2046:../Generated_Code/UTIL0.c **** **         num             - Value to convert.
2047:../Generated_Code/UTIL0.c **** **     Returns     : Nothing
2048:../Generated_Code/UTIL0.c **** ** ===================================================================
2049:../Generated_Code/UTIL0.c **** */
2050:../Generated_Code/UTIL0.c **** void UTIL0_strcatNum32sDotValue100(byte *dst, size_t dstSize, long num)
2051:../Generated_Code/UTIL0.c **** {
 5935              		.loc 1 2051 0
 5936              		.cfi_startproc
 5937 0000 80B5     		push	{r7, lr}
 5938              	.LCFI144:
 5939              		.cfi_def_cfa_offset 8
 5940              		.cfi_offset 7, -8
 5941              		.cfi_offset 14, -4
 5942 0002 86B0     		sub	sp, sp, #24
 5943              	.LCFI145:
 5944              		.cfi_def_cfa_offset 32
 5945 0004 02AF     		add	r7, sp, #8
 5946              	.LCFI146:
 5947              		.cfi_def_cfa 7, 24
 5948 0006 F860     		str	r0, [r7, #12]
 5949 0008 B960     		str	r1, [r7, #8]
 5950 000a 7A60     		str	r2, [r7, #4]
2052:../Generated_Code/UTIL0.c ****   UTIL0_strcatNum32s(dst, dstSize, num/100);
 5951              		.loc 1 2052 0
 5952 000c 7B68     		ldr	r3, [r7, #4]
 5953 000e 181C     		mov	r0, r3
 5954 0010 6421     		mov	r1, #100
 5955 0012 FFF7FEFF 		bl	__aeabi_idiv
 5956 0016 031C     		mov	r3, r0
 5957 0018 F968     		ldr	r1, [r7, #12]
 5958 001a BA68     		ldr	r2, [r7, #8]
 5959 001c 081C     		mov	r0, r1
 5960 001e 111C     		mov	r1, r2
 5961 0020 1A1C     		mov	r2, r3
 5962 0022 FFF7FEFF 		bl	_Z18UTIL0_strcatNum32sPhjl
2053:../Generated_Code/UTIL0.c ****   UTIL0_chcat(dst, dstSize, '.');
 5963              		.loc 1 2053 0
 5964 0026 FA68     		ldr	r2, [r7, #12]
 5965 0028 BB68     		ldr	r3, [r7, #8]
 5966 002a 101C     		mov	r0, r2
 5967 002c 191C     		mov	r1, r3
 5968 002e 2E22     		mov	r2, #46
 5969 0030 FFF7FEFF 		bl	_Z11UTIL0_chcatPhjh
2054:../Generated_Code/UTIL0.c ****   if (num<0) {
 5970              		.loc 1 2054 0
 5971 0034 7B68     		ldr	r3, [r7, #4]
 5972 0036 002B     		cmp	r3, #0
 5973 0038 02DA     		bge	.L320
2055:../Generated_Code/UTIL0.c ****     num = -num;
 5974              		.loc 1 2055 0
 5975 003a 7B68     		ldr	r3, [r7, #4]
 5976 003c 5B42     		neg	r3, r3
 5977 003e 7B60     		str	r3, [r7, #4]
 5978              	.L320:
2056:../Generated_Code/UTIL0.c ****   }
2057:../Generated_Code/UTIL0.c ****   UTIL0_strcatNum16uFormatted(dst, dstSize, (uint16_t)(num%100), '0', 2);
 5979              		.loc 1 2057 0
 5980 0040 7B68     		ldr	r3, [r7, #4]
 5981 0042 181C     		mov	r0, r3
 5982 0044 6421     		mov	r1, #100
 5983 0046 FFF7FEFF 		bl	__aeabi_idivmod
 5984 004a 0B1C     		mov	r3, r1
 5985 004c 9BB2     		uxth	r3, r3
 5986 004e F968     		ldr	r1, [r7, #12]
 5987 0050 BA68     		ldr	r2, [r7, #8]
 5988 0052 0220     		mov	r0, #2
 5989 0054 0090     		str	r0, [sp]
 5990 0056 081C     		mov	r0, r1
 5991 0058 111C     		mov	r1, r2
 5992 005a 1A1C     		mov	r2, r3
 5993 005c 3023     		mov	r3, #48
 5994 005e FFF7FEFF 		bl	_Z27UTIL0_strcatNum16uFormattedPhjtch
2058:../Generated_Code/UTIL0.c **** }
 5995              		.loc 1 2058 0
 5996 0062 BD46     		mov	sp, r7
 5997 0064 04B0     		add	sp, sp, #16
 5998              		@ sp needed for prologue
 5999 0066 80BD     		pop	{r7, pc}
 6000              		.cfi_endproc
 6001              	.LFE53:
 6003              		.section	.text._Z13UTIL0_strFindPhS_,"ax",%progbits
 6004              		.align	2
 6005              		.global	_Z13UTIL0_strFindPhS_
 6006              		.code	16
 6007              		.thumb_func
 6009              	_Z13UTIL0_strFindPhS_:
 6010              	.LFB54:
2059:../Generated_Code/UTIL0.c **** 
2060:../Generated_Code/UTIL0.c **** /*
2061:../Generated_Code/UTIL0.c **** ** ===================================================================
2062:../Generated_Code/UTIL0.c **** **     Method      :  UTIL0_strFind (component Utility)
2063:../Generated_Code/UTIL0.c **** **     Description :
2064:../Generated_Code/UTIL0.c **** **         Searches a substring inside a string and returns the
2065:../Generated_Code/UTIL0.c **** **         position.
2066:../Generated_Code/UTIL0.c **** **     Parameters  :
2067:../Generated_Code/UTIL0.c **** **         NAME            - DESCRIPTION
2068:../Generated_Code/UTIL0.c **** **       * str             - Pointer to string which will be searched
2069:../Generated_Code/UTIL0.c **** **       * subStr          - Pointer to substring to search
2070:../Generated_Code/UTIL0.c **** **                           inside str
2071:../Generated_Code/UTIL0.c **** **     Returns     :
2072:../Generated_Code/UTIL0.c **** **         ---             - -1 if not found, otherwise the character
2073:../Generated_Code/UTIL0.c **** **                           index.
2074:../Generated_Code/UTIL0.c **** ** ===================================================================
2075:../Generated_Code/UTIL0.c **** */
2076:../Generated_Code/UTIL0.c **** int16_t UTIL0_strFind(byte *str, byte *subStr)
2077:../Generated_Code/UTIL0.c **** {
 6011              		.loc 1 2077 0
 6012              		.cfi_startproc
 6013 0000 80B5     		push	{r7, lr}
 6014              	.LCFI147:
 6015              		.cfi_def_cfa_offset 8
 6016              		.cfi_offset 7, -8
 6017              		.cfi_offset 14, -4
 6018 0002 84B0     		sub	sp, sp, #16
 6019              	.LCFI148:
 6020              		.cfi_def_cfa_offset 24
 6021 0004 00AF     		add	r7, sp, #0
 6022              	.LCFI149:
 6023              		.cfi_def_cfa_register 7
 6024 0006 7860     		str	r0, [r7, #4]
 6025 0008 3960     		str	r1, [r7]
 6026              	.LBB40:
2078:../Generated_Code/UTIL0.c ****   int16_t i, len;
2079:../Generated_Code/UTIL0.c **** 
2080:../Generated_Code/UTIL0.c ****   len = (int16_t)UTIL0_strlen((char*)subStr);
 6027              		.loc 1 2080 0
 6028 000a 3B68     		ldr	r3, [r7]
 6029 000c 181C     		mov	r0, r3
 6030 000e FFF7FEFF 		bl	strlen
 6031 0012 021C     		mov	r2, r0
 6032 0014 3B1C     		mov	r3, r7
 6033 0016 0C33     		add	r3, r3, #12
 6034 0018 1A80     		strh	r2, [r3]
2081:../Generated_Code/UTIL0.c ****   for (i=0; *str!='\0'; i++, str++) {
 6035              		.loc 1 2081 0
 6036 001a 3B1C     		mov	r3, r7
 6037 001c 0E33     		add	r3, r3, #14
 6038 001e 0022     		mov	r2, #0
 6039 0020 1A80     		strh	r2, [r3]
 6040 0022 1BE0     		b	.L322
 6041              	.L325:
2082:../Generated_Code/UTIL0.c ****     if (UTIL0_strncmp((char*)str, (char*)subStr, len)==0) {
 6042              		.loc 1 2082 0
 6043 0024 3B1C     		mov	r3, r7
 6044 0026 0C33     		add	r3, r3, #12
 6045 0028 0022     		mov	r2, #0
 6046 002a 9B5E     		ldrsh	r3, [r3, r2]
 6047 002c 7968     		ldr	r1, [r7, #4]
 6048 002e 3A68     		ldr	r2, [r7]
 6049 0030 081C     		mov	r0, r1
 6050 0032 111C     		mov	r1, r2
 6051 0034 1A1C     		mov	r2, r3
 6052 0036 FFF7FEFF 		bl	strncmp
 6053 003a 031C     		mov	r3, r0
 6054 003c 002B     		cmp	r3, #0
 6055 003e 03D1     		bne	.L323
2083:../Generated_Code/UTIL0.c ****       return i; /* found */
 6056              		.loc 1 2083 0
 6057 0040 3B1C     		mov	r3, r7
 6058 0042 0E33     		add	r3, r3, #14
 6059 0044 1B88     		ldrh	r3, [r3]
 6060 0046 11E0     		b	.L324
 6061              	.L323:
2081:../Generated_Code/UTIL0.c ****   for (i=0; *str!='\0'; i++, str++) {
 6062              		.loc 1 2081 0
 6063 0048 3B1C     		mov	r3, r7
 6064 004a 0E33     		add	r3, r3, #14
 6065 004c 3A1C     		mov	r2, r7
 6066 004e 0E32     		add	r2, r2, #14
 6067 0050 1288     		ldrh	r2, [r2]
 6068 0052 0132     		add	r2, r2, #1
 6069 0054 1A80     		strh	r2, [r3]
 6070 0056 7B68     		ldr	r3, [r7, #4]
 6071 0058 0133     		add	r3, r3, #1
 6072 005a 7B60     		str	r3, [r7, #4]
 6073              	.L322:
2081:../Generated_Code/UTIL0.c ****   for (i=0; *str!='\0'; i++, str++) {
 6074              		.loc 1 2081 0 is_stmt 0
 6075 005c 7B68     		ldr	r3, [r7, #4]
 6076 005e 1B78     		ldrb	r3, [r3]
 6077 0060 5A1E     		sub	r2, r3, #1
 6078 0062 9341     		sbc	r3, r3, r2
 6079 0064 DBB2     		uxtb	r3, r3
 6080 0066 002B     		cmp	r3, #0
 6081 0068 DCD1     		bne	.L325
2084:../Generated_Code/UTIL0.c ****     }
2085:../Generated_Code/UTIL0.c ****   }
2086:../Generated_Code/UTIL0.c ****   return -1; /* not found */
 6082              		.loc 1 2086 0 is_stmt 1
 6083 006a 034B     		ldr	r3, .L326
 6084              	.L324:
 6085 006c 1BB2     		sxth	r3, r3
 6086              	.LBE40:
2087:../Generated_Code/UTIL0.c **** }
 6087              		.loc 1 2087 0
 6088 006e 181C     		mov	r0, r3
 6089 0070 BD46     		mov	sp, r7
 6090 0072 04B0     		add	sp, sp, #16
 6091              		@ sp needed for prologue
 6092 0074 80BD     		pop	{r7, pc}
 6093              	.L327:
 6094 0076 C046     		.align	2
 6095              	.L326:
 6096 0078 FFFF0000 		.word	65535
 6097              		.cfi_endproc
 6098              	.LFE54:
 6100              		.section	.rodata._ZZ13UTIL0_WeekDaythhE4skew,"a",%progbits
 6101              		.align	2
 6104              	_ZZ13UTIL0_WeekDaythhE4skew:
 6105 0000 00       		.byte	0
 6106 0001 03       		.byte	3
 6107 0002 03       		.byte	3
 6108 0003 06       		.byte	6
 6109 0004 01       		.byte	1
 6110 0005 04       		.byte	4
 6111 0006 06       		.byte	6
 6112 0007 02       		.byte	2
 6113 0008 05       		.byte	5
 6114 0009 00       		.byte	0
 6115 000a 03       		.byte	3
 6116 000b 05       		.byte	5
 6117              		.text
 6118              	.Letext0:
 6119              		.file 2 "../Generated_Code/PE_Types.h"
 6120              		.file 3 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 6121              		.file 4 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UTIL0.c
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:18     .text._Z12UTIL0_strcpyPhjPKh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:23     .text._Z12UTIL0_strcpyPhjPKh:00000000 _Z12UTIL0_strcpyPhjPKh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:97     .text._Z12UTIL0_strcatPhjPKh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:102    .text._Z12UTIL0_strcatPhjPKh:00000000 _Z12UTIL0_strcatPhjPKh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:206    .text._Z11UTIL0_chcatPhjh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:211    .text._Z11UTIL0_chcatPhjh:00000000 _Z11UTIL0_chcatPhjh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:291    .text._Z16UTIL0_Num8uToStrPhjh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:296    .text._Z16UTIL0_Num8uToStrPhjh:00000000 _Z16UTIL0_Num8uToStrPhjh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:386    .text._Z17UTIL0_Num16uToStrPhjt:00000000 _Z17UTIL0_Num16uToStrPhjt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:334    .text._Z16UTIL0_Num8sToStrPhja:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:339    .text._Z16UTIL0_Num8sToStrPhja:00000000 _Z16UTIL0_Num8sToStrPhja
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:610    .text._Z17UTIL0_Num16sToStrPhjs:00000000 _Z17UTIL0_Num16sToStrPhjs
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:381    .text._Z17UTIL0_Num16uToStrPhjt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:599    .rodata:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:605    .text._Z17UTIL0_Num16sToStrPhjs:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:897    .text._Z17UTIL0_Num16sToStrPhjs:000001c8 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:903    .text._ZL17ShiftRightAndFillPhhh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:907    .text._ZL17ShiftRightAndFillPhhh:00000000 _ZL17ShiftRightAndFillPhhh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1073   .text._Z26UTIL0_Num16sToStrFormattedPhjsch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1078   .text._Z26UTIL0_Num16sToStrFormattedPhjsch:00000000 _Z26UTIL0_Num16sToStrFormattedPhjsch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1131   .text._Z26UTIL0_Num16uToStrFormattedPhjtch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1136   .text._Z26UTIL0_Num16uToStrFormattedPhjtch:00000000 _Z26UTIL0_Num16uToStrFormattedPhjtch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1188   .text._Z26UTIL0_Num32uToStrFormattedPhjmch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1193   .text._Z26UTIL0_Num32uToStrFormattedPhjmch:00000000 _Z26UTIL0_Num32uToStrFormattedPhjmch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2587   .text._Z17UTIL0_Num32uToStrPhjm:00000000 _Z17UTIL0_Num32uToStrPhjm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1242   .text._Z26UTIL0_Num32sToStrFormattedPhjlch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1247   .text._Z26UTIL0_Num32sToStrFormattedPhjlch:00000000 _Z26UTIL0_Num32sToStrFormattedPhjlch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2306   .text._Z17UTIL0_Num32sToStrPhjl:00000000 _Z17UTIL0_Num32sToStrPhjl
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1296   .text._Z17UTIL0_strcatNum8uPhjh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1301   .text._Z17UTIL0_strcatNum8uPhjh:00000000 _Z17UTIL0_strcatNum8uPhjh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1349   .text._Z17UTIL0_strcatNum8sPhja:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1354   .text._Z17UTIL0_strcatNum8sPhja:00000000 _Z17UTIL0_strcatNum8sPhja
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1403   .text._Z18UTIL0_strcatNum16uPhjt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1408   .text._Z18UTIL0_strcatNum16uPhjt:00000000 _Z18UTIL0_strcatNum16uPhjt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1456   .text._Z18UTIL0_strcatNum16sPhjs:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1461   .text._Z18UTIL0_strcatNum16sPhjs:00000000 _Z18UTIL0_strcatNum16sPhjs
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1510   .text._Z27UTIL0_strcatNum16uFormattedPhjtch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1515   .text._Z27UTIL0_strcatNum16uFormattedPhjtch:00000000 _Z27UTIL0_strcatNum16uFormattedPhjtch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1572   .text._Z27UTIL0_strcatNum16sFormattedPhjsch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1577   .text._Z27UTIL0_strcatNum16sFormattedPhjsch:00000000 _Z27UTIL0_strcatNum16sFormattedPhjsch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1635   .text._Z27UTIL0_strcatNum32uFormattedPhjmch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1640   .text._Z27UTIL0_strcatNum32uFormattedPhjmch:00000000 _Z27UTIL0_strcatNum32uFormattedPhjmch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1694   .text._Z27UTIL0_strcatNum32sFormattedPhjlch:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1699   .text._Z27UTIL0_strcatNum32sFormattedPhjlch:00000000 _Z27UTIL0_strcatNum32sFormattedPhjlch
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1753   .text._Z19UTIL0_strcatNum8HexPhjh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1758   .text._Z19UTIL0_strcatNum8HexPhjh:00000000 _Z19UTIL0_strcatNum8HexPhjh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1861   .text._Z20UTIL0_strcatNum16HexPhjt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1866   .text._Z20UTIL0_strcatNum16HexPhjt:00000000 _Z20UTIL0_strcatNum16HexPhjt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1975   .text._Z20UTIL0_strcatNum24HexPhjm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:1980   .text._Z20UTIL0_strcatNum24HexPhjm:00000000 _Z20UTIL0_strcatNum24HexPhjm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2085   .text._Z20UTIL0_strcatNum32HexPhjm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2090   .text._Z20UTIL0_strcatNum32HexPhjm:00000000 _Z20UTIL0_strcatNum32HexPhjm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2195   .text._Z18UTIL0_strcatNum32sPhjl:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2200   .text._Z18UTIL0_strcatNum32sPhjl:00000000 _Z18UTIL0_strcatNum32sPhjl
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2246   .text._Z18UTIL0_strcatNum32uPhjm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2251   .text._Z18UTIL0_strcatNum32uPhjm:00000000 _Z18UTIL0_strcatNum32uPhjm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2301   .text._Z17UTIL0_Num32sToStrPhjl:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2577   .text._Z17UTIL0_Num32sToStrPhjl:000001a8 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2582   .text._Z17UTIL0_Num32uToStrPhjm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2793   .text._Z16UTIL0_IsLeapYeart:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2798   .text._Z16UTIL0_IsLeapYeart:00000000 _Z16UTIL0_IsLeapYeart
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2862   .text._Z13UTIL0_WeekDaythh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:2867   .text._Z13UTIL0_WeekDaythh:00000000 _Z13UTIL0_WeekDaythh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3022   .text._Z13UTIL0_WeekDaythh:000000f0 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:6104   .rodata._ZZ13UTIL0_WeekDaythhE4skew:00000000 _ZZ13UTIL0_WeekDaythhE4skew
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3032   .text._Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3037   .text._Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc:00000000 _Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3303   .text._Z21UTIL0_ReadEscapedNamePKhPhjPjS2_PKc:00000168 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3308   .text._Z11UTIL0_xatoiPPKhPl:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3313   .text._Z11UTIL0_xatoiPPKhPl:00000000 _Z11UTIL0_xatoiPPKhPl
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3663   .text._Z14UTIL0_ScanDatePPKhPhS2_Pt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3668   .text._Z14UTIL0_ScanDatePPKhPhS2_Pt:00000000 _Z14UTIL0_ScanDatePPKhPhS2_Pt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4175   .text._Z25UTIL0_ScanDecimal8uNumberPPKhPh:00000000 _Z25UTIL0_ScanDecimal8uNumberPPKhPh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4462   .text._Z26UTIL0_ScanDecimal16uNumberPPKhPt:00000000 _Z26UTIL0_ScanDecimal16uNumberPPKhPt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3878   .text._Z14UTIL0_ScanDatePPKhPhS2_Pt:00000124 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3883   .text._Z14UTIL0_ScanTimePPKhPhS2_S2_S2_:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:3888   .text._Z14UTIL0_ScanTimePPKhPhS2_S2_S2_:00000000 _Z14UTIL0_ScanTimePPKhPhS2_S2_S2_
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4170   .text._Z25UTIL0_ScanDecimal8uNumberPPKhPh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4319   .text._Z25UTIL0_ScanDecimal8sNumberPPKhPa:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4324   .text._Z25UTIL0_ScanDecimal8sNumberPPKhPa:00000000 _Z25UTIL0_ScanDecimal8sNumberPPKhPa
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4457   .text._Z26UTIL0_ScanDecimal16uNumberPPKhPt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4606   .text._Z26UTIL0_ScanDecimal16sNumberPPKhPs:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4611   .text._Z26UTIL0_ScanDecimal16sNumberPPKhPs:00000000 _Z26UTIL0_ScanDecimal16sNumberPPKhPs
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4744   .text._Z26UTIL0_ScanDecimal32uNumberPPKhPm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4749   .text._Z26UTIL0_ScanDecimal32uNumberPPKhPm:00000000 _Z26UTIL0_ScanDecimal32uNumberPPKhPm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4892   .text._Z26UTIL0_ScanDecimal32sNumberPPKhPm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:4897   .text._Z26UTIL0_ScanDecimal32sNumberPPKhPm:00000000 _Z26UTIL0_ScanDecimal32sNumberPPKhPm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5024   .text._ZL16PreScanHexNumberPPKh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5028   .text._ZL16PreScanHexNumberPPKh:00000000 _ZL16PreScanHexNumberPPKh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5110   .text._ZL8HexToDecPPKhPh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5114   .text._ZL8HexToDecPPKhPh:00000000 _ZL8HexToDecPPKhPh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5243   .text._Z22UTIL0_ScanHex32uNumberPPKhPm:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5248   .text._Z22UTIL0_ScanHex32uNumberPPKhPm:00000000 _Z22UTIL0_ScanHex32uNumberPPKhPm
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5371   .text._Z22UTIL0_ScanHex16uNumberPPKhPt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5376   .text._Z22UTIL0_ScanHex16uNumberPPKhPt:00000000 _Z22UTIL0_ScanHex16uNumberPPKhPt
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5501   .text._Z21UTIL0_ScanHex8uNumberPPKhPh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5506   .text._Z21UTIL0_ScanHex8uNumberPPKhPh:00000000 _Z21UTIL0_ScanHex8uNumberPPKhPh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5631   .text._Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5636   .text._Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh:00000000 _Z29UTIL0_ScanHex8uNumberNoPrefixPPKhPh
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5763   .text._Z16UTIL0_strtailcmpPhS_:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5768   .text._Z16UTIL0_strtailcmpPhS_:00000000 _Z16UTIL0_strtailcmpPhS_
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5855   .text._Z16UTIL0_strCutTailPhS_:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5860   .text._Z16UTIL0_strCutTailPhS_:00000000 _Z16UTIL0_strCutTailPhS_
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5928   .text._Z29UTIL0_strcatNum32sDotValue100Phjl:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:5933   .text._Z29UTIL0_strcatNum32sDotValue100Phjl:00000000 _Z29UTIL0_strcatNum32sDotValue100Phjl
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:6004   .text._Z13UTIL0_strFindPhS_:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:6009   .text._Z13UTIL0_strFindPhS_:00000000 _Z13UTIL0_strFindPhS_
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:6096   .text._Z13UTIL0_strFindPhS_:00000078 $d
C:\Users\JH\AppData\Local\Temp\ccIqamKz.s:6101   .rodata._ZZ13UTIL0_WeekDaythhE4skew:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
__aeabi_idivmod
__aeabi_idiv
strchr
strlen
strncmp
