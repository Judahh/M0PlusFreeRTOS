   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"queue.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.xQueueGenericReset,"ax",%progbits
  18              		.align	2
  19              		.global	xQueueGenericReset
  20              		.code	16
  21              		.thumb_func
  23              	xQueueGenericReset:
  24              	.LFB9:
  25              		.file 1 "../Generated_Code/queue.c"
   1:../Generated_Code/queue.c **** /*
   2:../Generated_Code/queue.c ****     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:../Generated_Code/queue.c ****     All rights reserved
   4:../Generated_Code/queue.c **** 
   5:../Generated_Code/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../Generated_Code/queue.c **** 
   7:../Generated_Code/queue.c ****     ***************************************************************************
   8:../Generated_Code/queue.c ****      *                                                                       *
   9:../Generated_Code/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:../Generated_Code/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:../Generated_Code/queue.c ****      *    platform software that has become a de facto standard.             *
  12:../Generated_Code/queue.c ****      *                                                                       *
  13:../Generated_Code/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:../Generated_Code/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:../Generated_Code/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:../Generated_Code/queue.c ****      *                                                                       *
  17:../Generated_Code/queue.c ****      *    Thank you!                                                         *
  18:../Generated_Code/queue.c ****      *                                                                       *
  19:../Generated_Code/queue.c ****     ***************************************************************************
  20:../Generated_Code/queue.c **** 
  21:../Generated_Code/queue.c ****     This file is part of the FreeRTOS distribution.
  22:../Generated_Code/queue.c **** 
  23:../Generated_Code/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:../Generated_Code/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:../Generated_Code/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:../Generated_Code/queue.c **** 
  27:../Generated_Code/queue.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:../Generated_Code/queue.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:../Generated_Code/queue.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:../Generated_Code/queue.c ****     >>! kernel.
  31:../Generated_Code/queue.c **** 
  32:../Generated_Code/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:../Generated_Code/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:../Generated_Code/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:../Generated_Code/queue.c ****     link: http://www.freertos.org/a00114.html
  36:../Generated_Code/queue.c **** 
  37:../Generated_Code/queue.c ****     1 tab == 4 spaces!
  38:../Generated_Code/queue.c **** 
  39:../Generated_Code/queue.c ****     ***************************************************************************
  40:../Generated_Code/queue.c ****      *                                                                       *
  41:../Generated_Code/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:../Generated_Code/queue.c ****      *    not run, what could be wrong?"                                     *
  43:../Generated_Code/queue.c ****      *                                                                       *
  44:../Generated_Code/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:../Generated_Code/queue.c ****      *                                                                       *
  46:../Generated_Code/queue.c ****     ***************************************************************************
  47:../Generated_Code/queue.c **** 
  48:../Generated_Code/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:../Generated_Code/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:../Generated_Code/queue.c **** 
  51:../Generated_Code/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:../Generated_Code/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:../Generated_Code/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:../Generated_Code/queue.c **** 
  55:../Generated_Code/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:../Generated_Code/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:../Generated_Code/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:../Generated_Code/queue.c **** 
  59:../Generated_Code/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:../Generated_Code/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:../Generated_Code/queue.c ****     mission critical applications that require provable dependability.
  62:../Generated_Code/queue.c **** 
  63:../Generated_Code/queue.c ****     1 tab == 4 spaces!
  64:../Generated_Code/queue.c **** */
  65:../Generated_Code/queue.c **** 
  66:../Generated_Code/queue.c **** #include <stdlib.h>
  67:../Generated_Code/queue.c **** #include <string.h>
  68:../Generated_Code/queue.c **** 
  69:../Generated_Code/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:../Generated_Code/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:../Generated_Code/queue.c **** task.h is included from an application file. */
  72:../Generated_Code/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:../Generated_Code/queue.c **** 
  74:../Generated_Code/queue.c **** #include "FreeRTOS.h"
  75:../Generated_Code/queue.c **** #include "task.h"
  76:../Generated_Code/queue.c **** #include "queue.h"
  77:../Generated_Code/queue.c **** 
  78:../Generated_Code/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:../Generated_Code/queue.c ****         #include "croutine.h"
  80:../Generated_Code/queue.c **** #endif
  81:../Generated_Code/queue.c **** 
  82:../Generated_Code/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:../Generated_Code/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:../Generated_Code/queue.c **** header files above, but not in this file, in order to generate the correct
  85:../Generated_Code/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:../Generated_Code/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:../Generated_Code/queue.c **** 
  88:../Generated_Code/queue.c **** 
  89:../Generated_Code/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  90:../Generated_Code/queue.c **** #define queueUNLOCKED                                   ( ( BaseType_t ) -1 )
  91:../Generated_Code/queue.c **** #define queueLOCKED_UNMODIFIED                  ( ( BaseType_t ) 0 )
  92:../Generated_Code/queue.c **** 
  93:../Generated_Code/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  94:../Generated_Code/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:../Generated_Code/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  96:../Generated_Code/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:../Generated_Code/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:../Generated_Code/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:../Generated_Code/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:../Generated_Code/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:../Generated_Code/queue.c **** against the coding standard (although an exception to the standard has been
 102:../Generated_Code/queue.c **** permitted where the dual use also significantly changes the type of the
 103:../Generated_Code/queue.c **** structure member). */
 104:../Generated_Code/queue.c **** #define pxMutexHolder                                   pcTail
 105:../Generated_Code/queue.c **** #define uxQueueType                                             pcHead
 106:../Generated_Code/queue.c **** #define queueQUEUE_IS_MUTEX                             NULL
 107:../Generated_Code/queue.c **** 
 108:../Generated_Code/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:../Generated_Code/queue.c **** zero. */
 110:../Generated_Code/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 111:../Generated_Code/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME               ( ( TickType_t ) 0U )
 112:../Generated_Code/queue.c **** 
 113:../Generated_Code/queue.c **** #if( configUSE_PREEMPTION == 0 )
 114:../Generated_Code/queue.c ****         /* If the cooperative scheduler is being used then a yield should not be
 115:../Generated_Code/queue.c ****         performed just because a higher priority task has been woken. */
 116:../Generated_Code/queue.c ****         #define queueYIELD_IF_USING_PREEMPTION()
 117:../Generated_Code/queue.c **** #else
 118:../Generated_Code/queue.c ****         #define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:../Generated_Code/queue.c **** #endif
 120:../Generated_Code/queue.c **** 
 121:../Generated_Code/queue.c **** /*
 122:../Generated_Code/queue.c ****  * Definition of the queue used by the scheduler.
 123:../Generated_Code/queue.c ****  * Items are queued by copy, not reference.
 124:../Generated_Code/queue.c ****  */
 125:../Generated_Code/queue.c **** typedef struct QueueDefinition
 126:../Generated_Code/queue.c **** {
 127:../Generated_Code/queue.c ****         int8_t *pcHead;                                 /*< Points to the beginning of the queue st
 128:../Generated_Code/queue.c ****         int8_t *pcTail;                                 /*< Points to the byte at the end of the qu
 129:../Generated_Code/queue.c ****         int8_t *pcWriteTo;                              /*< Points to the free next place in the st
 130:../Generated_Code/queue.c **** 
 131:../Generated_Code/queue.c ****         union                                                   /* Use of a union is an exception t
 132:../Generated_Code/queue.c ****         {
 133:../Generated_Code/queue.c ****                 int8_t *pcReadFrom;                     /*< Points to the last place that a queued 
 134:../Generated_Code/queue.c ****                 UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a rec
 135:../Generated_Code/queue.c ****         } u;
 136:../Generated_Code/queue.c **** 
 137:../Generated_Code/queue.c ****         List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post 
 138:../Generated_Code/queue.c ****         List_t xTasksWaitingToReceive;  /*< List of tasks that are blocked waiting to read from thi
 139:../Generated_Code/queue.c **** 
 140:../Generated_Code/queue.c ****         volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 141:../Generated_Code/queue.c ****         UBaseType_t uxLength;                   /*< The length of the queue defined as the number o
 142:../Generated_Code/queue.c ****         UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold
 143:../Generated_Code/queue.c **** 
 144:../Generated_Code/queue.c ****         volatile BaseType_t xRxLock;    /*< Stores the number of items received from the queue (rem
 145:../Generated_Code/queue.c ****         volatile BaseType_t xTxLock;    /*< Stores the number of items transmitted to the queue (ad
 146:../Generated_Code/queue.c **** 
 147:../Generated_Code/queue.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
 148:../Generated_Code/queue.c ****                 UBaseType_t uxQueueNumber;
 149:../Generated_Code/queue.c ****                 uint8_t ucQueueType;
 150:../Generated_Code/queue.c ****         #endif
 151:../Generated_Code/queue.c **** 
 152:../Generated_Code/queue.c ****         #if ( configUSE_QUEUE_SETS == 1 )
 153:../Generated_Code/queue.c ****                 struct QueueDefinition *pxQueueSetContainer;
 154:../Generated_Code/queue.c ****         #endif
 155:../Generated_Code/queue.c **** 
 156:../Generated_Code/queue.c **** } xQUEUE;
 157:../Generated_Code/queue.c **** 
 158:../Generated_Code/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 159:../Generated_Code/queue.c **** name below to enable the use of older kernel aware debuggers. */
 160:../Generated_Code/queue.c **** typedef xQUEUE Queue_t;
 161:../Generated_Code/queue.c **** 
 162:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 163:../Generated_Code/queue.c **** 
 164:../Generated_Code/queue.c **** /*
 165:../Generated_Code/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 166:../Generated_Code/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 167:../Generated_Code/queue.c ****  */
 168:../Generated_Code/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 169:../Generated_Code/queue.c **** 
 170:../Generated_Code/queue.c ****         /* The type stored within the queue registry array.  This allows a name
 171:../Generated_Code/queue.c ****         to be assigned to each queue making kernel aware debugging a little
 172:../Generated_Code/queue.c ****         more user friendly. */
 173:../Generated_Code/queue.c ****         typedef struct QUEUE_REGISTRY_ITEM
 174:../Generated_Code/queue.c ****         {
 175:../Generated_Code/queue.c ****                 const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for string
 176:../Generated_Code/queue.c ****                 QueueHandle_t xHandle;
 177:../Generated_Code/queue.c ****         } xQueueRegistryItem;
 178:../Generated_Code/queue.c **** 
 179:../Generated_Code/queue.c ****         /* The old xQueueRegistryItem name is maintained above then typedefed to the
 180:../Generated_Code/queue.c ****         new xQueueRegistryItem name below to enable the use of older kernel aware
 181:../Generated_Code/queue.c ****         debuggers. */
 182:../Generated_Code/queue.c ****         typedef xQueueRegistryItem QueueRegistryItem_t;
 183:../Generated_Code/queue.c **** 
 184:../Generated_Code/queue.c ****         /* The queue registry is simply an array of QueueRegistryItem_t structures.
 185:../Generated_Code/queue.c ****         The pcQueueName member of a structure being NULL is indicative of the
 186:../Generated_Code/queue.c ****         array position being vacant. */
 187:../Generated_Code/queue.c ****         QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 188:../Generated_Code/queue.c **** 
 189:../Generated_Code/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 190:../Generated_Code/queue.c **** 
 191:../Generated_Code/queue.c **** /*
 192:../Generated_Code/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 193:../Generated_Code/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 194:../Generated_Code/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 195:../Generated_Code/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 196:../Generated_Code/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 197:../Generated_Code/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 198:../Generated_Code/queue.c ****  */
 199:../Generated_Code/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 200:../Generated_Code/queue.c **** 
 201:../Generated_Code/queue.c **** /*
 202:../Generated_Code/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 203:../Generated_Code/queue.c ****  *
 204:../Generated_Code/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 205:../Generated_Code/queue.c ****  */
 206:../Generated_Code/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 207:../Generated_Code/queue.c **** 
 208:../Generated_Code/queue.c **** /*
 209:../Generated_Code/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 210:../Generated_Code/queue.c ****  *
 211:../Generated_Code/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 212:../Generated_Code/queue.c ****  */
 213:../Generated_Code/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 214:../Generated_Code/queue.c **** 
 215:../Generated_Code/queue.c **** /*
 216:../Generated_Code/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 217:../Generated_Code/queue.c ****  * back of the queue.
 218:../Generated_Code/queue.c ****  */
 219:../Generated_Code/queue.c **** static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_
 220:../Generated_Code/queue.c **** 
 221:../Generated_Code/queue.c **** /*
 222:../Generated_Code/queue.c ****  * Copies an item out of a queue.
 223:../Generated_Code/queue.c ****  */
 224:../Generated_Code/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 225:../Generated_Code/queue.c **** 
 226:../Generated_Code/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 227:../Generated_Code/queue.c ****         /*
 228:../Generated_Code/queue.c ****          * Checks to see if a queue is a member of a queue set, and if so, notifies
 229:../Generated_Code/queue.c ****          * the queue set that the queue contains data.
 230:../Generated_Code/queue.c ****          */
 231:../Generated_Code/queue.c ****         static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType
 232:../Generated_Code/queue.c **** #endif
 233:../Generated_Code/queue.c **** 
 234:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 235:../Generated_Code/queue.c **** 
 236:../Generated_Code/queue.c **** /*
 237:../Generated_Code/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:../Generated_Code/queue.c ****  * accessing the queue event lists.
 239:../Generated_Code/queue.c ****  */
 240:../Generated_Code/queue.c **** #define prvLockQueue( pxQueue )                                                         \
 241:../Generated_Code/queue.c ****         taskENTER_CRITICAL();                                                                   \
 242:../Generated_Code/queue.c ****         {                                                                                          
 243:../Generated_Code/queue.c ****                 if( ( pxQueue )->xRxLock == queueUNLOCKED )                     \
 244:../Generated_Code/queue.c ****                 {                                                                                  
 245:../Generated_Code/queue.c ****                         ( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;  \
 246:../Generated_Code/queue.c ****                 }                                                                                  
 247:../Generated_Code/queue.c ****                 if( ( pxQueue )->xTxLock == queueUNLOCKED )                     \
 248:../Generated_Code/queue.c ****                 {                                                                                  
 249:../Generated_Code/queue.c ****                         ( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;  \
 250:../Generated_Code/queue.c ****                 }                                                                                  
 251:../Generated_Code/queue.c ****         }                                                                                          
 252:../Generated_Code/queue.c ****         taskEXIT_CRITICAL()
 253:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 254:../Generated_Code/queue.c **** 
 255:../Generated_Code/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:../Generated_Code/queue.c **** {
  26              		.loc 1 256 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 24
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39 0006 7860     		str	r0, [r7, #4]
  40 0008 3960     		str	r1, [r7]
  41              	.LBB2:
 257:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  42              		.loc 1 257 0
  43 000a 7B68     		ldr	r3, [r7, #4]
  44 000c FB60     		str	r3, [r7, #12]
 258:../Generated_Code/queue.c **** 
 259:../Generated_Code/queue.c ****         configASSERT( pxQueue );
  45              		.loc 1 259 0
  46 000e FB68     		ldr	r3, [r7, #12]
  47 0010 002B     		cmp	r3, #0
  48 0012 01D1     		bne	.L2
  49              		.loc 1 259 0 is_stmt 0
  50              	@ 259 "../Generated_Code/queue.c" 1
  51 0014 72B6     		cpsid i
  52              	@ 0 "" 2
  53              		.code	16
  54              	.L3:
  55              		.loc 1 259 0
  56 0016 FEE7     		b	.L3
  57              	.L2:
 260:../Generated_Code/queue.c **** 
 261:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
  58              		.loc 1 261 0 is_stmt 1
  59 0018 FFF7FEFF 		bl	vPortEnterCritical
 262:../Generated_Code/queue.c ****         {
 263:../Generated_Code/queue.c ****                 pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  60              		.loc 1 263 0
  61 001c FB68     		ldr	r3, [r7, #12]
  62 001e 1A68     		ldr	r2, [r3]
  63 0020 FB68     		ldr	r3, [r7, #12]
  64 0022 D96B     		ldr	r1, [r3, #60]
  65 0024 FB68     		ldr	r3, [r7, #12]
  66 0026 1B6C     		ldr	r3, [r3, #64]
  67 0028 4B43     		mul	r3, r1
  68 002a D218     		add	r2, r2, r3
  69 002c FB68     		ldr	r3, [r7, #12]
  70 002e 5A60     		str	r2, [r3, #4]
 264:../Generated_Code/queue.c ****                 pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  71              		.loc 1 264 0
  72 0030 FB68     		ldr	r3, [r7, #12]
  73 0032 0022     		mov	r2, #0
  74 0034 9A63     		str	r2, [r3, #56]
 265:../Generated_Code/queue.c ****                 pxQueue->pcWriteTo = pxQueue->pcHead;
  75              		.loc 1 265 0
  76 0036 FB68     		ldr	r3, [r7, #12]
  77 0038 1A68     		ldr	r2, [r3]
  78 003a FB68     		ldr	r3, [r7, #12]
  79 003c 9A60     		str	r2, [r3, #8]
 266:../Generated_Code/queue.c ****                 pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1
  80              		.loc 1 266 0
  81 003e FB68     		ldr	r3, [r7, #12]
  82 0040 1A68     		ldr	r2, [r3]
  83 0042 FB68     		ldr	r3, [r7, #12]
  84 0044 DB6B     		ldr	r3, [r3, #60]
  85 0046 591E     		sub	r1, r3, #1
  86 0048 FB68     		ldr	r3, [r7, #12]
  87 004a 1B6C     		ldr	r3, [r3, #64]
  88 004c 4B43     		mul	r3, r1
  89 004e D218     		add	r2, r2, r3
  90 0050 FB68     		ldr	r3, [r7, #12]
  91 0052 DA60     		str	r2, [r3, #12]
 267:../Generated_Code/queue.c ****                 pxQueue->xRxLock = queueUNLOCKED;
  92              		.loc 1 267 0
  93 0054 FB68     		ldr	r3, [r7, #12]
  94 0056 0122     		mov	r2, #1
  95 0058 5242     		neg	r2, r2
  96 005a 5A64     		str	r2, [r3, #68]
 268:../Generated_Code/queue.c ****                 pxQueue->xTxLock = queueUNLOCKED;
  97              		.loc 1 268 0
  98 005c FB68     		ldr	r3, [r7, #12]
  99 005e 0122     		mov	r2, #1
 100 0060 5242     		neg	r2, r2
 101 0062 9A64     		str	r2, [r3, #72]
 269:../Generated_Code/queue.c **** 
 270:../Generated_Code/queue.c ****                 if( xNewQueue == pdFALSE )
 102              		.loc 1 270 0
 103 0064 3B68     		ldr	r3, [r7]
 104 0066 002B     		cmp	r3, #0
 105 0068 12D1     		bne	.L4
 271:../Generated_Code/queue.c ****                 {
 272:../Generated_Code/queue.c ****                         /* If there are tasks blocked waiting to read from the queue, then
 273:../Generated_Code/queue.c ****                         the tasks will remain blocked as after this function exits the queue
 274:../Generated_Code/queue.c ****                         will still be empty.  If there are tasks blocked waiting to write to
 275:../Generated_Code/queue.c ****                         the queue, then one should be unblocked as after this function exits
 276:../Generated_Code/queue.c ****                         it will be possible to write to it. */
 277:../Generated_Code/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 106              		.loc 1 277 0
 107 006a FB68     		ldr	r3, [r7, #12]
 108 006c 1B69     		ldr	r3, [r3, #16]
 109 006e 002B     		cmp	r3, #0
 110 0070 18D0     		beq	.L5
 278:../Generated_Code/queue.c ****                         {
 279:../Generated_Code/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) =
 111              		.loc 1 279 0
 112 0072 FB68     		ldr	r3, [r7, #12]
 113 0074 1033     		add	r3, r3, #16
 114 0076 181C     		mov	r0, r3
 115 0078 FFF7FEFF 		bl	xTaskRemoveFromEventList
 116 007c 031C     		mov	r3, r0
 117 007e 013B     		sub	r3, r3, #1
 118 0080 5A42     		neg	r2, r3
 119 0082 5341     		adc	r3, r3, r2
 120 0084 DBB2     		uxtb	r3, r3
 121 0086 002B     		cmp	r3, #0
 122 0088 0CD0     		beq	.L5
 280:../Generated_Code/queue.c ****                                 {
 281:../Generated_Code/queue.c ****                                         queueYIELD_IF_USING_PREEMPTION();
 123              		.loc 1 281 0
 124 008a FFF7FEFF 		bl	vPortYieldFromISR
 125 008e 09E0     		b	.L5
 126              	.L4:
 282:../Generated_Code/queue.c ****                                 }
 283:../Generated_Code/queue.c ****                                 else
 284:../Generated_Code/queue.c ****                                 {
 285:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
 286:../Generated_Code/queue.c ****                                 }
 287:../Generated_Code/queue.c ****                         }
 288:../Generated_Code/queue.c ****                         else
 289:../Generated_Code/queue.c ****                         {
 290:../Generated_Code/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 291:../Generated_Code/queue.c ****                         }
 292:../Generated_Code/queue.c ****                 }
 293:../Generated_Code/queue.c ****                 else
 294:../Generated_Code/queue.c ****                 {
 295:../Generated_Code/queue.c ****                         /* Ensure the event queues start in the correct state. */
 296:../Generated_Code/queue.c ****                         vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 127              		.loc 1 296 0
 128 0090 FB68     		ldr	r3, [r7, #12]
 129 0092 1033     		add	r3, r3, #16
 130 0094 181C     		mov	r0, r3
 131 0096 FFF7FEFF 		bl	vListInitialise
 297:../Generated_Code/queue.c ****                         vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 132              		.loc 1 297 0
 133 009a FB68     		ldr	r3, [r7, #12]
 134 009c 2433     		add	r3, r3, #36
 135 009e 181C     		mov	r0, r3
 136 00a0 FFF7FEFF 		bl	vListInitialise
 137              	.L5:
 298:../Generated_Code/queue.c ****                 }
 299:../Generated_Code/queue.c ****         }
 300:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 138              		.loc 1 300 0
 139 00a4 FFF7FEFF 		bl	vPortExitCritical
 301:../Generated_Code/queue.c **** 
 302:../Generated_Code/queue.c ****         /* A value is returned for calling semantic consistency with previous
 303:../Generated_Code/queue.c ****         versions. */
 304:../Generated_Code/queue.c ****         return pdPASS;
 140              		.loc 1 304 0
 141 00a8 0123     		mov	r3, #1
 142              	.LBE2:
 305:../Generated_Code/queue.c **** }
 143              		.loc 1 305 0
 144 00aa 181C     		mov	r0, r3
 145 00ac BD46     		mov	sp, r7
 146 00ae 04B0     		add	sp, sp, #16
 147              		@ sp needed for prologue
 148 00b0 80BD     		pop	{r7, pc}
 149              		.cfi_endproc
 150              	.LFE9:
 152 00b2 C046     		.section	.text.xQueueGenericCreate,"ax",%progbits
 153              		.align	2
 154              		.global	xQueueGenericCreate
 155              		.code	16
 156              		.thumb_func
 158              	xQueueGenericCreate:
 159              	.LFB10:
 306:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 307:../Generated_Code/queue.c **** 
 308:../Generated_Code/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 309:../Generated_Code/queue.c **** {
 160              		.loc 1 309 0
 161              		.cfi_startproc
 162 0000 80B5     		push	{r7, lr}
 163              	.LCFI3:
 164              		.cfi_def_cfa_offset 8
 165              		.cfi_offset 7, -8
 166              		.cfi_offset 14, -4
 167 0002 88B0     		sub	sp, sp, #32
 168              	.LCFI4:
 169              		.cfi_def_cfa_offset 40
 170 0004 00AF     		add	r7, sp, #0
 171              	.LCFI5:
 172              		.cfi_def_cfa_register 7
 173 0006 F860     		str	r0, [r7, #12]
 174 0008 B960     		str	r1, [r7, #8]
 175 000a FB1D     		add	r3, r7, #7
 176 000c 1A70     		strb	r2, [r3]
 177              	.LBB3:
 310:../Generated_Code/queue.c **** Queue_t *pxNewQueue;
 311:../Generated_Code/queue.c **** size_t xQueueSizeInBytes;
 312:../Generated_Code/queue.c **** QueueHandle_t xReturn = NULL;
 178              		.loc 1 312 0
 179 000e 0023     		mov	r3, #0
 180 0010 FB61     		str	r3, [r7, #28]
 313:../Generated_Code/queue.c **** 
 314:../Generated_Code/queue.c ****         /* Remove compiler warnings about unused parameters should
 315:../Generated_Code/queue.c ****         configUSE_TRACE_FACILITY not be set to 1. */
 316:../Generated_Code/queue.c ****         ( void ) ucQueueType;
 317:../Generated_Code/queue.c **** 
 318:../Generated_Code/queue.c ****         /* Allocate the new queue structure. */
 319:../Generated_Code/queue.c ****         if( uxQueueLength > ( UBaseType_t ) 0 )
 181              		.loc 1 319 0
 182 0012 FB68     		ldr	r3, [r7, #12]
 183 0014 002B     		cmp	r3, #0
 184 0016 29D0     		beq	.L8
 320:../Generated_Code/queue.c ****         {
 321:../Generated_Code/queue.c ****                 pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 185              		.loc 1 321 0
 186 0018 4C20     		mov	r0, #76
 187 001a FFF7FEFF 		bl	pvPortMalloc
 188 001e 031C     		mov	r3, r0
 189 0020 BB61     		str	r3, [r7, #24]
 322:../Generated_Code/queue.c ****                 if( pxNewQueue != NULL )
 190              		.loc 1 322 0
 191 0022 BB69     		ldr	r3, [r7, #24]
 192 0024 002B     		cmp	r3, #0
 193 0026 21D0     		beq	.L8
 323:../Generated_Code/queue.c ****                 {
 324:../Generated_Code/queue.c ****                         /* Create the list of pointers to queue items.  The queue is one byte
 325:../Generated_Code/queue.c ****                         longer than asked for to make wrap checking easier/faster. */
 326:../Generated_Code/queue.c ****                         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 
 194              		.loc 1 326 0
 195 0028 FB68     		ldr	r3, [r7, #12]
 196 002a BA68     		ldr	r2, [r7, #8]
 197 002c 5343     		mul	r3, r2
 198 002e 0133     		add	r3, r3, #1
 199 0030 7B61     		str	r3, [r7, #20]
 327:../Generated_Code/queue.c **** 
 328:../Generated_Code/queue.c ****                         pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
 200              		.loc 1 328 0
 201 0032 7B69     		ldr	r3, [r7, #20]
 202 0034 181C     		mov	r0, r3
 203 0036 FFF7FEFF 		bl	pvPortMalloc
 204 003a 021C     		mov	r2, r0
 205 003c BB69     		ldr	r3, [r7, #24]
 206 003e 1A60     		str	r2, [r3]
 329:../Generated_Code/queue.c ****                         if( pxNewQueue->pcHead != NULL )
 207              		.loc 1 329 0
 208 0040 BB69     		ldr	r3, [r7, #24]
 209 0042 1B68     		ldr	r3, [r3]
 210 0044 002B     		cmp	r3, #0
 211 0046 0DD0     		beq	.L9
 330:../Generated_Code/queue.c ****                         {
 331:../Generated_Code/queue.c ****                                 /* Initialise the queue members as described above where the
 332:../Generated_Code/queue.c ****                                 queue type is defined. */
 333:../Generated_Code/queue.c ****                                 pxNewQueue->uxLength = uxQueueLength;
 212              		.loc 1 333 0
 213 0048 BB69     		ldr	r3, [r7, #24]
 214 004a FA68     		ldr	r2, [r7, #12]
 215 004c DA63     		str	r2, [r3, #60]
 334:../Generated_Code/queue.c ****                                 pxNewQueue->uxItemSize = uxItemSize;
 216              		.loc 1 334 0
 217 004e BB69     		ldr	r3, [r7, #24]
 218 0050 BA68     		ldr	r2, [r7, #8]
 219 0052 1A64     		str	r2, [r3, #64]
 335:../Generated_Code/queue.c ****                                 ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 220              		.loc 1 335 0
 221 0054 BB69     		ldr	r3, [r7, #24]
 222 0056 181C     		mov	r0, r3
 223 0058 0121     		mov	r1, #1
 224 005a FFF7FEFF 		bl	xQueueGenericReset
 336:../Generated_Code/queue.c **** 
 337:../Generated_Code/queue.c ****                                 #if ( configUSE_TRACE_FACILITY == 1 )
 338:../Generated_Code/queue.c ****                                 {
 339:../Generated_Code/queue.c ****                                         pxNewQueue->ucQueueType = ucQueueType;
 340:../Generated_Code/queue.c ****                                 }
 341:../Generated_Code/queue.c ****                                 #endif /* configUSE_TRACE_FACILITY */
 342:../Generated_Code/queue.c **** 
 343:../Generated_Code/queue.c ****                                 #if( configUSE_QUEUE_SETS == 1 )
 344:../Generated_Code/queue.c ****                                 {
 345:../Generated_Code/queue.c ****                                         pxNewQueue->pxQueueSetContainer = NULL;
 346:../Generated_Code/queue.c ****                                 }
 347:../Generated_Code/queue.c ****                                 #endif /* configUSE_QUEUE_SETS */
 348:../Generated_Code/queue.c **** 
 349:../Generated_Code/queue.c ****                                 traceQUEUE_CREATE( pxNewQueue );
 350:../Generated_Code/queue.c ****                                 xReturn = pxNewQueue;
 225              		.loc 1 350 0
 226 005e BB69     		ldr	r3, [r7, #24]
 227 0060 FB61     		str	r3, [r7, #28]
 228 0062 03E0     		b	.L8
 229              	.L9:
 351:../Generated_Code/queue.c ****                         }
 352:../Generated_Code/queue.c ****                         else
 353:../Generated_Code/queue.c ****                         {
 354:../Generated_Code/queue.c ****                                 traceQUEUE_CREATE_FAILED( ucQueueType );
 355:../Generated_Code/queue.c ****                                 vPortFree( pxNewQueue );
 230              		.loc 1 355 0
 231 0064 BB69     		ldr	r3, [r7, #24]
 232 0066 181C     		mov	r0, r3
 233 0068 FFF7FEFF 		bl	vPortFree
 234              	.L8:
 356:../Generated_Code/queue.c ****                         }
 357:../Generated_Code/queue.c ****                 }
 358:../Generated_Code/queue.c ****                 else
 359:../Generated_Code/queue.c ****                 {
 360:../Generated_Code/queue.c ****                         mtCOVERAGE_TEST_MARKER();
 361:../Generated_Code/queue.c ****                 }
 362:../Generated_Code/queue.c ****         }
 363:../Generated_Code/queue.c ****         else
 364:../Generated_Code/queue.c ****         {
 365:../Generated_Code/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 366:../Generated_Code/queue.c ****         }
 367:../Generated_Code/queue.c **** 
 368:../Generated_Code/queue.c ****         configASSERT( xReturn );
 235              		.loc 1 368 0
 236 006c FB69     		ldr	r3, [r7, #28]
 237 006e 002B     		cmp	r3, #0
 238 0070 01D1     		bne	.L10
 239              		.loc 1 368 0 is_stmt 0
 240              	@ 368 "../Generated_Code/queue.c" 1
 241 0072 72B6     		cpsid i
 242              	@ 0 "" 2
 243              		.code	16
 244              	.L11:
 245              		.loc 1 368 0
 246 0074 FEE7     		b	.L11
 247              	.L10:
 369:../Generated_Code/queue.c **** 
 370:../Generated_Code/queue.c ****         return xReturn;
 248              		.loc 1 370 0 is_stmt 1
 249 0076 FB69     		ldr	r3, [r7, #28]
 250              	.LBE3:
 371:../Generated_Code/queue.c **** }
 251              		.loc 1 371 0
 252 0078 181C     		mov	r0, r3
 253 007a BD46     		mov	sp, r7
 254 007c 08B0     		add	sp, sp, #32
 255              		@ sp needed for prologue
 256 007e 80BD     		pop	{r7, pc}
 257              		.cfi_endproc
 258              	.LFE10:
 260              		.section	.text.xQueueCreateMutex,"ax",%progbits
 261              		.align	2
 262              		.global	xQueueCreateMutex
 263              		.code	16
 264              		.thumb_func
 266              	xQueueCreateMutex:
 267              	.LFB11:
 372:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 373:../Generated_Code/queue.c **** 
 374:../Generated_Code/queue.c **** #if ( configUSE_MUTEXES == 1 )
 375:../Generated_Code/queue.c **** 
 376:../Generated_Code/queue.c ****         QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 377:../Generated_Code/queue.c ****         {
 268              		.loc 1 377 0
 269              		.cfi_startproc
 270 0000 80B5     		push	{r7, lr}
 271              	.LCFI6:
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 7, -8
 274              		.cfi_offset 14, -4
 275 0002 84B0     		sub	sp, sp, #16
 276              	.LCFI7:
 277              		.cfi_def_cfa_offset 24
 278 0004 00AF     		add	r7, sp, #0
 279              	.LCFI8:
 280              		.cfi_def_cfa_register 7
 281 0006 021C     		mov	r2, r0
 282 0008 FB1D     		add	r3, r7, #7
 283 000a 1A70     		strb	r2, [r3]
 284              	.LBB4:
 378:../Generated_Code/queue.c ****         Queue_t *pxNewQueue;
 379:../Generated_Code/queue.c **** 
 380:../Generated_Code/queue.c ****                 /* Prevent compiler warnings about unused parameters if
 381:../Generated_Code/queue.c ****                 configUSE_TRACE_FACILITY does not equal 1. */
 382:../Generated_Code/queue.c ****                 ( void ) ucQueueType;
 383:../Generated_Code/queue.c **** 
 384:../Generated_Code/queue.c ****                 /* Allocate the new queue structure. */
 385:../Generated_Code/queue.c ****                 pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 285              		.loc 1 385 0
 286 000c 4C20     		mov	r0, #76
 287 000e FFF7FEFF 		bl	pvPortMalloc
 288 0012 031C     		mov	r3, r0
 289 0014 FB60     		str	r3, [r7, #12]
 386:../Generated_Code/queue.c ****                 if( pxNewQueue != NULL )
 290              		.loc 1 386 0
 291 0016 FB68     		ldr	r3, [r7, #12]
 292 0018 002B     		cmp	r3, #0
 293 001a 2DD0     		beq	.L14
 387:../Generated_Code/queue.c ****                 {
 388:../Generated_Code/queue.c ****                         /* Information required for priority inheritance. */
 389:../Generated_Code/queue.c ****                         pxNewQueue->pxMutexHolder = NULL;
 294              		.loc 1 389 0
 295 001c FB68     		ldr	r3, [r7, #12]
 296 001e 0022     		mov	r2, #0
 297 0020 5A60     		str	r2, [r3, #4]
 390:../Generated_Code/queue.c ****                         pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 298              		.loc 1 390 0
 299 0022 FB68     		ldr	r3, [r7, #12]
 300 0024 0022     		mov	r2, #0
 301 0026 1A60     		str	r2, [r3]
 391:../Generated_Code/queue.c **** 
 392:../Generated_Code/queue.c ****                         /* Queues used as a mutex no data is actually copied into or out
 393:../Generated_Code/queue.c ****                         of the queue. */
 394:../Generated_Code/queue.c ****                         pxNewQueue->pcWriteTo = NULL;
 302              		.loc 1 394 0
 303 0028 FB68     		ldr	r3, [r7, #12]
 304 002a 0022     		mov	r2, #0
 305 002c 9A60     		str	r2, [r3, #8]
 395:../Generated_Code/queue.c ****                         pxNewQueue->u.pcReadFrom = NULL;
 306              		.loc 1 395 0
 307 002e FB68     		ldr	r3, [r7, #12]
 308 0030 0022     		mov	r2, #0
 309 0032 DA60     		str	r2, [r3, #12]
 396:../Generated_Code/queue.c **** 
 397:../Generated_Code/queue.c ****                         /* Each mutex has a length of 1 (like a binary semaphore) and
 398:../Generated_Code/queue.c ****                         an item size of 0 as nothing is actually copied into or out
 399:../Generated_Code/queue.c ****                         of the mutex. */
 400:../Generated_Code/queue.c ****                         pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 310              		.loc 1 400 0
 311 0034 FB68     		ldr	r3, [r7, #12]
 312 0036 0022     		mov	r2, #0
 313 0038 9A63     		str	r2, [r3, #56]
 401:../Generated_Code/queue.c ****                         pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 314              		.loc 1 401 0
 315 003a FB68     		ldr	r3, [r7, #12]
 316 003c 0122     		mov	r2, #1
 317 003e DA63     		str	r2, [r3, #60]
 402:../Generated_Code/queue.c ****                         pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 318              		.loc 1 402 0
 319 0040 FB68     		ldr	r3, [r7, #12]
 320 0042 0022     		mov	r2, #0
 321 0044 1A64     		str	r2, [r3, #64]
 403:../Generated_Code/queue.c ****                         pxNewQueue->xRxLock = queueUNLOCKED;
 322              		.loc 1 403 0
 323 0046 FB68     		ldr	r3, [r7, #12]
 324 0048 0122     		mov	r2, #1
 325 004a 5242     		neg	r2, r2
 326 004c 5A64     		str	r2, [r3, #68]
 404:../Generated_Code/queue.c ****                         pxNewQueue->xTxLock = queueUNLOCKED;
 327              		.loc 1 404 0
 328 004e FB68     		ldr	r3, [r7, #12]
 329 0050 0122     		mov	r2, #1
 330 0052 5242     		neg	r2, r2
 331 0054 9A64     		str	r2, [r3, #72]
 405:../Generated_Code/queue.c **** 
 406:../Generated_Code/queue.c ****                         #if ( configUSE_TRACE_FACILITY == 1 )
 407:../Generated_Code/queue.c ****                         {
 408:../Generated_Code/queue.c ****                                 pxNewQueue->ucQueueType = ucQueueType;
 409:../Generated_Code/queue.c ****                         }
 410:../Generated_Code/queue.c ****                         #endif
 411:../Generated_Code/queue.c **** 
 412:../Generated_Code/queue.c ****                         #if ( configUSE_QUEUE_SETS == 1 )
 413:../Generated_Code/queue.c ****                         {
 414:../Generated_Code/queue.c ****                                 pxNewQueue->pxQueueSetContainer = NULL;
 415:../Generated_Code/queue.c ****                         }
 416:../Generated_Code/queue.c ****                         #endif
 417:../Generated_Code/queue.c **** 
 418:../Generated_Code/queue.c ****                         /* Ensure the event queues start with the correct state. */
 419:../Generated_Code/queue.c ****                         vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 332              		.loc 1 419 0
 333 0056 FB68     		ldr	r3, [r7, #12]
 334 0058 1033     		add	r3, r3, #16
 335 005a 181C     		mov	r0, r3
 336 005c FFF7FEFF 		bl	vListInitialise
 420:../Generated_Code/queue.c ****                         vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 337              		.loc 1 420 0
 338 0060 FB68     		ldr	r3, [r7, #12]
 339 0062 2433     		add	r3, r3, #36
 340 0064 181C     		mov	r0, r3
 341 0066 FFF7FEFF 		bl	vListInitialise
 421:../Generated_Code/queue.c **** 
 422:../Generated_Code/queue.c ****                         traceCREATE_MUTEX( pxNewQueue );
 423:../Generated_Code/queue.c **** 
 424:../Generated_Code/queue.c ****                         /* Start with the semaphore in the expected state. */
 425:../Generated_Code/queue.c ****                         ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_
 342              		.loc 1 425 0
 343 006a FB68     		ldr	r3, [r7, #12]
 344 006c 181C     		mov	r0, r3
 345 006e 0021     		mov	r1, #0
 346 0070 0022     		mov	r2, #0
 347 0072 0023     		mov	r3, #0
 348 0074 FFF7FEFF 		bl	xQueueGenericSend
 349              	.L14:
 426:../Generated_Code/queue.c ****                 }
 427:../Generated_Code/queue.c ****                 else
 428:../Generated_Code/queue.c ****                 {
 429:../Generated_Code/queue.c ****                         traceCREATE_MUTEX_FAILED();
 430:../Generated_Code/queue.c ****                 }
 431:../Generated_Code/queue.c **** 
 432:../Generated_Code/queue.c ****                 configASSERT( pxNewQueue );
 350              		.loc 1 432 0
 351 0078 FB68     		ldr	r3, [r7, #12]
 352 007a 002B     		cmp	r3, #0
 353 007c 01D1     		bne	.L15
 354              		.loc 1 432 0 is_stmt 0
 355              	@ 432 "../Generated_Code/queue.c" 1
 356 007e 72B6     		cpsid i
 357              	@ 0 "" 2
 358              		.code	16
 359              	.L16:
 360              		.loc 1 432 0
 361 0080 FEE7     		b	.L16
 362              	.L15:
 433:../Generated_Code/queue.c ****                 return pxNewQueue;
 363              		.loc 1 433 0 is_stmt 1
 364 0082 FB68     		ldr	r3, [r7, #12]
 365              	.LBE4:
 434:../Generated_Code/queue.c ****         }
 366              		.loc 1 434 0
 367 0084 181C     		mov	r0, r3
 368 0086 BD46     		mov	sp, r7
 369 0088 04B0     		add	sp, sp, #16
 370              		@ sp needed for prologue
 371 008a 80BD     		pop	{r7, pc}
 372              		.cfi_endproc
 373              	.LFE11:
 375              		.section	.text.xQueueGetMutexHolder,"ax",%progbits
 376              		.align	2
 377              		.global	xQueueGetMutexHolder
 378              		.code	16
 379              		.thumb_func
 381              	xQueueGetMutexHolder:
 382              	.LFB12:
 435:../Generated_Code/queue.c **** 
 436:../Generated_Code/queue.c **** #endif /* configUSE_MUTEXES */
 437:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 438:../Generated_Code/queue.c **** 
 439:../Generated_Code/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 440:../Generated_Code/queue.c **** 
 441:../Generated_Code/queue.c ****         void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 442:../Generated_Code/queue.c ****         {
 383              		.loc 1 442 0
 384              		.cfi_startproc
 385 0000 80B5     		push	{r7, lr}
 386              	.LCFI9:
 387              		.cfi_def_cfa_offset 8
 388              		.cfi_offset 7, -8
 389              		.cfi_offset 14, -4
 390 0002 84B0     		sub	sp, sp, #16
 391              	.LCFI10:
 392              		.cfi_def_cfa_offset 24
 393 0004 00AF     		add	r7, sp, #0
 394              	.LCFI11:
 395              		.cfi_def_cfa_register 7
 396 0006 7860     		str	r0, [r7, #4]
 397              	.LBB5:
 443:../Generated_Code/queue.c ****         void *pxReturn;
 444:../Generated_Code/queue.c **** 
 445:../Generated_Code/queue.c ****                 /* This function is called by xSemaphoreGetMutexHolder(), and should not
 446:../Generated_Code/queue.c ****                 be called directly.  Note:  This is a good way of determining if the
 447:../Generated_Code/queue.c ****                 calling task is the mutex holder, but not a good way of determining the
 448:../Generated_Code/queue.c ****                 identity of the mutex holder, as the holder may change between the
 449:../Generated_Code/queue.c ****                 following critical section exiting and the function returning. */
 450:../Generated_Code/queue.c ****                 taskENTER_CRITICAL();
 398              		.loc 1 450 0
 399 0008 FFF7FEFF 		bl	vPortEnterCritical
 451:../Generated_Code/queue.c ****                 {
 452:../Generated_Code/queue.c ****                         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 400              		.loc 1 452 0
 401 000c 7B68     		ldr	r3, [r7, #4]
 402 000e 1B68     		ldr	r3, [r3]
 403 0010 002B     		cmp	r3, #0
 404 0012 03D1     		bne	.L19
 453:../Generated_Code/queue.c ****                         {
 454:../Generated_Code/queue.c ****                                 pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 405              		.loc 1 454 0
 406 0014 7B68     		ldr	r3, [r7, #4]
 407 0016 5B68     		ldr	r3, [r3, #4]
 408 0018 FB60     		str	r3, [r7, #12]
 409 001a 01E0     		b	.L20
 410              	.L19:
 455:../Generated_Code/queue.c ****                         }
 456:../Generated_Code/queue.c ****                         else
 457:../Generated_Code/queue.c ****                         {
 458:../Generated_Code/queue.c ****                                 pxReturn = NULL;
 411              		.loc 1 458 0
 412 001c 0023     		mov	r3, #0
 413 001e FB60     		str	r3, [r7, #12]
 414              	.L20:
 459:../Generated_Code/queue.c ****                         }
 460:../Generated_Code/queue.c ****                 }
 461:../Generated_Code/queue.c ****                 taskEXIT_CRITICAL();
 415              		.loc 1 461 0
 416 0020 FFF7FEFF 		bl	vPortExitCritical
 462:../Generated_Code/queue.c **** 
 463:../Generated_Code/queue.c ****                 return pxReturn;
 417              		.loc 1 463 0
 418 0024 FB68     		ldr	r3, [r7, #12]
 419              	.LBE5:
 464:../Generated_Code/queue.c ****         }
 420              		.loc 1 464 0
 421 0026 181C     		mov	r0, r3
 422 0028 BD46     		mov	sp, r7
 423 002a 04B0     		add	sp, sp, #16
 424              		@ sp needed for prologue
 425 002c 80BD     		pop	{r7, pc}
 426              		.cfi_endproc
 427              	.LFE12:
 429 002e C046     		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 430              		.align	2
 431              		.global	xQueueGiveMutexRecursive
 432              		.code	16
 433              		.thumb_func
 435              	xQueueGiveMutexRecursive:
 436              	.LFB13:
 465:../Generated_Code/queue.c **** 
 466:../Generated_Code/queue.c **** #endif
 467:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 468:../Generated_Code/queue.c **** 
 469:../Generated_Code/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 470:../Generated_Code/queue.c **** 
 471:../Generated_Code/queue.c ****         BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 472:../Generated_Code/queue.c ****         {
 437              		.loc 1 472 0
 438              		.cfi_startproc
 439 0000 90B5     		push	{r4, r7, lr}
 440              	.LCFI12:
 441              		.cfi_def_cfa_offset 12
 442              		.cfi_offset 4, -12
 443              		.cfi_offset 7, -8
 444              		.cfi_offset 14, -4
 445 0002 85B0     		sub	sp, sp, #20
 446              	.LCFI13:
 447              		.cfi_def_cfa_offset 32
 448 0004 00AF     		add	r7, sp, #0
 449              	.LCFI14:
 450              		.cfi_def_cfa_register 7
 451 0006 7860     		str	r0, [r7, #4]
 452              	.LBB6:
 473:../Generated_Code/queue.c ****         BaseType_t xReturn;
 474:../Generated_Code/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 453              		.loc 1 474 0
 454 0008 7B68     		ldr	r3, [r7, #4]
 455 000a BB60     		str	r3, [r7, #8]
 475:../Generated_Code/queue.c **** 
 476:../Generated_Code/queue.c ****                 configASSERT( pxMutex );
 456              		.loc 1 476 0
 457 000c BB68     		ldr	r3, [r7, #8]
 458 000e 002B     		cmp	r3, #0
 459 0010 01D1     		bne	.L23
 460              		.loc 1 476 0 is_stmt 0
 461              	@ 476 "../Generated_Code/queue.c" 1
 462 0012 72B6     		cpsid i
 463              	@ 0 "" 2
 464              		.code	16
 465              	.L24:
 466              		.loc 1 476 0
 467 0014 FEE7     		b	.L24
 468              	.L23:
 477:../Generated_Code/queue.c **** 
 478:../Generated_Code/queue.c ****                 /* If this is the task that holds the mutex then pxMutexHolder will not
 479:../Generated_Code/queue.c ****                 change outside of this task.  If this task does not hold the mutex then
 480:../Generated_Code/queue.c ****                 pxMutexHolder can never coincidentally equal the tasks handle, and as
 481:../Generated_Code/queue.c ****                 this is the only condition we are interested in it does not matter if
 482:../Generated_Code/queue.c ****                 pxMutexHolder is accessed simultaneously by another task.  Therefore no
 483:../Generated_Code/queue.c ****                 mutual exclusion is required to test the pxMutexHolder variable. */
 484:../Generated_Code/queue.c ****                 if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961
 469              		.loc 1 484 0 is_stmt 1
 470 0016 BB68     		ldr	r3, [r7, #8]
 471 0018 5C68     		ldr	r4, [r3, #4]
 472 001a FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 473 001e 031C     		mov	r3, r0
 474 0020 E31A     		sub	r3, r4, r3
 475 0022 5A42     		neg	r2, r3
 476 0024 5341     		adc	r3, r3, r2
 477 0026 DBB2     		uxtb	r3, r3
 478 0028 002B     		cmp	r3, #0
 479 002a 12D0     		beq	.L25
 485:../Generated_Code/queue.c ****                 {
 486:../Generated_Code/queue.c ****                         traceGIVE_MUTEX_RECURSIVE( pxMutex );
 487:../Generated_Code/queue.c **** 
 488:../Generated_Code/queue.c ****                         /* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 489:../Generated_Code/queue.c ****                         the task handle, therefore no underflow check is required.  Also,
 490:../Generated_Code/queue.c ****                         uxRecursiveCallCount is only modified by the mutex holder, and as
 491:../Generated_Code/queue.c ****                         there can only be one, no mutual exclusion is required to modify the
 492:../Generated_Code/queue.c ****                         uxRecursiveCallCount member. */
 493:../Generated_Code/queue.c ****                         ( pxMutex->u.uxRecursiveCallCount )--;
 480              		.loc 1 493 0
 481 002c BB68     		ldr	r3, [r7, #8]
 482 002e DB68     		ldr	r3, [r3, #12]
 483 0030 5A1E     		sub	r2, r3, #1
 484 0032 BB68     		ldr	r3, [r7, #8]
 485 0034 DA60     		str	r2, [r3, #12]
 494:../Generated_Code/queue.c **** 
 495:../Generated_Code/queue.c ****                         /* Have we unwound the call count? */
 496:../Generated_Code/queue.c ****                         if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 486              		.loc 1 496 0
 487 0036 BB68     		ldr	r3, [r7, #8]
 488 0038 DB68     		ldr	r3, [r3, #12]
 489 003a 002B     		cmp	r3, #0
 490 003c 06D1     		bne	.L26
 497:../Generated_Code/queue.c ****                         {
 498:../Generated_Code/queue.c ****                                 /* Return the mutex.  This will automatically unblock any other
 499:../Generated_Code/queue.c ****                                 task that might be waiting to access the mutex. */
 500:../Generated_Code/queue.c ****                                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TI
 491              		.loc 1 500 0
 492 003e BB68     		ldr	r3, [r7, #8]
 493 0040 181C     		mov	r0, r3
 494 0042 0021     		mov	r1, #0
 495 0044 0022     		mov	r2, #0
 496 0046 0023     		mov	r3, #0
 497 0048 FFF7FEFF 		bl	xQueueGenericSend
 498              	.L26:
 501:../Generated_Code/queue.c ****                         }
 502:../Generated_Code/queue.c ****                         else
 503:../Generated_Code/queue.c ****                         {
 504:../Generated_Code/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 505:../Generated_Code/queue.c ****                         }
 506:../Generated_Code/queue.c **** 
 507:../Generated_Code/queue.c ****                         xReturn = pdPASS;
 499              		.loc 1 507 0
 500 004c 0123     		mov	r3, #1
 501 004e FB60     		str	r3, [r7, #12]
 502 0050 01E0     		b	.L27
 503              	.L25:
 508:../Generated_Code/queue.c ****                 }
 509:../Generated_Code/queue.c ****                 else
 510:../Generated_Code/queue.c ****                 {
 511:../Generated_Code/queue.c ****                         /* We cannot give the mutex because we are not the holder. */
 512:../Generated_Code/queue.c ****                         xReturn = pdFAIL;
 504              		.loc 1 512 0
 505 0052 0023     		mov	r3, #0
 506 0054 FB60     		str	r3, [r7, #12]
 507              	.L27:
 513:../Generated_Code/queue.c **** 
 514:../Generated_Code/queue.c ****                         traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 515:../Generated_Code/queue.c ****                 }
 516:../Generated_Code/queue.c **** 
 517:../Generated_Code/queue.c ****                 return xReturn;
 508              		.loc 1 517 0
 509 0056 FB68     		ldr	r3, [r7, #12]
 510              	.LBE6:
 518:../Generated_Code/queue.c ****         }
 511              		.loc 1 518 0
 512 0058 181C     		mov	r0, r3
 513 005a BD46     		mov	sp, r7
 514 005c 05B0     		add	sp, sp, #20
 515              		@ sp needed for prologue
 516 005e 90BD     		pop	{r4, r7, pc}
 517              		.cfi_endproc
 518              	.LFE13:
 520              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 521              		.align	2
 522              		.global	xQueueTakeMutexRecursive
 523              		.code	16
 524              		.thumb_func
 526              	xQueueTakeMutexRecursive:
 527              	.LFB14:
 519:../Generated_Code/queue.c **** 
 520:../Generated_Code/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 521:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 522:../Generated_Code/queue.c **** 
 523:../Generated_Code/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 524:../Generated_Code/queue.c **** 
 525:../Generated_Code/queue.c ****         BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 526:../Generated_Code/queue.c ****         {
 528              		.loc 1 526 0
 529              		.cfi_startproc
 530 0000 90B5     		push	{r4, r7, lr}
 531              	.LCFI15:
 532              		.cfi_def_cfa_offset 12
 533              		.cfi_offset 4, -12
 534              		.cfi_offset 7, -8
 535              		.cfi_offset 14, -4
 536 0002 85B0     		sub	sp, sp, #20
 537              	.LCFI16:
 538              		.cfi_def_cfa_offset 32
 539 0004 00AF     		add	r7, sp, #0
 540              	.LCFI17:
 541              		.cfi_def_cfa_register 7
 542 0006 7860     		str	r0, [r7, #4]
 543 0008 3960     		str	r1, [r7]
 544              	.LBB7:
 527:../Generated_Code/queue.c ****         BaseType_t xReturn;
 528:../Generated_Code/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 545              		.loc 1 528 0
 546 000a 7B68     		ldr	r3, [r7, #4]
 547 000c BB60     		str	r3, [r7, #8]
 529:../Generated_Code/queue.c **** 
 530:../Generated_Code/queue.c ****                 configASSERT( pxMutex );
 548              		.loc 1 530 0
 549 000e BB68     		ldr	r3, [r7, #8]
 550 0010 002B     		cmp	r3, #0
 551 0012 01D1     		bne	.L30
 552              		.loc 1 530 0 is_stmt 0
 553              	@ 530 "../Generated_Code/queue.c" 1
 554 0014 72B6     		cpsid i
 555              	@ 0 "" 2
 556              		.code	16
 557              	.L31:
 558              		.loc 1 530 0
 559 0016 FEE7     		b	.L31
 560              	.L30:
 531:../Generated_Code/queue.c **** 
 532:../Generated_Code/queue.c ****                 /* Comments regarding mutual exclusion as per those within
 533:../Generated_Code/queue.c ****                 xQueueGiveMutexRecursive(). */
 534:../Generated_Code/queue.c **** 
 535:../Generated_Code/queue.c ****                 traceTAKE_MUTEX_RECURSIVE( pxMutex );
 536:../Generated_Code/queue.c **** 
 537:../Generated_Code/queue.c ****                 if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961
 561              		.loc 1 537 0 is_stmt 1
 562 0018 BB68     		ldr	r3, [r7, #8]
 563 001a 5C68     		ldr	r4, [r3, #4]
 564 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 565 0020 031C     		mov	r3, r0
 566 0022 E31A     		sub	r3, r4, r3
 567 0024 5A42     		neg	r2, r3
 568 0026 5341     		adc	r3, r3, r2
 569 0028 DBB2     		uxtb	r3, r3
 570 002a 002B     		cmp	r3, #0
 571 002c 07D0     		beq	.L32
 538:../Generated_Code/queue.c ****                 {
 539:../Generated_Code/queue.c ****                         ( pxMutex->u.uxRecursiveCallCount )++;
 572              		.loc 1 539 0
 573 002e BB68     		ldr	r3, [r7, #8]
 574 0030 DB68     		ldr	r3, [r3, #12]
 575 0032 5A1C     		add	r2, r3, #1
 576 0034 BB68     		ldr	r3, [r7, #8]
 577 0036 DA60     		str	r2, [r3, #12]
 540:../Generated_Code/queue.c ****                         xReturn = pdPASS;
 578              		.loc 1 540 0
 579 0038 0123     		mov	r3, #1
 580 003a FB60     		str	r3, [r7, #12]
 581 003c 11E0     		b	.L33
 582              	.L32:
 541:../Generated_Code/queue.c ****                 }
 542:../Generated_Code/queue.c ****                 else
 543:../Generated_Code/queue.c ****                 {
 544:../Generated_Code/queue.c ****                         xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 583              		.loc 1 544 0
 584 003e BA68     		ldr	r2, [r7, #8]
 585 0040 3B68     		ldr	r3, [r7]
 586 0042 101C     		mov	r0, r2
 587 0044 0021     		mov	r1, #0
 588 0046 1A1C     		mov	r2, r3
 589 0048 0023     		mov	r3, #0
 590 004a FFF7FEFF 		bl	xQueueGenericReceive
 591 004e 031C     		mov	r3, r0
 592 0050 FB60     		str	r3, [r7, #12]
 545:../Generated_Code/queue.c **** 
 546:../Generated_Code/queue.c ****                         /* pdPASS will only be returned if we successfully obtained the mutex,
 547:../Generated_Code/queue.c ****                         we may have blocked to reach here. */
 548:../Generated_Code/queue.c ****                         if( xReturn == pdPASS )
 593              		.loc 1 548 0
 594 0052 FB68     		ldr	r3, [r7, #12]
 595 0054 012B     		cmp	r3, #1
 596 0056 04D1     		bne	.L33
 549:../Generated_Code/queue.c ****                         {
 550:../Generated_Code/queue.c ****                                 ( pxMutex->u.uxRecursiveCallCount )++;
 597              		.loc 1 550 0
 598 0058 BB68     		ldr	r3, [r7, #8]
 599 005a DB68     		ldr	r3, [r3, #12]
 600 005c 5A1C     		add	r2, r3, #1
 601 005e BB68     		ldr	r3, [r7, #8]
 602 0060 DA60     		str	r2, [r3, #12]
 603              	.L33:
 551:../Generated_Code/queue.c ****                         }
 552:../Generated_Code/queue.c ****                         else
 553:../Generated_Code/queue.c ****                         {
 554:../Generated_Code/queue.c ****                                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 555:../Generated_Code/queue.c ****                         }
 556:../Generated_Code/queue.c ****                 }
 557:../Generated_Code/queue.c **** 
 558:../Generated_Code/queue.c ****                 return xReturn;
 604              		.loc 1 558 0
 605 0062 FB68     		ldr	r3, [r7, #12]
 606              	.LBE7:
 559:../Generated_Code/queue.c ****         }
 607              		.loc 1 559 0
 608 0064 181C     		mov	r0, r3
 609 0066 BD46     		mov	sp, r7
 610 0068 05B0     		add	sp, sp, #20
 611              		@ sp needed for prologue
 612 006a 90BD     		pop	{r4, r7, pc}
 613              		.cfi_endproc
 614              	.LFE14:
 616              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 617              		.align	2
 618              		.global	xQueueCreateCountingSemaphore
 619              		.code	16
 620              		.thumb_func
 622              	xQueueCreateCountingSemaphore:
 623              	.LFB15:
 560:../Generated_Code/queue.c **** 
 561:../Generated_Code/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 562:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 563:../Generated_Code/queue.c **** 
 564:../Generated_Code/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 565:../Generated_Code/queue.c **** 
 566:../Generated_Code/queue.c ****         QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_
 567:../Generated_Code/queue.c ****         {
 624              		.loc 1 567 0
 625              		.cfi_startproc
 626 0000 80B5     		push	{r7, lr}
 627              	.LCFI18:
 628              		.cfi_def_cfa_offset 8
 629              		.cfi_offset 7, -8
 630              		.cfi_offset 14, -4
 631 0002 84B0     		sub	sp, sp, #16
 632              	.LCFI19:
 633              		.cfi_def_cfa_offset 24
 634 0004 00AF     		add	r7, sp, #0
 635              	.LCFI20:
 636              		.cfi_def_cfa_register 7
 637 0006 7860     		str	r0, [r7, #4]
 638 0008 3960     		str	r1, [r7]
 639              	.LBB8:
 568:../Generated_Code/queue.c ****         QueueHandle_t xHandle;
 569:../Generated_Code/queue.c **** 
 570:../Generated_Code/queue.c ****                 configASSERT( uxMaxCount != 0 );
 640              		.loc 1 570 0
 641 000a 7B68     		ldr	r3, [r7, #4]
 642 000c 002B     		cmp	r3, #0
 643 000e 01D1     		bne	.L36
 644              		.loc 1 570 0 is_stmt 0
 645              	@ 570 "../Generated_Code/queue.c" 1
 646 0010 72B6     		cpsid i
 647              	@ 0 "" 2
 648              		.code	16
 649              	.L37:
 650              		.loc 1 570 0
 651 0012 FEE7     		b	.L37
 652              	.L36:
 571:../Generated_Code/queue.c ****                 configASSERT( uxInitialCount <= uxMaxCount );
 653              		.loc 1 571 0 is_stmt 1
 654 0014 3A68     		ldr	r2, [r7]
 655 0016 7B68     		ldr	r3, [r7, #4]
 656 0018 9A42     		cmp	r2, r3
 657 001a 01D9     		bls	.L38
 658              		.loc 1 571 0 is_stmt 0
 659              	@ 571 "../Generated_Code/queue.c" 1
 660 001c 72B6     		cpsid i
 661              	@ 0 "" 2
 662              		.code	16
 663              	.L39:
 664              		.loc 1 571 0
 665 001e FEE7     		b	.L39
 666              	.L38:
 572:../Generated_Code/queue.c **** 
 573:../Generated_Code/queue.c ****                 xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQ
 667              		.loc 1 573 0 is_stmt 1
 668 0020 7B68     		ldr	r3, [r7, #4]
 669 0022 181C     		mov	r0, r3
 670 0024 0021     		mov	r1, #0
 671 0026 0222     		mov	r2, #2
 672 0028 FFF7FEFF 		bl	xQueueGenericCreate
 673 002c 031C     		mov	r3, r0
 674 002e FB60     		str	r3, [r7, #12]
 574:../Generated_Code/queue.c **** 
 575:../Generated_Code/queue.c ****                 if( xHandle != NULL )
 675              		.loc 1 575 0
 676 0030 FB68     		ldr	r3, [r7, #12]
 677 0032 002B     		cmp	r3, #0
 678 0034 02D0     		beq	.L40
 576:../Generated_Code/queue.c ****                 {
 577:../Generated_Code/queue.c ****                         ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 679              		.loc 1 577 0
 680 0036 FB68     		ldr	r3, [r7, #12]
 681 0038 3A68     		ldr	r2, [r7]
 682 003a 9A63     		str	r2, [r3, #56]
 683              	.L40:
 578:../Generated_Code/queue.c **** 
 579:../Generated_Code/queue.c ****                         traceCREATE_COUNTING_SEMAPHORE();
 580:../Generated_Code/queue.c ****                 }
 581:../Generated_Code/queue.c ****                 else
 582:../Generated_Code/queue.c ****                 {
 583:../Generated_Code/queue.c ****                         traceCREATE_COUNTING_SEMAPHORE_FAILED();
 584:../Generated_Code/queue.c ****                 }
 585:../Generated_Code/queue.c **** 
 586:../Generated_Code/queue.c ****                 configASSERT( xHandle );
 684              		.loc 1 586 0
 685 003c FB68     		ldr	r3, [r7, #12]
 686 003e 002B     		cmp	r3, #0
 687 0040 01D1     		bne	.L41
 688              		.loc 1 586 0 is_stmt 0
 689              	@ 586 "../Generated_Code/queue.c" 1
 690 0042 72B6     		cpsid i
 691              	@ 0 "" 2
 692              		.code	16
 693              	.L42:
 694              		.loc 1 586 0
 695 0044 FEE7     		b	.L42
 696              	.L41:
 587:../Generated_Code/queue.c ****                 return xHandle;
 697              		.loc 1 587 0 is_stmt 1
 698 0046 FB68     		ldr	r3, [r7, #12]
 699              	.LBE8:
 588:../Generated_Code/queue.c ****         }
 700              		.loc 1 588 0
 701 0048 181C     		mov	r0, r3
 702 004a BD46     		mov	sp, r7
 703 004c 04B0     		add	sp, sp, #16
 704              		@ sp needed for prologue
 705 004e 80BD     		pop	{r7, pc}
 706              		.cfi_endproc
 707              	.LFE15:
 709              		.section	.text.xQueueGenericSend,"ax",%progbits
 710              		.align	2
 711              		.global	xQueueGenericSend
 712              		.code	16
 713              		.thumb_func
 715              	xQueueGenericSend:
 716              	.LFB16:
 589:../Generated_Code/queue.c **** 
 590:../Generated_Code/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 591:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 592:../Generated_Code/queue.c **** 
 593:../Generated_Code/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 594:../Generated_Code/queue.c **** {
 717              		.loc 1 594 0
 718              		.cfi_startproc
 719 0000 80B5     		push	{r7, lr}
 720              	.LCFI21:
 721              		.cfi_def_cfa_offset 8
 722              		.cfi_offset 7, -8
 723              		.cfi_offset 14, -4
 724 0002 88B0     		sub	sp, sp, #32
 725              	.LCFI22:
 726              		.cfi_def_cfa_offset 40
 727 0004 00AF     		add	r7, sp, #0
 728              	.LCFI23:
 729              		.cfi_def_cfa_register 7
 730 0006 F860     		str	r0, [r7, #12]
 731 0008 B960     		str	r1, [r7, #8]
 732 000a 7A60     		str	r2, [r7, #4]
 733 000c 3B60     		str	r3, [r7]
 734              	.LBB9:
 595:../Generated_Code/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 735              		.loc 1 595 0
 736 000e 0023     		mov	r3, #0
 737 0010 FB61     		str	r3, [r7, #28]
 596:../Generated_Code/queue.c **** TimeOut_t xTimeOut;
 597:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 738              		.loc 1 597 0
 739 0012 FB68     		ldr	r3, [r7, #12]
 740 0014 BB61     		str	r3, [r7, #24]
 598:../Generated_Code/queue.c **** 
 599:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 741              		.loc 1 599 0
 742 0016 BB69     		ldr	r3, [r7, #24]
 743 0018 002B     		cmp	r3, #0
 744 001a 01D1     		bne	.L45
 745              		.loc 1 599 0 is_stmt 0
 746              	@ 599 "../Generated_Code/queue.c" 1
 747 001c 72B6     		cpsid i
 748              	@ 0 "" 2
 749              		.code	16
 750              	.L46:
 751              		.loc 1 599 0
 752 001e FEE7     		b	.L46
 753              	.L45:
 600:../Generated_Code/queue.c ****         configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U )
 754              		.loc 1 600 0 is_stmt 1
 755 0020 BB68     		ldr	r3, [r7, #8]
 756 0022 002B     		cmp	r3, #0
 757 0024 05D1     		bne	.L47
 758              		.loc 1 600 0 is_stmt 0
 759 0026 BB69     		ldr	r3, [r7, #24]
 760 0028 1B6C     		ldr	r3, [r3, #64]
 761 002a 002B     		cmp	r3, #0
 762 002c 01D0     		beq	.L47
 763              		.loc 1 600 0
 764              	@ 600 "../Generated_Code/queue.c" 1
 765 002e 72B6     		cpsid i
 766              	@ 0 "" 2
 767              		.code	16
 768              	.L48:
 769              		.loc 1 600 0
 770 0030 FEE7     		b	.L48
 771              	.L47:
 601:../Generated_Code/queue.c ****         configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 772              		.loc 1 601 0 is_stmt 1
 773 0032 3B68     		ldr	r3, [r7]
 774 0034 022B     		cmp	r3, #2
 775 0036 05D1     		bne	.L49
 776              		.loc 1 601 0 is_stmt 0
 777 0038 BB69     		ldr	r3, [r7, #24]
 778 003a DB6B     		ldr	r3, [r3, #60]
 779 003c 012B     		cmp	r3, #1
 780 003e 01D0     		beq	.L49
 781              		.loc 1 601 0
 782              	@ 601 "../Generated_Code/queue.c" 1
 783 0040 72B6     		cpsid i
 784              	@ 0 "" 2
 785              		.code	16
 786              	.L50:
 787              		.loc 1 601 0
 788 0042 FEE7     		b	.L50
 789              	.L49:
 602:../Generated_Code/queue.c ****         #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 603:../Generated_Code/queue.c ****         {
 604:../Generated_Code/queue.c ****                 configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTick
 790              		.loc 1 604 0 is_stmt 1
 791 0044 FFF7FEFF 		bl	xTaskGetSchedulerState
 792 0048 031C     		mov	r3, r0
 793 004a 002B     		cmp	r3, #0
 794 004c 04D1     		bne	.L51
 795              		.loc 1 604 0 is_stmt 0
 796 004e 7B68     		ldr	r3, [r7, #4]
 797 0050 002B     		cmp	r3, #0
 798 0052 01D0     		beq	.L51
 799              		.loc 1 604 0
 800 0054 0123     		mov	r3, #1
 801 0056 00E0     		b	.L52
 802              	.L51:
 803              		.loc 1 604 0
 804 0058 0023     		mov	r3, #0
 805              	.L52:
 806              		.loc 1 604 0
 807 005a 002B     		cmp	r3, #0
 808 005c 02D0     		beq	.L53
 809              		.loc 1 604 0
 810              	@ 604 "../Generated_Code/queue.c" 1
 811 005e 72B6     		cpsid i
 812              	@ 0 "" 2
 813              		.code	16
 814              	.L54:
 815              		.loc 1 604 0
 816 0060 FEE7     		b	.L54
 817              	.L69:
 605:../Generated_Code/queue.c ****         }
 606:../Generated_Code/queue.c ****         #endif
 607:../Generated_Code/queue.c **** 
 608:../Generated_Code/queue.c **** 
 609:../Generated_Code/queue.c ****         /* This function relaxes the coding standard somewhat to allow return
 610:../Generated_Code/queue.c ****         statements within the function itself.  This is done in the interest
 611:../Generated_Code/queue.c ****         of execution time efficiency. */
 612:../Generated_Code/queue.c ****         for( ;; )
 818              		.loc 1 612 0 is_stmt 1
 819 0062 C046     		mov	r8, r8
 820              	.L53:
 613:../Generated_Code/queue.c ****         {
 614:../Generated_Code/queue.c ****                 taskENTER_CRITICAL();
 821              		.loc 1 614 0
 822 0064 FFF7FEFF 		bl	vPortEnterCritical
 615:../Generated_Code/queue.c ****                 {
 616:../Generated_Code/queue.c ****                         /* Is there room on the queue now?  The running task must be
 617:../Generated_Code/queue.c ****                         the highest priority task wanting to access the queue.  If
 618:../Generated_Code/queue.c ****                         the head item in the queue is to be overwritten then it does
 619:../Generated_Code/queue.c ****                         not matter if the queue is full. */
 620:../Generated_Code/queue.c ****                         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition =
 823              		.loc 1 620 0
 824 0068 BB69     		ldr	r3, [r7, #24]
 825 006a 9A6B     		ldr	r2, [r3, #56]
 826 006c BB69     		ldr	r3, [r7, #24]
 827 006e DB6B     		ldr	r3, [r3, #60]
 828 0070 9A42     		cmp	r2, r3
 829 0072 02D3     		bcc	.L55
 830              		.loc 1 620 0 is_stmt 0
 831 0074 3B68     		ldr	r3, [r7]
 832 0076 022B     		cmp	r3, #2
 833 0078 01D1     		bne	.L56
 834              	.L55:
 835              		.loc 1 620 0
 836 007a 0123     		mov	r3, #1
 837 007c 00E0     		b	.L57
 838              	.L56:
 839              		.loc 1 620 0
 840 007e 0023     		mov	r3, #0
 841              	.L57:
 842              		.loc 1 620 0
 843 0080 002B     		cmp	r3, #0
 844 0082 1DD0     		beq	.L58
 621:../Generated_Code/queue.c ****                         {
 622:../Generated_Code/queue.c ****                                 traceQUEUE_SEND( pxQueue );
 623:../Generated_Code/queue.c ****                                 prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 845              		.loc 1 623 0 is_stmt 1
 846 0084 B969     		ldr	r1, [r7, #24]
 847 0086 BA68     		ldr	r2, [r7, #8]
 848 0088 3B68     		ldr	r3, [r7]
 849 008a 081C     		mov	r0, r1
 850 008c 111C     		mov	r1, r2
 851 008e 1A1C     		mov	r2, r3
 852 0090 FFF7FEFF 		bl	_ZL18prvCopyDataToQueueP15QueueDefinitionPKvl
 624:../Generated_Code/queue.c **** 
 625:../Generated_Code/queue.c ****                                 #if ( configUSE_QUEUE_SETS == 1 )
 626:../Generated_Code/queue.c ****                                 {
 627:../Generated_Code/queue.c ****                                         if( pxQueue->pxQueueSetContainer != NULL )
 628:../Generated_Code/queue.c ****                                         {
 629:../Generated_Code/queue.c ****                                                 if( prvNotifyQueueSetContainer( pxQueue, xCopyPosit
 630:../Generated_Code/queue.c ****                                                 {
 631:../Generated_Code/queue.c ****                                                         /* The queue is a member of a queue set, an
 632:../Generated_Code/queue.c ****                                                         to the queue set caused a higher priority t
 633:../Generated_Code/queue.c ****                                                         unblock. A context switch is required. */
 634:../Generated_Code/queue.c ****                                                         queueYIELD_IF_USING_PREEMPTION();
 635:../Generated_Code/queue.c ****                                                 }
 636:../Generated_Code/queue.c ****                                                 else
 637:../Generated_Code/queue.c ****                                                 {
 638:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
 639:../Generated_Code/queue.c ****                                                 }
 640:../Generated_Code/queue.c ****                                         }
 641:../Generated_Code/queue.c ****                                         else
 642:../Generated_Code/queue.c ****                                         {
 643:../Generated_Code/queue.c ****                                                 /* If there was a task waiting for data to arrive o
 644:../Generated_Code/queue.c ****                                                 queue then unblock it now. */
 645:../Generated_Code/queue.c ****                                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToR
 646:../Generated_Code/queue.c ****                                                 {
 647:../Generated_Code/queue.c ****                                                         if( xTaskRemoveFromEventList( &( pxQueue->x
 648:../Generated_Code/queue.c ****                                                         {
 649:../Generated_Code/queue.c ****                                                                 /* The unblocked task has a priorit
 650:../Generated_Code/queue.c ****                                                                 our own so yield immediately.  Yes 
 651:../Generated_Code/queue.c ****                                                                 do this from within the critical se
 652:../Generated_Code/queue.c ****                                                                 kernel takes care of that. */
 653:../Generated_Code/queue.c ****                                                                 queueYIELD_IF_USING_PREEMPTION();
 654:../Generated_Code/queue.c ****                                                         }
 655:../Generated_Code/queue.c ****                                                         else
 656:../Generated_Code/queue.c ****                                                         {
 657:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
 658:../Generated_Code/queue.c ****                                                         }
 659:../Generated_Code/queue.c ****                                                 }
 660:../Generated_Code/queue.c ****                                                 else
 661:../Generated_Code/queue.c ****                                                 {
 662:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
 663:../Generated_Code/queue.c ****                                                 }
 664:../Generated_Code/queue.c ****                                         }
 665:../Generated_Code/queue.c ****                                 }
 666:../Generated_Code/queue.c ****                                 #else /* configUSE_QUEUE_SETS */
 667:../Generated_Code/queue.c ****                                 {
 668:../Generated_Code/queue.c ****                                         /* If there was a task waiting for data to arrive on the
 669:../Generated_Code/queue.c ****                                         queue then unblock it now. */
 670:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive )
 853              		.loc 1 670 0
 854 0094 BB69     		ldr	r3, [r7, #24]
 855 0096 5B6A     		ldr	r3, [r3, #36]
 856 0098 002B     		cmp	r3, #0
 857 009a 0DD0     		beq	.L59
 671:../Generated_Code/queue.c ****                                         {
 672:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
 858              		.loc 1 672 0
 859 009c BB69     		ldr	r3, [r7, #24]
 860 009e 2433     		add	r3, r3, #36
 861 00a0 181C     		mov	r0, r3
 862 00a2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 863 00a6 031C     		mov	r3, r0
 864 00a8 013B     		sub	r3, r3, #1
 865 00aa 5A42     		neg	r2, r3
 866 00ac 5341     		adc	r3, r3, r2
 867 00ae DBB2     		uxtb	r3, r3
 868 00b0 002B     		cmp	r3, #0
 869 00b2 01D0     		beq	.L59
 673:../Generated_Code/queue.c ****                                                 {
 674:../Generated_Code/queue.c ****                                                         /* The unblocked task has a priority higher
 675:../Generated_Code/queue.c ****                                                         our own so yield immediately.  Yes it is ok
 676:../Generated_Code/queue.c ****                                                         this from within the critical section - the
 677:../Generated_Code/queue.c ****                                                         takes care of that. */
 678:../Generated_Code/queue.c ****                                                         queueYIELD_IF_USING_PREEMPTION();
 870              		.loc 1 678 0
 871 00b4 FFF7FEFF 		bl	vPortYieldFromISR
 872              	.L59:
 679:../Generated_Code/queue.c ****                                                 }
 680:../Generated_Code/queue.c ****                                                 else
 681:../Generated_Code/queue.c ****                                                 {
 682:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
 683:../Generated_Code/queue.c ****                                                 }
 684:../Generated_Code/queue.c ****                                         }
 685:../Generated_Code/queue.c ****                                         else
 686:../Generated_Code/queue.c ****                                         {
 687:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
 688:../Generated_Code/queue.c ****                                         }
 689:../Generated_Code/queue.c ****                                 }
 690:../Generated_Code/queue.c ****                                 #endif /* configUSE_QUEUE_SETS */
 691:../Generated_Code/queue.c **** 
 692:../Generated_Code/queue.c ****                                 taskEXIT_CRITICAL();
 873              		.loc 1 692 0
 874 00b8 FFF7FEFF 		bl	vPortExitCritical
 693:../Generated_Code/queue.c **** 
 694:../Generated_Code/queue.c ****                                 /* Return to the original privilege level before exiting the
 695:../Generated_Code/queue.c ****                                 function. */
 696:../Generated_Code/queue.c ****                                 return pdPASS;
 875              		.loc 1 696 0
 876 00bc 0123     		mov	r3, #1
 877 00be 6BE0     		b	.L68
 878              	.L58:
 697:../Generated_Code/queue.c ****                         }
 698:../Generated_Code/queue.c ****                         else
 699:../Generated_Code/queue.c ****                         {
 700:../Generated_Code/queue.c ****                                 if( xTicksToWait == ( TickType_t ) 0 )
 879              		.loc 1 700 0
 880 00c0 7B68     		ldr	r3, [r7, #4]
 881 00c2 002B     		cmp	r3, #0
 882 00c4 03D1     		bne	.L61
 701:../Generated_Code/queue.c ****                                 {
 702:../Generated_Code/queue.c ****                                         /* The queue was full and no block time is specified (or
 703:../Generated_Code/queue.c ****                                         the block time has expired) so leave now. */
 704:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
 883              		.loc 1 704 0
 884 00c6 FFF7FEFF 		bl	vPortExitCritical
 705:../Generated_Code/queue.c **** 
 706:../Generated_Code/queue.c ****                                         /* Return to the original privilege level before exiting
 707:../Generated_Code/queue.c ****                                         the function. */
 708:../Generated_Code/queue.c ****                                         traceQUEUE_SEND_FAILED( pxQueue );
 709:../Generated_Code/queue.c ****                                         return errQUEUE_FULL;
 885              		.loc 1 709 0
 886 00ca 0023     		mov	r3, #0
 887 00cc 64E0     		b	.L68
 888              	.L61:
 710:../Generated_Code/queue.c ****                                 }
 711:../Generated_Code/queue.c ****                                 else if( xEntryTimeSet == pdFALSE )
 889              		.loc 1 711 0
 890 00ce FB69     		ldr	r3, [r7, #28]
 891 00d0 002B     		cmp	r3, #0
 892 00d2 06D1     		bne	.L62
 712:../Generated_Code/queue.c ****                                 {
 713:../Generated_Code/queue.c ****                                         /* The queue was full and a block time was specified so
 714:../Generated_Code/queue.c ****                                         configure the timeout structure. */
 715:../Generated_Code/queue.c ****                                         vTaskSetTimeOutState( &xTimeOut );
 893              		.loc 1 715 0
 894 00d4 3B1C     		mov	r3, r7
 895 00d6 1033     		add	r3, r3, #16
 896 00d8 181C     		mov	r0, r3
 897 00da FFF7FEFF 		bl	vTaskSetTimeOutState
 716:../Generated_Code/queue.c ****                                         xEntryTimeSet = pdTRUE;
 898              		.loc 1 716 0
 899 00de 0123     		mov	r3, #1
 900 00e0 FB61     		str	r3, [r7, #28]
 901              	.L62:
 717:../Generated_Code/queue.c ****                                 }
 718:../Generated_Code/queue.c ****                                 else
 719:../Generated_Code/queue.c ****                                 {
 720:../Generated_Code/queue.c ****                                         /* Entry time was already set. */
 721:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
 722:../Generated_Code/queue.c ****                                 }
 723:../Generated_Code/queue.c ****                         }
 724:../Generated_Code/queue.c ****                 }
 725:../Generated_Code/queue.c ****                 taskEXIT_CRITICAL();
 902              		.loc 1 725 0
 903 00e2 FFF7FEFF 		bl	vPortExitCritical
 726:../Generated_Code/queue.c **** 
 727:../Generated_Code/queue.c ****                 /* Interrupts and other tasks can send to and receive from the queue
 728:../Generated_Code/queue.c ****                 now the critical section has been exited. */
 729:../Generated_Code/queue.c **** 
 730:../Generated_Code/queue.c ****                 vTaskSuspendAll();
 904              		.loc 1 730 0
 905 00e6 FFF7FEFF 		bl	vTaskSuspendAll
 731:../Generated_Code/queue.c ****                 prvLockQueue( pxQueue );
 906              		.loc 1 731 0
 907 00ea FFF7FEFF 		bl	vPortEnterCritical
 908 00ee BB69     		ldr	r3, [r7, #24]
 909 00f0 5B6C     		ldr	r3, [r3, #68]
 910 00f2 0133     		add	r3, r3, #1
 911 00f4 5A42     		neg	r2, r3
 912 00f6 5341     		adc	r3, r3, r2
 913 00f8 DBB2     		uxtb	r3, r3
 914 00fa 002B     		cmp	r3, #0
 915 00fc 02D0     		beq	.L63
 916              		.loc 1 731 0 is_stmt 0
 917 00fe BB69     		ldr	r3, [r7, #24]
 918 0100 0022     		mov	r2, #0
 919 0102 5A64     		str	r2, [r3, #68]
 920              	.L63:
 921              		.loc 1 731 0
 922 0104 BB69     		ldr	r3, [r7, #24]
 923 0106 9B6C     		ldr	r3, [r3, #72]
 924 0108 0133     		add	r3, r3, #1
 925 010a 5A42     		neg	r2, r3
 926 010c 5341     		adc	r3, r3, r2
 927 010e DBB2     		uxtb	r3, r3
 928 0110 002B     		cmp	r3, #0
 929 0112 02D0     		beq	.L64
 930              		.loc 1 731 0
 931 0114 BB69     		ldr	r3, [r7, #24]
 932 0116 0022     		mov	r2, #0
 933 0118 9A64     		str	r2, [r3, #72]
 934              	.L64:
 935              		.loc 1 731 0
 936 011a FFF7FEFF 		bl	vPortExitCritical
 732:../Generated_Code/queue.c **** 
 733:../Generated_Code/queue.c ****                 /* Update the timeout state to see if it has expired yet. */
 734:../Generated_Code/queue.c ****                 if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 937              		.loc 1 734 0 is_stmt 1
 938 011e 3A1C     		mov	r2, r7
 939 0120 1032     		add	r2, r2, #16
 940 0122 3B1D     		add	r3, r7, #4
 941 0124 101C     		mov	r0, r2
 942 0126 191C     		mov	r1, r3
 943 0128 FFF7FEFF 		bl	xTaskCheckForTimeOut
 944 012c 031C     		mov	r3, r0
 945 012e 5A42     		neg	r2, r3
 946 0130 5341     		adc	r3, r3, r2
 947 0132 DBB2     		uxtb	r3, r3
 948 0134 002B     		cmp	r3, #0
 949 0136 28D0     		beq	.L65
 735:../Generated_Code/queue.c ****                 {
 736:../Generated_Code/queue.c ****                         if( prvIsQueueFull( pxQueue ) != pdFALSE )
 950              		.loc 1 736 0
 951 0138 BB69     		ldr	r3, [r7, #24]
 952 013a 181C     		mov	r0, r3
 953 013c FFF7FEFF 		bl	_ZL14prvIsQueueFullPK15QueueDefinition
 954 0140 031C     		mov	r3, r0
 955 0142 5A1E     		sub	r2, r3, #1
 956 0144 9341     		sbc	r3, r3, r2
 957 0146 DBB2     		uxtb	r3, r3
 958 0148 002B     		cmp	r3, #0
 959 014a 17D0     		beq	.L66
 737:../Generated_Code/queue.c ****                         {
 738:../Generated_Code/queue.c ****                                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 739:../Generated_Code/queue.c ****                                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToW
 960              		.loc 1 739 0
 961 014c BB69     		ldr	r3, [r7, #24]
 962 014e 1A1C     		mov	r2, r3
 963 0150 1032     		add	r2, r2, #16
 964 0152 7B68     		ldr	r3, [r7, #4]
 965 0154 101C     		mov	r0, r2
 966 0156 191C     		mov	r1, r3
 967 0158 FFF7FEFF 		bl	vTaskPlaceOnEventList
 740:../Generated_Code/queue.c **** 
 741:../Generated_Code/queue.c ****                                 /* Unlocking the queue means queue events can effect the
 742:../Generated_Code/queue.c ****                                 event list.  It is possible     that interrupts occurring now
 743:../Generated_Code/queue.c ****                                 remove this task from the event list again - but as the
 744:../Generated_Code/queue.c ****                                 scheduler is suspended the task will go onto the pending
 745:../Generated_Code/queue.c ****                                 ready last instead of the actual ready list. */
 746:../Generated_Code/queue.c ****                                 prvUnlockQueue( pxQueue );
 968              		.loc 1 746 0
 969 015c BB69     		ldr	r3, [r7, #24]
 970 015e 181C     		mov	r0, r3
 971 0160 FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
 747:../Generated_Code/queue.c **** 
 748:../Generated_Code/queue.c ****                                 /* Resuming the scheduler will move tasks from the pending
 749:../Generated_Code/queue.c ****                                 ready list into the ready list - so it is feasible that this
 750:../Generated_Code/queue.c ****                                 task is already in a ready list before it yields - in which
 751:../Generated_Code/queue.c ****                                 case the yield will not cause a context switch unless there
 752:../Generated_Code/queue.c ****                                 is also a higher priority task in the pending ready list. */
 753:../Generated_Code/queue.c ****                                 if( xTaskResumeAll() == pdFALSE )
 972              		.loc 1 753 0
 973 0164 FFF7FEFF 		bl	xTaskResumeAll
 974 0168 031C     		mov	r3, r0
 975 016a 5A42     		neg	r2, r3
 976 016c 5341     		adc	r3, r3, r2
 977 016e DBB2     		uxtb	r3, r3
 978 0170 002B     		cmp	r3, #0
 979 0172 00D1     		bne	.LCB808
 980 0174 75E7     		b	.L69	@long jump
 981              	.LCB808:
 754:../Generated_Code/queue.c ****                                 {
 755:../Generated_Code/queue.c ****                                         portYIELD_WITHIN_API();
 982              		.loc 1 755 0
 983 0176 FFF7FEFF 		bl	vPortYieldFromISR
 612:../Generated_Code/queue.c ****         for( ;; )
 984              		.loc 1 612 0
 985 017a 72E7     		b	.L69
 986              	.L66:
 756:../Generated_Code/queue.c ****                                 }
 757:../Generated_Code/queue.c ****                         }
 758:../Generated_Code/queue.c ****                         else
 759:../Generated_Code/queue.c ****                         {
 760:../Generated_Code/queue.c ****                                 /* Try again. */
 761:../Generated_Code/queue.c ****                                 prvUnlockQueue( pxQueue );
 987              		.loc 1 761 0
 988 017c BB69     		ldr	r3, [r7, #24]
 989 017e 181C     		mov	r0, r3
 990 0180 FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
 762:../Generated_Code/queue.c ****                                 ( void ) xTaskResumeAll();
 991              		.loc 1 762 0
 992 0184 FFF7FEFF 		bl	xTaskResumeAll
 612:../Generated_Code/queue.c ****         for( ;; )
 993              		.loc 1 612 0
 994 0188 6BE7     		b	.L69
 995              	.L65:
 763:../Generated_Code/queue.c ****                         }
 764:../Generated_Code/queue.c ****                 }
 765:../Generated_Code/queue.c ****                 else
 766:../Generated_Code/queue.c ****                 {
 767:../Generated_Code/queue.c ****                         /* The timeout has expired. */
 768:../Generated_Code/queue.c ****                         prvUnlockQueue( pxQueue );
 996              		.loc 1 768 0
 997 018a BB69     		ldr	r3, [r7, #24]
 998 018c 181C     		mov	r0, r3
 999 018e FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
 769:../Generated_Code/queue.c ****                         ( void ) xTaskResumeAll();
 1000              		.loc 1 769 0
 1001 0192 FFF7FEFF 		bl	xTaskResumeAll
 770:../Generated_Code/queue.c **** 
 771:../Generated_Code/queue.c ****                         /* Return to the original privilege level before exiting the
 772:../Generated_Code/queue.c ****                         function. */
 773:../Generated_Code/queue.c ****                         traceQUEUE_SEND_FAILED( pxQueue );
 774:../Generated_Code/queue.c ****                         return errQUEUE_FULL;
 1002              		.loc 1 774 0
 1003 0196 0023     		mov	r3, #0
 1004              	.L68:
 1005              	.LBE9:
 775:../Generated_Code/queue.c ****                 }
 776:../Generated_Code/queue.c ****         }
 777:../Generated_Code/queue.c **** }
 1006              		.loc 1 777 0
 1007 0198 181C     		mov	r0, r3
 1008 019a BD46     		mov	sp, r7
 1009 019c 08B0     		add	sp, sp, #32
 1010              		@ sp needed for prologue
 1011 019e 80BD     		pop	{r7, pc}
 1012              		.cfi_endproc
 1013              	.LFE16:
 1015              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1016              		.align	2
 1017              		.global	xQueueGenericSendFromISR
 1018              		.code	16
 1019              		.thumb_func
 1021              	xQueueGenericSendFromISR:
 1022              	.LFB17:
 778:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 779:../Generated_Code/queue.c **** 
 780:../Generated_Code/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 781:../Generated_Code/queue.c **** 
 782:../Generated_Code/queue.c ****         BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, Ti
 783:../Generated_Code/queue.c ****         {
 784:../Generated_Code/queue.c ****         BaseType_t xEntryTimeSet = pdFALSE;
 785:../Generated_Code/queue.c ****         TimeOut_t xTimeOut;
 786:../Generated_Code/queue.c ****         Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 787:../Generated_Code/queue.c **** 
 788:../Generated_Code/queue.c ****                 configASSERT( pxQueue );
 789:../Generated_Code/queue.c ****                 configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_
 790:../Generated_Code/queue.c **** 
 791:../Generated_Code/queue.c ****                 for( ;; )
 792:../Generated_Code/queue.c ****                 {
 793:../Generated_Code/queue.c ****                         taskENTER_CRITICAL();
 794:../Generated_Code/queue.c ****                         {
 795:../Generated_Code/queue.c ****                                 /* Is there room on the queue now?  To be running we must be
 796:../Generated_Code/queue.c ****                                 the highest priority task wanting to access the queue. */
 797:../Generated_Code/queue.c ****                                 if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 798:../Generated_Code/queue.c ****                                 {
 799:../Generated_Code/queue.c ****                                         traceQUEUE_SEND( pxQueue );
 800:../Generated_Code/queue.c ****                                         prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition )
 801:../Generated_Code/queue.c **** 
 802:../Generated_Code/queue.c ****                                         /* If there was a task waiting for data to arrive on the
 803:../Generated_Code/queue.c ****                                         queue then unblock it now. */
 804:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive )
 805:../Generated_Code/queue.c ****                                         {
 806:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
 807:../Generated_Code/queue.c ****                                                 {
 808:../Generated_Code/queue.c ****                                                         /* The unblocked task has a priority higher
 809:../Generated_Code/queue.c ****                                                         our own so yield immediately. */
 810:../Generated_Code/queue.c ****                                                         portYIELD_WITHIN_API();
 811:../Generated_Code/queue.c ****                                                 }
 812:../Generated_Code/queue.c ****                                                 else
 813:../Generated_Code/queue.c ****                                                 {
 814:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
 815:../Generated_Code/queue.c ****                                                 }
 816:../Generated_Code/queue.c ****                                         }
 817:../Generated_Code/queue.c ****                                         else
 818:../Generated_Code/queue.c ****                                         {
 819:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
 820:../Generated_Code/queue.c ****                                         }
 821:../Generated_Code/queue.c **** 
 822:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
 823:../Generated_Code/queue.c ****                                         return pdPASS;
 824:../Generated_Code/queue.c ****                                 }
 825:../Generated_Code/queue.c ****                                 else
 826:../Generated_Code/queue.c ****                                 {
 827:../Generated_Code/queue.c ****                                         if( xTicksToWait == ( TickType_t ) 0 )
 828:../Generated_Code/queue.c ****                                         {
 829:../Generated_Code/queue.c ****                                                 taskEXIT_CRITICAL();
 830:../Generated_Code/queue.c ****                                                 return errQUEUE_FULL;
 831:../Generated_Code/queue.c ****                                         }
 832:../Generated_Code/queue.c ****                                         else if( xEntryTimeSet == pdFALSE )
 833:../Generated_Code/queue.c ****                                         {
 834:../Generated_Code/queue.c ****                                                 vTaskSetTimeOutState( &xTimeOut );
 835:../Generated_Code/queue.c ****                                                 xEntryTimeSet = pdTRUE;
 836:../Generated_Code/queue.c ****                                         }
 837:../Generated_Code/queue.c ****                                 }
 838:../Generated_Code/queue.c ****                         }
 839:../Generated_Code/queue.c ****                         taskEXIT_CRITICAL();
 840:../Generated_Code/queue.c **** 
 841:../Generated_Code/queue.c ****                         taskENTER_CRITICAL();
 842:../Generated_Code/queue.c ****                         {
 843:../Generated_Code/queue.c ****                                 if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 844:../Generated_Code/queue.c ****                                 {
 845:../Generated_Code/queue.c ****                                         if( prvIsQueueFull( pxQueue ) != pdFALSE )
 846:../Generated_Code/queue.c ****                                         {
 847:../Generated_Code/queue.c ****                                                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 848:../Generated_Code/queue.c ****                                                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToS
 849:../Generated_Code/queue.c ****                                                 portYIELD_WITHIN_API();
 850:../Generated_Code/queue.c ****                                         }
 851:../Generated_Code/queue.c ****                                         else
 852:../Generated_Code/queue.c ****                                         {
 853:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
 854:../Generated_Code/queue.c ****                                         }
 855:../Generated_Code/queue.c ****                                 }
 856:../Generated_Code/queue.c ****                                 else
 857:../Generated_Code/queue.c ****                                 {
 858:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
 859:../Generated_Code/queue.c ****                                         traceQUEUE_SEND_FAILED( pxQueue );
 860:../Generated_Code/queue.c ****                                         return errQUEUE_FULL;
 861:../Generated_Code/queue.c ****                                 }
 862:../Generated_Code/queue.c ****                         }
 863:../Generated_Code/queue.c ****                         taskEXIT_CRITICAL();
 864:../Generated_Code/queue.c ****                 }
 865:../Generated_Code/queue.c ****         }
 866:../Generated_Code/queue.c **** 
 867:../Generated_Code/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 868:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
 869:../Generated_Code/queue.c **** 
 870:../Generated_Code/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 871:../Generated_Code/queue.c **** 
 872:../Generated_Code/queue.c ****         BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t
 873:../Generated_Code/queue.c ****         {
 874:../Generated_Code/queue.c ****         BaseType_t xEntryTimeSet = pdFALSE;
 875:../Generated_Code/queue.c ****         TimeOut_t xTimeOut;
 876:../Generated_Code/queue.c ****         int8_t *pcOriginalReadPosition;
 877:../Generated_Code/queue.c ****         Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 878:../Generated_Code/queue.c **** 
 879:../Generated_Code/queue.c ****                 configASSERT( pxQueue );
 880:../Generated_Code/queue.c ****                 configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0
 881:../Generated_Code/queue.c **** 
 882:../Generated_Code/queue.c ****                 for( ;; )
 883:../Generated_Code/queue.c ****                 {
 884:../Generated_Code/queue.c ****                         taskENTER_CRITICAL();
 885:../Generated_Code/queue.c ****                         {
 886:../Generated_Code/queue.c ****                                 if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 887:../Generated_Code/queue.c ****                                 {
 888:../Generated_Code/queue.c ****                                         /* Remember our read position in case we are just peeking. 
 889:../Generated_Code/queue.c ****                                         pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 890:../Generated_Code/queue.c **** 
 891:../Generated_Code/queue.c ****                                         prvCopyDataFromQueue( pxQueue, pvBuffer );
 892:../Generated_Code/queue.c **** 
 893:../Generated_Code/queue.c ****                                         if( xJustPeeking == pdFALSE )
 894:../Generated_Code/queue.c ****                                         {
 895:../Generated_Code/queue.c ****                                                 traceQUEUE_RECEIVE( pxQueue );
 896:../Generated_Code/queue.c **** 
 897:../Generated_Code/queue.c ****                                                 /* Data is actually being removed (not just peeked)
 898:../Generated_Code/queue.c ****                                                 --( pxQueue->uxMessagesWaiting );
 899:../Generated_Code/queue.c **** 
 900:../Generated_Code/queue.c ****                                                 #if ( configUSE_MUTEXES == 1 )
 901:../Generated_Code/queue.c ****                                                 {
 902:../Generated_Code/queue.c ****                                                         if( pxQueue->uxQueueType == queueQUEUE_IS_M
 903:../Generated_Code/queue.c ****                                                         {
 904:../Generated_Code/queue.c ****                                                                 /* Record the information required 
 905:../Generated_Code/queue.c ****                                                                 priority inheritance should it beco
 906:../Generated_Code/queue.c ****                                                                 pxQueue->pxMutexHolder = ( int8_t *
 907:../Generated_Code/queue.c ****                                                         }
 908:../Generated_Code/queue.c ****                                                         else
 909:../Generated_Code/queue.c ****                                                         {
 910:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
 911:../Generated_Code/queue.c ****                                                         }
 912:../Generated_Code/queue.c ****                                                 }
 913:../Generated_Code/queue.c ****                                                 #endif
 914:../Generated_Code/queue.c **** 
 915:../Generated_Code/queue.c ****                                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToS
 916:../Generated_Code/queue.c ****                                                 {
 917:../Generated_Code/queue.c ****                                                         if( xTaskRemoveFromEventList( &( pxQueue->x
 918:../Generated_Code/queue.c ****                                                         {
 919:../Generated_Code/queue.c ****                                                                 portYIELD_WITHIN_API();
 920:../Generated_Code/queue.c ****                                                         }
 921:../Generated_Code/queue.c ****                                                         else
 922:../Generated_Code/queue.c ****                                                         {
 923:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
 924:../Generated_Code/queue.c ****                                                         }
 925:../Generated_Code/queue.c ****                                                 }
 926:../Generated_Code/queue.c ****                                         }
 927:../Generated_Code/queue.c ****                                         else
 928:../Generated_Code/queue.c ****                                         {
 929:../Generated_Code/queue.c ****                                                 traceQUEUE_PEEK( pxQueue );
 930:../Generated_Code/queue.c **** 
 931:../Generated_Code/queue.c ****                                                 /* We are not removing the data, so reset our read
 932:../Generated_Code/queue.c ****                                                 pointer. */
 933:../Generated_Code/queue.c ****                                                 pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 934:../Generated_Code/queue.c **** 
 935:../Generated_Code/queue.c ****                                                 /* The data is being left in the queue, so see if t
 936:../Generated_Code/queue.c ****                                                 any other tasks waiting for the data. */
 937:../Generated_Code/queue.c ****                                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToR
 938:../Generated_Code/queue.c ****                                                 {
 939:../Generated_Code/queue.c ****                                                         /* Tasks that are removed from the event li
 940:../Generated_Code/queue.c ****                                                         the pending ready list as the scheduler is 
 941:../Generated_Code/queue.c ****                                                         if( xTaskRemoveFromEventList( &( pxQueue->x
 942:../Generated_Code/queue.c ****                                                         {
 943:../Generated_Code/queue.c ****                                                                 /* The task waiting has a higher pr
 944:../Generated_Code/queue.c ****                                                                 portYIELD_WITHIN_API();
 945:../Generated_Code/queue.c ****                                                         }
 946:../Generated_Code/queue.c ****                                                         else
 947:../Generated_Code/queue.c ****                                                         {
 948:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
 949:../Generated_Code/queue.c ****                                                         }
 950:../Generated_Code/queue.c ****                                                 }
 951:../Generated_Code/queue.c ****                                                 else
 952:../Generated_Code/queue.c ****                                                 {
 953:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
 954:../Generated_Code/queue.c ****                                                 }
 955:../Generated_Code/queue.c ****                                         }
 956:../Generated_Code/queue.c **** 
 957:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
 958:../Generated_Code/queue.c ****                                         return pdPASS;
 959:../Generated_Code/queue.c ****                                 }
 960:../Generated_Code/queue.c ****                                 else
 961:../Generated_Code/queue.c ****                                 {
 962:../Generated_Code/queue.c ****                                         if( xTicksToWait == ( TickType_t ) 0 )
 963:../Generated_Code/queue.c ****                                         {
 964:../Generated_Code/queue.c ****                                                 taskEXIT_CRITICAL();
 965:../Generated_Code/queue.c ****                                                 traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:../Generated_Code/queue.c ****                                                 return errQUEUE_EMPTY;
 967:../Generated_Code/queue.c ****                                         }
 968:../Generated_Code/queue.c ****                                         else if( xEntryTimeSet == pdFALSE )
 969:../Generated_Code/queue.c ****                                         {
 970:../Generated_Code/queue.c ****                                                 vTaskSetTimeOutState( &xTimeOut );
 971:../Generated_Code/queue.c ****                                                 xEntryTimeSet = pdTRUE;
 972:../Generated_Code/queue.c ****                                         }
 973:../Generated_Code/queue.c ****                                 }
 974:../Generated_Code/queue.c ****                         }
 975:../Generated_Code/queue.c ****                         taskEXIT_CRITICAL();
 976:../Generated_Code/queue.c **** 
 977:../Generated_Code/queue.c ****                         taskENTER_CRITICAL();
 978:../Generated_Code/queue.c ****                         {
 979:../Generated_Code/queue.c ****                                 if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 980:../Generated_Code/queue.c ****                                 {
 981:../Generated_Code/queue.c ****                                         if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 982:../Generated_Code/queue.c ****                                         {
 983:../Generated_Code/queue.c ****                                                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 984:../Generated_Code/queue.c **** 
 985:../Generated_Code/queue.c ****                                                 #if ( configUSE_MUTEXES == 1 )
 986:../Generated_Code/queue.c ****                                                 {
 987:../Generated_Code/queue.c ****                                                         if( pxQueue->uxQueueType == queueQUEUE_IS_M
 988:../Generated_Code/queue.c ****                                                         {
 989:../Generated_Code/queue.c ****                                                                 taskENTER_CRITICAL();
 990:../Generated_Code/queue.c ****                                                                 {
 991:../Generated_Code/queue.c ****                                                                         vTaskPriorityInherit( ( voi
 992:../Generated_Code/queue.c ****                                                                 }
 993:../Generated_Code/queue.c ****                                                                 taskEXIT_CRITICAL();
 994:../Generated_Code/queue.c ****                                                         }
 995:../Generated_Code/queue.c ****                                                         else
 996:../Generated_Code/queue.c ****                                                         {
 997:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
 998:../Generated_Code/queue.c ****                                                         }
 999:../Generated_Code/queue.c ****                                                 }
1000:../Generated_Code/queue.c ****                                                 #endif
1001:../Generated_Code/queue.c **** 
1002:../Generated_Code/queue.c ****                                                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToR
1003:../Generated_Code/queue.c ****                                                 portYIELD_WITHIN_API();
1004:../Generated_Code/queue.c ****                                         }
1005:../Generated_Code/queue.c ****                                         else
1006:../Generated_Code/queue.c ****                                         {
1007:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1008:../Generated_Code/queue.c ****                                         }
1009:../Generated_Code/queue.c ****                                 }
1010:../Generated_Code/queue.c ****                                 else
1011:../Generated_Code/queue.c ****                                 {
1012:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
1013:../Generated_Code/queue.c ****                                         traceQUEUE_RECEIVE_FAILED( pxQueue );
1014:../Generated_Code/queue.c ****                                         return errQUEUE_EMPTY;
1015:../Generated_Code/queue.c ****                                 }
1016:../Generated_Code/queue.c ****                         }
1017:../Generated_Code/queue.c ****                         taskEXIT_CRITICAL();
1018:../Generated_Code/queue.c ****                 }
1019:../Generated_Code/queue.c ****         }
1020:../Generated_Code/queue.c **** 
1021:../Generated_Code/queue.c **** 
1022:../Generated_Code/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1023:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1024:../Generated_Code/queue.c **** 
1025:../Generated_Code/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1026:../Generated_Code/queue.c **** {
 1023              		.loc 1 1026 0
 1024              		.cfi_startproc
 1025 0000 80B5     		push	{r7, lr}
 1026              	.LCFI24:
 1027              		.cfi_def_cfa_offset 8
 1028              		.cfi_offset 7, -8
 1029              		.cfi_offset 14, -4
 1030 0002 88B0     		sub	sp, sp, #32
 1031              	.LCFI25:
 1032              		.cfi_def_cfa_offset 40
 1033 0004 00AF     		add	r7, sp, #0
 1034              	.LCFI26:
 1035              		.cfi_def_cfa_register 7
 1036 0006 F860     		str	r0, [r7, #12]
 1037 0008 B960     		str	r1, [r7, #8]
 1038 000a 7A60     		str	r2, [r7, #4]
 1039 000c 3B60     		str	r3, [r7]
 1040              	.LBB10:
1027:../Generated_Code/queue.c **** BaseType_t xReturn;
1028:../Generated_Code/queue.c **** UBaseType_t uxSavedInterruptStatus;
1029:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1041              		.loc 1 1029 0
 1042 000e FB68     		ldr	r3, [r7, #12]
 1043 0010 BB61     		str	r3, [r7, #24]
1030:../Generated_Code/queue.c **** 
1031:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1044              		.loc 1 1031 0
 1045 0012 BB69     		ldr	r3, [r7, #24]
 1046 0014 002B     		cmp	r3, #0
 1047 0016 01D1     		bne	.L71
 1048              		.loc 1 1031 0 is_stmt 0
 1049              	@ 1031 "../Generated_Code/queue.c" 1
 1050 0018 72B6     		cpsid i
 1051              	@ 0 "" 2
 1052              		.code	16
 1053              	.L72:
 1054              		.loc 1 1031 0
 1055 001a FEE7     		b	.L72
 1056              	.L71:
1032:../Generated_Code/queue.c ****         configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U )
 1057              		.loc 1 1032 0 is_stmt 1
 1058 001c BB68     		ldr	r3, [r7, #8]
 1059 001e 002B     		cmp	r3, #0
 1060 0020 05D1     		bne	.L73
 1061              		.loc 1 1032 0 is_stmt 0
 1062 0022 BB69     		ldr	r3, [r7, #24]
 1063 0024 1B6C     		ldr	r3, [r3, #64]
 1064 0026 002B     		cmp	r3, #0
 1065 0028 01D0     		beq	.L73
 1066              		.loc 1 1032 0
 1067              	@ 1032 "../Generated_Code/queue.c" 1
 1068 002a 72B6     		cpsid i
 1069              	@ 0 "" 2
 1070              		.code	16
 1071              	.L74:
 1072              		.loc 1 1032 0
 1073 002c FEE7     		b	.L74
 1074              	.L73:
1033:../Generated_Code/queue.c ****         configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1075              		.loc 1 1033 0 is_stmt 1
 1076 002e 3B68     		ldr	r3, [r7]
 1077 0030 022B     		cmp	r3, #2
 1078 0032 05D1     		bne	.L75
 1079              		.loc 1 1033 0 is_stmt 0
 1080 0034 BB69     		ldr	r3, [r7, #24]
 1081 0036 DB6B     		ldr	r3, [r3, #60]
 1082 0038 012B     		cmp	r3, #1
 1083 003a 01D0     		beq	.L75
 1084              		.loc 1 1033 0
 1085              	@ 1033 "../Generated_Code/queue.c" 1
 1086 003c 72B6     		cpsid i
 1087              	@ 0 "" 2
 1088              		.code	16
 1089              	.L76:
 1090              		.loc 1 1033 0
 1091 003e FEE7     		b	.L76
 1092              	.L75:
1034:../Generated_Code/queue.c **** 
1035:../Generated_Code/queue.c ****         /* RTOS ports that support interrupt nesting have the concept of a maximum
1036:../Generated_Code/queue.c ****         system call (or maximum API call) interrupt priority.  Interrupts that are
1037:../Generated_Code/queue.c ****         above the maximum system call priority are kept permanently enabled, even
1038:../Generated_Code/queue.c ****         when the RTOS kernel is in a critical section, but cannot make any calls to
1039:../Generated_Code/queue.c ****         FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1040:../Generated_Code/queue.c ****         then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1041:../Generated_Code/queue.c ****         failure if a FreeRTOS API function is called from an interrupt that has been
1042:../Generated_Code/queue.c ****         assigned a priority above the configured maximum system call priority.
1043:../Generated_Code/queue.c ****         Only FreeRTOS functions that end in FromISR can be called from interrupts
1044:../Generated_Code/queue.c ****         that have been assigned a priority at or (logically) below the maximum
1045:../Generated_Code/queue.c ****         system call     interrupt priority.  FreeRTOS maintains a separate interrupt
1046:../Generated_Code/queue.c ****         safe API to ensure interrupt entry is as fast and as simple as possible.
1047:../Generated_Code/queue.c ****         More information (albeit Cortex-M specific) is provided on the following
1048:../Generated_Code/queue.c ****         link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1049:../Generated_Code/queue.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1050:../Generated_Code/queue.c **** 
1051:../Generated_Code/queue.c ****         /* Similar to xQueueGenericSend, except without blocking if there is no room
1052:../Generated_Code/queue.c ****         in the queue.  Also don't directly wake a task that was blocked on a queue
1053:../Generated_Code/queue.c ****         read, instead return a flag to say whether a context switch is required or
1054:../Generated_Code/queue.c ****         not (i.e. has a task with a higher priority than us been woken by this
1055:../Generated_Code/queue.c ****         post). */
1056:../Generated_Code/queue.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1093              		.loc 1 1056 0 is_stmt 1
 1094 0040 0023     		mov	r3, #0
 1095 0042 7B61     		str	r3, [r7, #20]
 1096              	@ 1056 "../Generated_Code/queue.c" 1
 1097 0044 72B6     		cpsid i
 1098              	@ 0 "" 2
1057:../Generated_Code/queue.c ****         {
1058:../Generated_Code/queue.c ****                 if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueO
 1099              		.loc 1 1058 0
 1100              		.code	16
 1101 0046 BB69     		ldr	r3, [r7, #24]
 1102 0048 9A6B     		ldr	r2, [r3, #56]
 1103 004a BB69     		ldr	r3, [r7, #24]
 1104 004c DB6B     		ldr	r3, [r3, #60]
 1105 004e 9A42     		cmp	r2, r3
 1106 0050 02D3     		bcc	.L77
 1107              		.loc 1 1058 0 is_stmt 0
 1108 0052 3B68     		ldr	r3, [r7]
 1109 0054 022B     		cmp	r3, #2
 1110 0056 01D1     		bne	.L78
 1111              	.L77:
 1112              		.loc 1 1058 0
 1113 0058 0123     		mov	r3, #1
 1114 005a 00E0     		b	.L79
 1115              	.L78:
 1116              		.loc 1 1058 0
 1117 005c 0023     		mov	r3, #0
 1118              	.L79:
 1119              		.loc 1 1058 0
 1120 005e 002B     		cmp	r3, #0
 1121 0060 2DD0     		beq	.L80
1059:../Generated_Code/queue.c ****                 {
1060:../Generated_Code/queue.c ****                         traceQUEUE_SEND_FROM_ISR( pxQueue );
1061:../Generated_Code/queue.c **** 
1062:../Generated_Code/queue.c ****                         prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1122              		.loc 1 1062 0 is_stmt 1
 1123 0062 B969     		ldr	r1, [r7, #24]
 1124 0064 BA68     		ldr	r2, [r7, #8]
 1125 0066 3B68     		ldr	r3, [r7]
 1126 0068 081C     		mov	r0, r1
 1127 006a 111C     		mov	r1, r2
 1128 006c 1A1C     		mov	r2, r3
 1129 006e FFF7FEFF 		bl	_ZL18prvCopyDataToQueueP15QueueDefinitionPKvl
1063:../Generated_Code/queue.c **** 
1064:../Generated_Code/queue.c ****                         /* The event list is not altered if the queue is locked.  This will
1065:../Generated_Code/queue.c ****                         be done when the queue is unlocked later. */
1066:../Generated_Code/queue.c ****                         if( pxQueue->xTxLock == queueUNLOCKED )
 1130              		.loc 1 1066 0
 1131 0072 BB69     		ldr	r3, [r7, #24]
 1132 0074 9B6C     		ldr	r3, [r3, #72]
 1133 0076 0133     		add	r3, r3, #1
 1134 0078 5A42     		neg	r2, r3
 1135 007a 5341     		adc	r3, r3, r2
 1136 007c DBB2     		uxtb	r3, r3
 1137 007e 002B     		cmp	r3, #0
 1138 0080 15D0     		beq	.L81
1067:../Generated_Code/queue.c ****                         {
1068:../Generated_Code/queue.c ****                                 #if ( configUSE_QUEUE_SETS == 1 )
1069:../Generated_Code/queue.c ****                                 {
1070:../Generated_Code/queue.c ****                                         if( pxQueue->pxQueueSetContainer != NULL )
1071:../Generated_Code/queue.c ****                                         {
1072:../Generated_Code/queue.c ****                                                 if( prvNotifyQueueSetContainer( pxQueue, xCopyPosit
1073:../Generated_Code/queue.c ****                                                 {
1074:../Generated_Code/queue.c ****                                                         /* The queue is a member of a queue set, an
1075:../Generated_Code/queue.c ****                                                         to the queue set caused a higher priority t
1076:../Generated_Code/queue.c ****                                                         unblock.  A context switch is required. */
1077:../Generated_Code/queue.c ****                                                         if( pxHigherPriorityTaskWoken != NULL )
1078:../Generated_Code/queue.c ****                                                         {
1079:../Generated_Code/queue.c ****                                                                 *pxHigherPriorityTaskWoken = pdTRUE
1080:../Generated_Code/queue.c ****                                                         }
1081:../Generated_Code/queue.c ****                                                         else
1082:../Generated_Code/queue.c ****                                                         {
1083:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
1084:../Generated_Code/queue.c ****                                                         }
1085:../Generated_Code/queue.c ****                                                 }
1086:../Generated_Code/queue.c ****                                                 else
1087:../Generated_Code/queue.c ****                                                 {
1088:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1089:../Generated_Code/queue.c ****                                                 }
1090:../Generated_Code/queue.c ****                                         }
1091:../Generated_Code/queue.c ****                                         else
1092:../Generated_Code/queue.c ****                                         {
1093:../Generated_Code/queue.c ****                                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToR
1094:../Generated_Code/queue.c ****                                                 {
1095:../Generated_Code/queue.c ****                                                         if( xTaskRemoveFromEventList( &( pxQueue->x
1096:../Generated_Code/queue.c ****                                                         {
1097:../Generated_Code/queue.c ****                                                                 /* The task waiting has a higher pr
1098:../Generated_Code/queue.c ****                                                                 context switch is required. */
1099:../Generated_Code/queue.c ****                                                                 if( pxHigherPriorityTaskWoken != NU
1100:../Generated_Code/queue.c ****                                                                 {
1101:../Generated_Code/queue.c ****                                                                         *pxHigherPriorityTaskWoken 
1102:../Generated_Code/queue.c ****                                                                 }
1103:../Generated_Code/queue.c ****                                                                 else
1104:../Generated_Code/queue.c ****                                                                 {
1105:../Generated_Code/queue.c ****                                                                         mtCOVERAGE_TEST_MARKER();
1106:../Generated_Code/queue.c ****                                                                 }
1107:../Generated_Code/queue.c ****                                                         }
1108:../Generated_Code/queue.c ****                                                         else
1109:../Generated_Code/queue.c ****                                                         {
1110:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
1111:../Generated_Code/queue.c ****                                                         }
1112:../Generated_Code/queue.c ****                                                 }
1113:../Generated_Code/queue.c ****                                                 else
1114:../Generated_Code/queue.c ****                                                 {
1115:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1116:../Generated_Code/queue.c ****                                                 }
1117:../Generated_Code/queue.c ****                                         }
1118:../Generated_Code/queue.c ****                                 }
1119:../Generated_Code/queue.c ****                                 #else /* configUSE_QUEUE_SETS */
1120:../Generated_Code/queue.c ****                                 {
1121:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive )
 1139              		.loc 1 1121 0
 1140 0082 BB69     		ldr	r3, [r7, #24]
 1141 0084 5B6A     		ldr	r3, [r3, #36]
 1142 0086 002B     		cmp	r3, #0
 1143 0088 16D0     		beq	.L82
1122:../Generated_Code/queue.c ****                                         {
1123:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
 1144              		.loc 1 1123 0
 1145 008a BB69     		ldr	r3, [r7, #24]
 1146 008c 2433     		add	r3, r3, #36
 1147 008e 181C     		mov	r0, r3
 1148 0090 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1149 0094 031C     		mov	r3, r0
 1150 0096 5A1E     		sub	r2, r3, #1
 1151 0098 9341     		sbc	r3, r3, r2
 1152 009a DBB2     		uxtb	r3, r3
 1153 009c 002B     		cmp	r3, #0
 1154 009e 0BD0     		beq	.L82
1124:../Generated_Code/queue.c ****                                                 {
1125:../Generated_Code/queue.c ****                                                         /* The task waiting has a higher priority s
1126:../Generated_Code/queue.c ****                                                         context switch is required. */
1127:../Generated_Code/queue.c ****                                                         if( pxHigherPriorityTaskWoken != NULL )
 1155              		.loc 1 1127 0
 1156 00a0 7B68     		ldr	r3, [r7, #4]
 1157 00a2 002B     		cmp	r3, #0
 1158 00a4 08D0     		beq	.L82
1128:../Generated_Code/queue.c ****                                                         {
1129:../Generated_Code/queue.c ****                                                                 *pxHigherPriorityTaskWoken = pdTRUE
 1159              		.loc 1 1129 0
 1160 00a6 7B68     		ldr	r3, [r7, #4]
 1161 00a8 0122     		mov	r2, #1
 1162 00aa 1A60     		str	r2, [r3]
 1163 00ac 04E0     		b	.L82
 1164              	.L81:
1130:../Generated_Code/queue.c ****                                                         }
1131:../Generated_Code/queue.c ****                                                         else
1132:../Generated_Code/queue.c ****                                                         {
1133:../Generated_Code/queue.c ****                                                                 mtCOVERAGE_TEST_MARKER();
1134:../Generated_Code/queue.c ****                                                         }
1135:../Generated_Code/queue.c ****                                                 }
1136:../Generated_Code/queue.c ****                                                 else
1137:../Generated_Code/queue.c ****                                                 {
1138:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1139:../Generated_Code/queue.c ****                                                 }
1140:../Generated_Code/queue.c ****                                         }
1141:../Generated_Code/queue.c ****                                         else
1142:../Generated_Code/queue.c ****                                         {
1143:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1144:../Generated_Code/queue.c ****                                         }
1145:../Generated_Code/queue.c ****                                 }
1146:../Generated_Code/queue.c ****                                 #endif /* configUSE_QUEUE_SETS */
1147:../Generated_Code/queue.c ****                         }
1148:../Generated_Code/queue.c ****                         else
1149:../Generated_Code/queue.c ****                         {
1150:../Generated_Code/queue.c ****                                 /* Increment the lock count so the task that unlocks the queue
1151:../Generated_Code/queue.c ****                                 knows that data was posted while it was locked. */
1152:../Generated_Code/queue.c ****                                 ++( pxQueue->xTxLock );
 1165              		.loc 1 1152 0
 1166 00ae BB69     		ldr	r3, [r7, #24]
 1167 00b0 9B6C     		ldr	r3, [r3, #72]
 1168 00b2 5A1C     		add	r2, r3, #1
 1169 00b4 BB69     		ldr	r3, [r7, #24]
 1170 00b6 9A64     		str	r2, [r3, #72]
 1171              	.L82:
1153:../Generated_Code/queue.c ****                         }
1154:../Generated_Code/queue.c **** 
1155:../Generated_Code/queue.c ****                         xReturn = pdPASS;
 1172              		.loc 1 1155 0
 1173 00b8 0123     		mov	r3, #1
 1174 00ba FB61     		str	r3, [r7, #28]
 1175 00bc 01E0     		b	.L83
 1176              	.L80:
1156:../Generated_Code/queue.c ****                 }
1157:../Generated_Code/queue.c ****                 else
1158:../Generated_Code/queue.c ****                 {
1159:../Generated_Code/queue.c ****                         traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1160:../Generated_Code/queue.c ****                         xReturn = errQUEUE_FULL;
 1177              		.loc 1 1160 0
 1178 00be 0023     		mov	r3, #0
 1179 00c0 FB61     		str	r3, [r7, #28]
 1180              	.L83:
1161:../Generated_Code/queue.c ****                 }
1162:../Generated_Code/queue.c ****         }
1163:../Generated_Code/queue.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1181              		.loc 1 1163 0
 1182              	@ 1163 "../Generated_Code/queue.c" 1
 1183 00c2 62B6     		cpsie i
 1184              	@ 0 "" 2
1164:../Generated_Code/queue.c **** 
1165:../Generated_Code/queue.c ****         return xReturn;
 1185              		.loc 1 1165 0
 1186              		.code	16
 1187 00c4 FB69     		ldr	r3, [r7, #28]
 1188              	.LBE10:
1166:../Generated_Code/queue.c **** }
 1189              		.loc 1 1166 0
 1190 00c6 181C     		mov	r0, r3
 1191 00c8 BD46     		mov	sp, r7
 1192 00ca 08B0     		add	sp, sp, #32
 1193              		@ sp needed for prologue
 1194 00cc 80BD     		pop	{r7, pc}
 1195              		.cfi_endproc
 1196              	.LFE17:
 1198 00ce C046     		.section	.text.xQueueGenericReceive,"ax",%progbits
 1199              		.align	2
 1200              		.global	xQueueGenericReceive
 1201              		.code	16
 1202              		.thumb_func
 1204              	xQueueGenericReceive:
 1205              	.LFB18:
1167:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1168:../Generated_Code/queue.c **** 
1169:../Generated_Code/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1170:../Generated_Code/queue.c **** {
 1206              		.loc 1 1170 0
 1207              		.cfi_startproc
 1208 0000 80B5     		push	{r7, lr}
 1209              	.LCFI27:
 1210              		.cfi_def_cfa_offset 8
 1211              		.cfi_offset 7, -8
 1212              		.cfi_offset 14, -4
 1213 0002 8AB0     		sub	sp, sp, #40
 1214              	.LCFI28:
 1215              		.cfi_def_cfa_offset 48
 1216 0004 00AF     		add	r7, sp, #0
 1217              	.LCFI29:
 1218              		.cfi_def_cfa_register 7
 1219 0006 F860     		str	r0, [r7, #12]
 1220 0008 B960     		str	r1, [r7, #8]
 1221 000a 7A60     		str	r2, [r7, #4]
 1222 000c 3B60     		str	r3, [r7]
 1223              	.LBB11:
1171:../Generated_Code/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1224              		.loc 1 1171 0
 1225 000e 0023     		mov	r3, #0
 1226 0010 7B62     		str	r3, [r7, #36]
1172:../Generated_Code/queue.c **** TimeOut_t xTimeOut;
1173:../Generated_Code/queue.c **** int8_t *pcOriginalReadPosition;
1174:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1227              		.loc 1 1174 0
 1228 0012 FB68     		ldr	r3, [r7, #12]
 1229 0014 3B62     		str	r3, [r7, #32]
1175:../Generated_Code/queue.c **** 
1176:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1230              		.loc 1 1176 0
 1231 0016 3B6A     		ldr	r3, [r7, #32]
 1232 0018 002B     		cmp	r3, #0
 1233 001a 01D1     		bne	.L86
 1234              		.loc 1 1176 0 is_stmt 0
 1235              	@ 1176 "../Generated_Code/queue.c" 1
 1236 001c 72B6     		cpsid i
 1237              	@ 0 "" 2
 1238              		.code	16
 1239              	.L87:
 1240              		.loc 1 1176 0
 1241 001e FEE7     		b	.L87
 1242              	.L86:
1177:../Generated_Code/queue.c ****         configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1243              		.loc 1 1177 0 is_stmt 1
 1244 0020 BB68     		ldr	r3, [r7, #8]
 1245 0022 002B     		cmp	r3, #0
 1246 0024 05D1     		bne	.L88
 1247              		.loc 1 1177 0 is_stmt 0
 1248 0026 3B6A     		ldr	r3, [r7, #32]
 1249 0028 1B6C     		ldr	r3, [r3, #64]
 1250 002a 002B     		cmp	r3, #0
 1251 002c 01D0     		beq	.L88
 1252              		.loc 1 1177 0
 1253              	@ 1177 "../Generated_Code/queue.c" 1
 1254 002e 72B6     		cpsid i
 1255              	@ 0 "" 2
 1256              		.code	16
 1257              	.L89:
 1258              		.loc 1 1177 0
 1259 0030 FEE7     		b	.L89
 1260              	.L88:
1178:../Generated_Code/queue.c ****         #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1179:../Generated_Code/queue.c ****         {
1180:../Generated_Code/queue.c ****                 configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTick
 1261              		.loc 1 1180 0 is_stmt 1
 1262 0032 FFF7FEFF 		bl	xTaskGetSchedulerState
 1263 0036 031C     		mov	r3, r0
 1264 0038 002B     		cmp	r3, #0
 1265 003a 04D1     		bne	.L90
 1266              		.loc 1 1180 0 is_stmt 0
 1267 003c 7B68     		ldr	r3, [r7, #4]
 1268 003e 002B     		cmp	r3, #0
 1269 0040 01D0     		beq	.L90
 1270              		.loc 1 1180 0
 1271 0042 0123     		mov	r3, #1
 1272 0044 00E0     		b	.L91
 1273              	.L90:
 1274              		.loc 1 1180 0
 1275 0046 0023     		mov	r3, #0
 1276              	.L91:
 1277              		.loc 1 1180 0
 1278 0048 002B     		cmp	r3, #0
 1279 004a 02D0     		beq	.L92
 1280              		.loc 1 1180 0
 1281              	@ 1180 "../Generated_Code/queue.c" 1
 1282 004c 72B6     		cpsid i
 1283              	@ 0 "" 2
 1284              		.code	16
 1285              	.L93:
 1286              		.loc 1 1180 0
 1287 004e FEE7     		b	.L93
 1288              	.L108:
1181:../Generated_Code/queue.c ****         }
1182:../Generated_Code/queue.c ****         #endif
1183:../Generated_Code/queue.c **** 
1184:../Generated_Code/queue.c ****         /* This function relaxes the coding standard somewhat to allow return
1185:../Generated_Code/queue.c ****         statements within the function itself.  This is done in the interest
1186:../Generated_Code/queue.c ****         of execution time efficiency. */
1187:../Generated_Code/queue.c **** 
1188:../Generated_Code/queue.c ****         for( ;; )
 1289              		.loc 1 1188 0 is_stmt 1
 1290 0050 C046     		mov	r8, r8
 1291              	.L92:
1189:../Generated_Code/queue.c ****         {
1190:../Generated_Code/queue.c ****                 taskENTER_CRITICAL();
 1292              		.loc 1 1190 0
 1293 0052 FFF7FEFF 		bl	vPortEnterCritical
1191:../Generated_Code/queue.c ****                 {
1192:../Generated_Code/queue.c ****                         /* Is there data in the queue now?  To be running we must be
1193:../Generated_Code/queue.c ****                         the highest priority task wanting to access the queue. */
1194:../Generated_Code/queue.c ****                         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1294              		.loc 1 1194 0
 1295 0056 3B6A     		ldr	r3, [r7, #32]
 1296 0058 9B6B     		ldr	r3, [r3, #56]
 1297 005a 5A1E     		sub	r2, r3, #1
 1298 005c 9341     		sbc	r3, r3, r2
 1299 005e DBB2     		uxtb	r3, r3
 1300 0060 002B     		cmp	r3, #0
 1301 0062 44D0     		beq	.L94
1195:../Generated_Code/queue.c ****                         {
1196:../Generated_Code/queue.c ****                                 /* Remember the read position in case the queue is only being
1197:../Generated_Code/queue.c ****                                 peeked. */
1198:../Generated_Code/queue.c ****                                 pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1302              		.loc 1 1198 0
 1303 0064 3B6A     		ldr	r3, [r7, #32]
 1304 0066 DB68     		ldr	r3, [r3, #12]
 1305 0068 FB61     		str	r3, [r7, #28]
1199:../Generated_Code/queue.c **** 
1200:../Generated_Code/queue.c ****                                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 1306              		.loc 1 1200 0
 1307 006a 3A6A     		ldr	r2, [r7, #32]
 1308 006c BB68     		ldr	r3, [r7, #8]
 1309 006e 101C     		mov	r0, r2
 1310 0070 191C     		mov	r1, r3
 1311 0072 FFF7FEFF 		bl	_ZL20prvCopyDataFromQueueP15QueueDefinitionPv
1201:../Generated_Code/queue.c **** 
1202:../Generated_Code/queue.c ****                                 if( xJustPeeking == pdFALSE )
 1312              		.loc 1 1202 0
 1313 0076 3B68     		ldr	r3, [r7]
 1314 0078 002B     		cmp	r3, #0
 1315 007a 20D1     		bne	.L95
1203:../Generated_Code/queue.c ****                                 {
1204:../Generated_Code/queue.c ****                                         traceQUEUE_RECEIVE( pxQueue );
1205:../Generated_Code/queue.c **** 
1206:../Generated_Code/queue.c ****                                         /* Actually removing data, not just peeking. */
1207:../Generated_Code/queue.c ****                                         --( pxQueue->uxMessagesWaiting );
 1316              		.loc 1 1207 0
 1317 007c 3B6A     		ldr	r3, [r7, #32]
 1318 007e 9B6B     		ldr	r3, [r3, #56]
 1319 0080 5A1E     		sub	r2, r3, #1
 1320 0082 3B6A     		ldr	r3, [r7, #32]
 1321 0084 9A63     		str	r2, [r3, #56]
1208:../Generated_Code/queue.c **** 
1209:../Generated_Code/queue.c ****                                         #if ( configUSE_MUTEXES == 1 )
1210:../Generated_Code/queue.c ****                                         {
1211:../Generated_Code/queue.c ****                                                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1322              		.loc 1 1211 0
 1323 0086 3B6A     		ldr	r3, [r7, #32]
 1324 0088 1B68     		ldr	r3, [r3]
 1325 008a 002B     		cmp	r3, #0
 1326 008c 04D1     		bne	.L96
1212:../Generated_Code/queue.c ****                                                 {
1213:../Generated_Code/queue.c ****                                                         /* Record the information required to imple
1214:../Generated_Code/queue.c ****                                                         priority inheritance should it become neces
1215:../Generated_Code/queue.c ****                                                         pxQueue->pxMutexHolder = ( int8_t * ) xTask
 1327              		.loc 1 1215 0
 1328 008e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1329 0092 021C     		mov	r2, r0
 1330 0094 3B6A     		ldr	r3, [r7, #32]
 1331 0096 5A60     		str	r2, [r3, #4]
 1332              	.L96:
1216:../Generated_Code/queue.c ****                                                 }
1217:../Generated_Code/queue.c ****                                                 else
1218:../Generated_Code/queue.c ****                                                 {
1219:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1220:../Generated_Code/queue.c ****                                                 }
1221:../Generated_Code/queue.c ****                                         }
1222:../Generated_Code/queue.c ****                                         #endif
1223:../Generated_Code/queue.c **** 
1224:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) 
 1333              		.loc 1 1224 0
 1334 0098 3B6A     		ldr	r3, [r7, #32]
 1335 009a 1B69     		ldr	r3, [r3, #16]
 1336 009c 002B     		cmp	r3, #0
 1337 009e 22D0     		beq	.L97
1225:../Generated_Code/queue.c ****                                         {
1226:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
 1338              		.loc 1 1226 0
 1339 00a0 3B6A     		ldr	r3, [r7, #32]
 1340 00a2 1033     		add	r3, r3, #16
 1341 00a4 181C     		mov	r0, r3
 1342 00a6 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1343 00aa 031C     		mov	r3, r0
 1344 00ac 013B     		sub	r3, r3, #1
 1345 00ae 5A42     		neg	r2, r3
 1346 00b0 5341     		adc	r3, r3, r2
 1347 00b2 DBB2     		uxtb	r3, r3
 1348 00b4 002B     		cmp	r3, #0
 1349 00b6 16D0     		beq	.L97
1227:../Generated_Code/queue.c ****                                                 {
1228:../Generated_Code/queue.c ****                                                         queueYIELD_IF_USING_PREEMPTION();
 1350              		.loc 1 1228 0
 1351 00b8 FFF7FEFF 		bl	vPortYieldFromISR
 1352 00bc 13E0     		b	.L97
 1353              	.L95:
1229:../Generated_Code/queue.c ****                                                 }
1230:../Generated_Code/queue.c ****                                                 else
1231:../Generated_Code/queue.c ****                                                 {
1232:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1233:../Generated_Code/queue.c ****                                                 }
1234:../Generated_Code/queue.c ****                                         }
1235:../Generated_Code/queue.c ****                                         else
1236:../Generated_Code/queue.c ****                                         {
1237:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1238:../Generated_Code/queue.c ****                                         }
1239:../Generated_Code/queue.c ****                                 }
1240:../Generated_Code/queue.c ****                                 else
1241:../Generated_Code/queue.c ****                                 {
1242:../Generated_Code/queue.c ****                                         traceQUEUE_PEEK( pxQueue );
1243:../Generated_Code/queue.c **** 
1244:../Generated_Code/queue.c ****                                         /* The data is not being removed, so reset the read
1245:../Generated_Code/queue.c ****                                         pointer. */
1246:../Generated_Code/queue.c ****                                         pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1354              		.loc 1 1246 0
 1355 00be 3B6A     		ldr	r3, [r7, #32]
 1356 00c0 FA69     		ldr	r2, [r7, #28]
 1357 00c2 DA60     		str	r2, [r3, #12]
1247:../Generated_Code/queue.c **** 
1248:../Generated_Code/queue.c ****                                         /* The data is being left in the queue, so see if there are
1249:../Generated_Code/queue.c ****                                         any other tasks waiting for the data. */
1250:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive )
 1358              		.loc 1 1250 0
 1359 00c4 3B6A     		ldr	r3, [r7, #32]
 1360 00c6 5B6A     		ldr	r3, [r3, #36]
 1361 00c8 002B     		cmp	r3, #0
 1362 00ca 0CD0     		beq	.L97
1251:../Generated_Code/queue.c ****                                         {
1252:../Generated_Code/queue.c ****                                                 /* Tasks that are removed from the event list will 
1253:../Generated_Code/queue.c ****                                                 the pending ready list as the scheduler is still su
1254:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
 1363              		.loc 1 1254 0
 1364 00cc 3B6A     		ldr	r3, [r7, #32]
 1365 00ce 2433     		add	r3, r3, #36
 1366 00d0 181C     		mov	r0, r3
 1367 00d2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1368 00d6 031C     		mov	r3, r0
 1369 00d8 5A1E     		sub	r2, r3, #1
 1370 00da 9341     		sbc	r3, r3, r2
 1371 00dc DBB2     		uxtb	r3, r3
 1372 00de 002B     		cmp	r3, #0
 1373 00e0 01D0     		beq	.L97
1255:../Generated_Code/queue.c ****                                                 {
1256:../Generated_Code/queue.c ****                                                         /* The task waiting has a higher priority t
1257:../Generated_Code/queue.c ****                                                         queueYIELD_IF_USING_PREEMPTION();
 1374              		.loc 1 1257 0
 1375 00e2 FFF7FEFF 		bl	vPortYieldFromISR
 1376              	.L97:
1258:../Generated_Code/queue.c ****                                                 }
1259:../Generated_Code/queue.c ****                                                 else
1260:../Generated_Code/queue.c ****                                                 {
1261:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1262:../Generated_Code/queue.c ****                                                 }
1263:../Generated_Code/queue.c ****                                         }
1264:../Generated_Code/queue.c ****                                         else
1265:../Generated_Code/queue.c ****                                         {
1266:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1267:../Generated_Code/queue.c ****                                         }
1268:../Generated_Code/queue.c ****                                 }
1269:../Generated_Code/queue.c **** 
1270:../Generated_Code/queue.c ****                                 taskEXIT_CRITICAL();
 1377              		.loc 1 1270 0
 1378 00e6 FFF7FEFF 		bl	vPortExitCritical
1271:../Generated_Code/queue.c ****                                 return pdPASS;
 1379              		.loc 1 1271 0
 1380 00ea 0123     		mov	r3, #1
 1381 00ec 78E0     		b	.L107
 1382              	.L94:
1272:../Generated_Code/queue.c ****                         }
1273:../Generated_Code/queue.c ****                         else
1274:../Generated_Code/queue.c ****                         {
1275:../Generated_Code/queue.c ****                                 if( xTicksToWait == ( TickType_t ) 0 )
 1383              		.loc 1 1275 0
 1384 00ee 7B68     		ldr	r3, [r7, #4]
 1385 00f0 002B     		cmp	r3, #0
 1386 00f2 03D1     		bne	.L99
1276:../Generated_Code/queue.c ****                                 {
1277:../Generated_Code/queue.c ****                                         /* The queue was empty and no block time is specified (or
1278:../Generated_Code/queue.c ****                                         the block time has expired) so leave now. */
1279:../Generated_Code/queue.c ****                                         taskEXIT_CRITICAL();
 1387              		.loc 1 1279 0
 1388 00f4 FFF7FEFF 		bl	vPortExitCritical
1280:../Generated_Code/queue.c ****                                         traceQUEUE_RECEIVE_FAILED( pxQueue );
1281:../Generated_Code/queue.c ****                                         return errQUEUE_EMPTY;
 1389              		.loc 1 1281 0
 1390 00f8 0023     		mov	r3, #0
 1391 00fa 71E0     		b	.L107
 1392              	.L99:
1282:../Generated_Code/queue.c ****                                 }
1283:../Generated_Code/queue.c ****                                 else if( xEntryTimeSet == pdFALSE )
 1393              		.loc 1 1283 0
 1394 00fc 7B6A     		ldr	r3, [r7, #36]
 1395 00fe 002B     		cmp	r3, #0
 1396 0100 06D1     		bne	.L100
1284:../Generated_Code/queue.c ****                                 {
1285:../Generated_Code/queue.c ****                                         /* The queue was empty and a block time was specified so
1286:../Generated_Code/queue.c ****                                         configure the timeout structure. */
1287:../Generated_Code/queue.c ****                                         vTaskSetTimeOutState( &xTimeOut );
 1397              		.loc 1 1287 0
 1398 0102 3B1C     		mov	r3, r7
 1399 0104 1433     		add	r3, r3, #20
 1400 0106 181C     		mov	r0, r3
 1401 0108 FFF7FEFF 		bl	vTaskSetTimeOutState
1288:../Generated_Code/queue.c ****                                         xEntryTimeSet = pdTRUE;
 1402              		.loc 1 1288 0
 1403 010c 0123     		mov	r3, #1
 1404 010e 7B62     		str	r3, [r7, #36]
 1405              	.L100:
1289:../Generated_Code/queue.c ****                                 }
1290:../Generated_Code/queue.c ****                                 else
1291:../Generated_Code/queue.c ****                                 {
1292:../Generated_Code/queue.c ****                                         /* Entry time was already set. */
1293:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1294:../Generated_Code/queue.c ****                                 }
1295:../Generated_Code/queue.c ****                         }
1296:../Generated_Code/queue.c ****                 }
1297:../Generated_Code/queue.c ****                 taskEXIT_CRITICAL();
 1406              		.loc 1 1297 0
 1407 0110 FFF7FEFF 		bl	vPortExitCritical
1298:../Generated_Code/queue.c **** 
1299:../Generated_Code/queue.c ****                 /* Interrupts and other tasks can send to and receive from the queue
1300:../Generated_Code/queue.c ****                 now the critical section has been exited. */
1301:../Generated_Code/queue.c **** 
1302:../Generated_Code/queue.c ****                 vTaskSuspendAll();
 1408              		.loc 1 1302 0
 1409 0114 FFF7FEFF 		bl	vTaskSuspendAll
1303:../Generated_Code/queue.c ****                 prvLockQueue( pxQueue );
 1410              		.loc 1 1303 0
 1411 0118 FFF7FEFF 		bl	vPortEnterCritical
 1412 011c 3B6A     		ldr	r3, [r7, #32]
 1413 011e 5B6C     		ldr	r3, [r3, #68]
 1414 0120 0133     		add	r3, r3, #1
 1415 0122 5A42     		neg	r2, r3
 1416 0124 5341     		adc	r3, r3, r2
 1417 0126 DBB2     		uxtb	r3, r3
 1418 0128 002B     		cmp	r3, #0
 1419 012a 02D0     		beq	.L101
 1420              		.loc 1 1303 0 is_stmt 0
 1421 012c 3B6A     		ldr	r3, [r7, #32]
 1422 012e 0022     		mov	r2, #0
 1423 0130 5A64     		str	r2, [r3, #68]
 1424              	.L101:
 1425              		.loc 1 1303 0
 1426 0132 3B6A     		ldr	r3, [r7, #32]
 1427 0134 9B6C     		ldr	r3, [r3, #72]
 1428 0136 0133     		add	r3, r3, #1
 1429 0138 5A42     		neg	r2, r3
 1430 013a 5341     		adc	r3, r3, r2
 1431 013c DBB2     		uxtb	r3, r3
 1432 013e 002B     		cmp	r3, #0
 1433 0140 02D0     		beq	.L102
 1434              		.loc 1 1303 0
 1435 0142 3B6A     		ldr	r3, [r7, #32]
 1436 0144 0022     		mov	r2, #0
 1437 0146 9A64     		str	r2, [r3, #72]
 1438              	.L102:
 1439              		.loc 1 1303 0
 1440 0148 FFF7FEFF 		bl	vPortExitCritical
1304:../Generated_Code/queue.c **** 
1305:../Generated_Code/queue.c ****                 /* Update the timeout state to see if it has expired yet. */
1306:../Generated_Code/queue.c ****                 if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1441              		.loc 1 1306 0 is_stmt 1
 1442 014c 3A1C     		mov	r2, r7
 1443 014e 1432     		add	r2, r2, #20
 1444 0150 3B1D     		add	r3, r7, #4
 1445 0152 101C     		mov	r0, r2
 1446 0154 191C     		mov	r1, r3
 1447 0156 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1448 015a 031C     		mov	r3, r0
 1449 015c 5A42     		neg	r2, r3
 1450 015e 5341     		adc	r3, r3, r2
 1451 0160 DBB2     		uxtb	r3, r3
 1452 0162 002B     		cmp	r3, #0
 1453 0164 35D0     		beq	.L103
1307:../Generated_Code/queue.c ****                 {
1308:../Generated_Code/queue.c ****                         if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1454              		.loc 1 1308 0
 1455 0166 3B6A     		ldr	r3, [r7, #32]
 1456 0168 181C     		mov	r0, r3
 1457 016a FFF7FEFF 		bl	_ZL15prvIsQueueEmptyPK15QueueDefinition
 1458 016e 031C     		mov	r3, r0
 1459 0170 5A1E     		sub	r2, r3, #1
 1460 0172 9341     		sbc	r3, r3, r2
 1461 0174 DBB2     		uxtb	r3, r3
 1462 0176 002B     		cmp	r3, #0
 1463 0178 24D0     		beq	.L104
1309:../Generated_Code/queue.c ****                         {
1310:../Generated_Code/queue.c ****                                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1311:../Generated_Code/queue.c **** 
1312:../Generated_Code/queue.c ****                                 #if ( configUSE_MUTEXES == 1 )
1313:../Generated_Code/queue.c ****                                 {
1314:../Generated_Code/queue.c ****                                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1464              		.loc 1 1314 0
 1465 017a 3B6A     		ldr	r3, [r7, #32]
 1466 017c 1B68     		ldr	r3, [r3]
 1467 017e 002B     		cmp	r3, #0
 1468 0180 08D1     		bne	.L105
1315:../Generated_Code/queue.c ****                                         {
1316:../Generated_Code/queue.c ****                                                 taskENTER_CRITICAL();
 1469              		.loc 1 1316 0
 1470 0182 FFF7FEFF 		bl	vPortEnterCritical
1317:../Generated_Code/queue.c ****                                                 {
1318:../Generated_Code/queue.c ****                                                         vTaskPriorityInherit( ( void * ) pxQueue->p
 1471              		.loc 1 1318 0
 1472 0186 3B6A     		ldr	r3, [r7, #32]
 1473 0188 5B68     		ldr	r3, [r3, #4]
 1474 018a 181C     		mov	r0, r3
 1475 018c FFF7FEFF 		bl	vTaskPriorityInherit
1319:../Generated_Code/queue.c ****                                                 }
1320:../Generated_Code/queue.c ****                                                 taskEXIT_CRITICAL();
 1476              		.loc 1 1320 0
 1477 0190 FFF7FEFF 		bl	vPortExitCritical
 1478              	.L105:
1321:../Generated_Code/queue.c ****                                         }
1322:../Generated_Code/queue.c ****                                         else
1323:../Generated_Code/queue.c ****                                         {
1324:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1325:../Generated_Code/queue.c ****                                         }
1326:../Generated_Code/queue.c ****                                 }
1327:../Generated_Code/queue.c ****                                 #endif
1328:../Generated_Code/queue.c **** 
1329:../Generated_Code/queue.c ****                                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicks
 1479              		.loc 1 1329 0
 1480 0194 3B6A     		ldr	r3, [r7, #32]
 1481 0196 1A1C     		mov	r2, r3
 1482 0198 2432     		add	r2, r2, #36
 1483 019a 7B68     		ldr	r3, [r7, #4]
 1484 019c 101C     		mov	r0, r2
 1485 019e 191C     		mov	r1, r3
 1486 01a0 FFF7FEFF 		bl	vTaskPlaceOnEventList
1330:../Generated_Code/queue.c ****                                 prvUnlockQueue( pxQueue );
 1487              		.loc 1 1330 0
 1488 01a4 3B6A     		ldr	r3, [r7, #32]
 1489 01a6 181C     		mov	r0, r3
 1490 01a8 FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
1331:../Generated_Code/queue.c ****                                 if( xTaskResumeAll() == pdFALSE )
 1491              		.loc 1 1331 0
 1492 01ac FFF7FEFF 		bl	xTaskResumeAll
 1493 01b0 031C     		mov	r3, r0
 1494 01b2 5A42     		neg	r2, r3
 1495 01b4 5341     		adc	r3, r3, r2
 1496 01b6 DBB2     		uxtb	r3, r3
 1497 01b8 002B     		cmp	r3, #0
 1498 01ba 00D1     		bne	.LCB1238
 1499 01bc 48E7     		b	.L108	@long jump
 1500              	.LCB1238:
1332:../Generated_Code/queue.c ****                                 {
1333:../Generated_Code/queue.c ****                                         portYIELD_WITHIN_API();
 1501              		.loc 1 1333 0
 1502 01be FFF7FEFF 		bl	vPortYieldFromISR
1188:../Generated_Code/queue.c ****         for( ;; )
 1503              		.loc 1 1188 0
 1504 01c2 45E7     		b	.L108
 1505              	.L104:
1334:../Generated_Code/queue.c ****                                 }
1335:../Generated_Code/queue.c ****                                 else
1336:../Generated_Code/queue.c ****                                 {
1337:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1338:../Generated_Code/queue.c ****                                 }
1339:../Generated_Code/queue.c ****                         }
1340:../Generated_Code/queue.c ****                         else
1341:../Generated_Code/queue.c ****                         {
1342:../Generated_Code/queue.c ****                                 /* Try again. */
1343:../Generated_Code/queue.c ****                                 prvUnlockQueue( pxQueue );
 1506              		.loc 1 1343 0
 1507 01c4 3B6A     		ldr	r3, [r7, #32]
 1508 01c6 181C     		mov	r0, r3
 1509 01c8 FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
1344:../Generated_Code/queue.c ****                                 ( void ) xTaskResumeAll();
 1510              		.loc 1 1344 0
 1511 01cc FFF7FEFF 		bl	xTaskResumeAll
1188:../Generated_Code/queue.c ****         for( ;; )
 1512              		.loc 1 1188 0
 1513 01d0 3EE7     		b	.L108
 1514              	.L103:
1345:../Generated_Code/queue.c ****                         }
1346:../Generated_Code/queue.c ****                 }
1347:../Generated_Code/queue.c ****                 else
1348:../Generated_Code/queue.c ****                 {
1349:../Generated_Code/queue.c ****                         prvUnlockQueue( pxQueue );
 1515              		.loc 1 1349 0
 1516 01d2 3B6A     		ldr	r3, [r7, #32]
 1517 01d4 181C     		mov	r0, r3
 1518 01d6 FFF7FEFF 		bl	_ZL14prvUnlockQueueP15QueueDefinition
1350:../Generated_Code/queue.c ****                         ( void ) xTaskResumeAll();
 1519              		.loc 1 1350 0
 1520 01da FFF7FEFF 		bl	xTaskResumeAll
1351:../Generated_Code/queue.c ****                         traceQUEUE_RECEIVE_FAILED( pxQueue );
1352:../Generated_Code/queue.c ****                         return errQUEUE_EMPTY;
 1521              		.loc 1 1352 0
 1522 01de 0023     		mov	r3, #0
 1523              	.L107:
 1524              	.LBE11:
1353:../Generated_Code/queue.c ****                 }
1354:../Generated_Code/queue.c ****         }
1355:../Generated_Code/queue.c **** }
 1525              		.loc 1 1355 0
 1526 01e0 181C     		mov	r0, r3
 1527 01e2 BD46     		mov	sp, r7
 1528 01e4 0AB0     		add	sp, sp, #40
 1529              		@ sp needed for prologue
 1530 01e6 80BD     		pop	{r7, pc}
 1531              		.cfi_endproc
 1532              	.LFE18:
 1534              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1535              		.align	2
 1536              		.global	xQueueReceiveFromISR
 1537              		.code	16
 1538              		.thumb_func
 1540              	xQueueReceiveFromISR:
 1541              	.LFB19:
1356:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1357:../Generated_Code/queue.c **** 
1358:../Generated_Code/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1359:../Generated_Code/queue.c **** {
 1542              		.loc 1 1359 0
 1543              		.cfi_startproc
 1544 0000 80B5     		push	{r7, lr}
 1545              	.LCFI30:
 1546              		.cfi_def_cfa_offset 8
 1547              		.cfi_offset 7, -8
 1548              		.cfi_offset 14, -4
 1549 0002 88B0     		sub	sp, sp, #32
 1550              	.LCFI31:
 1551              		.cfi_def_cfa_offset 40
 1552 0004 00AF     		add	r7, sp, #0
 1553              	.LCFI32:
 1554              		.cfi_def_cfa_register 7
 1555 0006 F860     		str	r0, [r7, #12]
 1556 0008 B960     		str	r1, [r7, #8]
 1557 000a 7A60     		str	r2, [r7, #4]
 1558              	.LBB12:
1360:../Generated_Code/queue.c **** BaseType_t xReturn;
1361:../Generated_Code/queue.c **** UBaseType_t uxSavedInterruptStatus;
1362:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1559              		.loc 1 1362 0
 1560 000c FB68     		ldr	r3, [r7, #12]
 1561 000e BB61     		str	r3, [r7, #24]
1363:../Generated_Code/queue.c **** 
1364:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1562              		.loc 1 1364 0
 1563 0010 BB69     		ldr	r3, [r7, #24]
 1564 0012 002B     		cmp	r3, #0
 1565 0014 01D1     		bne	.L110
 1566              		.loc 1 1364 0 is_stmt 0
 1567              	@ 1364 "../Generated_Code/queue.c" 1
 1568 0016 72B6     		cpsid i
 1569              	@ 0 "" 2
 1570              		.code	16
 1571              	.L111:
 1572              		.loc 1 1364 0
 1573 0018 FEE7     		b	.L111
 1574              	.L110:
1365:../Generated_Code/queue.c ****         configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1575              		.loc 1 1365 0 is_stmt 1
 1576 001a BB68     		ldr	r3, [r7, #8]
 1577 001c 002B     		cmp	r3, #0
 1578 001e 05D1     		bne	.L112
 1579              		.loc 1 1365 0 is_stmt 0
 1580 0020 BB69     		ldr	r3, [r7, #24]
 1581 0022 1B6C     		ldr	r3, [r3, #64]
 1582 0024 002B     		cmp	r3, #0
 1583 0026 01D0     		beq	.L112
 1584              		.loc 1 1365 0
 1585              	@ 1365 "../Generated_Code/queue.c" 1
 1586 0028 72B6     		cpsid i
 1587              	@ 0 "" 2
 1588              		.code	16
 1589              	.L113:
 1590              		.loc 1 1365 0
 1591 002a FEE7     		b	.L113
 1592              	.L112:
1366:../Generated_Code/queue.c **** 
1367:../Generated_Code/queue.c ****         /* RTOS ports that support interrupt nesting have the concept of a maximum
1368:../Generated_Code/queue.c ****         system call (or maximum API call) interrupt priority.  Interrupts that are
1369:../Generated_Code/queue.c ****         above the maximum system call priority are kept permanently enabled, even
1370:../Generated_Code/queue.c ****         when the RTOS kernel is in a critical section, but cannot make any calls to
1371:../Generated_Code/queue.c ****         FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1372:../Generated_Code/queue.c ****         then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1373:../Generated_Code/queue.c ****         failure if a FreeRTOS API function is called from an interrupt that has been
1374:../Generated_Code/queue.c ****         assigned a priority above the configured maximum system call priority.
1375:../Generated_Code/queue.c ****         Only FreeRTOS functions that end in FromISR can be called from interrupts
1376:../Generated_Code/queue.c ****         that have been assigned a priority at or (logically) below the maximum
1377:../Generated_Code/queue.c ****         system call     interrupt priority.  FreeRTOS maintains a separate interrupt
1378:../Generated_Code/queue.c ****         safe API to ensure interrupt entry is as fast and as simple as possible.
1379:../Generated_Code/queue.c ****         More information (albeit Cortex-M specific) is provided on the following
1380:../Generated_Code/queue.c ****         link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1381:../Generated_Code/queue.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1382:../Generated_Code/queue.c **** 
1383:../Generated_Code/queue.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1593              		.loc 1 1383 0 is_stmt 1
 1594 002c 0023     		mov	r3, #0
 1595 002e 7B61     		str	r3, [r7, #20]
 1596              	@ 1383 "../Generated_Code/queue.c" 1
 1597 0030 72B6     		cpsid i
 1598              	@ 0 "" 2
1384:../Generated_Code/queue.c ****         {
1385:../Generated_Code/queue.c ****                 /* Cannot block in an ISR, so check there is data available. */
1386:../Generated_Code/queue.c ****                 if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1599              		.loc 1 1386 0
 1600              		.code	16
 1601 0032 BB69     		ldr	r3, [r7, #24]
 1602 0034 9B6B     		ldr	r3, [r3, #56]
 1603 0036 5A1E     		sub	r2, r3, #1
 1604 0038 9341     		sbc	r3, r3, r2
 1605 003a DBB2     		uxtb	r3, r3
 1606 003c 002B     		cmp	r3, #0
 1607 003e 30D0     		beq	.L114
1387:../Generated_Code/queue.c ****                 {
1388:../Generated_Code/queue.c ****                         traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1389:../Generated_Code/queue.c **** 
1390:../Generated_Code/queue.c ****                         prvCopyDataFromQueue( pxQueue, pvBuffer );
 1608              		.loc 1 1390 0
 1609 0040 BA69     		ldr	r2, [r7, #24]
 1610 0042 BB68     		ldr	r3, [r7, #8]
 1611 0044 101C     		mov	r0, r2
 1612 0046 191C     		mov	r1, r3
 1613 0048 FFF7FEFF 		bl	_ZL20prvCopyDataFromQueueP15QueueDefinitionPv
1391:../Generated_Code/queue.c ****                         --( pxQueue->uxMessagesWaiting );
 1614              		.loc 1 1391 0
 1615 004c BB69     		ldr	r3, [r7, #24]
 1616 004e 9B6B     		ldr	r3, [r3, #56]
 1617 0050 5A1E     		sub	r2, r3, #1
 1618 0052 BB69     		ldr	r3, [r7, #24]
 1619 0054 9A63     		str	r2, [r3, #56]
1392:../Generated_Code/queue.c **** 
1393:../Generated_Code/queue.c ****                         /* If the queue is locked the event list will not be modified.
1394:../Generated_Code/queue.c ****                         Instead update the lock count so the task that unlocks the queue
1395:../Generated_Code/queue.c ****                         will know that an ISR has removed data while the queue was
1396:../Generated_Code/queue.c ****                         locked. */
1397:../Generated_Code/queue.c ****                         if( pxQueue->xRxLock == queueUNLOCKED )
 1620              		.loc 1 1397 0
 1621 0056 BB69     		ldr	r3, [r7, #24]
 1622 0058 5B6C     		ldr	r3, [r3, #68]
 1623 005a 0133     		add	r3, r3, #1
 1624 005c 5A42     		neg	r2, r3
 1625 005e 5341     		adc	r3, r3, r2
 1626 0060 DBB2     		uxtb	r3, r3
 1627 0062 002B     		cmp	r3, #0
 1628 0064 15D0     		beq	.L115
1398:../Generated_Code/queue.c ****                         {
1399:../Generated_Code/queue.c ****                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFAL
 1629              		.loc 1 1399 0
 1630 0066 BB69     		ldr	r3, [r7, #24]
 1631 0068 1B69     		ldr	r3, [r3, #16]
 1632 006a 002B     		cmp	r3, #0
 1633 006c 16D0     		beq	.L116
1400:../Generated_Code/queue.c ****                                 {
1401:../Generated_Code/queue.c ****                                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSe
 1634              		.loc 1 1401 0
 1635 006e BB69     		ldr	r3, [r7, #24]
 1636 0070 1033     		add	r3, r3, #16
 1637 0072 181C     		mov	r0, r3
 1638 0074 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1639 0078 031C     		mov	r3, r0
 1640 007a 5A1E     		sub	r2, r3, #1
 1641 007c 9341     		sbc	r3, r3, r2
 1642 007e DBB2     		uxtb	r3, r3
 1643 0080 002B     		cmp	r3, #0
 1644 0082 0BD0     		beq	.L116
1402:../Generated_Code/queue.c ****                                         {
1403:../Generated_Code/queue.c ****                                                 /* The task waiting has a higher priority than us s
1404:../Generated_Code/queue.c ****                                                 force a context switch. */
1405:../Generated_Code/queue.c ****                                                 if( pxHigherPriorityTaskWoken != NULL )
 1645              		.loc 1 1405 0
 1646 0084 7B68     		ldr	r3, [r7, #4]
 1647 0086 002B     		cmp	r3, #0
 1648 0088 08D0     		beq	.L116
1406:../Generated_Code/queue.c ****                                                 {
1407:../Generated_Code/queue.c ****                                                         *pxHigherPriorityTaskWoken = pdTRUE;
 1649              		.loc 1 1407 0
 1650 008a 7B68     		ldr	r3, [r7, #4]
 1651 008c 0122     		mov	r2, #1
 1652 008e 1A60     		str	r2, [r3]
 1653 0090 04E0     		b	.L116
 1654              	.L115:
1408:../Generated_Code/queue.c ****                                                 }
1409:../Generated_Code/queue.c ****                                                 else
1410:../Generated_Code/queue.c ****                                                 {
1411:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1412:../Generated_Code/queue.c ****                                                 }
1413:../Generated_Code/queue.c ****                                         }
1414:../Generated_Code/queue.c ****                                         else
1415:../Generated_Code/queue.c ****                                         {
1416:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1417:../Generated_Code/queue.c ****                                         }
1418:../Generated_Code/queue.c ****                                 }
1419:../Generated_Code/queue.c ****                                 else
1420:../Generated_Code/queue.c ****                                 {
1421:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1422:../Generated_Code/queue.c ****                                 }
1423:../Generated_Code/queue.c ****                         }
1424:../Generated_Code/queue.c ****                         else
1425:../Generated_Code/queue.c ****                         {
1426:../Generated_Code/queue.c ****                                 /* Increment the lock count so the task that unlocks the queue
1427:../Generated_Code/queue.c ****                                 knows that data was removed while it was locked. */
1428:../Generated_Code/queue.c ****                                 ++( pxQueue->xRxLock );
 1655              		.loc 1 1428 0
 1656 0092 BB69     		ldr	r3, [r7, #24]
 1657 0094 5B6C     		ldr	r3, [r3, #68]
 1658 0096 5A1C     		add	r2, r3, #1
 1659 0098 BB69     		ldr	r3, [r7, #24]
 1660 009a 5A64     		str	r2, [r3, #68]
 1661              	.L116:
1429:../Generated_Code/queue.c ****                         }
1430:../Generated_Code/queue.c **** 
1431:../Generated_Code/queue.c ****                         xReturn = pdPASS;
 1662              		.loc 1 1431 0
 1663 009c 0123     		mov	r3, #1
 1664 009e FB61     		str	r3, [r7, #28]
 1665 00a0 01E0     		b	.L117
 1666              	.L114:
1432:../Generated_Code/queue.c ****                 }
1433:../Generated_Code/queue.c ****                 else
1434:../Generated_Code/queue.c ****                 {
1435:../Generated_Code/queue.c ****                         xReturn = pdFAIL;
 1667              		.loc 1 1435 0
 1668 00a2 0023     		mov	r3, #0
 1669 00a4 FB61     		str	r3, [r7, #28]
 1670              	.L117:
1436:../Generated_Code/queue.c ****                         traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1437:../Generated_Code/queue.c ****                 }
1438:../Generated_Code/queue.c ****         }
1439:../Generated_Code/queue.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1671              		.loc 1 1439 0
 1672              	@ 1439 "../Generated_Code/queue.c" 1
 1673 00a6 62B6     		cpsie i
 1674              	@ 0 "" 2
1440:../Generated_Code/queue.c **** 
1441:../Generated_Code/queue.c ****         return xReturn;
 1675              		.loc 1 1441 0
 1676              		.code	16
 1677 00a8 FB69     		ldr	r3, [r7, #28]
 1678              	.LBE12:
1442:../Generated_Code/queue.c **** }
 1679              		.loc 1 1442 0
 1680 00aa 181C     		mov	r0, r3
 1681 00ac BD46     		mov	sp, r7
 1682 00ae 08B0     		add	sp, sp, #32
 1683              		@ sp needed for prologue
 1684 00b0 80BD     		pop	{r7, pc}
 1685              		.cfi_endproc
 1686              	.LFE19:
 1688 00b2 C046     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1689              		.align	2
 1690              		.global	xQueuePeekFromISR
 1691              		.code	16
 1692              		.thumb_func
 1694              	xQueuePeekFromISR:
 1695              	.LFB20:
1443:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1444:../Generated_Code/queue.c **** 
1445:../Generated_Code/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1446:../Generated_Code/queue.c **** {
 1696              		.loc 1 1446 0
 1697              		.cfi_startproc
 1698 0000 80B5     		push	{r7, lr}
 1699              	.LCFI33:
 1700              		.cfi_def_cfa_offset 8
 1701              		.cfi_offset 7, -8
 1702              		.cfi_offset 14, -4
 1703 0002 86B0     		sub	sp, sp, #24
 1704              	.LCFI34:
 1705              		.cfi_def_cfa_offset 32
 1706 0004 00AF     		add	r7, sp, #0
 1707              	.LCFI35:
 1708              		.cfi_def_cfa_register 7
 1709 0006 7860     		str	r0, [r7, #4]
 1710 0008 3960     		str	r1, [r7]
 1711              	.LBB13:
1447:../Generated_Code/queue.c **** BaseType_t xReturn;
1448:../Generated_Code/queue.c **** UBaseType_t uxSavedInterruptStatus;
1449:../Generated_Code/queue.c **** int8_t *pcOriginalReadPosition;
1450:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1712              		.loc 1 1450 0
 1713 000a 7B68     		ldr	r3, [r7, #4]
 1714 000c 3B61     		str	r3, [r7, #16]
1451:../Generated_Code/queue.c **** 
1452:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1715              		.loc 1 1452 0
 1716 000e 3B69     		ldr	r3, [r7, #16]
 1717 0010 002B     		cmp	r3, #0
 1718 0012 01D1     		bne	.L120
 1719              		.loc 1 1452 0 is_stmt 0
 1720              	@ 1452 "../Generated_Code/queue.c" 1
 1721 0014 72B6     		cpsid i
 1722              	@ 0 "" 2
 1723              		.code	16
 1724              	.L121:
 1725              		.loc 1 1452 0
 1726 0016 FEE7     		b	.L121
 1727              	.L120:
1453:../Generated_Code/queue.c ****         configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1728              		.loc 1 1453 0 is_stmt 1
 1729 0018 3B68     		ldr	r3, [r7]
 1730 001a 002B     		cmp	r3, #0
 1731 001c 05D1     		bne	.L122
 1732              		.loc 1 1453 0 is_stmt 0
 1733 001e 3B69     		ldr	r3, [r7, #16]
 1734 0020 1B6C     		ldr	r3, [r3, #64]
 1735 0022 002B     		cmp	r3, #0
 1736 0024 01D0     		beq	.L122
 1737              		.loc 1 1453 0
 1738              	@ 1453 "../Generated_Code/queue.c" 1
 1739 0026 72B6     		cpsid i
 1740              	@ 0 "" 2
 1741              		.code	16
 1742              	.L123:
 1743              		.loc 1 1453 0
 1744 0028 FEE7     		b	.L123
 1745              	.L122:
1454:../Generated_Code/queue.c **** 
1455:../Generated_Code/queue.c ****         /* RTOS ports that support interrupt nesting have the concept of a maximum
1456:../Generated_Code/queue.c ****         system call (or maximum API call) interrupt priority.  Interrupts that are
1457:../Generated_Code/queue.c ****         above the maximum system call priority are kept permanently enabled, even
1458:../Generated_Code/queue.c ****         when the RTOS kernel is in a critical section, but cannot make any calls to
1459:../Generated_Code/queue.c ****         FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1460:../Generated_Code/queue.c ****         then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1461:../Generated_Code/queue.c ****         failure if a FreeRTOS API function is called from an interrupt that has been
1462:../Generated_Code/queue.c ****         assigned a priority above the configured maximum system call priority.
1463:../Generated_Code/queue.c ****         Only FreeRTOS functions that end in FromISR can be called from interrupts
1464:../Generated_Code/queue.c ****         that have been assigned a priority at or (logically) below the maximum
1465:../Generated_Code/queue.c ****         system call     interrupt priority.  FreeRTOS maintains a separate interrupt
1466:../Generated_Code/queue.c ****         safe API to ensure interrupt entry is as fast and as simple as possible.
1467:../Generated_Code/queue.c ****         More information (albeit Cortex-M specific) is provided on the following
1468:../Generated_Code/queue.c ****         link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1469:../Generated_Code/queue.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1470:../Generated_Code/queue.c **** 
1471:../Generated_Code/queue.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1746              		.loc 1 1471 0 is_stmt 1
 1747 002a 0023     		mov	r3, #0
 1748 002c FB60     		str	r3, [r7, #12]
 1749              	@ 1471 "../Generated_Code/queue.c" 1
 1750 002e 72B6     		cpsid i
 1751              	@ 0 "" 2
1472:../Generated_Code/queue.c ****         {
1473:../Generated_Code/queue.c ****                 /* Cannot block in an ISR, so check there is data available. */
1474:../Generated_Code/queue.c ****                 if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1752              		.loc 1 1474 0
 1753              		.code	16
 1754 0030 3B69     		ldr	r3, [r7, #16]
 1755 0032 9B6B     		ldr	r3, [r3, #56]
 1756 0034 5A1E     		sub	r2, r3, #1
 1757 0036 9341     		sbc	r3, r3, r2
 1758 0038 DBB2     		uxtb	r3, r3
 1759 003a 002B     		cmp	r3, #0
 1760 003c 0ED0     		beq	.L124
1475:../Generated_Code/queue.c ****                 {
1476:../Generated_Code/queue.c ****                         traceQUEUE_PEEK_FROM_ISR( pxQueue );
1477:../Generated_Code/queue.c **** 
1478:../Generated_Code/queue.c ****                         /* Remember the read position so it can be reset as nothing is
1479:../Generated_Code/queue.c ****                         actually being removed from the queue. */
1480:../Generated_Code/queue.c ****                         pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1761              		.loc 1 1480 0
 1762 003e 3B69     		ldr	r3, [r7, #16]
 1763 0040 DB68     		ldr	r3, [r3, #12]
 1764 0042 BB60     		str	r3, [r7, #8]
1481:../Generated_Code/queue.c ****                         prvCopyDataFromQueue( pxQueue, pvBuffer );
 1765              		.loc 1 1481 0
 1766 0044 3A69     		ldr	r2, [r7, #16]
 1767 0046 3B68     		ldr	r3, [r7]
 1768 0048 101C     		mov	r0, r2
 1769 004a 191C     		mov	r1, r3
 1770 004c FFF7FEFF 		bl	_ZL20prvCopyDataFromQueueP15QueueDefinitionPv
1482:../Generated_Code/queue.c ****                         pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1771              		.loc 1 1482 0
 1772 0050 3B69     		ldr	r3, [r7, #16]
 1773 0052 BA68     		ldr	r2, [r7, #8]
 1774 0054 DA60     		str	r2, [r3, #12]
1483:../Generated_Code/queue.c **** 
1484:../Generated_Code/queue.c ****                         xReturn = pdPASS;
 1775              		.loc 1 1484 0
 1776 0056 0123     		mov	r3, #1
 1777 0058 7B61     		str	r3, [r7, #20]
 1778 005a 01E0     		b	.L125
 1779              	.L124:
1485:../Generated_Code/queue.c ****                 }
1486:../Generated_Code/queue.c ****                 else
1487:../Generated_Code/queue.c ****                 {
1488:../Generated_Code/queue.c ****                         xReturn = pdFAIL;
 1780              		.loc 1 1488 0
 1781 005c 0023     		mov	r3, #0
 1782 005e 7B61     		str	r3, [r7, #20]
 1783              	.L125:
1489:../Generated_Code/queue.c ****                         traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1490:../Generated_Code/queue.c ****                 }
1491:../Generated_Code/queue.c ****         }
1492:../Generated_Code/queue.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1784              		.loc 1 1492 0
 1785              	@ 1492 "../Generated_Code/queue.c" 1
 1786 0060 62B6     		cpsie i
 1787              	@ 0 "" 2
1493:../Generated_Code/queue.c **** 
1494:../Generated_Code/queue.c ****         return xReturn;
 1788              		.loc 1 1494 0
 1789              		.code	16
 1790 0062 7B69     		ldr	r3, [r7, #20]
 1791              	.LBE13:
1495:../Generated_Code/queue.c **** }
 1792              		.loc 1 1495 0
 1793 0064 181C     		mov	r0, r3
 1794 0066 BD46     		mov	sp, r7
 1795 0068 06B0     		add	sp, sp, #24
 1796              		@ sp needed for prologue
 1797 006a 80BD     		pop	{r7, pc}
 1798              		.cfi_endproc
 1799              	.LFE20:
 1801              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1802              		.align	2
 1803              		.global	uxQueueMessagesWaiting
 1804              		.code	16
 1805              		.thumb_func
 1807              	uxQueueMessagesWaiting:
 1808              	.LFB21:
1496:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1497:../Generated_Code/queue.c **** 
1498:../Generated_Code/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1499:../Generated_Code/queue.c **** {
 1809              		.loc 1 1499 0
 1810              		.cfi_startproc
 1811 0000 80B5     		push	{r7, lr}
 1812              	.LCFI36:
 1813              		.cfi_def_cfa_offset 8
 1814              		.cfi_offset 7, -8
 1815              		.cfi_offset 14, -4
 1816 0002 84B0     		sub	sp, sp, #16
 1817              	.LCFI37:
 1818              		.cfi_def_cfa_offset 24
 1819 0004 00AF     		add	r7, sp, #0
 1820              	.LCFI38:
 1821              		.cfi_def_cfa_register 7
 1822 0006 7860     		str	r0, [r7, #4]
 1823              	.LBB14:
1500:../Generated_Code/queue.c **** UBaseType_t uxReturn;
1501:../Generated_Code/queue.c **** 
1502:../Generated_Code/queue.c ****         configASSERT( xQueue );
 1824              		.loc 1 1502 0
 1825 0008 7B68     		ldr	r3, [r7, #4]
 1826 000a 002B     		cmp	r3, #0
 1827 000c 01D1     		bne	.L128
 1828              		.loc 1 1502 0 is_stmt 0
 1829              	@ 1502 "../Generated_Code/queue.c" 1
 1830 000e 72B6     		cpsid i
 1831              	@ 0 "" 2
 1832              		.code	16
 1833              	.L129:
 1834              		.loc 1 1502 0
 1835 0010 FEE7     		b	.L129
 1836              	.L128:
1503:../Generated_Code/queue.c **** 
1504:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 1837              		.loc 1 1504 0 is_stmt 1
 1838 0012 FFF7FEFF 		bl	vPortEnterCritical
1505:../Generated_Code/queue.c ****         {
1506:../Generated_Code/queue.c ****                 uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1839              		.loc 1 1506 0
 1840 0016 7B68     		ldr	r3, [r7, #4]
 1841 0018 9B6B     		ldr	r3, [r3, #56]
 1842 001a FB60     		str	r3, [r7, #12]
1507:../Generated_Code/queue.c ****         }
1508:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 1843              		.loc 1 1508 0
 1844 001c FFF7FEFF 		bl	vPortExitCritical
1509:../Generated_Code/queue.c **** 
1510:../Generated_Code/queue.c ****         return uxReturn;
 1845              		.loc 1 1510 0
 1846 0020 FB68     		ldr	r3, [r7, #12]
 1847              	.LBE14:
1511:../Generated_Code/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1848              		.loc 1 1511 0
 1849 0022 181C     		mov	r0, r3
 1850 0024 BD46     		mov	sp, r7
 1851 0026 04B0     		add	sp, sp, #16
 1852              		@ sp needed for prologue
 1853 0028 80BD     		pop	{r7, pc}
 1854              		.cfi_endproc
 1855              	.LFE21:
 1857 002a C046     		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1858              		.align	2
 1859              		.global	uxQueueSpacesAvailable
 1860              		.code	16
 1861              		.thumb_func
 1863              	uxQueueSpacesAvailable:
 1864              	.LFB22:
1512:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1513:../Generated_Code/queue.c **** 
1514:../Generated_Code/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1515:../Generated_Code/queue.c **** {
 1865              		.loc 1 1515 0
 1866              		.cfi_startproc
 1867 0000 80B5     		push	{r7, lr}
 1868              	.LCFI39:
 1869              		.cfi_def_cfa_offset 8
 1870              		.cfi_offset 7, -8
 1871              		.cfi_offset 14, -4
 1872 0002 84B0     		sub	sp, sp, #16
 1873              	.LCFI40:
 1874              		.cfi_def_cfa_offset 24
 1875 0004 00AF     		add	r7, sp, #0
 1876              	.LCFI41:
 1877              		.cfi_def_cfa_register 7
 1878 0006 7860     		str	r0, [r7, #4]
 1879              	.LBB15:
1516:../Generated_Code/queue.c **** UBaseType_t uxReturn;
1517:../Generated_Code/queue.c **** Queue_t *pxQueue;
1518:../Generated_Code/queue.c **** 
1519:../Generated_Code/queue.c ****         pxQueue = ( Queue_t * ) xQueue;
 1880              		.loc 1 1519 0
 1881 0008 7B68     		ldr	r3, [r7, #4]
 1882 000a FB60     		str	r3, [r7, #12]
1520:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1883              		.loc 1 1520 0
 1884 000c FB68     		ldr	r3, [r7, #12]
 1885 000e 002B     		cmp	r3, #0
 1886 0010 01D1     		bne	.L132
 1887              		.loc 1 1520 0 is_stmt 0
 1888              	@ 1520 "../Generated_Code/queue.c" 1
 1889 0012 72B6     		cpsid i
 1890              	@ 0 "" 2
 1891              		.code	16
 1892              	.L133:
 1893              		.loc 1 1520 0
 1894 0014 FEE7     		b	.L133
 1895              	.L132:
1521:../Generated_Code/queue.c **** 
1522:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 1896              		.loc 1 1522 0 is_stmt 1
 1897 0016 FFF7FEFF 		bl	vPortEnterCritical
1523:../Generated_Code/queue.c ****         {
1524:../Generated_Code/queue.c ****                 uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1898              		.loc 1 1524 0
 1899 001a FB68     		ldr	r3, [r7, #12]
 1900 001c DA6B     		ldr	r2, [r3, #60]
 1901 001e FB68     		ldr	r3, [r7, #12]
 1902 0020 9B6B     		ldr	r3, [r3, #56]
 1903 0022 D31A     		sub	r3, r2, r3
 1904 0024 BB60     		str	r3, [r7, #8]
1525:../Generated_Code/queue.c ****         }
1526:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 1905              		.loc 1 1526 0
 1906 0026 FFF7FEFF 		bl	vPortExitCritical
1527:../Generated_Code/queue.c **** 
1528:../Generated_Code/queue.c ****         return uxReturn;
 1907              		.loc 1 1528 0
 1908 002a BB68     		ldr	r3, [r7, #8]
 1909              	.LBE15:
1529:../Generated_Code/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1910              		.loc 1 1529 0
 1911 002c 181C     		mov	r0, r3
 1912 002e BD46     		mov	sp, r7
 1913 0030 04B0     		add	sp, sp, #16
 1914              		@ sp needed for prologue
 1915 0032 80BD     		pop	{r7, pc}
 1916              		.cfi_endproc
 1917              	.LFE22:
 1919              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1920              		.align	2
 1921              		.global	uxQueueMessagesWaitingFromISR
 1922              		.code	16
 1923              		.thumb_func
 1925              	uxQueueMessagesWaitingFromISR:
 1926              	.LFB23:
1530:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1531:../Generated_Code/queue.c **** 
1532:../Generated_Code/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1533:../Generated_Code/queue.c **** {
 1927              		.loc 1 1533 0
 1928              		.cfi_startproc
 1929 0000 80B5     		push	{r7, lr}
 1930              	.LCFI42:
 1931              		.cfi_def_cfa_offset 8
 1932              		.cfi_offset 7, -8
 1933              		.cfi_offset 14, -4
 1934 0002 84B0     		sub	sp, sp, #16
 1935              	.LCFI43:
 1936              		.cfi_def_cfa_offset 24
 1937 0004 00AF     		add	r7, sp, #0
 1938              	.LCFI44:
 1939              		.cfi_def_cfa_register 7
 1940 0006 7860     		str	r0, [r7, #4]
 1941              	.LBB16:
1534:../Generated_Code/queue.c **** UBaseType_t uxReturn;
1535:../Generated_Code/queue.c **** 
1536:../Generated_Code/queue.c ****         configASSERT( xQueue );
 1942              		.loc 1 1536 0
 1943 0008 7B68     		ldr	r3, [r7, #4]
 1944 000a 002B     		cmp	r3, #0
 1945 000c 01D1     		bne	.L136
 1946              		.loc 1 1536 0 is_stmt 0
 1947              	@ 1536 "../Generated_Code/queue.c" 1
 1948 000e 72B6     		cpsid i
 1949              	@ 0 "" 2
 1950              		.code	16
 1951              	.L137:
 1952              		.loc 1 1536 0
 1953 0010 FEE7     		b	.L137
 1954              	.L136:
1537:../Generated_Code/queue.c **** 
1538:../Generated_Code/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1955              		.loc 1 1538 0 is_stmt 1
 1956 0012 7B68     		ldr	r3, [r7, #4]
 1957 0014 9B6B     		ldr	r3, [r3, #56]
 1958 0016 FB60     		str	r3, [r7, #12]
1539:../Generated_Code/queue.c **** 
1540:../Generated_Code/queue.c ****         return uxReturn;
 1959              		.loc 1 1540 0
 1960 0018 FB68     		ldr	r3, [r7, #12]
 1961              	.LBE16:
1541:../Generated_Code/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1962              		.loc 1 1541 0
 1963 001a 181C     		mov	r0, r3
 1964 001c BD46     		mov	sp, r7
 1965 001e 04B0     		add	sp, sp, #16
 1966              		@ sp needed for prologue
 1967 0020 80BD     		pop	{r7, pc}
 1968              		.cfi_endproc
 1969              	.LFE23:
 1971 0022 C046     		.section	.text.vQueueDelete,"ax",%progbits
 1972              		.align	2
 1973              		.global	vQueueDelete
 1974              		.code	16
 1975              		.thumb_func
 1977              	vQueueDelete:
 1978              	.LFB24:
1542:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1543:../Generated_Code/queue.c **** 
1544:../Generated_Code/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1545:../Generated_Code/queue.c **** {
 1979              		.loc 1 1545 0
 1980              		.cfi_startproc
 1981 0000 80B5     		push	{r7, lr}
 1982              	.LCFI45:
 1983              		.cfi_def_cfa_offset 8
 1984              		.cfi_offset 7, -8
 1985              		.cfi_offset 14, -4
 1986 0002 84B0     		sub	sp, sp, #16
 1987              	.LCFI46:
 1988              		.cfi_def_cfa_offset 24
 1989 0004 00AF     		add	r7, sp, #0
 1990              	.LCFI47:
 1991              		.cfi_def_cfa_register 7
 1992 0006 7860     		str	r0, [r7, #4]
 1993              	.LBB17:
1546:../Generated_Code/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1994              		.loc 1 1546 0
 1995 0008 7B68     		ldr	r3, [r7, #4]
 1996 000a FB60     		str	r3, [r7, #12]
1547:../Generated_Code/queue.c **** 
1548:../Generated_Code/queue.c ****         configASSERT( pxQueue );
 1997              		.loc 1 1548 0
 1998 000c FB68     		ldr	r3, [r7, #12]
 1999 000e 002B     		cmp	r3, #0
 2000 0010 01D1     		bne	.L140
 2001              		.loc 1 1548 0 is_stmt 0
 2002              	@ 1548 "../Generated_Code/queue.c" 1
 2003 0012 72B6     		cpsid i
 2004              	@ 0 "" 2
 2005              		.code	16
 2006              	.L141:
 2007              		.loc 1 1548 0
 2008 0014 FEE7     		b	.L141
 2009              	.L140:
1549:../Generated_Code/queue.c **** 
1550:../Generated_Code/queue.c ****         traceQUEUE_DELETE( pxQueue );
1551:../Generated_Code/queue.c ****         #if ( configQUEUE_REGISTRY_SIZE > 0 )
1552:../Generated_Code/queue.c ****         {
1553:../Generated_Code/queue.c ****                 vQueueUnregisterQueue( pxQueue );
1554:../Generated_Code/queue.c ****         }
1555:../Generated_Code/queue.c ****         #endif
1556:../Generated_Code/queue.c ****         if( pxQueue->pcHead != NULL )
 2010              		.loc 1 1556 0 is_stmt 1
 2011 0016 FB68     		ldr	r3, [r7, #12]
 2012 0018 1B68     		ldr	r3, [r3]
 2013 001a 002B     		cmp	r3, #0
 2014 001c 04D0     		beq	.L142
1557:../Generated_Code/queue.c ****         {
1558:../Generated_Code/queue.c ****                 vPortFree( pxQueue->pcHead );
 2015              		.loc 1 1558 0
 2016 001e FB68     		ldr	r3, [r7, #12]
 2017 0020 1B68     		ldr	r3, [r3]
 2018 0022 181C     		mov	r0, r3
 2019 0024 FFF7FEFF 		bl	vPortFree
 2020              	.L142:
1559:../Generated_Code/queue.c ****         }
1560:../Generated_Code/queue.c ****         vPortFree( pxQueue );
 2021              		.loc 1 1560 0
 2022 0028 FB68     		ldr	r3, [r7, #12]
 2023 002a 181C     		mov	r0, r3
 2024 002c FFF7FEFF 		bl	vPortFree
 2025              	.LBE17:
1561:../Generated_Code/queue.c **** }
 2026              		.loc 1 1561 0
 2027 0030 BD46     		mov	sp, r7
 2028 0032 04B0     		add	sp, sp, #16
 2029              		@ sp needed for prologue
 2030 0034 80BD     		pop	{r7, pc}
 2031              		.cfi_endproc
 2032              	.LFE24:
 2034 0036 C046     		.section	.text._ZL18prvCopyDataToQueueP15QueueDefinitionPKvl,"ax",%progbits
 2035              		.align	2
 2036              		.code	16
 2037              		.thumb_func
 2039              	_ZL18prvCopyDataToQueueP15QueueDefinitionPKvl:
 2040              	.LFB25:
1562:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1563:../Generated_Code/queue.c **** 
1564:../Generated_Code/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1565:../Generated_Code/queue.c **** 
1566:../Generated_Code/queue.c ****         UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1567:../Generated_Code/queue.c ****         {
1568:../Generated_Code/queue.c ****                 return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1569:../Generated_Code/queue.c ****         }
1570:../Generated_Code/queue.c **** 
1571:../Generated_Code/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1572:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1573:../Generated_Code/queue.c **** 
1574:../Generated_Code/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1575:../Generated_Code/queue.c **** 
1576:../Generated_Code/queue.c ****         void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1577:../Generated_Code/queue.c ****         {
1578:../Generated_Code/queue.c ****                 ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1579:../Generated_Code/queue.c ****         }
1580:../Generated_Code/queue.c **** 
1581:../Generated_Code/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1582:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1583:../Generated_Code/queue.c **** 
1584:../Generated_Code/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1585:../Generated_Code/queue.c **** 
1586:../Generated_Code/queue.c ****         uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1587:../Generated_Code/queue.c ****         {
1588:../Generated_Code/queue.c ****                 return ( ( Queue_t * ) xQueue )->ucQueueType;
1589:../Generated_Code/queue.c ****         }
1590:../Generated_Code/queue.c **** 
1591:../Generated_Code/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1592:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1593:../Generated_Code/queue.c **** 
1594:../Generated_Code/queue.c **** static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_
1595:../Generated_Code/queue.c **** {
 2041              		.loc 1 1595 0
 2042              		.cfi_startproc
 2043 0000 80B5     		push	{r7, lr}
 2044              	.LCFI48:
 2045              		.cfi_def_cfa_offset 8
 2046              		.cfi_offset 7, -8
 2047              		.cfi_offset 14, -4
 2048 0002 84B0     		sub	sp, sp, #16
 2049              	.LCFI49:
 2050              		.cfi_def_cfa_offset 24
 2051 0004 00AF     		add	r7, sp, #0
 2052              	.LCFI50:
 2053              		.cfi_def_cfa_register 7
 2054 0006 F860     		str	r0, [r7, #12]
 2055 0008 B960     		str	r1, [r7, #8]
 2056 000a 7A60     		str	r2, [r7, #4]
1596:../Generated_Code/queue.c ****         if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2057              		.loc 1 1596 0
 2058 000c FB68     		ldr	r3, [r7, #12]
 2059 000e 1B6C     		ldr	r3, [r3, #64]
 2060 0010 002B     		cmp	r3, #0
 2061 0012 0CD1     		bne	.L144
1597:../Generated_Code/queue.c ****         {
1598:../Generated_Code/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1599:../Generated_Code/queue.c ****                 {
1600:../Generated_Code/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2062              		.loc 1 1600 0
 2063 0014 FB68     		ldr	r3, [r7, #12]
 2064 0016 1B68     		ldr	r3, [r3]
 2065 0018 002B     		cmp	r3, #0
 2066 001a 56D1     		bne	.L145
1601:../Generated_Code/queue.c ****                         {
1602:../Generated_Code/queue.c ****                                 /* The mutex is no longer being held. */
1603:../Generated_Code/queue.c ****                                 vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 2067              		.loc 1 1603 0
 2068 001c FB68     		ldr	r3, [r7, #12]
 2069 001e 5B68     		ldr	r3, [r3, #4]
 2070 0020 181C     		mov	r0, r3
 2071 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1604:../Generated_Code/queue.c ****                                 pxQueue->pxMutexHolder = NULL;
 2072              		.loc 1 1604 0
 2073 0026 FB68     		ldr	r3, [r7, #12]
 2074 0028 0022     		mov	r2, #0
 2075 002a 5A60     		str	r2, [r3, #4]
 2076 002c 4DE0     		b	.L145
 2077              	.L144:
1605:../Generated_Code/queue.c ****                         }
1606:../Generated_Code/queue.c ****                         else
1607:../Generated_Code/queue.c ****                         {
1608:../Generated_Code/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1609:../Generated_Code/queue.c ****                         }
1610:../Generated_Code/queue.c ****                 }
1611:../Generated_Code/queue.c ****                 #endif /* configUSE_MUTEXES */
1612:../Generated_Code/queue.c ****         }
1613:../Generated_Code/queue.c ****         else if( xPosition == queueSEND_TO_BACK )
 2078              		.loc 1 1613 0
 2079 002e 7B68     		ldr	r3, [r7, #4]
 2080 0030 002B     		cmp	r3, #0
 2081 0032 1BD1     		bne	.L146
1614:../Generated_Code/queue.c ****         {
1615:../Generated_Code/queue.c ****                 ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->
 2082              		.loc 1 1615 0
 2083 0034 FB68     		ldr	r3, [r7, #12]
 2084 0036 9968     		ldr	r1, [r3, #8]
 2085 0038 FB68     		ldr	r3, [r7, #12]
 2086 003a 1B6C     		ldr	r3, [r3, #64]
 2087 003c BA68     		ldr	r2, [r7, #8]
 2088 003e 081C     		mov	r0, r1
 2089 0040 111C     		mov	r1, r2
 2090 0042 1A1C     		mov	r2, r3
 2091 0044 FFF7FEFF 		bl	memcpy
1616:../Generated_Code/queue.c ****                 pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2092              		.loc 1 1616 0
 2093 0048 FB68     		ldr	r3, [r7, #12]
 2094 004a 9A68     		ldr	r2, [r3, #8]
 2095 004c FB68     		ldr	r3, [r7, #12]
 2096 004e 1B6C     		ldr	r3, [r3, #64]
 2097 0050 D218     		add	r2, r2, r3
 2098 0052 FB68     		ldr	r3, [r7, #12]
 2099 0054 9A60     		str	r2, [r3, #8]
1617:../Generated_Code/queue.c ****                 if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified 
 2100              		.loc 1 1617 0
 2101 0056 FB68     		ldr	r3, [r7, #12]
 2102 0058 9A68     		ldr	r2, [r3, #8]
 2103 005a FB68     		ldr	r3, [r7, #12]
 2104 005c 5B68     		ldr	r3, [r3, #4]
 2105 005e 9A42     		cmp	r2, r3
 2106 0060 33D3     		bcc	.L145
1618:../Generated_Code/queue.c ****                 {
1619:../Generated_Code/queue.c ****                         pxQueue->pcWriteTo = pxQueue->pcHead;
 2107              		.loc 1 1619 0
 2108 0062 FB68     		ldr	r3, [r7, #12]
 2109 0064 1A68     		ldr	r2, [r3]
 2110 0066 FB68     		ldr	r3, [r7, #12]
 2111 0068 9A60     		str	r2, [r3, #8]
 2112 006a 2EE0     		b	.L145
 2113              	.L146:
1620:../Generated_Code/queue.c ****                 }
1621:../Generated_Code/queue.c ****                 else
1622:../Generated_Code/queue.c ****                 {
1623:../Generated_Code/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1624:../Generated_Code/queue.c ****                 }
1625:../Generated_Code/queue.c ****         }
1626:../Generated_Code/queue.c ****         else
1627:../Generated_Code/queue.c ****         {
1628:../Generated_Code/queue.c ****                 ( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueu
 2114              		.loc 1 1628 0
 2115 006c FB68     		ldr	r3, [r7, #12]
 2116 006e D968     		ldr	r1, [r3, #12]
 2117 0070 FB68     		ldr	r3, [r7, #12]
 2118 0072 1B6C     		ldr	r3, [r3, #64]
 2119 0074 BA68     		ldr	r2, [r7, #8]
 2120 0076 081C     		mov	r0, r1
 2121 0078 111C     		mov	r1, r2
 2122 007a 1A1C     		mov	r2, r3
 2123 007c FFF7FEFF 		bl	memcpy
1629:../Generated_Code/queue.c ****                 pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 2124              		.loc 1 1629 0
 2125 0080 FB68     		ldr	r3, [r7, #12]
 2126 0082 DA68     		ldr	r2, [r3, #12]
 2127 0084 FB68     		ldr	r3, [r7, #12]
 2128 0086 1B6C     		ldr	r3, [r3, #64]
 2129 0088 5B42     		neg	r3, r3
 2130 008a D218     		add	r2, r2, r3
 2131 008c FB68     		ldr	r3, [r7, #12]
 2132 008e DA60     		str	r2, [r3, #12]
1630:../Generated_Code/queue.c ****                 if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justifie
 2133              		.loc 1 1630 0
 2134 0090 FB68     		ldr	r3, [r7, #12]
 2135 0092 DA68     		ldr	r2, [r3, #12]
 2136 0094 FB68     		ldr	r3, [r7, #12]
 2137 0096 1B68     		ldr	r3, [r3]
 2138 0098 9A42     		cmp	r2, r3
 2139 009a 07D2     		bcs	.L147
1631:../Generated_Code/queue.c ****                 {
1632:../Generated_Code/queue.c ****                         pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 2140              		.loc 1 1632 0
 2141 009c FB68     		ldr	r3, [r7, #12]
 2142 009e 5A68     		ldr	r2, [r3, #4]
 2143 00a0 FB68     		ldr	r3, [r7, #12]
 2144 00a2 1B6C     		ldr	r3, [r3, #64]
 2145 00a4 5B42     		neg	r3, r3
 2146 00a6 D218     		add	r2, r2, r3
 2147 00a8 FB68     		ldr	r3, [r7, #12]
 2148 00aa DA60     		str	r2, [r3, #12]
 2149              	.L147:
1633:../Generated_Code/queue.c ****                 }
1634:../Generated_Code/queue.c ****                 else
1635:../Generated_Code/queue.c ****                 {
1636:../Generated_Code/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1637:../Generated_Code/queue.c ****                 }
1638:../Generated_Code/queue.c **** 
1639:../Generated_Code/queue.c ****                 if( xPosition == queueOVERWRITE )
 2150              		.loc 1 1639 0
 2151 00ac 7B68     		ldr	r3, [r7, #4]
 2152 00ae 022B     		cmp	r3, #2
 2153 00b0 0BD1     		bne	.L145
1640:../Generated_Code/queue.c ****                 {
1641:../Generated_Code/queue.c ****                         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2154              		.loc 1 1641 0
 2155 00b2 FB68     		ldr	r3, [r7, #12]
 2156 00b4 9B6B     		ldr	r3, [r3, #56]
 2157 00b6 5A1E     		sub	r2, r3, #1
 2158 00b8 9341     		sbc	r3, r3, r2
 2159 00ba DBB2     		uxtb	r3, r3
 2160 00bc 002B     		cmp	r3, #0
 2161 00be 04D0     		beq	.L145
1642:../Generated_Code/queue.c ****                         {
1643:../Generated_Code/queue.c ****                                 /* An item is not being added but overwritten, so subtract
1644:../Generated_Code/queue.c ****                                 one from the recorded number of items in the queue so when
1645:../Generated_Code/queue.c ****                                 one is added again below the number of recorded items remains
1646:../Generated_Code/queue.c ****                                 correct. */
1647:../Generated_Code/queue.c ****                                 --( pxQueue->uxMessagesWaiting );
 2162              		.loc 1 1647 0
 2163 00c0 FB68     		ldr	r3, [r7, #12]
 2164 00c2 9B6B     		ldr	r3, [r3, #56]
 2165 00c4 5A1E     		sub	r2, r3, #1
 2166 00c6 FB68     		ldr	r3, [r7, #12]
 2167 00c8 9A63     		str	r2, [r3, #56]
 2168              	.L145:
1648:../Generated_Code/queue.c ****                         }
1649:../Generated_Code/queue.c ****                         else
1650:../Generated_Code/queue.c ****                         {
1651:../Generated_Code/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1652:../Generated_Code/queue.c ****                         }
1653:../Generated_Code/queue.c ****                 }
1654:../Generated_Code/queue.c ****                 else
1655:../Generated_Code/queue.c ****                 {
1656:../Generated_Code/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1657:../Generated_Code/queue.c ****                 }
1658:../Generated_Code/queue.c ****         }
1659:../Generated_Code/queue.c **** 
1660:../Generated_Code/queue.c ****         ++( pxQueue->uxMessagesWaiting );
 2169              		.loc 1 1660 0
 2170 00ca FB68     		ldr	r3, [r7, #12]
 2171 00cc 9B6B     		ldr	r3, [r3, #56]
 2172 00ce 5A1C     		add	r2, r3, #1
 2173 00d0 FB68     		ldr	r3, [r7, #12]
 2174 00d2 9A63     		str	r2, [r3, #56]
1661:../Generated_Code/queue.c **** }
 2175              		.loc 1 1661 0
 2176 00d4 BD46     		mov	sp, r7
 2177 00d6 04B0     		add	sp, sp, #16
 2178              		@ sp needed for prologue
 2179 00d8 80BD     		pop	{r7, pc}
 2180              		.cfi_endproc
 2181              	.LFE25:
 2183 00da C046     		.section	.text._ZL20prvCopyDataFromQueueP15QueueDefinitionPv,"ax",%progbits
 2184              		.align	2
 2185              		.code	16
 2186              		.thumb_func
 2188              	_ZL20prvCopyDataFromQueueP15QueueDefinitionPv:
 2189              	.LFB26:
1662:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1663:../Generated_Code/queue.c **** 
1664:../Generated_Code/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1665:../Generated_Code/queue.c **** {
 2190              		.loc 1 1665 0
 2191              		.cfi_startproc
 2192 0000 80B5     		push	{r7, lr}
 2193              	.LCFI51:
 2194              		.cfi_def_cfa_offset 8
 2195              		.cfi_offset 7, -8
 2196              		.cfi_offset 14, -4
 2197 0002 82B0     		sub	sp, sp, #8
 2198              	.LCFI52:
 2199              		.cfi_def_cfa_offset 16
 2200 0004 00AF     		add	r7, sp, #0
 2201              	.LCFI53:
 2202              		.cfi_def_cfa_register 7
 2203 0006 7860     		str	r0, [r7, #4]
 2204 0008 3960     		str	r1, [r7]
1666:../Generated_Code/queue.c ****         if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 2205              		.loc 1 1666 0
 2206 000a 7B68     		ldr	r3, [r7, #4]
 2207 000c 1B68     		ldr	r3, [r3]
 2208 000e 002B     		cmp	r3, #0
 2209 0010 1AD0     		beq	.L148
1667:../Generated_Code/queue.c ****         {
1668:../Generated_Code/queue.c ****                 pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2210              		.loc 1 1668 0
 2211 0012 7B68     		ldr	r3, [r7, #4]
 2212 0014 DA68     		ldr	r2, [r3, #12]
 2213 0016 7B68     		ldr	r3, [r7, #4]
 2214 0018 1B6C     		ldr	r3, [r3, #64]
 2215 001a D218     		add	r2, r2, r3
 2216 001c 7B68     		ldr	r3, [r7, #4]
 2217 001e DA60     		str	r2, [r3, #12]
1669:../Generated_Code/queue.c ****                 if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justifi
 2218              		.loc 1 1669 0
 2219 0020 7B68     		ldr	r3, [r7, #4]
 2220 0022 DA68     		ldr	r2, [r3, #12]
 2221 0024 7B68     		ldr	r3, [r7, #4]
 2222 0026 5B68     		ldr	r3, [r3, #4]
 2223 0028 9A42     		cmp	r2, r3
 2224 002a 03D3     		bcc	.L150
1670:../Generated_Code/queue.c ****                 {
1671:../Generated_Code/queue.c ****                         pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2225              		.loc 1 1671 0
 2226 002c 7B68     		ldr	r3, [r7, #4]
 2227 002e 1A68     		ldr	r2, [r3]
 2228 0030 7B68     		ldr	r3, [r7, #4]
 2229 0032 DA60     		str	r2, [r3, #12]
 2230              	.L150:
1672:../Generated_Code/queue.c ****                 }
1673:../Generated_Code/queue.c ****                 else
1674:../Generated_Code/queue.c ****                 {
1675:../Generated_Code/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1676:../Generated_Code/queue.c ****                 }
1677:../Generated_Code/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) 
 2231              		.loc 1 1677 0
 2232 0034 7B68     		ldr	r3, [r7, #4]
 2233 0036 DA68     		ldr	r2, [r3, #12]
 2234 0038 7B68     		ldr	r3, [r7, #4]
 2235 003a 1B6C     		ldr	r3, [r3, #64]
 2236 003c 3968     		ldr	r1, [r7]
 2237 003e 081C     		mov	r0, r1
 2238 0040 111C     		mov	r1, r2
 2239 0042 1A1C     		mov	r2, r3
 2240 0044 FFF7FEFF 		bl	memcpy
 2241              	.L148:
1678:../Generated_Code/queue.c ****         }
1679:../Generated_Code/queue.c ****         else
1680:../Generated_Code/queue.c ****         {
1681:../Generated_Code/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1682:../Generated_Code/queue.c ****         }
1683:../Generated_Code/queue.c **** }
 2242              		.loc 1 1683 0
 2243 0048 BD46     		mov	sp, r7
 2244 004a 02B0     		add	sp, sp, #8
 2245              		@ sp needed for prologue
 2246 004c 80BD     		pop	{r7, pc}
 2247              		.cfi_endproc
 2248              	.LFE26:
 2250 004e C046     		.section	.text._ZL14prvUnlockQueueP15QueueDefinition,"ax",%progbits
 2251              		.align	2
 2252              		.code	16
 2253              		.thumb_func
 2255              	_ZL14prvUnlockQueueP15QueueDefinition:
 2256              	.LFB27:
1684:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1685:../Generated_Code/queue.c **** 
1686:../Generated_Code/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1687:../Generated_Code/queue.c **** {
 2257              		.loc 1 1687 0
 2258              		.cfi_startproc
 2259 0000 80B5     		push	{r7, lr}
 2260              	.LCFI54:
 2261              		.cfi_def_cfa_offset 8
 2262              		.cfi_offset 7, -8
 2263              		.cfi_offset 14, -4
 2264 0002 82B0     		sub	sp, sp, #8
 2265              	.LCFI55:
 2266              		.cfi_def_cfa_offset 16
 2267 0004 00AF     		add	r7, sp, #0
 2268              	.LCFI56:
 2269              		.cfi_def_cfa_register 7
 2270 0006 7860     		str	r0, [r7, #4]
1688:../Generated_Code/queue.c ****         /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1689:../Generated_Code/queue.c **** 
1690:../Generated_Code/queue.c ****         /* The lock counts contains the number of extra data items placed or
1691:../Generated_Code/queue.c ****         removed from the queue while the queue was locked.  When a queue is
1692:../Generated_Code/queue.c ****         locked items can be added or removed, but the event lists cannot be
1693:../Generated_Code/queue.c ****         updated. */
1694:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 2271              		.loc 1 1694 0
 2272 0008 FFF7FEFF 		bl	vPortEnterCritical
1695:../Generated_Code/queue.c ****         {
1696:../Generated_Code/queue.c ****                 /* See if data was added to the queue while it was locked. */
1697:../Generated_Code/queue.c ****                 while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2273              		.loc 1 1697 0
 2274 000c 15E0     		b	.L152
 2275              	.L156:
1698:../Generated_Code/queue.c ****                 {
1699:../Generated_Code/queue.c ****                         /* Data was posted while the queue was locked.  Are any tasks
1700:../Generated_Code/queue.c ****                         blocked waiting for data to become available? */
1701:../Generated_Code/queue.c ****                         #if ( configUSE_QUEUE_SETS == 1 )
1702:../Generated_Code/queue.c ****                         {
1703:../Generated_Code/queue.c ****                                 if( pxQueue->pxQueueSetContainer != NULL )
1704:../Generated_Code/queue.c ****                                 {
1705:../Generated_Code/queue.c ****                                         if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK 
1706:../Generated_Code/queue.c ****                                         {
1707:../Generated_Code/queue.c ****                                                 /* The queue is a member of a queue set, and postin
1708:../Generated_Code/queue.c ****                                                 the queue set caused a higher priority task to unbl
1709:../Generated_Code/queue.c ****                                                 A context switch is required. */
1710:../Generated_Code/queue.c ****                                                 vTaskMissedYield();
1711:../Generated_Code/queue.c ****                                         }
1712:../Generated_Code/queue.c ****                                         else
1713:../Generated_Code/queue.c ****                                         {
1714:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1715:../Generated_Code/queue.c ****                                         }
1716:../Generated_Code/queue.c ****                                 }
1717:../Generated_Code/queue.c ****                                 else
1718:../Generated_Code/queue.c ****                                 {
1719:../Generated_Code/queue.c ****                                         /* Tasks that are removed from the event list will get adde
1720:../Generated_Code/queue.c ****                                         the pending ready list as the scheduler is still suspended.
1721:../Generated_Code/queue.c ****                                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive )
1722:../Generated_Code/queue.c ****                                         {
1723:../Generated_Code/queue.c ****                                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWai
1724:../Generated_Code/queue.c ****                                                 {
1725:../Generated_Code/queue.c ****                                                         /* The task waiting has a higher priority s
1726:../Generated_Code/queue.c ****                                                         context switch is required. */
1727:../Generated_Code/queue.c ****                                                         vTaskMissedYield();
1728:../Generated_Code/queue.c ****                                                 }
1729:../Generated_Code/queue.c ****                                                 else
1730:../Generated_Code/queue.c ****                                                 {
1731:../Generated_Code/queue.c ****                                                         mtCOVERAGE_TEST_MARKER();
1732:../Generated_Code/queue.c ****                                                 }
1733:../Generated_Code/queue.c ****                                         }
1734:../Generated_Code/queue.c ****                                         else
1735:../Generated_Code/queue.c ****                                         {
1736:../Generated_Code/queue.c ****                                                 break;
1737:../Generated_Code/queue.c ****                                         }
1738:../Generated_Code/queue.c ****                                 }
1739:../Generated_Code/queue.c ****                         }
1740:../Generated_Code/queue.c ****                         #else /* configUSE_QUEUE_SETS */
1741:../Generated_Code/queue.c ****                         {
1742:../Generated_Code/queue.c ****                                 /* Tasks that are removed from the event list will get added to
1743:../Generated_Code/queue.c ****                                 the pending ready list as the scheduler is still suspended. */
1744:../Generated_Code/queue.c ****                                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pd
 2276              		.loc 1 1744 0
 2277 000e 7B68     		ldr	r3, [r7, #4]
 2278 0010 5B6A     		ldr	r3, [r3, #36]
 2279 0012 002B     		cmp	r3, #0
 2280 0014 1AD0     		beq	.L162
1745:../Generated_Code/queue.c ****                                 {
1746:../Generated_Code/queue.c ****                                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToRe
 2281              		.loc 1 1746 0
 2282 0016 7B68     		ldr	r3, [r7, #4]
 2283 0018 2433     		add	r3, r3, #36
 2284 001a 181C     		mov	r0, r3
 2285 001c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2286 0020 031C     		mov	r3, r0
 2287 0022 5A1E     		sub	r2, r3, #1
 2288 0024 9341     		sbc	r3, r3, r2
 2289 0026 DBB2     		uxtb	r3, r3
 2290 0028 002B     		cmp	r3, #0
 2291 002a 01D0     		beq	.L154
1747:../Generated_Code/queue.c ****                                         {
1748:../Generated_Code/queue.c ****                                                 /* The task waiting has a higher priority so record
1749:../Generated_Code/queue.c ****                                                 context switch is required. */
1750:../Generated_Code/queue.c ****                                                 vTaskMissedYield();
 2292              		.loc 1 1750 0
 2293 002c FFF7FEFF 		bl	vTaskMissedYield
 2294              	.L154:
1751:../Generated_Code/queue.c ****                                         }
1752:../Generated_Code/queue.c ****                                         else
1753:../Generated_Code/queue.c ****                                         {
1754:../Generated_Code/queue.c ****                                                 mtCOVERAGE_TEST_MARKER();
1755:../Generated_Code/queue.c ****                                         }
1756:../Generated_Code/queue.c ****                                 }
1757:../Generated_Code/queue.c ****                                 else
1758:../Generated_Code/queue.c ****                                 {
1759:../Generated_Code/queue.c ****                                         break;
1760:../Generated_Code/queue.c ****                                 }
1761:../Generated_Code/queue.c ****                         }
1762:../Generated_Code/queue.c ****                         #endif /* configUSE_QUEUE_SETS */
1763:../Generated_Code/queue.c **** 
1764:../Generated_Code/queue.c ****                         --( pxQueue->xTxLock );
 2295              		.loc 1 1764 0
 2296 0030 7B68     		ldr	r3, [r7, #4]
 2297 0032 9B6C     		ldr	r3, [r3, #72]
 2298 0034 5A1E     		sub	r2, r3, #1
 2299 0036 7B68     		ldr	r3, [r7, #4]
 2300 0038 9A64     		str	r2, [r3, #72]
 2301              	.L152:
1697:../Generated_Code/queue.c ****                 while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2302              		.loc 1 1697 0
 2303 003a 7B68     		ldr	r3, [r7, #4]
 2304 003c 9B6C     		ldr	r3, [r3, #72]
 2305 003e DA17     		asr	r2, r3, #31
 2306 0040 D31A     		sub	r3, r2, r3
 2307 0042 DB0F     		lsr	r3, r3, #31
 2308 0044 DBB2     		uxtb	r3, r3
 2309 0046 002B     		cmp	r3, #0
 2310 0048 E1D1     		bne	.L156
 2311 004a 00E0     		b	.L155
 2312              	.L162:
1759:../Generated_Code/queue.c ****                                         break;
 2313              		.loc 1 1759 0
 2314 004c C046     		mov	r8, r8
 2315              	.L155:
1765:../Generated_Code/queue.c ****                 }
1766:../Generated_Code/queue.c **** 
1767:../Generated_Code/queue.c ****                 pxQueue->xTxLock = queueUNLOCKED;
 2316              		.loc 1 1767 0
 2317 004e 7B68     		ldr	r3, [r7, #4]
 2318 0050 0122     		mov	r2, #1
 2319 0052 5242     		neg	r2, r2
 2320 0054 9A64     		str	r2, [r3, #72]
1768:../Generated_Code/queue.c ****         }
1769:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 2321              		.loc 1 1769 0
 2322 0056 FFF7FEFF 		bl	vPortExitCritical
1770:../Generated_Code/queue.c **** 
1771:../Generated_Code/queue.c ****         /* Do the same for the Rx lock. */
1772:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 2323              		.loc 1 1772 0
 2324 005a FFF7FEFF 		bl	vPortEnterCritical
1773:../Generated_Code/queue.c ****         {
1774:../Generated_Code/queue.c ****                 while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2325              		.loc 1 1774 0
 2326 005e 15E0     		b	.L157
 2327              	.L161:
1775:../Generated_Code/queue.c ****                 {
1776:../Generated_Code/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2328              		.loc 1 1776 0
 2329 0060 7B68     		ldr	r3, [r7, #4]
 2330 0062 1B69     		ldr	r3, [r3, #16]
 2331 0064 002B     		cmp	r3, #0
 2332 0066 1AD0     		beq	.L163
1777:../Generated_Code/queue.c ****                         {
1778:../Generated_Code/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) !
 2333              		.loc 1 1778 0
 2334 0068 7B68     		ldr	r3, [r7, #4]
 2335 006a 1033     		add	r3, r3, #16
 2336 006c 181C     		mov	r0, r3
 2337 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2338 0072 031C     		mov	r3, r0
 2339 0074 5A1E     		sub	r2, r3, #1
 2340 0076 9341     		sbc	r3, r3, r2
 2341 0078 DBB2     		uxtb	r3, r3
 2342 007a 002B     		cmp	r3, #0
 2343 007c 01D0     		beq	.L159
1779:../Generated_Code/queue.c ****                                 {
1780:../Generated_Code/queue.c ****                                         vTaskMissedYield();
 2344              		.loc 1 1780 0
 2345 007e FFF7FEFF 		bl	vTaskMissedYield
 2346              	.L159:
1781:../Generated_Code/queue.c ****                                 }
1782:../Generated_Code/queue.c ****                                 else
1783:../Generated_Code/queue.c ****                                 {
1784:../Generated_Code/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1785:../Generated_Code/queue.c ****                                 }
1786:../Generated_Code/queue.c **** 
1787:../Generated_Code/queue.c ****                                 --( pxQueue->xRxLock );
 2347              		.loc 1 1787 0
 2348 0082 7B68     		ldr	r3, [r7, #4]
 2349 0084 5B6C     		ldr	r3, [r3, #68]
 2350 0086 5A1E     		sub	r2, r3, #1
 2351 0088 7B68     		ldr	r3, [r7, #4]
 2352 008a 5A64     		str	r2, [r3, #68]
 2353              	.L157:
1774:../Generated_Code/queue.c ****                 while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2354              		.loc 1 1774 0
 2355 008c 7B68     		ldr	r3, [r7, #4]
 2356 008e 5B6C     		ldr	r3, [r3, #68]
 2357 0090 DA17     		asr	r2, r3, #31
 2358 0092 D31A     		sub	r3, r2, r3
 2359 0094 DB0F     		lsr	r3, r3, #31
 2360 0096 DBB2     		uxtb	r3, r3
 2361 0098 002B     		cmp	r3, #0
 2362 009a E1D1     		bne	.L161
 2363 009c 00E0     		b	.L160
 2364              	.L163:
1788:../Generated_Code/queue.c ****                         }
1789:../Generated_Code/queue.c ****                         else
1790:../Generated_Code/queue.c ****                         {
1791:../Generated_Code/queue.c ****                                 break;
 2365              		.loc 1 1791 0
 2366 009e C046     		mov	r8, r8
 2367              	.L160:
1792:../Generated_Code/queue.c ****                         }
1793:../Generated_Code/queue.c ****                 }
1794:../Generated_Code/queue.c **** 
1795:../Generated_Code/queue.c ****                 pxQueue->xRxLock = queueUNLOCKED;
 2368              		.loc 1 1795 0
 2369 00a0 7B68     		ldr	r3, [r7, #4]
 2370 00a2 0122     		mov	r2, #1
 2371 00a4 5242     		neg	r2, r2
 2372 00a6 5A64     		str	r2, [r3, #68]
1796:../Generated_Code/queue.c ****         }
1797:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 2373              		.loc 1 1797 0
 2374 00a8 FFF7FEFF 		bl	vPortExitCritical
1798:../Generated_Code/queue.c **** }
 2375              		.loc 1 1798 0
 2376 00ac BD46     		mov	sp, r7
 2377 00ae 02B0     		add	sp, sp, #8
 2378              		@ sp needed for prologue
 2379 00b0 80BD     		pop	{r7, pc}
 2380              		.cfi_endproc
 2381              	.LFE27:
 2383 00b2 C046     		.section	.text._ZL15prvIsQueueEmptyPK15QueueDefinition,"ax",%progbits
 2384              		.align	2
 2385              		.code	16
 2386              		.thumb_func
 2388              	_ZL15prvIsQueueEmptyPK15QueueDefinition:
 2389              	.LFB28:
1799:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1800:../Generated_Code/queue.c **** 
1801:../Generated_Code/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1802:../Generated_Code/queue.c **** {
 2390              		.loc 1 1802 0
 2391              		.cfi_startproc
 2392 0000 80B5     		push	{r7, lr}
 2393              	.LCFI57:
 2394              		.cfi_def_cfa_offset 8
 2395              		.cfi_offset 7, -8
 2396              		.cfi_offset 14, -4
 2397 0002 84B0     		sub	sp, sp, #16
 2398              	.LCFI58:
 2399              		.cfi_def_cfa_offset 24
 2400 0004 00AF     		add	r7, sp, #0
 2401              	.LCFI59:
 2402              		.cfi_def_cfa_register 7
 2403 0006 7860     		str	r0, [r7, #4]
 2404              	.LBB18:
1803:../Generated_Code/queue.c **** BaseType_t xReturn;
1804:../Generated_Code/queue.c **** 
1805:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 2405              		.loc 1 1805 0
 2406 0008 FFF7FEFF 		bl	vPortEnterCritical
1806:../Generated_Code/queue.c ****         {
1807:../Generated_Code/queue.c ****                 if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2407              		.loc 1 1807 0
 2408 000c 7B68     		ldr	r3, [r7, #4]
 2409 000e 9B6B     		ldr	r3, [r3, #56]
 2410 0010 5A42     		neg	r2, r3
 2411 0012 5341     		adc	r3, r3, r2
 2412 0014 DBB2     		uxtb	r3, r3
 2413 0016 002B     		cmp	r3, #0
 2414 0018 02D0     		beq	.L165
1808:../Generated_Code/queue.c ****                 {
1809:../Generated_Code/queue.c ****                         xReturn = pdTRUE;
 2415              		.loc 1 1809 0
 2416 001a 0123     		mov	r3, #1
 2417 001c FB60     		str	r3, [r7, #12]
 2418 001e 01E0     		b	.L166
 2419              	.L165:
1810:../Generated_Code/queue.c ****                 }
1811:../Generated_Code/queue.c ****                 else
1812:../Generated_Code/queue.c ****                 {
1813:../Generated_Code/queue.c ****                         xReturn = pdFALSE;
 2420              		.loc 1 1813 0
 2421 0020 0023     		mov	r3, #0
 2422 0022 FB60     		str	r3, [r7, #12]
 2423              	.L166:
1814:../Generated_Code/queue.c ****                 }
1815:../Generated_Code/queue.c ****         }
1816:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 2424              		.loc 1 1816 0
 2425 0024 FFF7FEFF 		bl	vPortExitCritical
1817:../Generated_Code/queue.c **** 
1818:../Generated_Code/queue.c ****         return xReturn;
 2426              		.loc 1 1818 0
 2427 0028 FB68     		ldr	r3, [r7, #12]
 2428              	.LBE18:
1819:../Generated_Code/queue.c **** }
 2429              		.loc 1 1819 0
 2430 002a 181C     		mov	r0, r3
 2431 002c BD46     		mov	sp, r7
 2432 002e 04B0     		add	sp, sp, #16
 2433              		@ sp needed for prologue
 2434 0030 80BD     		pop	{r7, pc}
 2435              		.cfi_endproc
 2436              	.LFE28:
 2438 0032 C046     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2439              		.align	2
 2440              		.global	xQueueIsQueueEmptyFromISR
 2441              		.code	16
 2442              		.thumb_func
 2444              	xQueueIsQueueEmptyFromISR:
 2445              	.LFB29:
1820:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1821:../Generated_Code/queue.c **** 
1822:../Generated_Code/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1823:../Generated_Code/queue.c **** {
 2446              		.loc 1 1823 0
 2447              		.cfi_startproc
 2448 0000 80B5     		push	{r7, lr}
 2449              	.LCFI60:
 2450              		.cfi_def_cfa_offset 8
 2451              		.cfi_offset 7, -8
 2452              		.cfi_offset 14, -4
 2453 0002 84B0     		sub	sp, sp, #16
 2454              	.LCFI61:
 2455              		.cfi_def_cfa_offset 24
 2456 0004 00AF     		add	r7, sp, #0
 2457              	.LCFI62:
 2458              		.cfi_def_cfa_register 7
 2459 0006 7860     		str	r0, [r7, #4]
 2460              	.LBB19:
1824:../Generated_Code/queue.c **** BaseType_t xReturn;
1825:../Generated_Code/queue.c **** 
1826:../Generated_Code/queue.c ****         configASSERT( xQueue );
 2461              		.loc 1 1826 0
 2462 0008 7B68     		ldr	r3, [r7, #4]
 2463 000a 002B     		cmp	r3, #0
 2464 000c 01D1     		bne	.L169
 2465              		.loc 1 1826 0 is_stmt 0
 2466              	@ 1826 "../Generated_Code/queue.c" 1
 2467 000e 72B6     		cpsid i
 2468              	@ 0 "" 2
 2469              		.code	16
 2470              	.L170:
 2471              		.loc 1 1826 0
 2472 0010 FEE7     		b	.L170
 2473              	.L169:
1827:../Generated_Code/queue.c ****         if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2474              		.loc 1 1827 0 is_stmt 1
 2475 0012 7B68     		ldr	r3, [r7, #4]
 2476 0014 9B6B     		ldr	r3, [r3, #56]
 2477 0016 5A42     		neg	r2, r3
 2478 0018 5341     		adc	r3, r3, r2
 2479 001a DBB2     		uxtb	r3, r3
 2480 001c 002B     		cmp	r3, #0
 2481 001e 02D0     		beq	.L171
1828:../Generated_Code/queue.c ****         {
1829:../Generated_Code/queue.c ****                 xReturn = pdTRUE;
 2482              		.loc 1 1829 0
 2483 0020 0123     		mov	r3, #1
 2484 0022 FB60     		str	r3, [r7, #12]
 2485 0024 01E0     		b	.L172
 2486              	.L171:
1830:../Generated_Code/queue.c ****         }
1831:../Generated_Code/queue.c ****         else
1832:../Generated_Code/queue.c ****         {
1833:../Generated_Code/queue.c ****                 xReturn = pdFALSE;
 2487              		.loc 1 1833 0
 2488 0026 0023     		mov	r3, #0
 2489 0028 FB60     		str	r3, [r7, #12]
 2490              	.L172:
1834:../Generated_Code/queue.c ****         }
1835:../Generated_Code/queue.c **** 
1836:../Generated_Code/queue.c ****         return xReturn;
 2491              		.loc 1 1836 0
 2492 002a FB68     		ldr	r3, [r7, #12]
 2493              	.LBE19:
1837:../Generated_Code/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2494              		.loc 1 1837 0
 2495 002c 181C     		mov	r0, r3
 2496 002e BD46     		mov	sp, r7
 2497 0030 04B0     		add	sp, sp, #16
 2498              		@ sp needed for prologue
 2499 0032 80BD     		pop	{r7, pc}
 2500              		.cfi_endproc
 2501              	.LFE29:
 2503              		.section	.text._ZL14prvIsQueueFullPK15QueueDefinition,"ax",%progbits
 2504              		.align	2
 2505              		.code	16
 2506              		.thumb_func
 2508              	_ZL14prvIsQueueFullPK15QueueDefinition:
 2509              	.LFB30:
1838:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1839:../Generated_Code/queue.c **** 
1840:../Generated_Code/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1841:../Generated_Code/queue.c **** {
 2510              		.loc 1 1841 0
 2511              		.cfi_startproc
 2512 0000 80B5     		push	{r7, lr}
 2513              	.LCFI63:
 2514              		.cfi_def_cfa_offset 8
 2515              		.cfi_offset 7, -8
 2516              		.cfi_offset 14, -4
 2517 0002 84B0     		sub	sp, sp, #16
 2518              	.LCFI64:
 2519              		.cfi_def_cfa_offset 24
 2520 0004 00AF     		add	r7, sp, #0
 2521              	.LCFI65:
 2522              		.cfi_def_cfa_register 7
 2523 0006 7860     		str	r0, [r7, #4]
 2524              	.LBB20:
1842:../Generated_Code/queue.c **** BaseType_t xReturn;
1843:../Generated_Code/queue.c **** 
1844:../Generated_Code/queue.c ****         taskENTER_CRITICAL();
 2525              		.loc 1 1844 0
 2526 0008 FFF7FEFF 		bl	vPortEnterCritical
1845:../Generated_Code/queue.c ****         {
1846:../Generated_Code/queue.c ****                 if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2527              		.loc 1 1846 0
 2528 000c 7B68     		ldr	r3, [r7, #4]
 2529 000e 9A6B     		ldr	r2, [r3, #56]
 2530 0010 7B68     		ldr	r3, [r7, #4]
 2531 0012 DB6B     		ldr	r3, [r3, #60]
 2532 0014 D31A     		sub	r3, r2, r3
 2533 0016 5A42     		neg	r2, r3
 2534 0018 5341     		adc	r3, r3, r2
 2535 001a DBB2     		uxtb	r3, r3
 2536 001c 002B     		cmp	r3, #0
 2537 001e 02D0     		beq	.L175
1847:../Generated_Code/queue.c ****                 {
1848:../Generated_Code/queue.c ****                         xReturn = pdTRUE;
 2538              		.loc 1 1848 0
 2539 0020 0123     		mov	r3, #1
 2540 0022 FB60     		str	r3, [r7, #12]
 2541 0024 01E0     		b	.L176
 2542              	.L175:
1849:../Generated_Code/queue.c ****                 }
1850:../Generated_Code/queue.c ****                 else
1851:../Generated_Code/queue.c ****                 {
1852:../Generated_Code/queue.c ****                         xReturn = pdFALSE;
 2543              		.loc 1 1852 0
 2544 0026 0023     		mov	r3, #0
 2545 0028 FB60     		str	r3, [r7, #12]
 2546              	.L176:
1853:../Generated_Code/queue.c ****                 }
1854:../Generated_Code/queue.c ****         }
1855:../Generated_Code/queue.c ****         taskEXIT_CRITICAL();
 2547              		.loc 1 1855 0
 2548 002a FFF7FEFF 		bl	vPortExitCritical
1856:../Generated_Code/queue.c **** 
1857:../Generated_Code/queue.c ****         return xReturn;
 2549              		.loc 1 1857 0
 2550 002e FB68     		ldr	r3, [r7, #12]
 2551              	.LBE20:
1858:../Generated_Code/queue.c **** }
 2552              		.loc 1 1858 0
 2553 0030 181C     		mov	r0, r3
 2554 0032 BD46     		mov	sp, r7
 2555 0034 04B0     		add	sp, sp, #16
 2556              		@ sp needed for prologue
 2557 0036 80BD     		pop	{r7, pc}
 2558              		.cfi_endproc
 2559              	.LFE30:
 2561              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2562              		.align	2
 2563              		.global	xQueueIsQueueFullFromISR
 2564              		.code	16
 2565              		.thumb_func
 2567              	xQueueIsQueueFullFromISR:
 2568              	.LFB31:
1859:../Generated_Code/queue.c **** /*-----------------------------------------------------------*/
1860:../Generated_Code/queue.c **** 
1861:../Generated_Code/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1862:../Generated_Code/queue.c **** {
 2569              		.loc 1 1862 0
 2570              		.cfi_startproc
 2571 0000 80B5     		push	{r7, lr}
 2572              	.LCFI66:
 2573              		.cfi_def_cfa_offset 8
 2574              		.cfi_offset 7, -8
 2575              		.cfi_offset 14, -4
 2576 0002 84B0     		sub	sp, sp, #16
 2577              	.LCFI67:
 2578              		.cfi_def_cfa_offset 24
 2579 0004 00AF     		add	r7, sp, #0
 2580              	.LCFI68:
 2581              		.cfi_def_cfa_register 7
 2582 0006 7860     		str	r0, [r7, #4]
 2583              	.LBB21:
1863:../Generated_Code/queue.c **** BaseType_t xReturn;
1864:../Generated_Code/queue.c **** 
1865:../Generated_Code/queue.c ****         configASSERT( xQueue );
 2584              		.loc 1 1865 0
 2585 0008 7B68     		ldr	r3, [r7, #4]
 2586 000a 002B     		cmp	r3, #0
 2587 000c 01D1     		bne	.L179
 2588              		.loc 1 1865 0 is_stmt 0
 2589              	@ 1865 "../Generated_Code/queue.c" 1
 2590 000e 72B6     		cpsid i
 2591              	@ 0 "" 2
 2592              		.code	16
 2593              	.L180:
 2594              		.loc 1 1865 0
 2595 0010 FEE7     		b	.L180
 2596              	.L179:
1866:../Generated_Code/queue.c ****         if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2597              		.loc 1 1866 0 is_stmt 1
 2598 0012 7B68     		ldr	r3, [r7, #4]
 2599 0014 9A6B     		ldr	r2, [r3, #56]
 2600 0016 7B68     		ldr	r3, [r7, #4]
 2601 0018 DB6B     		ldr	r3, [r3, #60]
 2602 001a D31A     		sub	r3, r2, r3
 2603 001c 5A42     		neg	r2, r3
 2604 001e 5341     		adc	r3, r3, r2
 2605 0020 DBB2     		uxtb	r3, r3
 2606 0022 002B     		cmp	r3, #0
 2607 0024 02D0     		beq	.L181
1867:../Generated_Code/queue.c ****         {
1868:../Generated_Code/queue.c ****                 xReturn = pdTRUE;
 2608              		.loc 1 1868 0
 2609 0026 0123     		mov	r3, #1
 2610 0028 FB60     		str	r3, [r7, #12]
 2611 002a 01E0     		b	.L182
 2612              	.L181:
1869:../Generated_Code/queue.c ****         }
1870:../Generated_Code/queue.c ****         else
1871:../Generated_Code/queue.c ****         {
1872:../Generated_Code/queue.c ****                 xReturn = pdFALSE;
 2613              		.loc 1 1872 0
 2614 002c 0023     		mov	r3, #0
 2615 002e FB60     		str	r3, [r7, #12]
 2616              	.L182:
1873:../Generated_Code/queue.c ****         }
1874:../Generated_Code/queue.c **** 
1875:../Generated_Code/queue.c ****         return xReturn;
 2617              		.loc 1 1875 0
 2618 0030 FB68     		ldr	r3, [r7, #12]
 2619              	.LBE21:
1876:../Generated_Code/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2620              		.loc 1 1876 0
 2621 0032 181C     		mov	r0, r3
 2622 0034 BD46     		mov	sp, r7
 2623 0036 04B0     		add	sp, sp, #16
 2624              		@ sp needed for prologue
 2625 0038 80BD     		pop	{r7, pc}
 2626              		.cfi_endproc
 2627              	.LFE31:
 2629 003a C046     		.text
 2630              	.Letext0:
 2631              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 2632              		.file 3 "../Generated_Code/portmacro.h"
 2633              		.file 4 "../Generated_Code/list.h"
 2634              		.file 5 "../Generated_Code/task.h"
 2635              		.file 6 "../Generated_Code/queue.h"
 2636              		.file 7 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:18     .text.xQueueGenericReset:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:23     .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:153    .text.xQueueGenericCreate:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:158    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:261    .text.xQueueCreateMutex:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:266    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:715    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:376    .text.xQueueGetMutexHolder:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:381    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:430    .text.xQueueGiveMutexRecursive:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:435    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:521    .text.xQueueTakeMutexRecursive:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:526    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1204   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:617    .text.xQueueCreateCountingSemaphore:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:622    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:710    .text.xQueueGenericSend:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2039   .text._ZL18prvCopyDataToQueueP15QueueDefinitionPKvl:00000000 _ZL18prvCopyDataToQueueP15QueueDefinitionPKvl
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2508   .text._ZL14prvIsQueueFullPK15QueueDefinition:00000000 _ZL14prvIsQueueFullPK15QueueDefinition
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2255   .text._ZL14prvUnlockQueueP15QueueDefinition:00000000 _ZL14prvUnlockQueueP15QueueDefinition
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1016   .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1021   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1199   .text.xQueueGenericReceive:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2188   .text._ZL20prvCopyDataFromQueueP15QueueDefinitionPv:00000000 _ZL20prvCopyDataFromQueueP15QueueDefinitionPv
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2388   .text._ZL15prvIsQueueEmptyPK15QueueDefinition:00000000 _ZL15prvIsQueueEmptyPK15QueueDefinition
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1535   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1540   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1689   .text.xQueuePeekFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1694   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1802   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1807   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1858   .text.uxQueueSpacesAvailable:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1863   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1920   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1925   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1972   .text.vQueueDelete:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:1977   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2035   .text._ZL18prvCopyDataToQueueP15QueueDefinitionPKvl:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2184   .text._ZL20prvCopyDataFromQueueP15QueueDefinitionPv:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2251   .text._ZL14prvUnlockQueueP15QueueDefinition:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2384   .text._ZL15prvIsQueueEmptyPK15QueueDefinition:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2439   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2444   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2504   .text._ZL14prvIsQueueFullPK15QueueDefinition:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2562   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccfndWE8.s:2567   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vListInitialise
vPortExitCritical
pvPortMalloc
vPortFree
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
