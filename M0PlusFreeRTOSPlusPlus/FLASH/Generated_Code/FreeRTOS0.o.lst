   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"FreeRTOS0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text._Z14FreeRTOS0_Initv,"ax",%progbits
  18              		.align	2
  19              		.global	_Z14FreeRTOS0_Initv
  20              		.code	16
  21              		.thumb_func
  23              	_Z14FreeRTOS0_Initv:
  24              	.LFB5:
  25              		.file 1 "../Generated_Code/FreeRTOS0.c"
   1:../Generated_Code/FreeRTOS0.c **** /* ###################################################################
   2:../Generated_Code/FreeRTOS0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/FreeRTOS0.c **** **     Filename    : FreeRTOS0.c
   4:../Generated_Code/FreeRTOS0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/FreeRTOS0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/FreeRTOS0.c **** **     Component   : FreeRTOS
   7:../Generated_Code/FreeRTOS0.c **** **     Version     : Component 01.360, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/FreeRTOS0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/FreeRTOS0.c **** **     Date/Time   : 2014-04-05, 15:28, # CodeGen: 4
  10:../Generated_Code/FreeRTOS0.c **** **     Abstract    :
  11:../Generated_Code/FreeRTOS0.c **** **          This component implements the FreeRTOS Realtime Operating System
  12:../Generated_Code/FreeRTOS0.c **** **     Settings    :
  13:../Generated_Code/FreeRTOS0.c **** **          Component name                                 : FreeRTOS0
  14:../Generated_Code/FreeRTOS0.c **** **          RTOS Version                                   : V8.0.0
  15:../Generated_Code/FreeRTOS0.c **** **          Custom Port                                    : Custom port settings
  16:../Generated_Code/FreeRTOS0.c **** **            Compiler                                     : automatic
  17:../Generated_Code/FreeRTOS0.c **** **            Static Sources                               : Disabled
  18:../Generated_Code/FreeRTOS0.c **** **            Custom portBASE_TYPE                         : Disabled
  19:../Generated_Code/FreeRTOS0.c **** **          Classic CodeWarrior                            : no
  20:../Generated_Code/FreeRTOS0.c **** **          Disabled Interrupts in Startup                 : yes
  21:../Generated_Code/FreeRTOS0.c **** **          Application Task Tags                          : no
  22:../Generated_Code/FreeRTOS0.c **** **          Use Trace Facility                             : no
  23:../Generated_Code/FreeRTOS0.c **** **          Trace Hooks                                    : Disabled
  24:../Generated_Code/FreeRTOS0.c **** **          Collect Runtime Statistics                     : Disabled
  25:../Generated_Code/FreeRTOS0.c **** **          Scheduler                                      : Settings for the scheduler
  26:../Generated_Code/FreeRTOS0.c **** **            ColdFire V1                                  : Disabled
  27:../Generated_Code/FreeRTOS0.c **** **            ColdFire V2                                  : Disabled
  28:../Generated_Code/FreeRTOS0.c **** **            Kinetis                                      : Enabled
  29:../Generated_Code/FreeRTOS0.c **** **              ARM Family                                 : Cortex M0+
  30:../Generated_Code/FreeRTOS0.c **** **              Floating Point Support                     : no
  31:../Generated_Code/FreeRTOS0.c **** **              Max SysCall Interrupt Priority             : 3
  32:../Generated_Code/FreeRTOS0.c **** **              RTOS Interrupt Priority                    : 3
  33:../Generated_Code/FreeRTOS0.c **** **              Lowest Interrupt Priority                  : 3
  34:../Generated_Code/FreeRTOS0.c **** **              Compiler Optimization Level                : 0
  35:../Generated_Code/FreeRTOS0.c **** **              SysTick                                    : Enabled
  36:../Generated_Code/FreeRTOS0.c **** **                Core Clock                               : yes
  37:../Generated_Code/FreeRTOS0.c **** **              Low Power Timer                            : Disabled
  38:../Generated_Code/FreeRTOS0.c **** **            non-LDD SWI                                  : Disabled
  39:../Generated_Code/FreeRTOS0.c **** **            Preemptive                                   : yes
  40:../Generated_Code/FreeRTOS0.c **** **            Use Co-Routines                              : no
  41:../Generated_Code/FreeRTOS0.c **** **            Idle should yield                            : yes
  42:../Generated_Code/FreeRTOS0.c **** **            Task Name Length                             : 25
  43:../Generated_Code/FreeRTOS0.c **** **            Minimal Stack Size                           : 200
  44:../Generated_Code/FreeRTOS0.c **** **            Maximum Priorities                           : 6
  45:../Generated_Code/FreeRTOS0.c **** **            Maximum Coroutine Priorities                 : 2
  46:../Generated_Code/FreeRTOS0.c **** **            Stackoverflow checking method                : Method 1
  47:../Generated_Code/FreeRTOS0.c **** **            Cleanup Resources                            : yes
  48:../Generated_Code/FreeRTOS0.c **** **          Ticks                                          : Settings for the periodic tick timer
  49:../Generated_Code/FreeRTOS0.c **** **            Tickless Idle Mode                           : Disabled
  50:../Generated_Code/FreeRTOS0.c **** **            Tick Rate (Hz)                               : 100
  51:../Generated_Code/FreeRTOS0.c **** **            Use 16bit ticks                              : no
  52:../Generated_Code/FreeRTOS0.c **** **            non-LDD Tick                                 : Disabled
  53:../Generated_Code/FreeRTOS0.c **** **            LDD Tick                                     : Disabled
  54:../Generated_Code/FreeRTOS0.c **** **          Queues                                         : Settings for Queues
  55:../Generated_Code/FreeRTOS0.c **** **            Queue Registry Size                          : 0
  56:../Generated_Code/FreeRTOS0.c **** **            Queue Sets                                   : no
  57:../Generated_Code/FreeRTOS0.c **** **          Semaphores and Mutexes                         : Settings for Mutex and Semaphore
  58:../Generated_Code/FreeRTOS0.c **** **            Use Mutexes                                  : yes
  59:../Generated_Code/FreeRTOS0.c **** **            Use Recursive Mutexes                        : yes
  60:../Generated_Code/FreeRTOS0.c **** **          Timers                                         : Disabled
  61:../Generated_Code/FreeRTOS0.c **** **          Memory                                         : Settings for the memory and heap alloc
  62:../Generated_Code/FreeRTOS0.c **** **            Memory Allocation Scheme                     : Scheme 2
  63:../Generated_Code/FreeRTOS0.c **** **            User Heap Section                            : Disabled
  64:../Generated_Code/FreeRTOS0.c **** **            Total Heap Size                              : 5000
  65:../Generated_Code/FreeRTOS0.c **** **          Shell                                          : Disabled
  66:../Generated_Code/FreeRTOS0.c **** **          Utility                                        : UTIL0
  67:../Generated_Code/FreeRTOS0.c **** **     Contents    :
  68:../Generated_Code/FreeRTOS0.c **** **         xTaskCreate                    - portBASE_TYPE FreeRTOS0_xTaskCreate(pdTASK_CODE pvTaskC
  69:../Generated_Code/FreeRTOS0.c **** **         vTaskStartScheduler            - void FreeRTOS0_vTaskStartScheduler(void);
  70:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspend                   - void FreeRTOS0_vTaskSuspend(xTaskHandle pxTaskToSuspend
  71:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspendAll                - void FreeRTOS0_vTaskSuspendAll(void);
  72:../Generated_Code/FreeRTOS0.c **** **         vTaskResume                    - void FreeRTOS0_vTaskResume(xTaskHandle pxTaskToResume);
  73:../Generated_Code/FreeRTOS0.c **** **         xTaskResumeAll                 - portBASE_TYPE FreeRTOS0_xTaskResumeAll(void);
  74:../Generated_Code/FreeRTOS0.c **** **         xTaskResumeFromISR             - portBASE_TYPE FreeRTOS0_xTaskResumeFromISR(xTaskHandle 
  75:../Generated_Code/FreeRTOS0.c **** **         taskYIELD                      - void FreeRTOS0_taskYIELD(void);
  76:../Generated_Code/FreeRTOS0.c **** **         taskENTER_CRITICAL             - void FreeRTOS0_taskENTER_CRITICAL(void);
  77:../Generated_Code/FreeRTOS0.c **** **         taskEXIT_CRITICAL              - void FreeRTOS0_taskEXIT_CRITICAL(void);
  78:../Generated_Code/FreeRTOS0.c **** **         taskDISABLE_INTERRUPTS         - void FreeRTOS0_taskDISABLE_INTERRUPTS(void);
  79:../Generated_Code/FreeRTOS0.c **** **         taskENABLE_INTERRUPTS          - void FreeRTOS0_taskENABLE_INTERRUPTS(void);
  80:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay                     - void FreeRTOS0_vTaskDelay(portTickType xTicksToDelay);
  81:../Generated_Code/FreeRTOS0.c **** **         vTaskDelayUntil                - void FreeRTOS0_vTaskDelayUntil(portTickType *pxPrevious
  82:../Generated_Code/FreeRTOS0.c **** **         uxTaskPriorityGet              - unsigned_portBASE_TYPE FreeRTOS0_uxTaskPriorityGet(xTas
  83:../Generated_Code/FreeRTOS0.c **** **         vTaskPrioritySet               - void FreeRTOS0_vTaskPrioritySet(xTaskHandle pxTask, uns
  84:../Generated_Code/FreeRTOS0.c **** **         xTaskGetTickCount              - portTickType FreeRTOS0_xTaskGetTickCount(void);
  85:../Generated_Code/FreeRTOS0.c **** **         xTaskGetTickCountFromISR       - portTickType FreeRTOS0_xTaskGetTickCountFromISR(void);
  86:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateRecursiveMutex - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateRecursiveMut
  87:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive        - bool FreeRTOS0_xSemaphoreTakeRecursive(xSemaphoreHandle
  88:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive        - bool FreeRTOS0_xSemaphoreGiveRecursive(xSemaphoreHandle
  89:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex          - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateMutex(void);
  90:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake                 - bool FreeRTOS0_xSemaphoreTake(xSemaphoreHandle xMutex, 
  91:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGive                 - bool FreeRTOS0_xSemaphoreGive(xSemaphoreHandle xMutex);
  92:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary         - void FreeRTOS0_vSemaphoreCreateBinary(xSemaphoreHandle 
  93:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting       - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateCounting(uns
  94:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR          - bool FreeRTOS0_xSemaphoreGiveFromISR(xSemaphoreHandle x
  95:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeFromISR          - bool FreeRTOS0_xSemaphoreTakeFromISR(xSemaphoreHandle x
  96:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreDelete               - void FreeRTOS0_vSemaphoreDelete(xSemaphoreHandle xSemap
  97:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGetMutexHolder       - void* FreeRTOS0_xSemaphoreGetMutexHolder(xSemaphoreHand
  98:../Generated_Code/FreeRTOS0.c **** **         pvPortMalloc                   - pVoid FreeRTOS0_pvPortMalloc(size_t xWantedSize);
  99:../Generated_Code/FreeRTOS0.c **** **         vPortFree                      - void FreeRTOS0_vPortFree(void *pv);
 100:../Generated_Code/FreeRTOS0.c **** **         xPortGetFreeHeapSize           - Tsize_t FreeRTOS0_xPortGetFreeHeapSize(void);
 101:../Generated_Code/FreeRTOS0.c **** **         xTaskGetSchedulerState         - portBASE_TYPE FreeRTOS0_xTaskGetSchedulerState(void);
 102:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetStackHighWaterMark    - unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetStackHighWate
 103:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetNumberOfTasks         - unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetNumberOfTasks
 104:../Generated_Code/FreeRTOS0.c **** **         uxQueueMessagesWaiting         - unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting
 105:../Generated_Code/FreeRTOS0.c **** **         uxQueueMessagesWaitingfromISR  - unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting
 106:../Generated_Code/FreeRTOS0.c **** **         xQueueCreate                   - xQueueHandle FreeRTOS0_xQueueCreate(unsigned_portBASE_T
 107:../Generated_Code/FreeRTOS0.c **** **         vQueueDelete                   - void FreeRTOS0_vQueueDelete(xQueueHandle pxQueueToDelet
 108:../Generated_Code/FreeRTOS0.c **** **         xQueueReset                    - portBASE_TYPE FreeRTOS0_xQueueReset(xQueueHandle xQueue
 109:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToBack               - portBASE_TYPE FreeRTOS0_xQueueSendToBack(xQueueHandle x
 110:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToFront              - portBASE_TYPE FreeRTOS0_xQueueSendToFront(xQueueHandle 
 111:../Generated_Code/FreeRTOS0.c **** **         xQueueReceive                  - portBASE_TYPE FreeRTOS0_xQueueReceive(xQueueHandle xQue
 112:../Generated_Code/FreeRTOS0.c **** **         xQueueOverwrite                - portBASE_TYPE FreeRTOS0_xQueueOverwrite(xQueueHandle xQ
 113:../Generated_Code/FreeRTOS0.c **** **         xQueueOverwriteFromISR         - portBASE_TYPE FreeRTOS0_xQueueOverwriteFromISR(xQueueHa
 114:../Generated_Code/FreeRTOS0.c **** **         xQueuePeek                     - portBASE_TYPE FreeRTOS0_xQueuePeek(xQueueHandle xQueue,
 115:../Generated_Code/FreeRTOS0.c **** **         xQueuePeekFromISR              - portBASE_TYPE FreeRTOS0_xQueuePeekFromISR(xQueueHandle 
 116:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToBackFromISR        - portBASE_TYPE FreeRTOS0_xQueueSendToBackFromISR(xQueueH
 117:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToFrontFromISR       - portBASE_TYPE FreeRTOS0_xQueueSendToFrontFromISR(xQueue
 118:../Generated_Code/FreeRTOS0.c **** **         xQueueReceiveFromISR           - portBASE_TYPE FreeRTOS0_xQueueReceiveFromISR(xQueueHand
 119:../Generated_Code/FreeRTOS0.c **** **         vQueueAddToRegistry            - void FreeRTOS0_vQueueAddToRegistry(xQueueHandle xQueue,
 120:../Generated_Code/FreeRTOS0.c **** **         vQueueUnregisterQueue          - void FreeRTOS0_vQueueUnregisterQueue(xQueueHandle xQueu
 121:../Generated_Code/FreeRTOS0.c **** **         xQueueIsQueueFullFromISR       - portBASE_TYPE FreeRTOS0_xQueueIsQueueFullFromISR(xQueue
 122:../Generated_Code/FreeRTOS0.c **** **         xQueueIsQueueEmptyFromISR      - portBASE_TYPE FreeRTOS0_xQueueIsQueueEmptyFromISR(xQueu
 123:../Generated_Code/FreeRTOS0.c **** **         xEventGroupCreate              - EventGroupHandle_t FreeRTOS0_xEventGroupCreate(void);
 124:../Generated_Code/FreeRTOS0.c **** **         xEventGroupWaitBits            - byte FreeRTOS0_xEventGroupWaitBits(const EventGroupHand
 125:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSetBits             - EventBits_t FreeRTOS0_xEventGroupSetBits(EventGroupHand
 126:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSetBitsFromISR      - EventBits_t FreeRTOS0_xEventGroupSetBitsFromISR(EventGr
 127:../Generated_Code/FreeRTOS0.c **** **         xEventGroupClearBits           - EventBits_t FreeRTOS0_xEventGroupClearBits(EventGroupHa
 128:../Generated_Code/FreeRTOS0.c **** **         xEventGroupClearBitsFromISR    - EventBits_t FreeRTOS0_xEventGroupClearBitsFromISR(Event
 129:../Generated_Code/FreeRTOS0.c **** **         xEventGroupGetBits             - EventBits_t FreeRTOS0_xEventGroupGetBits(EventGroupHand
 130:../Generated_Code/FreeRTOS0.c **** **         xEventGroupGetBitsFromISR      - EventBits_t FreeRTOS0_xEventGroupGetBitsFromISR(EventGr
 131:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSync                - EventBits_t FreeRTOS0_xEventGroupSync(EventGroupHandle_
 132:../Generated_Code/FreeRTOS0.c **** **         Init                           - void FreeRTOS0_Init(void);
 133:../Generated_Code/FreeRTOS0.c **** **
 134:../Generated_Code/FreeRTOS0.c **** **     License : Open Source (LGPL)
 135:../Generated_Code/FreeRTOS0.c **** **     FreeRTOS (c) Copyright 2003-2014 Richard Barry, http: www.FreeRTOS.org
 136:../Generated_Code/FreeRTOS0.c **** **     FreeRTOS Processor Expert Component: (c) Copyright Erich Styger, 2013
 137:../Generated_Code/FreeRTOS0.c **** **     Processor Expert and CodeWarrior (c) Copyright Freescale Semiconductor, 2013, all rights res
 138:../Generated_Code/FreeRTOS0.c **** **     This is a free software and is opened for education, research and commercial developments un
 139:../Generated_Code/FreeRTOS0.c **** **     * This is a free software and there is NO WARRANTY.
 140:../Generated_Code/FreeRTOS0.c **** **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or
 141:../Generated_Code/FreeRTOS0.c **** **     * Redistributions of source code must retain the above copyright notice.
 142:../Generated_Code/FreeRTOS0.c **** ** ###################################################################*/
 143:../Generated_Code/FreeRTOS0.c **** /*!
 144:../Generated_Code/FreeRTOS0.c **** ** @file FreeRTOS0.c
 145:../Generated_Code/FreeRTOS0.c **** ** @version 01.00
 146:../Generated_Code/FreeRTOS0.c **** ** @brief
 147:../Generated_Code/FreeRTOS0.c **** **          This component implements the FreeRTOS Realtime Operating System
 148:../Generated_Code/FreeRTOS0.c **** */         
 149:../Generated_Code/FreeRTOS0.c **** /*!
 150:../Generated_Code/FreeRTOS0.c **** **  @addtogroup FreeRTOS0_module FreeRTOS0 module documentation
 151:../Generated_Code/FreeRTOS0.c **** **  @{
 152:../Generated_Code/FreeRTOS0.c **** */         
 153:../Generated_Code/FreeRTOS0.c **** 
 154:../Generated_Code/FreeRTOS0.c **** /* MODULE FreeRTOS0. */
 155:../Generated_Code/FreeRTOS0.c **** 
 156:../Generated_Code/FreeRTOS0.c **** #include "Events.h"
 157:../Generated_Code/FreeRTOS0.c **** #include "FreeRTOS0.h"
 158:../Generated_Code/FreeRTOS0.c **** #include "portTicks.h"                 /* interface to tick counter */
 159:../Generated_Code/FreeRTOS0.c **** 
 160:../Generated_Code/FreeRTOS0.c **** 
 161:../Generated_Code/FreeRTOS0.c **** /*
 162:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 163:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskCreate (component FreeRTOS)
 164:../Generated_Code/FreeRTOS0.c **** **     Description :
 165:../Generated_Code/FreeRTOS0.c **** **         Create a new task and add it to the list of tasks that are
 166:../Generated_Code/FreeRTOS0.c **** **         ready to run.
 167:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 168:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 169:../Generated_Code/FreeRTOS0.c **** **         pvTaskCode      - Pointer to the task entry
 170:../Generated_Code/FreeRTOS0.c **** **                           function. Tasks must be implemented to
 171:../Generated_Code/FreeRTOS0.c **** **                           never return (i.e. continuous loop).
 172:../Generated_Code/FreeRTOS0.c **** **         pcName          - A descriptive name for the task.
 173:../Generated_Code/FreeRTOS0.c **** **                           This is mainly used to facilitate debugging.
 174:../Generated_Code/FreeRTOS0.c **** **                           Max length defined by
 175:../Generated_Code/FreeRTOS0.c **** **                           configMAX_TASK_NAME_LEN.
 176:../Generated_Code/FreeRTOS0.c **** **         usStackDepth    - The size of the task
 177:../Generated_Code/FreeRTOS0.c **** **                           stack specified as the number of variables
 178:../Generated_Code/FreeRTOS0.c **** **                           the stack can hold - not the number of
 179:../Generated_Code/FreeRTOS0.c **** **                           bytes. For example, if the stack is 16 bits
 180:../Generated_Code/FreeRTOS0.c **** **                           wide and usStackDepth is defined as 100,
 181:../Generated_Code/FreeRTOS0.c **** **                           200 bytes will be allocated for stack
 182:../Generated_Code/FreeRTOS0.c **** **                           storage. The stack depth multiplied by the
 183:../Generated_Code/FreeRTOS0.c **** **                           stack width must not exceed the maximum
 184:../Generated_Code/FreeRTOS0.c **** **                           value that can be contained in a variable
 185:../Generated_Code/FreeRTOS0.c **** **                           of type size_t.
 186:../Generated_Code/FreeRTOS0.c **** **         pvParameters    - Pointer that will be
 187:../Generated_Code/FreeRTOS0.c **** **                           used as the parameter for the task being
 188:../Generated_Code/FreeRTOS0.c **** **                           created.
 189:../Generated_Code/FreeRTOS0.c **** **         uxPriority      - The priority at which the
 190:../Generated_Code/FreeRTOS0.c **** **                           task should run.
 191:../Generated_Code/FreeRTOS0.c **** **         pvCreatedTask   - Used to pass back a
 192:../Generated_Code/FreeRTOS0.c **** **                           handle by which the created task can be
 193:../Generated_Code/FreeRTOS0.c **** **                           referenced.
 194:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 195:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS if the task was successfully
 196:../Generated_Code/FreeRTOS0.c **** **                           created and added to a ready list,
 197:../Generated_Code/FreeRTOS0.c **** **                           otherwise an error code defined in the file
 198:../Generated_Code/FreeRTOS0.c **** **                           projdefs.h
 199:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 200:../Generated_Code/FreeRTOS0.c **** */
 201:../Generated_Code/FreeRTOS0.c **** /*
 202:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned
 203:../Generated_Code/FreeRTOS0.c **** {
 204:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 205:../Generated_Code/FreeRTOS0.c **** }
 206:../Generated_Code/FreeRTOS0.c **** */
 207:../Generated_Code/FreeRTOS0.c **** 
 208:../Generated_Code/FreeRTOS0.c **** /*
 209:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 210:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskStartScheduler (component FreeRTOS)
 211:../Generated_Code/FreeRTOS0.c **** **     Description :
 212:../Generated_Code/FreeRTOS0.c **** **         Starts the real time kernel tick processing. After calling
 213:../Generated_Code/FreeRTOS0.c **** **         the kernel has control over which tasks are executed and
 214:../Generated_Code/FreeRTOS0.c **** **         when.
 215:../Generated_Code/FreeRTOS0.c **** **         The idle task is created automatically when
 216:../Generated_Code/FreeRTOS0.c **** **         vTaskStartScheduler() is called.
 217:../Generated_Code/FreeRTOS0.c **** **         If vTaskStartScheduler() is successful the function will not
 218:../Generated_Code/FreeRTOS0.c **** **         return until an executing task calls vTaskEndScheduler().
 219:../Generated_Code/FreeRTOS0.c **** **         The function might fail and return immediately if there is
 220:../Generated_Code/FreeRTOS0.c **** **         insufficient RAM available for the idle task to be created.
 221:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 222:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 223:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 224:../Generated_Code/FreeRTOS0.c **** */
 225:../Generated_Code/FreeRTOS0.c **** /*
 226:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskStartScheduler(void)
 227:../Generated_Code/FreeRTOS0.c **** {
 228:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 229:../Generated_Code/FreeRTOS0.c **** }
 230:../Generated_Code/FreeRTOS0.c **** */
 231:../Generated_Code/FreeRTOS0.c **** 
 232:../Generated_Code/FreeRTOS0.c **** /*
 233:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 234:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskYIELD (component FreeRTOS)
 235:../Generated_Code/FreeRTOS0.c **** **     Description :
 236:../Generated_Code/FreeRTOS0.c **** **         Macro for forcing a context switch.
 237:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 238:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 239:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 240:../Generated_Code/FreeRTOS0.c **** */
 241:../Generated_Code/FreeRTOS0.c **** /*
 242:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskYIELD(void)
 243:../Generated_Code/FreeRTOS0.c **** {
 244:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 245:../Generated_Code/FreeRTOS0.c **** }
 246:../Generated_Code/FreeRTOS0.c **** */
 247:../Generated_Code/FreeRTOS0.c **** 
 248:../Generated_Code/FreeRTOS0.c **** /*
 249:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 250:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskENTER_CRITICAL (component FreeRTOS)
 251:../Generated_Code/FreeRTOS0.c **** **     Description :
 252:../Generated_Code/FreeRTOS0.c **** **         Macro to mark the start of a critical code region.
 253:../Generated_Code/FreeRTOS0.c **** **         Preemptive context switches cannot occur when in a critical
 254:../Generated_Code/FreeRTOS0.c **** **         region.
 255:../Generated_Code/FreeRTOS0.c **** **         NOTE: This may alter the stack (depending on the portable
 256:../Generated_Code/FreeRTOS0.c **** **         implementation) so must be used with care!
 257:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 258:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 259:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 260:../Generated_Code/FreeRTOS0.c **** */
 261:../Generated_Code/FreeRTOS0.c **** /*
 262:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskENTER_CRITICAL(void)
 263:../Generated_Code/FreeRTOS0.c **** {
 264:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 265:../Generated_Code/FreeRTOS0.c **** }
 266:../Generated_Code/FreeRTOS0.c **** */
 267:../Generated_Code/FreeRTOS0.c **** 
 268:../Generated_Code/FreeRTOS0.c **** /*
 269:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 270:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskEXIT_CRITICAL (component FreeRTOS)
 271:../Generated_Code/FreeRTOS0.c **** **     Description :
 272:../Generated_Code/FreeRTOS0.c **** **         Macro to mark the end of a critical code region. Preemptive
 273:../Generated_Code/FreeRTOS0.c **** **         context switches cannot occur when in a critical region.
 274:../Generated_Code/FreeRTOS0.c **** **         NOTE: This may alter the stack (depending on the portable
 275:../Generated_Code/FreeRTOS0.c **** **         implementation) so must be used with care!
 276:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 277:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 278:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 279:../Generated_Code/FreeRTOS0.c **** */
 280:../Generated_Code/FreeRTOS0.c **** /*
 281:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskEXIT_CRITICAL(void)
 282:../Generated_Code/FreeRTOS0.c **** {
 283:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 284:../Generated_Code/FreeRTOS0.c **** }
 285:../Generated_Code/FreeRTOS0.c **** */
 286:../Generated_Code/FreeRTOS0.c **** 
 287:../Generated_Code/FreeRTOS0.c **** /*
 288:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 289:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskDISABLE_INTERRUPTS (component FreeRTOS)
 290:../Generated_Code/FreeRTOS0.c **** **     Description :
 291:../Generated_Code/FreeRTOS0.c **** **         Macro to disable all maskable interrupts.
 292:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 293:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 294:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 295:../Generated_Code/FreeRTOS0.c **** */
 296:../Generated_Code/FreeRTOS0.c **** /*
 297:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskDISABLE_INTERRUPTS(void)
 298:../Generated_Code/FreeRTOS0.c **** {
 299:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 300:../Generated_Code/FreeRTOS0.c **** }
 301:../Generated_Code/FreeRTOS0.c **** */
 302:../Generated_Code/FreeRTOS0.c **** 
 303:../Generated_Code/FreeRTOS0.c **** /*
 304:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 305:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskENABLE_INTERRUPTS (component FreeRTOS)
 306:../Generated_Code/FreeRTOS0.c **** **     Description :
 307:../Generated_Code/FreeRTOS0.c **** **         Macro to enable microcontroller interrupts.
 308:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 309:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 310:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 311:../Generated_Code/FreeRTOS0.c **** */
 312:../Generated_Code/FreeRTOS0.c **** /*
 313:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskENABLE_INTERRUPTS(void)
 314:../Generated_Code/FreeRTOS0.c **** {
 315:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 316:../Generated_Code/FreeRTOS0.c **** }
 317:../Generated_Code/FreeRTOS0.c **** */
 318:../Generated_Code/FreeRTOS0.c **** 
 319:../Generated_Code/FreeRTOS0.c **** /*
 320:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 321:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskSuspendAll (component FreeRTOS)
 322:../Generated_Code/FreeRTOS0.c **** **     Description :
 323:../Generated_Code/FreeRTOS0.c **** **         Suspends all real time kernel activity while keeping
 324:../Generated_Code/FreeRTOS0.c **** **         interrupts (including the kernel tick) enabled.
 325:../Generated_Code/FreeRTOS0.c **** **         After calling vTaskSuspendAll () the calling task will
 326:../Generated_Code/FreeRTOS0.c **** **         continue to execute without risk of being swapped out until
 327:../Generated_Code/FreeRTOS0.c **** **         a call to xTaskResumeAll () has been made.
 328:../Generated_Code/FreeRTOS0.c **** **         API functions that have the potential to cause a context
 329:../Generated_Code/FreeRTOS0.c **** **         switch (for example, vTaskDelayUntil(), xQueueSend(), etc.)
 330:../Generated_Code/FreeRTOS0.c **** **         must not be called while the scheduler is suspended.
 331:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 332:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 333:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 334:../Generated_Code/FreeRTOS0.c **** */
 335:../Generated_Code/FreeRTOS0.c **** /*
 336:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskSuspendAll(void)
 337:../Generated_Code/FreeRTOS0.c **** {
 338:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 339:../Generated_Code/FreeRTOS0.c **** }
 340:../Generated_Code/FreeRTOS0.c **** */
 341:../Generated_Code/FreeRTOS0.c **** 
 342:../Generated_Code/FreeRTOS0.c **** /*
 343:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 344:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskResumeAll (component FreeRTOS)
 345:../Generated_Code/FreeRTOS0.c **** **     Description :
 346:../Generated_Code/FreeRTOS0.c **** **         Resumes real time kernel activity following a call to
 347:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspendAll (). After a call to xTaskSuspendAll () the
 348:../Generated_Code/FreeRTOS0.c **** **         kernel will take control of which task is executing at any
 349:../Generated_Code/FreeRTOS0.c **** **         time.
 350:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 351:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 352:../Generated_Code/FreeRTOS0.c **** **         ---             - If resuming the scheduler caused a context
 353:../Generated_Code/FreeRTOS0.c **** **                           switch then pdTRUE is returned, otherwise
 354:../Generated_Code/FreeRTOS0.c **** **                           pdFALSE is returned.
 355:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 356:../Generated_Code/FreeRTOS0.c **** */
 357:../Generated_Code/FreeRTOS0.c **** /*
 358:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskResumeAll(void)
 359:../Generated_Code/FreeRTOS0.c **** {
 360:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 361:../Generated_Code/FreeRTOS0.c **** }
 362:../Generated_Code/FreeRTOS0.c **** */
 363:../Generated_Code/FreeRTOS0.c **** 
 364:../Generated_Code/FreeRTOS0.c **** /*
 365:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 366:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskResumeFromISR (component FreeRTOS)
 367:../Generated_Code/FreeRTOS0.c **** **     Description :
 368:../Generated_Code/FreeRTOS0.c **** **         An implementation of vTaskResume() that can be called from
 369:../Generated_Code/FreeRTOS0.c **** **         within an ISR. A task that has been suspended by one of more
 370:../Generated_Code/FreeRTOS0.c **** **         calls to vTaskSuspend() will be made available for running
 371:../Generated_Code/FreeRTOS0.c **** **         again by a single call to xTaskResumeFromISR().
 372:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 373:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 374:../Generated_Code/FreeRTOS0.c **** **         pxTaskToResume  - Handle to the task
 375:../Generated_Code/FreeRTOS0.c **** **                           being readied.
 376:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 377:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
 378:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 379:../Generated_Code/FreeRTOS0.c **** */
 380:../Generated_Code/FreeRTOS0.c **** /*
 381:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskResumeFromISR(xTaskHandle pxTaskToResume)
 382:../Generated_Code/FreeRTOS0.c **** {
 383:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 384:../Generated_Code/FreeRTOS0.c **** }
 385:../Generated_Code/FreeRTOS0.c **** */
 386:../Generated_Code/FreeRTOS0.c **** 
 387:../Generated_Code/FreeRTOS0.c **** /*
 388:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 389:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskDelay (component FreeRTOS)
 390:../Generated_Code/FreeRTOS0.c **** **     Description :
 391:../Generated_Code/FreeRTOS0.c **** **         Delay a task for a given number of ticks. The actual time
 392:../Generated_Code/FreeRTOS0.c **** **         that the task remains blocked depends on the tick rate. The
 393:../Generated_Code/FreeRTOS0.c **** **         constant portTICK_RATE_MS can be used to calculate real time
 394:../Generated_Code/FreeRTOS0.c **** **         from the tick rate - with the resolution of one tick period.
 395:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() specifies a time at which the task wishes to
 396:../Generated_Code/FreeRTOS0.c **** **         unblock relative to the time at which vTaskDelay() is called.
 397:../Generated_Code/FreeRTOS0.c **** **         For example, specifying a block period of 100 ticks will
 398:../Generated_Code/FreeRTOS0.c **** **         cause the task to unblock 100 ticks after vTaskDelay() is
 399:../Generated_Code/FreeRTOS0.c **** **         called. vTaskDelay() does not therefore provide a good
 400:../Generated_Code/FreeRTOS0.c **** **         method of controlling the frequency of a cyclical task as
 401:../Generated_Code/FreeRTOS0.c **** **         the path taken through the code, as well as other task and
 402:../Generated_Code/FreeRTOS0.c **** **         interrupt activity, will effect the frequency at which
 403:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() gets called and therefore the time at which the
 404:../Generated_Code/FreeRTOS0.c **** **         task next executes. See vTaskDelayUntil() for an alternative
 405:../Generated_Code/FreeRTOS0.c **** **         API function designed to facilitate fixed frequency
 406:../Generated_Code/FreeRTOS0.c **** **         execution. It does this by specifying an absolute time
 407:../Generated_Code/FreeRTOS0.c **** **         (rather than a relative time) at which the calling task
 408:../Generated_Code/FreeRTOS0.c **** **         should unblock. 
 409:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 410:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 411:../Generated_Code/FreeRTOS0.c **** **         xTicksToDelay   - The amount of time, in
 412:../Generated_Code/FreeRTOS0.c **** **                           tick periods, that the calling task should
 413:../Generated_Code/FreeRTOS0.c **** **                           block.
 414:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 415:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 416:../Generated_Code/FreeRTOS0.c **** */
 417:../Generated_Code/FreeRTOS0.c **** /*
 418:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskDelay(portTickType xTicksToDelay)
 419:../Generated_Code/FreeRTOS0.c **** {
 420:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 421:../Generated_Code/FreeRTOS0.c **** }
 422:../Generated_Code/FreeRTOS0.c **** */
 423:../Generated_Code/FreeRTOS0.c **** 
 424:../Generated_Code/FreeRTOS0.c **** /*
 425:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 426:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskDelayUntil (component FreeRTOS)
 427:../Generated_Code/FreeRTOS0.c **** **     Description :
 428:../Generated_Code/FreeRTOS0.c **** **         Delay a task until a specified time. This function can be
 429:../Generated_Code/FreeRTOS0.c **** **         used by cyclical tasks to ensure a constant execution
 430:../Generated_Code/FreeRTOS0.c **** **         frequency.
 431:../Generated_Code/FreeRTOS0.c **** **         This function differs from vTaskDelay() in one important
 432:../Generated_Code/FreeRTOS0.c **** **         aspect: vTaskDelay() specifies a time at which the task
 433:../Generated_Code/FreeRTOS0.c **** **         wishes to unblock relative to the time at which vTaskDelay()
 434:../Generated_Code/FreeRTOS0.c **** **         is called, whereas vTaskDelayUntil() specifies an absolute
 435:../Generated_Code/FreeRTOS0.c **** **         time at which the task wishes to unblock.
 436:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() will cause a task to block for the specified
 437:../Generated_Code/FreeRTOS0.c **** **         number of ticks from the time vTaskDelay() is called. It is
 438:../Generated_Code/FreeRTOS0.c **** **         therefore difficult to use vTaskDelay() by itself to
 439:../Generated_Code/FreeRTOS0.c **** **         generate a fixed execution frequency as the time between a
 440:../Generated_Code/FreeRTOS0.c **** **         task unblocking following a call to vTaskDelay() and that
 441:../Generated_Code/FreeRTOS0.c **** **         task next calling vTaskDelay() may not be fixed [the task
 442:../Generated_Code/FreeRTOS0.c **** **         may take a different path though the code between calls, or
 443:../Generated_Code/FreeRTOS0.c **** **         may get interrupted or preempted a different number of times
 444:../Generated_Code/FreeRTOS0.c **** **         each time it executes].
 445:../Generated_Code/FreeRTOS0.c **** **         Whereas vTaskDelay() specifies a wake time relative to the
 446:../Generated_Code/FreeRTOS0.c **** **         time at which the function is called, vTaskDelayUntil()
 447:../Generated_Code/FreeRTOS0.c **** **         specifies the absolute (exact) time at which it wishes to
 448:../Generated_Code/FreeRTOS0.c **** **         unblock.
 449:../Generated_Code/FreeRTOS0.c **** **         It should be noted that vTaskDelayUntil() will return
 450:../Generated_Code/FreeRTOS0.c **** **         immediately (without blocking) if it is used to specify a
 451:../Generated_Code/FreeRTOS0.c **** **         wake time that is already in the past. Therefore a task
 452:../Generated_Code/FreeRTOS0.c **** **         using vTaskDelayUntil() to execute periodically will have to
 453:../Generated_Code/FreeRTOS0.c **** **         re-calculate its required wake time if the periodic
 454:../Generated_Code/FreeRTOS0.c **** **         execution is halted for any reason (for example, the task is
 455:../Generated_Code/FreeRTOS0.c **** **         temporarily placed into the Suspended state) causing the
 456:../Generated_Code/FreeRTOS0.c **** **         task to miss one or more periodic executions. This can be
 457:../Generated_Code/FreeRTOS0.c **** **         detected by checking the variable passed by reference as the
 458:../Generated_Code/FreeRTOS0.c **** **         pxPreviousWakeTime parameter against the current tick count.
 459:../Generated_Code/FreeRTOS0.c **** **         This is however not necessary under most usage scenarios.
 460:../Generated_Code/FreeRTOS0.c **** **         The constant portTICK_RATE_MS can be used to calculate real
 461:../Generated_Code/FreeRTOS0.c **** **         time from the tick rate - with the resolution of one tick
 462:../Generated_Code/FreeRTOS0.c **** **         period.
 463:../Generated_Code/FreeRTOS0.c **** **         This function must not be called while the scheduler has
 464:../Generated_Code/FreeRTOS0.c **** **         been suspended by a call to vTaskSuspendAll(). 
 465:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 466:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 467:../Generated_Code/FreeRTOS0.c **** **         pxPreviousWakeTime - Pointer to a
 468:../Generated_Code/FreeRTOS0.c **** **                           variable that holds the time at which the
 469:../Generated_Code/FreeRTOS0.c **** **                           task was last unblocked. The variable must
 470:../Generated_Code/FreeRTOS0.c **** **                           be initialised with the current time prior
 471:../Generated_Code/FreeRTOS0.c **** **                           to its first use (see the example below).
 472:../Generated_Code/FreeRTOS0.c **** **                           Following this the variable is
 473:../Generated_Code/FreeRTOS0.c **** **                           automatically updated within
 474:../Generated_Code/FreeRTOS0.c **** **                           vTaskDelayUntil(). 
 475:../Generated_Code/FreeRTOS0.c **** **         xTimeIncrement  - The cycle time
 476:../Generated_Code/FreeRTOS0.c **** **                           period. The task will be unblocked at time
 477:../Generated_Code/FreeRTOS0.c **** **                           (*pxPreviousWakeTime + xTimeIncrement).
 478:../Generated_Code/FreeRTOS0.c **** **                           Calling vTaskDelayUntil with the same
 479:../Generated_Code/FreeRTOS0.c **** **                           xTimeIncrement parameter value will cause
 480:../Generated_Code/FreeRTOS0.c **** **                           the task to execute with a fixed interval
 481:../Generated_Code/FreeRTOS0.c **** **                           period. 
 482:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 483:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 484:../Generated_Code/FreeRTOS0.c **** */
 485:../Generated_Code/FreeRTOS0.c **** /*
 486:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
 487:../Generated_Code/FreeRTOS0.c **** {
 488:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 489:../Generated_Code/FreeRTOS0.c **** }
 490:../Generated_Code/FreeRTOS0.c **** */
 491:../Generated_Code/FreeRTOS0.c **** 
 492:../Generated_Code/FreeRTOS0.c **** /*
 493:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 494:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskPriorityGet (component FreeRTOS)
 495:../Generated_Code/FreeRTOS0.c **** **     Description :
 496:../Generated_Code/FreeRTOS0.c **** **         Obtain the priority of any task.
 497:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 498:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 499:../Generated_Code/FreeRTOS0.c **** **         pxTask          - Handle of the task to be queried.
 500:../Generated_Code/FreeRTOS0.c **** **                           Passing a NULL handle results in the
 501:../Generated_Code/FreeRTOS0.c **** **                           priority of the calling task being returned.
 502:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 503:../Generated_Code/FreeRTOS0.c **** **         ---             - The priority of pxTask.
 504:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 505:../Generated_Code/FreeRTOS0.c **** */
 506:../Generated_Code/FreeRTOS0.c **** /*
 507:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskPriorityGet(xTaskHandle pxTask)
 508:../Generated_Code/FreeRTOS0.c **** {
 509:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 510:../Generated_Code/FreeRTOS0.c **** }
 511:../Generated_Code/FreeRTOS0.c **** */
 512:../Generated_Code/FreeRTOS0.c **** 
 513:../Generated_Code/FreeRTOS0.c **** /*
 514:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 515:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskPrioritySet (component FreeRTOS)
 516:../Generated_Code/FreeRTOS0.c **** **     Description :
 517:../Generated_Code/FreeRTOS0.c **** **         Set the priority of any task.
 518:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 519:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 520:../Generated_Code/FreeRTOS0.c **** **         pxTask          - Handle to the task for which the
 521:../Generated_Code/FreeRTOS0.c **** **                           priority is being set. Passing a NULL
 522:../Generated_Code/FreeRTOS0.c **** **                           handle results in the priority of the
 523:../Generated_Code/FreeRTOS0.c **** **                           calling task being set.
 524:../Generated_Code/FreeRTOS0.c **** **         uxNewPriority   - The priority to which
 525:../Generated_Code/FreeRTOS0.c **** **                           the task will be set.
 526:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 527:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 528:../Generated_Code/FreeRTOS0.c **** */
 529:../Generated_Code/FreeRTOS0.c **** /*
 530:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
 531:../Generated_Code/FreeRTOS0.c **** {
 532:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 533:../Generated_Code/FreeRTOS0.c **** }
 534:../Generated_Code/FreeRTOS0.c **** */
 535:../Generated_Code/FreeRTOS0.c **** 
 536:../Generated_Code/FreeRTOS0.c **** /*
 537:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 538:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTakeRecursive (component FreeRTOS)
 539:../Generated_Code/FreeRTOS0.c **** **     Description :
 540:../Generated_Code/FreeRTOS0.c **** **         Macro to recursively obtain, or 'take', a mutex type
 541:../Generated_Code/FreeRTOS0.c **** **         semaphore. The mutex must have previously been created using
 542:../Generated_Code/FreeRTOS0.c **** **         a call to xSemaphoreCreateRecursiveMutex();
 543:../Generated_Code/FreeRTOS0.c **** **         This macro must not be used on mutexes created using
 544:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex(). A mutex used recursively can be
 545:../Generated_Code/FreeRTOS0.c **** **         'taken' repeatedly by the owner. The mutex doesn't become
 546:../Generated_Code/FreeRTOS0.c **** **         available again until the owner has called
 547:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive() for each successful 'take' request.
 548:../Generated_Code/FreeRTOS0.c **** **         For example, if a task successfully 'takes' the same mutex 5
 549:../Generated_Code/FreeRTOS0.c **** **         times then the mutex will not be available to any other task
 550:../Generated_Code/FreeRTOS0.c **** **         until it has also  'given' the mutex back exactly five times.
 551:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 552:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 553:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being obtained.
 554:../Generated_Code/FreeRTOS0.c **** **                           This is the handle returned by
 555:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateRecursiveMutex();
 556:../Generated_Code/FreeRTOS0.c **** **         xBlockTime      - The time in ticks to wait
 557:../Generated_Code/FreeRTOS0.c **** **                           for the semaphore to become available.  The
 558:../Generated_Code/FreeRTOS0.c **** **                           macro portTICK_RATE_MS can be used to
 559:../Generated_Code/FreeRTOS0.c **** **                           convert this to a real time.  A block time
 560:../Generated_Code/FreeRTOS0.c **** **                           of zero can be used to poll the semaphore.
 561:../Generated_Code/FreeRTOS0.c **** **                           If the task already owns the semaphore then
 562:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreTakeRecursive() will return
 563:../Generated_Code/FreeRTOS0.c **** **                           immediately no matter what the value of
 564:../Generated_Code/FreeRTOS0.c **** **                           xBlockTime.
 565:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 566:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was
 567:../Generated_Code/FreeRTOS0.c **** **                           obtained.  pdFALSE if xBlockTime expired
 568:../Generated_Code/FreeRTOS0.c **** **                           without the semaphore becoming available.
 569:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 570:../Generated_Code/FreeRTOS0.c **** */
 571:../Generated_Code/FreeRTOS0.c **** /*
 572:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
 573:../Generated_Code/FreeRTOS0.c **** {
 574:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 575:../Generated_Code/FreeRTOS0.c **** }
 576:../Generated_Code/FreeRTOS0.c **** */
 577:../Generated_Code/FreeRTOS0.c **** 
 578:../Generated_Code/FreeRTOS0.c **** /*
 579:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 580:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGiveRecursive (component FreeRTOS)
 581:../Generated_Code/FreeRTOS0.c **** **     Description :
 582:../Generated_Code/FreeRTOS0.c **** **         Macro to recursively release, or 'give', a mutex type
 583:../Generated_Code/FreeRTOS0.c **** **         semaphore. The mutex must have previously been created using
 584:../Generated_Code/FreeRTOS0.c **** **         a call to xSemaphoreCreateRecursiveMutex();
 585:../Generated_Code/FreeRTOS0.c **** **         This macro must not be used on mutexes created using
 586:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex(). A mutex used recursively can be
 587:../Generated_Code/FreeRTOS0.c **** **         'taken' repeatedly by the owner. The mutex doesn't become
 588:../Generated_Code/FreeRTOS0.c **** **         available again until the owner has called
 589:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive() for each successful 'take' request.
 590:../Generated_Code/FreeRTOS0.c **** **         For example, if a task successfully 'takes' the same mutex 5
 591:../Generated_Code/FreeRTOS0.c **** **         times then the mutex will not be available to any other task
 592:../Generated_Code/FreeRTOS0.c **** **         until it has also  'given' the mutex back exactly five times.
 593:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 594:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 595:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being released,
 596:../Generated_Code/FreeRTOS0.c **** **                           or 'given'.  This is the handle returned by
 597:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 598:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 599:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 600:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 601:../Generated_Code/FreeRTOS0.c **** */
 602:../Generated_Code/FreeRTOS0.c **** /*
 603:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
 604:../Generated_Code/FreeRTOS0.c **** {
 605:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 606:../Generated_Code/FreeRTOS0.c **** }
 607:../Generated_Code/FreeRTOS0.c **** */
 608:../Generated_Code/FreeRTOS0.c **** 
 609:../Generated_Code/FreeRTOS0.c **** /*
 610:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 611:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateRecursiveMutex (component FreeRTOS)
 612:../Generated_Code/FreeRTOS0.c **** **     Description :
 613:../Generated_Code/FreeRTOS0.c **** **         Macro that implements a recursive mutex by using the
 614:../Generated_Code/FreeRTOS0.c **** **         existing queue mechanism.
 615:../Generated_Code/FreeRTOS0.c **** **         Mutexes created using this macro can be accessed using the
 616:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
 617:../Generated_Code/FreeRTOS0.c **** **         macros.  The  xSemaphoreTake() and xSemaphoreGive() macros
 618:../Generated_Code/FreeRTOS0.c **** **         should not be used.
 619:../Generated_Code/FreeRTOS0.c **** **         A mutex used recursively can be 'taken' repeatedly by the
 620:../Generated_Code/FreeRTOS0.c **** **         owner. The mutex doesn't become available again until the
 621:../Generated_Code/FreeRTOS0.c **** **         owner has called xSemaphoreGiveRecursive() for each
 622:../Generated_Code/FreeRTOS0.c **** **         successful 'take' request.  For example, if a task
 623:../Generated_Code/FreeRTOS0.c **** **         successfully 'takes' the same mutex 5 times then the mutex
 624:../Generated_Code/FreeRTOS0.c **** **         will not be available to any other task until it has also
 625:../Generated_Code/FreeRTOS0.c **** **         'given' the mutex back exactly five times.
 626:../Generated_Code/FreeRTOS0.c **** **         This type of semaphore uses a priority inheritance mechanism
 627:../Generated_Code/FreeRTOS0.c **** **         so a task 'taking' a semaphore MUST ALWAYS 'give' the
 628:../Generated_Code/FreeRTOS0.c **** **         semaphore back once the semaphore it is no longer required.
 629:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores cannot be used from within interrupt
 630:../Generated_Code/FreeRTOS0.c **** **         service routines.
 631:../Generated_Code/FreeRTOS0.c **** **         See vSemaphoreCreateBinary() for an alternative
 632:../Generated_Code/FreeRTOS0.c **** **         implementation that can be used for pure synchronisation
 633:../Generated_Code/FreeRTOS0.c **** **         (where one task or interrupt always 'gives' the semaphore
 634:../Generated_Code/FreeRTOS0.c **** **         and another always 'takes' the semaphore) and from within
 635:../Generated_Code/FreeRTOS0.c **** **         interrupt service routines.
 636:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 637:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 638:../Generated_Code/FreeRTOS0.c **** **         ---             - Handle to the created mutex semaphore.
 639:../Generated_Code/FreeRTOS0.c **** **                           Should be of type  xSemaphoreHandle.
 640:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 641:../Generated_Code/FreeRTOS0.c **** */
 642:../Generated_Code/FreeRTOS0.c **** /*
 643:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateRecursiveMutex(void)
 644:../Generated_Code/FreeRTOS0.c **** {
 645:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 646:../Generated_Code/FreeRTOS0.c **** }
 647:../Generated_Code/FreeRTOS0.c **** */
 648:../Generated_Code/FreeRTOS0.c **** 
 649:../Generated_Code/FreeRTOS0.c **** /*
 650:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 651:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vSemaphoreDelete (component FreeRTOS)
 652:../Generated_Code/FreeRTOS0.c **** **     Description :
 653:../Generated_Code/FreeRTOS0.c **** **         Delete a semaphore.  This function must be used with care.
 654:../Generated_Code/FreeRTOS0.c **** **         For example, do not delete a mutex type semaphore if the
 655:../Generated_Code/FreeRTOS0.c **** **         mutex is held by a task.
 656:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 657:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 658:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore to
 659:../Generated_Code/FreeRTOS0.c **** **                           be deleted.
 660:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 661:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 662:../Generated_Code/FreeRTOS0.c **** */
 663:../Generated_Code/FreeRTOS0.c **** /*
 664:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vSemaphoreDelete(xSemaphoreHandle xSemaphore)
 665:../Generated_Code/FreeRTOS0.c **** {
 666:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 667:../Generated_Code/FreeRTOS0.c **** }
 668:../Generated_Code/FreeRTOS0.c **** */
 669:../Generated_Code/FreeRTOS0.c **** 
 670:../Generated_Code/FreeRTOS0.c **** /*
 671:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 672:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskSuspend (component FreeRTOS)
 673:../Generated_Code/FreeRTOS0.c **** **     Description :
 674:../Generated_Code/FreeRTOS0.c **** **         Suspend any task. When suspended a task will never get any
 675:../Generated_Code/FreeRTOS0.c **** **         microcontroller processing time, no matter what its priority.
 676:../Generated_Code/FreeRTOS0.c **** **         Calls to vTaskSuspend are not accumulative - i.e. calling
 677:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspend() twice on the same task still only requires
 678:../Generated_Code/FreeRTOS0.c **** **         one call to vTaskResume() to ready the suspended task.
 679:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 680:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 681:../Generated_Code/FreeRTOS0.c **** **         pxTaskToSuspend - Handle to the task
 682:../Generated_Code/FreeRTOS0.c **** **                           being suspended. Passing a NULL handle will
 683:../Generated_Code/FreeRTOS0.c **** **                           cause the calling task to be suspended.
 684:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 685:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 686:../Generated_Code/FreeRTOS0.c **** */
 687:../Generated_Code/FreeRTOS0.c **** /*
 688:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskSuspend(xTaskHandle pxTaskToSuspend)
 689:../Generated_Code/FreeRTOS0.c **** {
 690:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 691:../Generated_Code/FreeRTOS0.c **** }
 692:../Generated_Code/FreeRTOS0.c **** */
 693:../Generated_Code/FreeRTOS0.c **** 
 694:../Generated_Code/FreeRTOS0.c **** /*
 695:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 696:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskResume (component FreeRTOS)
 697:../Generated_Code/FreeRTOS0.c **** **     Description :
 698:../Generated_Code/FreeRTOS0.c **** **         Resumes a suspended task. A task that has been suspended by
 699:../Generated_Code/FreeRTOS0.c **** **         one of more calls to vTaskSuspend() will be made available
 700:../Generated_Code/FreeRTOS0.c **** **         for running again by a single call to vTaskResume().
 701:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 702:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 703:../Generated_Code/FreeRTOS0.c **** **         pxTaskToResume  - Handle to the task
 704:../Generated_Code/FreeRTOS0.c **** **                           being readied.
 705:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 706:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 707:../Generated_Code/FreeRTOS0.c **** */
 708:../Generated_Code/FreeRTOS0.c **** /*
 709:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskResume(xTaskHandle pxTaskToResume)
 710:../Generated_Code/FreeRTOS0.c **** {
 711:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 712:../Generated_Code/FreeRTOS0.c **** }
 713:../Generated_Code/FreeRTOS0.c **** */
 714:../Generated_Code/FreeRTOS0.c **** 
 715:../Generated_Code/FreeRTOS0.c **** /*
 716:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 717:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateMutex (component FreeRTOS)
 718:../Generated_Code/FreeRTOS0.c **** **     Description :
 719:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a mutex semaphore by using the existing
 720:../Generated_Code/FreeRTOS0.c **** **         queue mechanism.
 721:../Generated_Code/FreeRTOS0.c **** **         Mutexes created using this macro can be accessed using the
 722:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() and xSemaphoreGive() macros. The
 723:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
 724:../Generated_Code/FreeRTOS0.c **** **         macros should not be used.
 725:../Generated_Code/FreeRTOS0.c **** **         Mutexes and binary semaphores are very similar but have some
 726:../Generated_Code/FreeRTOS0.c **** **         subtle differences: Mutexes include a priority inheritance
 727:../Generated_Code/FreeRTOS0.c **** **         mechanism, binary semaphores do not. This makes binary
 728:../Generated_Code/FreeRTOS0.c **** **         semaphores the better choice for implementing
 729:../Generated_Code/FreeRTOS0.c **** **         synchronisation (between tasks or between tasks and an
 730:../Generated_Code/FreeRTOS0.c **** **         interrupt), and mutexes the better choice for implementing
 731:../Generated_Code/FreeRTOS0.c **** **         simple mutual exclusion.
 732:../Generated_Code/FreeRTOS0.c **** **         The priority of a task that 'takes' a mutex can potentially
 733:../Generated_Code/FreeRTOS0.c **** **         be raised if another task of higher priority attempts to
 734:../Generated_Code/FreeRTOS0.c **** **         obtain the same mutex. The task that owns the mutex
 735:../Generated_Code/FreeRTOS0.c **** **         'inherits' the priority of the task attempting to 'take' the
 736:../Generated_Code/FreeRTOS0.c **** **         same mutex. This means the mutex must always be 'given' back
 737:../Generated_Code/FreeRTOS0.c **** **         - otherwise the higher priority task will never be able to
 738:../Generated_Code/FreeRTOS0.c **** **         obtain the mutex, and the lower priority task will never
 739:../Generated_Code/FreeRTOS0.c **** **         'disinherit' the priority. An example of a mutex being used
 740:../Generated_Code/FreeRTOS0.c **** **         to implement mutual exclusion is provided on the
 741:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() documentation page.
 742:../Generated_Code/FreeRTOS0.c **** **         A binary semaphore need not be given back once obtained, so
 743:../Generated_Code/FreeRTOS0.c **** **         task synchronisation can be implemented by one
 744:../Generated_Code/FreeRTOS0.c **** **         task/interrupt continuously 'giving' the semaphore while
 745:../Generated_Code/FreeRTOS0.c **** **         another continuously 'takes' the semaphore. This is
 746:../Generated_Code/FreeRTOS0.c **** **         demonstrated by the sample code on the
 747:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() documentation page.
 748:../Generated_Code/FreeRTOS0.c **** **         Both mutex and binary semaphores are assigned to variables
 749:../Generated_Code/FreeRTOS0.c **** **         of type xSemaphoreHandle and can be used in any API function
 750:../Generated_Code/FreeRTOS0.c **** **         that takes a parameter of this type. 
 751:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 752:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 753:../Generated_Code/FreeRTOS0.c **** **         ---             - Handle to the created mutex semaphore.
 754:../Generated_Code/FreeRTOS0.c **** **                           Should be of type  xSemaphoreHandle.
 755:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 756:../Generated_Code/FreeRTOS0.c **** */
 757:../Generated_Code/FreeRTOS0.c **** /*
 758:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateMutex(void)
 759:../Generated_Code/FreeRTOS0.c **** {
 760:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 761:../Generated_Code/FreeRTOS0.c **** }
 762:../Generated_Code/FreeRTOS0.c **** */
 763:../Generated_Code/FreeRTOS0.c **** 
 764:../Generated_Code/FreeRTOS0.c **** /*
 765:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 766:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTake (component FreeRTOS)
 767:../Generated_Code/FreeRTOS0.c **** **     Description :
 768:../Generated_Code/FreeRTOS0.c **** **         Macro to obtain a semaphore. The semaphore must have
 769:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 770:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
 771:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting().
 772:../Generated_Code/FreeRTOS0.c **** **         This macro must not be called from an ISR.
 773:../Generated_Code/FreeRTOS0.c **** **         xQueueReceiveFromISR() can be used to take a semaphore from
 774:../Generated_Code/FreeRTOS0.c **** **         within an interrupt if required, although this would not be
 775:../Generated_Code/FreeRTOS0.c **** **         a normal operation. Semaphores use queues as their
 776:../Generated_Code/FreeRTOS0.c **** **         underlying mechanism, so functions are to some extent
 777:../Generated_Code/FreeRTOS0.c **** **         interoperable.
 778:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() is part of the fully featured intertask
 779:../Generated_Code/FreeRTOS0.c **** **         communications API. xSemaphoreAltTake() is the alternative
 780:../Generated_Code/FreeRTOS0.c **** **         API equivalent. Both versions require the same parameters
 781:../Generated_Code/FreeRTOS0.c **** **         and return the same values.
 782:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 783:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 784:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being obtained.
 785:../Generated_Code/FreeRTOS0.c **** **                           This is the handle returned by
 786:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 787:../Generated_Code/FreeRTOS0.c **** **         xBlockTime      - The time in ticks to wait
 788:../Generated_Code/FreeRTOS0.c **** **                           for the semaphore to become available.  The
 789:../Generated_Code/FreeRTOS0.c **** **                           macro portTICK_RATE_MS can be used to
 790:../Generated_Code/FreeRTOS0.c **** **                           convert this to a real time.  A block time
 791:../Generated_Code/FreeRTOS0.c **** **                           of zero can be used to poll the semaphore.
 792:../Generated_Code/FreeRTOS0.c **** **                           If the task already owns the semaphore then
 793:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreTakeRecursive() will return
 794:../Generated_Code/FreeRTOS0.c **** **                           immediately no matter what the value of
 795:../Generated_Code/FreeRTOS0.c **** **                           xBlockTime. Specifying the block time as
 796:../Generated_Code/FreeRTOS0.c **** **                           portMAX_DELAY will cause the task to block
 797:../Generated_Code/FreeRTOS0.c **** **                           indefinitely (without a timeout).
 798:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 799:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was
 800:../Generated_Code/FreeRTOS0.c **** **                           obtained.  pdFALSE if xBlockTime expired
 801:../Generated_Code/FreeRTOS0.c **** **                           without the semaphore becoming available.
 802:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 803:../Generated_Code/FreeRTOS0.c **** */
 804:../Generated_Code/FreeRTOS0.c **** /*
 805:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
 806:../Generated_Code/FreeRTOS0.c **** {
 807:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 808:../Generated_Code/FreeRTOS0.c **** }
 809:../Generated_Code/FreeRTOS0.c **** */
 810:../Generated_Code/FreeRTOS0.c **** 
 811:../Generated_Code/FreeRTOS0.c **** /*
 812:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 813:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGive (component FreeRTOS)
 814:../Generated_Code/FreeRTOS0.c **** **     Description :
 815:../Generated_Code/FreeRTOS0.c **** **         Macro to release a semaphore. The semaphore must have
 816:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 817:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
 818:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting(), and obtained using
 819:../Generated_Code/FreeRTOS0.c **** **         sSemaphoreTake().
 820:../Generated_Code/FreeRTOS0.c **** **         This must not be used from an ISR. See
 821:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() for an alternative which can be used
 822:../Generated_Code/FreeRTOS0.c **** **         from an ISR.
 823:../Generated_Code/FreeRTOS0.c **** **         This macro must also not be used on semaphores created using
 824:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateRecursiveMutex().
 825:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGive() is part of the fully featured intertask
 826:../Generated_Code/FreeRTOS0.c **** **         communications API. xSemaphoreAltGive() is the alternative
 827:../Generated_Code/FreeRTOS0.c **** **         API equivalent. Both versions require the same parameters
 828:../Generated_Code/FreeRTOS0.c **** **         and return the same values. 
 829:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 830:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 831:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being released,
 832:../Generated_Code/FreeRTOS0.c **** **                           or 'given'.  This is the handle returned by
 833:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 834:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 835:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 836:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 837:../Generated_Code/FreeRTOS0.c **** */
 838:../Generated_Code/FreeRTOS0.c **** /*
 839:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGive(xSemaphoreHandle xMutex)
 840:../Generated_Code/FreeRTOS0.c **** {
 841:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 842:../Generated_Code/FreeRTOS0.c **** }
 843:../Generated_Code/FreeRTOS0.c **** */
 844:../Generated_Code/FreeRTOS0.c **** 
 845:../Generated_Code/FreeRTOS0.c **** /*
 846:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 847:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vSemaphoreCreateBinary (component FreeRTOS)
 848:../Generated_Code/FreeRTOS0.c **** **     Description :
 849:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a semaphore by using the existing queue
 850:../Generated_Code/FreeRTOS0.c **** **         mechanism. The queue length is 1 as this is a binary
 851:../Generated_Code/FreeRTOS0.c **** **         semaphore. The data size is 0 as we don't want to actually
 852:../Generated_Code/FreeRTOS0.c **** **         store any data - we just want to know if the queue is empty
 853:../Generated_Code/FreeRTOS0.c **** **         or full.
 854:../Generated_Code/FreeRTOS0.c **** **         Binary semaphores and mutexes are very similar but have some
 855:../Generated_Code/FreeRTOS0.c **** **         subtle differences: Mutexes include a priority inheritance
 856:../Generated_Code/FreeRTOS0.c **** **         mechanism, binary semaphores do not. This makes binary
 857:../Generated_Code/FreeRTOS0.c **** **         semaphores the better choice for implementing
 858:../Generated_Code/FreeRTOS0.c **** **         synchronisation (between tasks or between tasks and an
 859:../Generated_Code/FreeRTOS0.c **** **         interrupt), and mutexes the better choice for implementing
 860:../Generated_Code/FreeRTOS0.c **** **         simple mutual exclusion.
 861:../Generated_Code/FreeRTOS0.c **** **         A binary semaphore need not be given back once obtained, so
 862:../Generated_Code/FreeRTOS0.c **** **         task synchronisation can be implemented by one
 863:../Generated_Code/FreeRTOS0.c **** **         task/interrupt continuously 'giving' the semaphore while
 864:../Generated_Code/FreeRTOS0.c **** **         another continuously 'takes' the semaphore. This is
 865:../Generated_Code/FreeRTOS0.c **** **         demonstrated by the sample code on the
 866:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() documentation page.
 867:../Generated_Code/FreeRTOS0.c **** **         The priority of a task that 'takes' a mutex can potentially
 868:../Generated_Code/FreeRTOS0.c **** **         be raised if another task of higher priority attempts to
 869:../Generated_Code/FreeRTOS0.c **** **         obtain the same mutex. The task that owns the mutex
 870:../Generated_Code/FreeRTOS0.c **** **         'inherits' the priority of the task attempting to 'take' the
 871:../Generated_Code/FreeRTOS0.c **** **         same mutex. This means the mutex must always be 'given' back
 872:../Generated_Code/FreeRTOS0.c **** **         - otherwise the higher priority task will never be able to
 873:../Generated_Code/FreeRTOS0.c **** **         obtain the mutex, and the lower priority task will never
 874:../Generated_Code/FreeRTOS0.c **** **         'disinherit' the priority. An example of a mutex being used
 875:../Generated_Code/FreeRTOS0.c **** **         to implement mutual exclusion is provided on the
 876:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() documentation page.
 877:../Generated_Code/FreeRTOS0.c **** **         Both mutex and binary semaphores are assigned to variables
 878:../Generated_Code/FreeRTOS0.c **** **         of type xSemaphoreHandle and can be used in any API function
 879:../Generated_Code/FreeRTOS0.c **** **         that takes a parameter of this type. 
 880:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 881:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 882:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - Handle to the created
 883:../Generated_Code/FreeRTOS0.c **** **                           semaphore. Should be of type
 884:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreHandle.
 885:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 886:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 887:../Generated_Code/FreeRTOS0.c **** */
 888:../Generated_Code/FreeRTOS0.c **** /*
 889:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
 890:../Generated_Code/FreeRTOS0.c **** {
 891:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 892:../Generated_Code/FreeRTOS0.c **** }
 893:../Generated_Code/FreeRTOS0.c **** */
 894:../Generated_Code/FreeRTOS0.c **** 
 895:../Generated_Code/FreeRTOS0.c **** /*
 896:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 897:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateCounting (component FreeRTOS)
 898:../Generated_Code/FreeRTOS0.c **** **     Description :
 899:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a counting semaphore by using the
 900:../Generated_Code/FreeRTOS0.c **** **         existing queue mechanism.
 901:../Generated_Code/FreeRTOS0.c **** **         Counting semaphores are typically used for two things:
 902:../Generated_Code/FreeRTOS0.c **** **         1. Counting events.
 903:../Generated_Code/FreeRTOS0.c **** **         In this usage scenario an event handler will 'give' a
 904:../Generated_Code/FreeRTOS0.c **** **         semaphore each time an event occurs (incrementing the
 905:../Generated_Code/FreeRTOS0.c **** **         semaphore count value), and a handler task will 'take' a
 906:../Generated_Code/FreeRTOS0.c **** **         semaphore each time it processes an event (decrementing the
 907:../Generated_Code/FreeRTOS0.c **** **         semaphore count value). The count value is therefore the
 908:../Generated_Code/FreeRTOS0.c **** **         difference between the number of events that have occurred
 909:../Generated_Code/FreeRTOS0.c **** **         and the number that have been processed. In this case it is
 910:../Generated_Code/FreeRTOS0.c **** **         desirable for the initial count value to be zero.
 911:../Generated_Code/FreeRTOS0.c **** **         2. Resource management.
 912:../Generated_Code/FreeRTOS0.c **** **         In this usage scenario the count value indicates the number
 913:../Generated_Code/FreeRTOS0.c **** **         of resources available. To obtain control of a resource a
 914:../Generated_Code/FreeRTOS0.c **** **         task must first obtain a semaphore - decrementing the
 915:../Generated_Code/FreeRTOS0.c **** **         semaphore count value. When the count value reaches zero
 916:../Generated_Code/FreeRTOS0.c **** **         there are no free resources. When a task finishes with the
 917:../Generated_Code/FreeRTOS0.c **** **         resource it 'gives' the semaphore back - incrementing the
 918:../Generated_Code/FreeRTOS0.c **** **         semaphore count value. In this case it is desirable for the
 919:../Generated_Code/FreeRTOS0.c **** **         initial count value to be equal to the maximum count value,
 920:../Generated_Code/FreeRTOS0.c **** **         indicating that all resources are free.
 921:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 922:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 923:../Generated_Code/FreeRTOS0.c **** **         uxMaxCount      - The maximum count value that
 924:../Generated_Code/FreeRTOS0.c **** **                           can be reached. When the semaphore reaches
 925:../Generated_Code/FreeRTOS0.c **** **                           this value it can no longer be 'given'.
 926:../Generated_Code/FreeRTOS0.c **** **         uxInitialCount  - The count value
 927:../Generated_Code/FreeRTOS0.c **** **                           assigned to the semaphore when it is
 928:../Generated_Code/FreeRTOS0.c **** **                           created.
 929:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 930:../Generated_Code/FreeRTOS0.c **** **         ---             - xSemaphoreHandle handle
 931:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 932:../Generated_Code/FreeRTOS0.c **** */
 933:../Generated_Code/FreeRTOS0.c **** /*
 934:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_por
 935:../Generated_Code/FreeRTOS0.c **** {
 936:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 937:../Generated_Code/FreeRTOS0.c **** }
 938:../Generated_Code/FreeRTOS0.c **** */
 939:../Generated_Code/FreeRTOS0.c **** 
 940:../Generated_Code/FreeRTOS0.c **** /*
 941:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 942:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGiveFromISR (component FreeRTOS)
 943:../Generated_Code/FreeRTOS0.c **** **     Description :
 944:../Generated_Code/FreeRTOS0.c **** **         Macro to release a semaphore. The semaphore must have
 945:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 946:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
 947:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores (those created using a call to
 948:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex()) must not be used with this macro.
 949:../Generated_Code/FreeRTOS0.c **** **         This macro can be used from an ISR.
 950:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 951:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 952:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore
 953:../Generated_Code/FreeRTOS0.c **** **                           being released. This is the handle returned
 954:../Generated_Code/FreeRTOS0.c **** **                           when the semaphore was created.
 955:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
 956:../Generated_Code/FreeRTOS0.c **** **                           - xSemaphoreGiveFromISR() will set
 957:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
 958:../Generated_Code/FreeRTOS0.c **** **                           giving the semaphoree caused a task to
 959:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
 960:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
 961:../Generated_Code/FreeRTOS0.c **** **                           task. If xSemaphoreGiveFromISR() sets this
 962:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
 963:../Generated_Code/FreeRTOS0.c **** **                           should be requested before the interrupt is
 964:../Generated_Code/FreeRTOS0.c **** **                           exited.
 965:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 966:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 967:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 968:../Generated_Code/FreeRTOS0.c **** */
 969:../Generated_Code/FreeRTOS0.c **** /*
 970:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPri
 971:../Generated_Code/FreeRTOS0.c **** {
 972:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 973:../Generated_Code/FreeRTOS0.c **** }
 974:../Generated_Code/FreeRTOS0.c **** */
 975:../Generated_Code/FreeRTOS0.c **** 
 976:../Generated_Code/FreeRTOS0.c **** /*
 977:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 978:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_pvPortMalloc (component FreeRTOS)
 979:../Generated_Code/FreeRTOS0.c **** **     Description :
 980:../Generated_Code/FreeRTOS0.c **** **         Allocates a memory block using the port pvPortMalloc()
 981:../Generated_Code/FreeRTOS0.c **** **         function
 982:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 983:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 984:../Generated_Code/FreeRTOS0.c **** **         xWantedSize     - size of memory block
 985:../Generated_Code/FreeRTOS0.c **** **                           requested
 986:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 987:../Generated_Code/FreeRTOS0.c **** **         ---             - memory block or NULL if failed
 988:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 989:../Generated_Code/FreeRTOS0.c **** */
 990:../Generated_Code/FreeRTOS0.c **** /*
 991:../Generated_Code/FreeRTOS0.c **** pVoid FreeRTOS0_pvPortMalloc(size_t xWantedSize)
 992:../Generated_Code/FreeRTOS0.c **** {
 993:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 994:../Generated_Code/FreeRTOS0.c **** }
 995:../Generated_Code/FreeRTOS0.c **** */
 996:../Generated_Code/FreeRTOS0.c **** 
 997:../Generated_Code/FreeRTOS0.c **** /*
 998:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 999:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vPortFree (component FreeRTOS)
1000:../Generated_Code/FreeRTOS0.c **** **     Description :
1001:../Generated_Code/FreeRTOS0.c **** **         Frees a memory block previously allocated with pvPortMalloc()
1002:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1003:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1004:../Generated_Code/FreeRTOS0.c **** **       * pv              - Pointer to data
1005:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1006:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1007:../Generated_Code/FreeRTOS0.c **** */
1008:../Generated_Code/FreeRTOS0.c **** /*
1009:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vPortFree(void *pv)
1010:../Generated_Code/FreeRTOS0.c **** {
1011:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1012:../Generated_Code/FreeRTOS0.c **** }
1013:../Generated_Code/FreeRTOS0.c **** */
1014:../Generated_Code/FreeRTOS0.c **** 
1015:../Generated_Code/FreeRTOS0.c **** /*
1016:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1017:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskGetTickCount (component FreeRTOS)
1018:../Generated_Code/FreeRTOS0.c **** **     Description :
1019:../Generated_Code/FreeRTOS0.c **** **         Return the count of ticks since vTaskStartScheduler was
1020:../Generated_Code/FreeRTOS0.c **** **         called.
1021:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1022:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1023:../Generated_Code/FreeRTOS0.c **** **         ---             - tick count
1024:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1025:../Generated_Code/FreeRTOS0.c **** */
1026:../Generated_Code/FreeRTOS0.c **** /*
1027:../Generated_Code/FreeRTOS0.c **** portTickType FreeRTOS0_xTaskGetTickCount(void)
1028:../Generated_Code/FreeRTOS0.c **** {
1029:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1030:../Generated_Code/FreeRTOS0.c **** }
1031:../Generated_Code/FreeRTOS0.c **** */
1032:../Generated_Code/FreeRTOS0.c **** 
1033:../Generated_Code/FreeRTOS0.c **** /*
1034:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1035:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskGetSchedulerState (component FreeRTOS)
1036:../Generated_Code/FreeRTOS0.c **** **     Description :
1037:../Generated_Code/FreeRTOS0.c **** **         Returns the state of the scheduler
1038:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1039:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1040:../Generated_Code/FreeRTOS0.c **** **         ---             - One of the following constants (defined
1041:../Generated_Code/FreeRTOS0.c **** **                           within task.h): taskSCHEDULER_NOT_STARTED,
1042:../Generated_Code/FreeRTOS0.c **** **                           taskSCHEDULER_RUNNING,
1043:../Generated_Code/FreeRTOS0.c **** **                           taskSCHEDULER_SUSPENDED.
1044:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1045:../Generated_Code/FreeRTOS0.c **** */
1046:../Generated_Code/FreeRTOS0.c **** /*
1047:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskGetSchedulerState(void)
1048:../Generated_Code/FreeRTOS0.c **** {
1049:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1050:../Generated_Code/FreeRTOS0.c **** }
1051:../Generated_Code/FreeRTOS0.c **** */
1052:../Generated_Code/FreeRTOS0.c **** 
1053:../Generated_Code/FreeRTOS0.c **** /*
1054:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1055:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskGetStackHighWaterMark (component FreeRTOS)
1056:../Generated_Code/FreeRTOS0.c **** **     Description :
1057:../Generated_Code/FreeRTOS0.c **** **         The stack used by a task will grow and shrink as the task
1058:../Generated_Code/FreeRTOS0.c **** **         executes and interrupts are processed.
1059:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetStackHighWaterMark() returns the minimum amount of
1060:../Generated_Code/FreeRTOS0.c **** **         remaining stack space that was available to the task since
1061:../Generated_Code/FreeRTOS0.c **** **         the task started executing - that is the amount of stack
1062:../Generated_Code/FreeRTOS0.c **** **         that remained unused when the task stack was at its greatest
1063:../Generated_Code/FreeRTOS0.c **** **         (deepest) value. This is what is referred to as the stack
1064:../Generated_Code/FreeRTOS0.c **** **         'high water mark'.
1065:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1066:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1067:../Generated_Code/FreeRTOS0.c **** **         xTask           - The handle of the task being queried.
1068:../Generated_Code/FreeRTOS0.c **** **                           A task may query its own high water mark by
1069:../Generated_Code/FreeRTOS0.c **** **                           passing NULL as the xTask parameter.
1070:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1071:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
1072:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1073:../Generated_Code/FreeRTOS0.c **** */
1074:../Generated_Code/FreeRTOS0.c **** /*
1075:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetStackHighWaterMark(xTaskHandle xTask)
1076:../Generated_Code/FreeRTOS0.c **** {
1077:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1078:../Generated_Code/FreeRTOS0.c **** }
1079:../Generated_Code/FreeRTOS0.c **** */
1080:../Generated_Code/FreeRTOS0.c **** 
1081:../Generated_Code/FreeRTOS0.c **** /*
1082:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1083:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskGetNumberOfTasks (component FreeRTOS)
1084:../Generated_Code/FreeRTOS0.c **** **     Description :
1085:../Generated_Code/FreeRTOS0.c **** **         Returns the number of tasks
1086:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1087:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1088:../Generated_Code/FreeRTOS0.c **** **         ---             - number of tasks
1089:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1090:../Generated_Code/FreeRTOS0.c **** */
1091:../Generated_Code/FreeRTOS0.c **** /*
1092:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetNumberOfTasks(void)
1093:../Generated_Code/FreeRTOS0.c **** {
1094:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1095:../Generated_Code/FreeRTOS0.c **** }
1096:../Generated_Code/FreeRTOS0.c **** */
1097:../Generated_Code/FreeRTOS0.c **** 
1098:../Generated_Code/FreeRTOS0.c **** /*
1099:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1100:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xPortGetFreeHeapSize (component FreeRTOS)
1101:../Generated_Code/FreeRTOS0.c **** **     Description :
1102:../Generated_Code/FreeRTOS0.c **** **         Returns the actual free size of the heap
1103:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1104:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1105:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
1106:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1107:../Generated_Code/FreeRTOS0.c **** */
1108:../Generated_Code/FreeRTOS0.c **** /*
1109:../Generated_Code/FreeRTOS0.c **** Tsize_t FreeRTOS0_xPortGetFreeHeapSize(void)
1110:../Generated_Code/FreeRTOS0.c **** {
1111:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1112:../Generated_Code/FreeRTOS0.c **** }
1113:../Generated_Code/FreeRTOS0.c **** */
1114:../Generated_Code/FreeRTOS0.c **** 
1115:../Generated_Code/FreeRTOS0.c **** /*
1116:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1117:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueCreate (component FreeRTOS)
1118:../Generated_Code/FreeRTOS0.c **** **     Description :
1119:../Generated_Code/FreeRTOS0.c **** **         Creates a queue.
1120:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1121:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1122:../Generated_Code/FreeRTOS0.c **** **         uxQueueLength   - The maximum number of
1123:../Generated_Code/FreeRTOS0.c **** **                           items the queue can hold at any time.
1124:../Generated_Code/FreeRTOS0.c **** **         uxItemSize      - The size in bytes of each
1125:../Generated_Code/FreeRTOS0.c **** **                           item the queue will hold.
1126:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1127:../Generated_Code/FreeRTOS0.c **** **         ---             - A handle to the created queue is returned
1128:../Generated_Code/FreeRTOS0.c **** **                           provided the queue was created successfully.
1129:../Generated_Code/FreeRTOS0.c **** **                           NULL is returned if the queue cannot be
1130:../Generated_Code/FreeRTOS0.c **** **                           created because there is too little heap
1131:../Generated_Code/FreeRTOS0.c **** **                           RAM available.
1132:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1133:../Generated_Code/FreeRTOS0.c **** */
1134:../Generated_Code/FreeRTOS0.c **** /*
1135:../Generated_Code/FreeRTOS0.c **** xQueueHandle FreeRTOS0_xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE ux
1136:../Generated_Code/FreeRTOS0.c **** {
1137:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1138:../Generated_Code/FreeRTOS0.c **** }
1139:../Generated_Code/FreeRTOS0.c **** */
1140:../Generated_Code/FreeRTOS0.c **** 
1141:../Generated_Code/FreeRTOS0.c **** /*
1142:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1143:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToFront (component FreeRTOS)
1144:../Generated_Code/FreeRTOS0.c **** **     Description :
1145:../Generated_Code/FreeRTOS0.c **** **         Sends an item to the front of a queue.
1146:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1147:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1148:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1149:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1150:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1151:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1152:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1153:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1154:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1155:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1156:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1157:../Generated_Code/FreeRTOS0.c **** **                           become available on the queue should the
1158:../Generated_Code/FreeRTOS0.c **** **                           queue already be full.
1159:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1160:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1161:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1162:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1163:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1164:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1165:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1166:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully sent to the
1167:../Generated_Code/FreeRTOS0.c **** **                           queue. If a block time was specified then
1168:../Generated_Code/FreeRTOS0.c **** **                           the calling task may have been temporarily
1169:../Generated_Code/FreeRTOS0.c **** **                           placed into the Blocked state to wait for
1170:../Generated_Code/FreeRTOS0.c **** **                           space to become available and space did
1171:../Generated_Code/FreeRTOS0.c **** **                           become available before the block time
1172:../Generated_Code/FreeRTOS0.c **** **                           expired.
1173:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL: The queue is already full so
1174:../Generated_Code/FreeRTOS0.c **** **                           no data could be sent to the queue. If a
1175:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1176:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1177:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1178:../Generated_Code/FreeRTOS0.c **** **                           become available, but no space became
1179:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1180:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1181:../Generated_Code/FreeRTOS0.c **** */
1182:../Generated_Code/FreeRTOS0.c **** /*
1183:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickT
1184:../Generated_Code/FreeRTOS0.c **** {
1185:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1186:../Generated_Code/FreeRTOS0.c **** }
1187:../Generated_Code/FreeRTOS0.c **** */
1188:../Generated_Code/FreeRTOS0.c **** 
1189:../Generated_Code/FreeRTOS0.c **** /*
1190:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1191:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToBack (component FreeRTOS)
1192:../Generated_Code/FreeRTOS0.c **** **     Description :
1193:../Generated_Code/FreeRTOS0.c **** **         Sends an item to the back of a queue.
1194:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1195:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1196:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1197:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1198:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1199:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1200:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1201:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1202:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1203:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1204:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1205:../Generated_Code/FreeRTOS0.c **** **                           become available on the queue should the
1206:../Generated_Code/FreeRTOS0.c **** **                           queue already be full.
1207:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1208:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1209:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1210:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1211:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1212:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1213:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1214:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully sent to the
1215:../Generated_Code/FreeRTOS0.c **** **                           queue. If a block time was specified then
1216:../Generated_Code/FreeRTOS0.c **** **                           the calling task may have been temporarily
1217:../Generated_Code/FreeRTOS0.c **** **                           placed into the Blocked state to wait for
1218:../Generated_Code/FreeRTOS0.c **** **                           space to become available and space did
1219:../Generated_Code/FreeRTOS0.c **** **                           become available before the block time
1220:../Generated_Code/FreeRTOS0.c **** **                           expired.
1221:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL: The queue is already full so
1222:../Generated_Code/FreeRTOS0.c **** **                           no data could be sent to the queue. If a
1223:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1224:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1225:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1226:../Generated_Code/FreeRTOS0.c **** **                           become available, but no space became
1227:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1228:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1229:../Generated_Code/FreeRTOS0.c **** */
1230:../Generated_Code/FreeRTOS0.c **** /*
1231:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickTy
1232:../Generated_Code/FreeRTOS0.c **** {
1233:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1234:../Generated_Code/FreeRTOS0.c **** }
1235:../Generated_Code/FreeRTOS0.c **** */
1236:../Generated_Code/FreeRTOS0.c **** 
1237:../Generated_Code/FreeRTOS0.c **** /*
1238:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1239:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReceive (component FreeRTOS)
1240:../Generated_Code/FreeRTOS0.c **** **     Description :
1241:../Generated_Code/FreeRTOS0.c **** **         Receives an item from a queue.
1242:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1243:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1244:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1245:../Generated_Code/FreeRTOS0.c **** **                           the data is to be received.
1246:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1247:../Generated_Code/FreeRTOS0.c **** **                           which the data received from the queue will
1248:../Generated_Code/FreeRTOS0.c **** **                           be copied.
1249:../Generated_Code/FreeRTOS0.c **** **                           The length of the buffer must be at least
1250:../Generated_Code/FreeRTOS0.c **** **                           equal to the queue item size (set when the
1251:../Generated_Code/FreeRTOS0.c **** **                           queue was created).
1252:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1253:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1254:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1255:../Generated_Code/FreeRTOS0.c **** **                           become available from the queue should the
1256:../Generated_Code/FreeRTOS0.c **** **                           queue already be empty.
1257:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1258:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1259:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1260:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1261:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1262:../Generated_Code/FreeRTOS0.c **** **                           for data.
1263:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1264:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1265:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1266:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1267:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1268:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1269:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1270:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1271:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1272:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1273:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1274:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1275:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1276:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1277:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1278:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1279:../Generated_Code/FreeRTOS0.c **** */
1280:../Generated_Code/FreeRTOS0.c **** /*
1281:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWai
1282:../Generated_Code/FreeRTOS0.c **** {
1283:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1284:../Generated_Code/FreeRTOS0.c **** }
1285:../Generated_Code/FreeRTOS0.c **** */
1286:../Generated_Code/FreeRTOS0.c **** 
1287:../Generated_Code/FreeRTOS0.c **** /*
1288:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1289:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueuePeek (component FreeRTOS)
1290:../Generated_Code/FreeRTOS0.c **** **     Description :
1291:../Generated_Code/FreeRTOS0.c **** **         Reads an item from a queue, but does not remove the item
1292:../Generated_Code/FreeRTOS0.c **** **         from the queue. Therefore the same item would be returned
1293:../Generated_Code/FreeRTOS0.c **** **         the next time xQueueReceive() or xQueuePeek() was called on
1294:../Generated_Code/FreeRTOS0.c **** **         the same queue.
1295:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1296:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1297:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1298:../Generated_Code/FreeRTOS0.c **** **                           the data is to be read.
1299:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1300:../Generated_Code/FreeRTOS0.c **** **                           which the data read from the queue will be
1301:../Generated_Code/FreeRTOS0.c **** **                           copied. The length of the buffer must be at
1302:../Generated_Code/FreeRTOS0.c **** **                           least equal to the queue item size (set
1303:../Generated_Code/FreeRTOS0.c **** **                           when the queue was created).
1304:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1305:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1306:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1307:../Generated_Code/FreeRTOS0.c **** **                           become available from the queue should the
1308:../Generated_Code/FreeRTOS0.c **** **                           queue already be empty.
1309:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1310:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1311:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1312:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1313:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1314:../Generated_Code/FreeRTOS0.c **** **                           for data.
1315:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1316:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1317:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1318:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1319:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1320:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1321:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1322:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1323:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1324:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1325:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1326:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1327:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1328:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1329:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1330:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1331:../Generated_Code/FreeRTOS0.c **** */
1332:../Generated_Code/FreeRTOS0.c **** /*
1333:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
1334:../Generated_Code/FreeRTOS0.c **** {
1335:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1336:../Generated_Code/FreeRTOS0.c **** }
1337:../Generated_Code/FreeRTOS0.c **** */
1338:../Generated_Code/FreeRTOS0.c **** 
1339:../Generated_Code/FreeRTOS0.c **** /*
1340:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1341:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vQueueDelete (component FreeRTOS)
1342:../Generated_Code/FreeRTOS0.c **** **     Description :
1343:../Generated_Code/FreeRTOS0.c **** **         Deletes a queue that was previously created using a call to
1344:../Generated_Code/FreeRTOS0.c **** **         xQueueCreate(). vQueueDelete() can also be used to delete a
1345:../Generated_Code/FreeRTOS0.c **** **         semaphore.
1346:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1347:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1348:../Generated_Code/FreeRTOS0.c **** **         pxQueueToDelete - The handle of the
1349:../Generated_Code/FreeRTOS0.c **** **                           queue being deleted. Semaphore handles can
1350:../Generated_Code/FreeRTOS0.c **** **                           also be used. Queues are used to pass data
1351:../Generated_Code/FreeRTOS0.c **** **                           between tasks and between tasks and
1352:../Generated_Code/FreeRTOS0.c **** **                           interrupts. A queue/semaphore must not be
1353:../Generated_Code/FreeRTOS0.c **** **                           deleted if there are any tasks that are
1354:../Generated_Code/FreeRTOS0.c **** **                           blocked on the queue/semaphore waiting for
1355:../Generated_Code/FreeRTOS0.c **** **                           events (sends or receives).
1356:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1357:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1358:../Generated_Code/FreeRTOS0.c **** */
1359:../Generated_Code/FreeRTOS0.c **** /*
1360:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vQueueDelete(xQueueHandle pxQueueToDelete)
1361:../Generated_Code/FreeRTOS0.c **** {
1362:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1363:../Generated_Code/FreeRTOS0.c **** }
1364:../Generated_Code/FreeRTOS0.c **** */
1365:../Generated_Code/FreeRTOS0.c **** 
1366:../Generated_Code/FreeRTOS0.c **** /*
1367:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1368:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxQueueMessagesWaiting (component FreeRTOS)
1369:../Generated_Code/FreeRTOS0.c **** **     Description :
1370:../Generated_Code/FreeRTOS0.c **** **         Queries the number of items that are currently held within a
1371:../Generated_Code/FreeRTOS0.c **** **         queue.
1372:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1373:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1374:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue being
1375:../Generated_Code/FreeRTOS0.c **** **                           queried.
1376:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1377:../Generated_Code/FreeRTOS0.c **** **         ---             - The number of items that are held within
1378:../Generated_Code/FreeRTOS0.c **** **                           the queue being queried.
1379:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1380:../Generated_Code/FreeRTOS0.c **** */
1381:../Generated_Code/FreeRTOS0.c **** /*
1382:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting(xQueueHandle xQueue)
1383:../Generated_Code/FreeRTOS0.c **** {
1384:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1385:../Generated_Code/FreeRTOS0.c **** }
1386:../Generated_Code/FreeRTOS0.c **** */
1387:../Generated_Code/FreeRTOS0.c **** 
1388:../Generated_Code/FreeRTOS0.c **** /*
1389:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1390:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxQueueMessagesWaitingfromISR (component FreeRTOS)
1391:../Generated_Code/FreeRTOS0.c **** **     Description :
1392:../Generated_Code/FreeRTOS0.c **** **         A version of uxQueueMessagesWaiting() that can be used from
1393:../Generated_Code/FreeRTOS0.c **** **         inside an interrupt service routine.
1394:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1395:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1396:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue being
1397:../Generated_Code/FreeRTOS0.c **** **                           queried.
1398:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1399:../Generated_Code/FreeRTOS0.c **** **         ---             - The number of items that are held within
1400:../Generated_Code/FreeRTOS0.c **** **                           the queue being queried.
1401:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1402:../Generated_Code/FreeRTOS0.c **** */
1403:../Generated_Code/FreeRTOS0.c **** /*
1404:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
1405:../Generated_Code/FreeRTOS0.c **** {
1406:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1407:../Generated_Code/FreeRTOS0.c **** }
1408:../Generated_Code/FreeRTOS0.c **** */
1409:../Generated_Code/FreeRTOS0.c **** 
1410:../Generated_Code/FreeRTOS0.c **** /*
1411:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1412:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReceiveFromISR (component FreeRTOS)
1413:../Generated_Code/FreeRTOS0.c **** **     Description :
1414:../Generated_Code/FreeRTOS0.c **** **         A version of xQueueReceive() that can be called from an ISR.
1415:../Generated_Code/FreeRTOS0.c **** **         Unlike xQueueReceive(), xQueueReceiveFromISR() does not
1416:../Generated_Code/FreeRTOS0.c **** **         permit a block time to be specified.
1417:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1418:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1419:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1420:../Generated_Code/FreeRTOS0.c **** **                           the data is to be received.
1421:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1422:../Generated_Code/FreeRTOS0.c **** **                           which the data received from the queue will
1423:../Generated_Code/FreeRTOS0.c **** **                           be copied.The length of the buffer must be
1424:../Generated_Code/FreeRTOS0.c **** **                           at least equal to the queue item size (set
1425:../Generated_Code/FreeRTOS0.c **** **                           when the queue was created).
1426:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1427:../Generated_Code/FreeRTOS0.c **** **                           - Pointer to A task may be blocked waiting
1428:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1429:../Generated_Code/FreeRTOS0.c **** **                           If xQueueReceiveFromISR() causes such a
1430:../Generated_Code/FreeRTOS0.c **** **                           task to unblock then
1431:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken will get set to
1432:../Generated_Code/FreeRTOS0.c **** **                           pdTRUE, otherwise
1433:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken will remain
1434:../Generated_Code/FreeRTOS0.c **** **                           unchanged.
1435:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1436:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1437:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1438:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1439:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1440:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1441:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1442:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1443:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1444:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1445:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1446:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1447:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1448:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1449:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1450:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1451:../Generated_Code/FreeRTOS0.c **** */
1452:../Generated_Code/FreeRTOS0.c **** /*
1453:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *px
1454:../Generated_Code/FreeRTOS0.c **** {
1455:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1456:../Generated_Code/FreeRTOS0.c **** }
1457:../Generated_Code/FreeRTOS0.c **** */
1458:../Generated_Code/FreeRTOS0.c **** 
1459:../Generated_Code/FreeRTOS0.c **** /*
1460:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1461:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToFrontFromISR (component FreeRTOS)
1462:../Generated_Code/FreeRTOS0.c **** **     Description :
1463:../Generated_Code/FreeRTOS0.c **** **         Versions of xQueueSendToFront() API functions that can be
1464:../Generated_Code/FreeRTOS0.c **** **         called from an ISR. Unlike xQueueSendToFront() these
1465:../Generated_Code/FreeRTOS0.c **** **         functions do not permit a block time to be specified.
1466:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1467:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1468:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1469:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1470:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1471:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1472:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1473:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1474:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1475:../Generated_Code/FreeRTOS0.c **** **                           - xQueueSendFromISR() will set
1476:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1477:../Generated_Code/FreeRTOS0.c **** **                           sending to the queue caused a task to
1478:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1479:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1480:../Generated_Code/FreeRTOS0.c **** **                           task. If xQueueSendFromISR() sets this
1481:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1482:../Generated_Code/FreeRTOS0.c **** **                           should be performed before the interrupt is
1483:../Generated_Code/FreeRTOS0.c **** **                           exited.
1484:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1485:../Generated_Code/FreeRTOS0.c **** **         ---             - pdTRUE Data was successfully sent to the
1486:../Generated_Code/FreeRTOS0.c **** **                           queue.
1487:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL Data could not be sent to the
1488:../Generated_Code/FreeRTOS0.c **** **                           queue because the queue was already full.
1489:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1490:../Generated_Code/FreeRTOS0.c **** */
1491:../Generated_Code/FreeRTOS0.c **** /*
1492:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, po
1493:../Generated_Code/FreeRTOS0.c **** {
1494:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1495:../Generated_Code/FreeRTOS0.c **** }
1496:../Generated_Code/FreeRTOS0.c **** */
1497:../Generated_Code/FreeRTOS0.c **** 
1498:../Generated_Code/FreeRTOS0.c **** /*
1499:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1500:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToBackFromISR (component FreeRTOS)
1501:../Generated_Code/FreeRTOS0.c **** **     Description :
1502:../Generated_Code/FreeRTOS0.c **** **         Versions of xQueueSendToBack() API functions that can be
1503:../Generated_Code/FreeRTOS0.c **** **         called from an ISR. Unlike xQueueSendToBack() these
1504:../Generated_Code/FreeRTOS0.c **** **         functions do not permit a block time to be specified.
1505:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1506:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1507:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1508:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1509:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1510:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1511:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1512:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1513:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1514:../Generated_Code/FreeRTOS0.c **** **                           - xQueueSendFromISR() will set
1515:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1516:../Generated_Code/FreeRTOS0.c **** **                           sending to the queue caused a task to
1517:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1518:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1519:../Generated_Code/FreeRTOS0.c **** **                           task. If xQueueSendFromISR() sets this
1520:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1521:../Generated_Code/FreeRTOS0.c **** **                           should be performed before the interrupt is
1522:../Generated_Code/FreeRTOS0.c **** **                           exited.
1523:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1524:../Generated_Code/FreeRTOS0.c **** **         ---             - pdTRUE Data was successfully sent to the
1525:../Generated_Code/FreeRTOS0.c **** **                           queue.
1526:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL Data could not be sent to the
1527:../Generated_Code/FreeRTOS0.c **** **                           queue because the queue was already full.
1528:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1529:../Generated_Code/FreeRTOS0.c **** */
1530:../Generated_Code/FreeRTOS0.c **** /*
1531:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, por
1532:../Generated_Code/FreeRTOS0.c **** {
1533:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1534:../Generated_Code/FreeRTOS0.c **** }
1535:../Generated_Code/FreeRTOS0.c **** */
1536:../Generated_Code/FreeRTOS0.c **** /*
1537:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1538:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReset (component FreeRTOS)
1539:../Generated_Code/FreeRTOS0.c **** **     Description :
1540:../Generated_Code/FreeRTOS0.c **** **         Reset a queue back to its original empty state.  pdPASS is
1541:../Generated_Code/FreeRTOS0.c **** **         returned if the queue is successfully reset.  pdFAIL is
1542:../Generated_Code/FreeRTOS0.c **** **         returned if the queue could not be reset because there are
1543:../Generated_Code/FreeRTOS0.c **** **         tasks blocked on the queue waiting to either receive from
1544:../Generated_Code/FreeRTOS0.c **** **         the queue or send to the queue.
1545:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1546:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1547:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to reset.
1548:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1549:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS is returned if the queue is
1550:../Generated_Code/FreeRTOS0.c **** **                           successfully reset. pdFAIL is returned if
1551:../Generated_Code/FreeRTOS0.c **** **                           the queue could not be reset because there
1552:../Generated_Code/FreeRTOS0.c **** **                           are tasks blocked on the queue waiting to
1553:../Generated_Code/FreeRTOS0.c **** **                           either receive from the queue or send to
1554:../Generated_Code/FreeRTOS0.c **** **                           the queue.
1555:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1556:../Generated_Code/FreeRTOS0.c **** */
1557:../Generated_Code/FreeRTOS0.c **** /*
1558:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReset(xQueueHandle xQueue)
1559:../Generated_Code/FreeRTOS0.c **** {
1560:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1561:../Generated_Code/FreeRTOS0.c **** }
1562:../Generated_Code/FreeRTOS0.c **** */
1563:../Generated_Code/FreeRTOS0.c **** 
1564:../Generated_Code/FreeRTOS0.c **** /*
1565:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1566:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGetMutexHolder (component FreeRTOS)
1567:../Generated_Code/FreeRTOS0.c **** **     Description :
1568:../Generated_Code/FreeRTOS0.c **** **         Returns the holder of a mutex or semaphore. If xMutex is
1569:../Generated_Code/FreeRTOS0.c **** **         indeed a mutex type semaphore, return the current mutex
1570:../Generated_Code/FreeRTOS0.c **** **         holder. If xMutex is not a mutex type semaphore, or the
1571:../Generated_Code/FreeRTOS0.c **** **         mutex is available (not held by a task), return NULL. Note:
1572:../Generated_Code/FreeRTOS0.c **** **         This Is is a good way of determining if the calling task is
1573:../Generated_Code/FreeRTOS0.c **** **         the mutex holder, but not a good way of determining the
1574:../Generated_Code/FreeRTOS0.c **** **         identity of the mutex holder as the holder may change
1575:../Generated_Code/FreeRTOS0.c **** **         between the function exiting and the returned value being
1576:../Generated_Code/FreeRTOS0.c **** **         tested.
1577:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1578:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1579:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore.
1580:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1581:../Generated_Code/FreeRTOS0.c **** **         ---             - Not NULL if the calling task is the holder
1582:../Generated_Code/FreeRTOS0.c **** **                           of the mutex, NULL otherwise.
1583:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1584:../Generated_Code/FreeRTOS0.c **** */
1585:../Generated_Code/FreeRTOS0.c **** /*
1586:../Generated_Code/FreeRTOS0.c **** void* FreeRTOS0_xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
1587:../Generated_Code/FreeRTOS0.c **** {
1588:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1589:../Generated_Code/FreeRTOS0.c **** }
1590:../Generated_Code/FreeRTOS0.c **** */
1591:../Generated_Code/FreeRTOS0.c **** 
1592:../Generated_Code/FreeRTOS0.c **** /*
1593:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1594:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTakeFromISR (component FreeRTOS)
1595:../Generated_Code/FreeRTOS0.c **** **     Description :
1596:../Generated_Code/FreeRTOS0.c **** **         Macro to take a semaphore from an ISR. The semaphore must
1597:../Generated_Code/FreeRTOS0.c **** **         have previously been created with a call to
1598:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
1599:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores (those created using a call to
1600:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex()) must not be used with this macro.
1601:../Generated_Code/FreeRTOS0.c **** **         This macro can be used from an ISR, however taking a
1602:../Generated_Code/FreeRTOS0.c **** **         semaphore from an ISR is not a common operation.  It is
1603:../Generated_Code/FreeRTOS0.c **** **         likely to only be useful when taking a counting semaphore
1604:../Generated_Code/FreeRTOS0.c **** **         when an interrupt is obtaining an object from a resource
1605:../Generated_Code/FreeRTOS0.c **** **         pool (when the semaphore count indicates the number of
1606:../Generated_Code/FreeRTOS0.c **** **         resources available).
1607:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1608:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1609:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore
1610:../Generated_Code/FreeRTOS0.c **** **                           being taken. This is the handle returned
1611:../Generated_Code/FreeRTOS0.c **** **                           when the semaphore was created.
1612:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1613:../Generated_Code/FreeRTOS0.c **** **                           - xSemaphoreTakeFromISR() will set
1614:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1615:../Generated_Code/FreeRTOS0.c **** **                           taking the semaphore caused a task to
1616:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1617:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1618:../Generated_Code/FreeRTOS0.c **** **                           task.  If xSemaphoreTakeFromISR() sets this
1619:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1620:../Generated_Code/FreeRTOS0.c **** **                           should be requested before the interrupt is
1621:../Generated_Code/FreeRTOS0.c **** **                           exited.
1622:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1623:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
1624:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1625:../Generated_Code/FreeRTOS0.c **** */
1626:../Generated_Code/FreeRTOS0.c **** /*
1627:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPri
1628:../Generated_Code/FreeRTOS0.c **** {
1629:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1630:../Generated_Code/FreeRTOS0.c **** }
1631:../Generated_Code/FreeRTOS0.c **** */
1632:../Generated_Code/FreeRTOS0.c **** 
1633:../Generated_Code/FreeRTOS0.c **** /*
1634:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1635:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_Init (component FreeRTOS)
1636:../Generated_Code/FreeRTOS0.c **** **     Description :
1637:../Generated_Code/FreeRTOS0.c **** **         Low level initialization routine called from startup code.
1638:../Generated_Code/FreeRTOS0.c **** **         This method ensures that the tick timer is  not enabled.
1639:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1640:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1641:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1642:../Generated_Code/FreeRTOS0.c **** */
1643:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_Init(void)
1644:../Generated_Code/FreeRTOS0.c **** {
  26              		.loc 1 1644 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 00AF     		add	r7, sp, #0
  34              	.LCFI1:
  35              		.cfi_def_cfa_register 7
1645:../Generated_Code/FreeRTOS0.c ****   vPortInitTickTimer();
  36              		.loc 1 1645 0
  37 0004 FFF7FEFF 		bl	vPortInitTickTimer
1646:../Generated_Code/FreeRTOS0.c ****   vPortStopTickTimer();
  38              		.loc 1 1646 0
  39 0008 FFF7FEFF 		bl	vPortStopTickTimer
1647:../Generated_Code/FreeRTOS0.c **** }
  40              		.loc 1 1647 0
  41 000c BD46     		mov	sp, r7
  42              		@ sp needed for prologue
  43 000e 80BD     		pop	{r7, pc}
  44              		.cfi_endproc
  45              	.LFE5:
  47              		.text
  48              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS0.c
C:\Users\JH\AppData\Local\Temp\cc3Hj29X.s:18     .text._Z14FreeRTOS0_Initv:00000000 $t
C:\Users\JH\AppData\Local\Temp\cc3Hj29X.s:23     .text._Z14FreeRTOS0_Initv:00000000 _Z14FreeRTOS0_Initv
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortInitTickTimer
vPortStopTickTimer
