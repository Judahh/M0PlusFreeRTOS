   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"FreeRTOS0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text._Z14FreeRTOS0_Initv,"ax",%progbits
  18              		.align	2
  19              		.global	_Z14FreeRTOS0_Initv
  20              		.code	16
  21              		.thumb_func
  23              	_Z14FreeRTOS0_Initv:
  24              	.LFB5:
  25              		.file 1 "../Generated_Code/FreeRTOS0.c"
   1:../Generated_Code/FreeRTOS0.c **** /* ###################################################################
   2:../Generated_Code/FreeRTOS0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/FreeRTOS0.c **** **     Filename    : FreeRTOS0.c
   4:../Generated_Code/FreeRTOS0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/FreeRTOS0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/FreeRTOS0.c **** **     Component   : FreeRTOS
   7:../Generated_Code/FreeRTOS0.c **** **     Version     : Component 01.360, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/FreeRTOS0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/FreeRTOS0.c **** **     Date/Time   : 2014-04-05, 20:25, # CodeGen: 10
  10:../Generated_Code/FreeRTOS0.c **** **     Abstract    :
  11:../Generated_Code/FreeRTOS0.c **** **          This component implements the FreeRTOS Realtime Operating System
  12:../Generated_Code/FreeRTOS0.c **** **     Settings    :
  13:../Generated_Code/FreeRTOS0.c **** **          Component name                                 : FreeRTOS0
  14:../Generated_Code/FreeRTOS0.c **** **          RTOS Version                                   : V8.0.0
  15:../Generated_Code/FreeRTOS0.c **** **          Custom Port                                    : Custom port settings
  16:../Generated_Code/FreeRTOS0.c **** **            Compiler                                     : automatic
  17:../Generated_Code/FreeRTOS0.c **** **            Static Sources                               : Disabled
  18:../Generated_Code/FreeRTOS0.c **** **            Custom portBASE_TYPE                         : Disabled
  19:../Generated_Code/FreeRTOS0.c **** **          Classic CodeWarrior                            : no
  20:../Generated_Code/FreeRTOS0.c **** **          Disabled Interrupts in Startup                 : yes
  21:../Generated_Code/FreeRTOS0.c **** **          Application Task Tags                          : no
  22:../Generated_Code/FreeRTOS0.c **** **          Use Trace Facility                             : no
  23:../Generated_Code/FreeRTOS0.c **** **          Trace Hooks                                    : Disabled
  24:../Generated_Code/FreeRTOS0.c **** **          Collect Runtime Statistics                     : Disabled
  25:../Generated_Code/FreeRTOS0.c **** **          Scheduler                                      : Settings for the scheduler
  26:../Generated_Code/FreeRTOS0.c **** **            ColdFire V1                                  : Disabled
  27:../Generated_Code/FreeRTOS0.c **** **            ColdFire V2                                  : Disabled
  28:../Generated_Code/FreeRTOS0.c **** **            Kinetis                                      : Enabled
  29:../Generated_Code/FreeRTOS0.c **** **              ARM Family                                 : Cortex M0+
  30:../Generated_Code/FreeRTOS0.c **** **              Floating Point Support                     : no
  31:../Generated_Code/FreeRTOS0.c **** **              Max SysCall Interrupt Priority             : 3
  32:../Generated_Code/FreeRTOS0.c **** **              RTOS Interrupt Priority                    : 3
  33:../Generated_Code/FreeRTOS0.c **** **              Lowest Interrupt Priority                  : 3
  34:../Generated_Code/FreeRTOS0.c **** **              Compiler Optimization Level                : 0
  35:../Generated_Code/FreeRTOS0.c **** **              SysTick                                    : Enabled
  36:../Generated_Code/FreeRTOS0.c **** **                Core Clock                               : yes
  37:../Generated_Code/FreeRTOS0.c **** **              Low Power Timer                            : Disabled
  38:../Generated_Code/FreeRTOS0.c **** **            non-LDD SWI                                  : Disabled
  39:../Generated_Code/FreeRTOS0.c **** **            Preemptive                                   : yes
  40:../Generated_Code/FreeRTOS0.c **** **            Use Co-Routines                              : no
  41:../Generated_Code/FreeRTOS0.c **** **            Idle should yield                            : yes
  42:../Generated_Code/FreeRTOS0.c **** **            Task Name Length                             : 25
  43:../Generated_Code/FreeRTOS0.c **** **            Minimal Stack Size                           : 200
  44:../Generated_Code/FreeRTOS0.c **** **            Maximum Priorities                           : 6
  45:../Generated_Code/FreeRTOS0.c **** **            Maximum Coroutine Priorities                 : 2
  46:../Generated_Code/FreeRTOS0.c **** **            Stackoverflow checking method                : Method 1
  47:../Generated_Code/FreeRTOS0.c **** **            Cleanup Resources                            : yes
  48:../Generated_Code/FreeRTOS0.c **** **          Ticks                                          : Settings for the periodic tick timer
  49:../Generated_Code/FreeRTOS0.c **** **            Tickless Idle Mode                           : Disabled
  50:../Generated_Code/FreeRTOS0.c **** **            Tick Rate (Hz)                               : 100
  51:../Generated_Code/FreeRTOS0.c **** **            Use 16bit ticks                              : no
  52:../Generated_Code/FreeRTOS0.c **** **            non-LDD Tick                                 : Disabled
  53:../Generated_Code/FreeRTOS0.c **** **            LDD Tick                                     : Disabled
  54:../Generated_Code/FreeRTOS0.c **** **          Queues                                         : Settings for Queues
  55:../Generated_Code/FreeRTOS0.c **** **            Queue Registry Size                          : 0
  56:../Generated_Code/FreeRTOS0.c **** **            Queue Sets                                   : no
  57:../Generated_Code/FreeRTOS0.c **** **          Semaphores and Mutexes                         : Settings for Mutex and Semaphore
  58:../Generated_Code/FreeRTOS0.c **** **            Use Mutexes                                  : yes
  59:../Generated_Code/FreeRTOS0.c **** **            Use Recursive Mutexes                        : yes
  60:../Generated_Code/FreeRTOS0.c **** **          Timers                                         : Disabled
  61:../Generated_Code/FreeRTOS0.c **** **          Memory                                         : Settings for the memory and heap alloc
  62:../Generated_Code/FreeRTOS0.c **** **            Memory Allocation Scheme                     : Scheme 2
  63:../Generated_Code/FreeRTOS0.c **** **            User Heap Section                            : Disabled
  64:../Generated_Code/FreeRTOS0.c **** **            Total Heap Size                              : 5000
  65:../Generated_Code/FreeRTOS0.c **** **          Shell                                          : Disabled
  66:../Generated_Code/FreeRTOS0.c **** **          Utility                                        : UTIL0
  67:../Generated_Code/FreeRTOS0.c **** **     Contents    :
  68:../Generated_Code/FreeRTOS0.c **** **         xTaskCreate                    - portBASE_TYPE FreeRTOS0_xTaskCreate(pdTASK_CODE pvTaskC
  69:../Generated_Code/FreeRTOS0.c **** **         vTaskDelete                    - void FreeRTOS0_vTaskDelete(xTaskHandle pxTask);
  70:../Generated_Code/FreeRTOS0.c **** **         vTaskStartScheduler            - void FreeRTOS0_vTaskStartScheduler(void);
  71:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspend                   - void FreeRTOS0_vTaskSuspend(xTaskHandle pxTaskToSuspend
  72:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspendAll                - void FreeRTOS0_vTaskSuspendAll(void);
  73:../Generated_Code/FreeRTOS0.c **** **         vTaskResume                    - void FreeRTOS0_vTaskResume(xTaskHandle pxTaskToResume);
  74:../Generated_Code/FreeRTOS0.c **** **         xTaskResumeAll                 - portBASE_TYPE FreeRTOS0_xTaskResumeAll(void);
  75:../Generated_Code/FreeRTOS0.c **** **         xTaskResumeFromISR             - portBASE_TYPE FreeRTOS0_xTaskResumeFromISR(xTaskHandle 
  76:../Generated_Code/FreeRTOS0.c **** **         taskYIELD                      - void FreeRTOS0_taskYIELD(void);
  77:../Generated_Code/FreeRTOS0.c **** **         taskENTER_CRITICAL             - void FreeRTOS0_taskENTER_CRITICAL(void);
  78:../Generated_Code/FreeRTOS0.c **** **         taskEXIT_CRITICAL              - void FreeRTOS0_taskEXIT_CRITICAL(void);
  79:../Generated_Code/FreeRTOS0.c **** **         taskDISABLE_INTERRUPTS         - void FreeRTOS0_taskDISABLE_INTERRUPTS(void);
  80:../Generated_Code/FreeRTOS0.c **** **         taskENABLE_INTERRUPTS          - void FreeRTOS0_taskENABLE_INTERRUPTS(void);
  81:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay                     - void FreeRTOS0_vTaskDelay(portTickType xTicksToDelay);
  82:../Generated_Code/FreeRTOS0.c **** **         vTaskDelayUntil                - void FreeRTOS0_vTaskDelayUntil(portTickType *pxPrevious
  83:../Generated_Code/FreeRTOS0.c **** **         uxTaskPriorityGet              - unsigned_portBASE_TYPE FreeRTOS0_uxTaskPriorityGet(xTas
  84:../Generated_Code/FreeRTOS0.c **** **         vTaskPrioritySet               - void FreeRTOS0_vTaskPrioritySet(xTaskHandle pxTask, uns
  85:../Generated_Code/FreeRTOS0.c **** **         xTaskGetTickCount              - portTickType FreeRTOS0_xTaskGetTickCount(void);
  86:../Generated_Code/FreeRTOS0.c **** **         xTaskGetTickCountFromISR       - portTickType FreeRTOS0_xTaskGetTickCountFromISR(void);
  87:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateRecursiveMutex - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateRecursiveMut
  88:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive        - bool FreeRTOS0_xSemaphoreTakeRecursive(xSemaphoreHandle
  89:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive        - bool FreeRTOS0_xSemaphoreGiveRecursive(xSemaphoreHandle
  90:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex          - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateMutex(void);
  91:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake                 - bool FreeRTOS0_xSemaphoreTake(xSemaphoreHandle xMutex, 
  92:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGive                 - bool FreeRTOS0_xSemaphoreGive(xSemaphoreHandle xMutex);
  93:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary         - void FreeRTOS0_vSemaphoreCreateBinary(xSemaphoreHandle 
  94:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting       - xSemaphoreHandle FreeRTOS0_xSemaphoreCreateCounting(uns
  95:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR          - bool FreeRTOS0_xSemaphoreGiveFromISR(xSemaphoreHandle x
  96:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeFromISR          - bool FreeRTOS0_xSemaphoreTakeFromISR(xSemaphoreHandle x
  97:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreDelete               - void FreeRTOS0_vSemaphoreDelete(xSemaphoreHandle xSemap
  98:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGetMutexHolder       - void* FreeRTOS0_xSemaphoreGetMutexHolder(xSemaphoreHand
  99:../Generated_Code/FreeRTOS0.c **** **         pvPortMalloc                   - pVoid FreeRTOS0_pvPortMalloc(size_t xWantedSize);
 100:../Generated_Code/FreeRTOS0.c **** **         vPortFree                      - void FreeRTOS0_vPortFree(void *pv);
 101:../Generated_Code/FreeRTOS0.c **** **         xPortGetFreeHeapSize           - Tsize_t FreeRTOS0_xPortGetFreeHeapSize(void);
 102:../Generated_Code/FreeRTOS0.c **** **         xTaskGetSchedulerState         - portBASE_TYPE FreeRTOS0_xTaskGetSchedulerState(void);
 103:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetStackHighWaterMark    - unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetStackHighWate
 104:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetNumberOfTasks         - unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetNumberOfTasks
 105:../Generated_Code/FreeRTOS0.c **** **         uxQueueMessagesWaiting         - unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting
 106:../Generated_Code/FreeRTOS0.c **** **         uxQueueMessagesWaitingfromISR  - unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting
 107:../Generated_Code/FreeRTOS0.c **** **         xQueueCreate                   - xQueueHandle FreeRTOS0_xQueueCreate(unsigned_portBASE_T
 108:../Generated_Code/FreeRTOS0.c **** **         vQueueDelete                   - void FreeRTOS0_vQueueDelete(xQueueHandle pxQueueToDelet
 109:../Generated_Code/FreeRTOS0.c **** **         xQueueReset                    - portBASE_TYPE FreeRTOS0_xQueueReset(xQueueHandle xQueue
 110:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToBack               - portBASE_TYPE FreeRTOS0_xQueueSendToBack(xQueueHandle x
 111:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToFront              - portBASE_TYPE FreeRTOS0_xQueueSendToFront(xQueueHandle 
 112:../Generated_Code/FreeRTOS0.c **** **         xQueueReceive                  - portBASE_TYPE FreeRTOS0_xQueueReceive(xQueueHandle xQue
 113:../Generated_Code/FreeRTOS0.c **** **         xQueueOverwrite                - portBASE_TYPE FreeRTOS0_xQueueOverwrite(xQueueHandle xQ
 114:../Generated_Code/FreeRTOS0.c **** **         xQueueOverwriteFromISR         - portBASE_TYPE FreeRTOS0_xQueueOverwriteFromISR(xQueueHa
 115:../Generated_Code/FreeRTOS0.c **** **         xQueuePeek                     - portBASE_TYPE FreeRTOS0_xQueuePeek(xQueueHandle xQueue,
 116:../Generated_Code/FreeRTOS0.c **** **         xQueuePeekFromISR              - portBASE_TYPE FreeRTOS0_xQueuePeekFromISR(xQueueHandle 
 117:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToBackFromISR        - portBASE_TYPE FreeRTOS0_xQueueSendToBackFromISR(xQueueH
 118:../Generated_Code/FreeRTOS0.c **** **         xQueueSendToFrontFromISR       - portBASE_TYPE FreeRTOS0_xQueueSendToFrontFromISR(xQueue
 119:../Generated_Code/FreeRTOS0.c **** **         xQueueReceiveFromISR           - portBASE_TYPE FreeRTOS0_xQueueReceiveFromISR(xQueueHand
 120:../Generated_Code/FreeRTOS0.c **** **         vQueueAddToRegistry            - void FreeRTOS0_vQueueAddToRegistry(xQueueHandle xQueue,
 121:../Generated_Code/FreeRTOS0.c **** **         vQueueUnregisterQueue          - void FreeRTOS0_vQueueUnregisterQueue(xQueueHandle xQueu
 122:../Generated_Code/FreeRTOS0.c **** **         xQueueIsQueueFullFromISR       - portBASE_TYPE FreeRTOS0_xQueueIsQueueFullFromISR(xQueue
 123:../Generated_Code/FreeRTOS0.c **** **         xQueueIsQueueEmptyFromISR      - portBASE_TYPE FreeRTOS0_xQueueIsQueueEmptyFromISR(xQueu
 124:../Generated_Code/FreeRTOS0.c **** **         xEventGroupCreate              - EventGroupHandle_t FreeRTOS0_xEventGroupCreate(void);
 125:../Generated_Code/FreeRTOS0.c **** **         xEventGroupWaitBits            - byte FreeRTOS0_xEventGroupWaitBits(const EventGroupHand
 126:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSetBits             - EventBits_t FreeRTOS0_xEventGroupSetBits(EventGroupHand
 127:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSetBitsFromISR      - EventBits_t FreeRTOS0_xEventGroupSetBitsFromISR(EventGr
 128:../Generated_Code/FreeRTOS0.c **** **         xEventGroupClearBits           - EventBits_t FreeRTOS0_xEventGroupClearBits(EventGroupHa
 129:../Generated_Code/FreeRTOS0.c **** **         xEventGroupClearBitsFromISR    - EventBits_t FreeRTOS0_xEventGroupClearBitsFromISR(Event
 130:../Generated_Code/FreeRTOS0.c **** **         xEventGroupGetBits             - EventBits_t FreeRTOS0_xEventGroupGetBits(EventGroupHand
 131:../Generated_Code/FreeRTOS0.c **** **         xEventGroupGetBitsFromISR      - EventBits_t FreeRTOS0_xEventGroupGetBitsFromISR(EventGr
 132:../Generated_Code/FreeRTOS0.c **** **         xEventGroupSync                - EventBits_t FreeRTOS0_xEventGroupSync(EventGroupHandle_
 133:../Generated_Code/FreeRTOS0.c **** **         Init                           - void FreeRTOS0_Init(void);
 134:../Generated_Code/FreeRTOS0.c **** **
 135:../Generated_Code/FreeRTOS0.c **** **     License : Open Source (LGPL)
 136:../Generated_Code/FreeRTOS0.c **** **     FreeRTOS (c) Copyright 2003-2014 Richard Barry, http: www.FreeRTOS.org
 137:../Generated_Code/FreeRTOS0.c **** **     FreeRTOS Processor Expert Component: (c) Copyright Erich Styger, 2013
 138:../Generated_Code/FreeRTOS0.c **** **     Processor Expert and CodeWarrior (c) Copyright Freescale Semiconductor, 2013, all rights res
 139:../Generated_Code/FreeRTOS0.c **** **     This is a free software and is opened for education, research and commercial developments un
 140:../Generated_Code/FreeRTOS0.c **** **     * This is a free software and there is NO WARRANTY.
 141:../Generated_Code/FreeRTOS0.c **** **     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or
 142:../Generated_Code/FreeRTOS0.c **** **     * Redistributions of source code must retain the above copyright notice.
 143:../Generated_Code/FreeRTOS0.c **** ** ###################################################################*/
 144:../Generated_Code/FreeRTOS0.c **** /*!
 145:../Generated_Code/FreeRTOS0.c **** ** @file FreeRTOS0.c
 146:../Generated_Code/FreeRTOS0.c **** ** @version 01.00
 147:../Generated_Code/FreeRTOS0.c **** ** @brief
 148:../Generated_Code/FreeRTOS0.c **** **          This component implements the FreeRTOS Realtime Operating System
 149:../Generated_Code/FreeRTOS0.c **** */         
 150:../Generated_Code/FreeRTOS0.c **** /*!
 151:../Generated_Code/FreeRTOS0.c **** **  @addtogroup FreeRTOS0_module FreeRTOS0 module documentation
 152:../Generated_Code/FreeRTOS0.c **** **  @{
 153:../Generated_Code/FreeRTOS0.c **** */         
 154:../Generated_Code/FreeRTOS0.c **** 
 155:../Generated_Code/FreeRTOS0.c **** /* MODULE FreeRTOS0. */
 156:../Generated_Code/FreeRTOS0.c **** 
 157:../Generated_Code/FreeRTOS0.c **** #include "Events.h"
 158:../Generated_Code/FreeRTOS0.c **** #include "FreeRTOS0.h"
 159:../Generated_Code/FreeRTOS0.c **** #include "portTicks.h"                 /* interface to tick counter */
 160:../Generated_Code/FreeRTOS0.c **** 
 161:../Generated_Code/FreeRTOS0.c **** 
 162:../Generated_Code/FreeRTOS0.c **** /*
 163:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 164:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskCreate (component FreeRTOS)
 165:../Generated_Code/FreeRTOS0.c **** **     Description :
 166:../Generated_Code/FreeRTOS0.c **** **         Create a new task and add it to the list of tasks that are
 167:../Generated_Code/FreeRTOS0.c **** **         ready to run.
 168:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 169:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 170:../Generated_Code/FreeRTOS0.c **** **         pvTaskCode      - Pointer to the task entry
 171:../Generated_Code/FreeRTOS0.c **** **                           function. Tasks must be implemented to
 172:../Generated_Code/FreeRTOS0.c **** **                           never return (i.e. continuous loop).
 173:../Generated_Code/FreeRTOS0.c **** **         pcName          - A descriptive name for the task.
 174:../Generated_Code/FreeRTOS0.c **** **                           This is mainly used to facilitate debugging.
 175:../Generated_Code/FreeRTOS0.c **** **                           Max length defined by
 176:../Generated_Code/FreeRTOS0.c **** **                           configMAX_TASK_NAME_LEN.
 177:../Generated_Code/FreeRTOS0.c **** **         usStackDepth    - The size of the task
 178:../Generated_Code/FreeRTOS0.c **** **                           stack specified as the number of variables
 179:../Generated_Code/FreeRTOS0.c **** **                           the stack can hold - not the number of
 180:../Generated_Code/FreeRTOS0.c **** **                           bytes. For example, if the stack is 16 bits
 181:../Generated_Code/FreeRTOS0.c **** **                           wide and usStackDepth is defined as 100,
 182:../Generated_Code/FreeRTOS0.c **** **                           200 bytes will be allocated for stack
 183:../Generated_Code/FreeRTOS0.c **** **                           storage. The stack depth multiplied by the
 184:../Generated_Code/FreeRTOS0.c **** **                           stack width must not exceed the maximum
 185:../Generated_Code/FreeRTOS0.c **** **                           value that can be contained in a variable
 186:../Generated_Code/FreeRTOS0.c **** **                           of type size_t.
 187:../Generated_Code/FreeRTOS0.c **** **         pvParameters    - Pointer that will be
 188:../Generated_Code/FreeRTOS0.c **** **                           used as the parameter for the task being
 189:../Generated_Code/FreeRTOS0.c **** **                           created.
 190:../Generated_Code/FreeRTOS0.c **** **         uxPriority      - The priority at which the
 191:../Generated_Code/FreeRTOS0.c **** **                           task should run.
 192:../Generated_Code/FreeRTOS0.c **** **         pvCreatedTask   - Used to pass back a
 193:../Generated_Code/FreeRTOS0.c **** **                           handle by which the created task can be
 194:../Generated_Code/FreeRTOS0.c **** **                           referenced.
 195:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 196:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS if the task was successfully
 197:../Generated_Code/FreeRTOS0.c **** **                           created and added to a ready list,
 198:../Generated_Code/FreeRTOS0.c **** **                           otherwise an error code defined in the file
 199:../Generated_Code/FreeRTOS0.c **** **                           projdefs.h
 200:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 201:../Generated_Code/FreeRTOS0.c **** */
 202:../Generated_Code/FreeRTOS0.c **** /*
 203:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned
 204:../Generated_Code/FreeRTOS0.c **** {
 205:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 206:../Generated_Code/FreeRTOS0.c **** }
 207:../Generated_Code/FreeRTOS0.c **** */
 208:../Generated_Code/FreeRTOS0.c **** 
 209:../Generated_Code/FreeRTOS0.c **** /*
 210:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 211:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskDelete (component FreeRTOS)
 212:../Generated_Code/FreeRTOS0.c **** **     Description :
 213:../Generated_Code/FreeRTOS0.c **** **         Remove a task from the RTOS real time kernels management.
 214:../Generated_Code/FreeRTOS0.c **** **         The task being deleted will be removed from all ready,
 215:../Generated_Code/FreeRTOS0.c **** **         blocked, suspended and event lists.
 216:../Generated_Code/FreeRTOS0.c **** **         NOTE: The idle task is responsible for freeing the kernel
 217:../Generated_Code/FreeRTOS0.c **** **         allocated memory from tasks that have been deleted. It is
 218:../Generated_Code/FreeRTOS0.c **** **         therefore important that the idle task is not starved of
 219:../Generated_Code/FreeRTOS0.c **** **         microcontroller processing time if your application makes
 220:../Generated_Code/FreeRTOS0.c **** **         any calls to vTaskDelete (). Memory allocated by the task
 221:../Generated_Code/FreeRTOS0.c **** **         code is not automatically freed, and should be freed before
 222:../Generated_Code/FreeRTOS0.c **** **         the task is deleted.
 223:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 224:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 225:../Generated_Code/FreeRTOS0.c **** **         pxTask          - The handle of the task to be deleted.
 226:../Generated_Code/FreeRTOS0.c **** **                           Passing NULL will cause the calling task to
 227:../Generated_Code/FreeRTOS0.c **** **                           be deleted.
 228:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 229:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 230:../Generated_Code/FreeRTOS0.c **** */
 231:../Generated_Code/FreeRTOS0.c **** /*
 232:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskDelete(xTaskHandle pxTask)
 233:../Generated_Code/FreeRTOS0.c **** {
 234:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 235:../Generated_Code/FreeRTOS0.c **** }
 236:../Generated_Code/FreeRTOS0.c **** */
 237:../Generated_Code/FreeRTOS0.c **** 
 238:../Generated_Code/FreeRTOS0.c **** /*
 239:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 240:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskStartScheduler (component FreeRTOS)
 241:../Generated_Code/FreeRTOS0.c **** **     Description :
 242:../Generated_Code/FreeRTOS0.c **** **         Starts the real time kernel tick processing. After calling
 243:../Generated_Code/FreeRTOS0.c **** **         the kernel has control over which tasks are executed and
 244:../Generated_Code/FreeRTOS0.c **** **         when.
 245:../Generated_Code/FreeRTOS0.c **** **         The idle task is created automatically when
 246:../Generated_Code/FreeRTOS0.c **** **         vTaskStartScheduler() is called.
 247:../Generated_Code/FreeRTOS0.c **** **         If vTaskStartScheduler() is successful the function will not
 248:../Generated_Code/FreeRTOS0.c **** **         return until an executing task calls vTaskEndScheduler().
 249:../Generated_Code/FreeRTOS0.c **** **         The function might fail and return immediately if there is
 250:../Generated_Code/FreeRTOS0.c **** **         insufficient RAM available for the idle task to be created.
 251:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 252:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 253:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 254:../Generated_Code/FreeRTOS0.c **** */
 255:../Generated_Code/FreeRTOS0.c **** /*
 256:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskStartScheduler(void)
 257:../Generated_Code/FreeRTOS0.c **** {
 258:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 259:../Generated_Code/FreeRTOS0.c **** }
 260:../Generated_Code/FreeRTOS0.c **** */
 261:../Generated_Code/FreeRTOS0.c **** 
 262:../Generated_Code/FreeRTOS0.c **** /*
 263:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 264:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskYIELD (component FreeRTOS)
 265:../Generated_Code/FreeRTOS0.c **** **     Description :
 266:../Generated_Code/FreeRTOS0.c **** **         Macro for forcing a context switch.
 267:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 268:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 269:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 270:../Generated_Code/FreeRTOS0.c **** */
 271:../Generated_Code/FreeRTOS0.c **** /*
 272:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskYIELD(void)
 273:../Generated_Code/FreeRTOS0.c **** {
 274:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 275:../Generated_Code/FreeRTOS0.c **** }
 276:../Generated_Code/FreeRTOS0.c **** */
 277:../Generated_Code/FreeRTOS0.c **** 
 278:../Generated_Code/FreeRTOS0.c **** /*
 279:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 280:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskENTER_CRITICAL (component FreeRTOS)
 281:../Generated_Code/FreeRTOS0.c **** **     Description :
 282:../Generated_Code/FreeRTOS0.c **** **         Macro to mark the start of a critical code region.
 283:../Generated_Code/FreeRTOS0.c **** **         Preemptive context switches cannot occur when in a critical
 284:../Generated_Code/FreeRTOS0.c **** **         region.
 285:../Generated_Code/FreeRTOS0.c **** **         NOTE: This may alter the stack (depending on the portable
 286:../Generated_Code/FreeRTOS0.c **** **         implementation) so must be used with care!
 287:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 288:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 289:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 290:../Generated_Code/FreeRTOS0.c **** */
 291:../Generated_Code/FreeRTOS0.c **** /*
 292:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskENTER_CRITICAL(void)
 293:../Generated_Code/FreeRTOS0.c **** {
 294:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 295:../Generated_Code/FreeRTOS0.c **** }
 296:../Generated_Code/FreeRTOS0.c **** */
 297:../Generated_Code/FreeRTOS0.c **** 
 298:../Generated_Code/FreeRTOS0.c **** /*
 299:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 300:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskEXIT_CRITICAL (component FreeRTOS)
 301:../Generated_Code/FreeRTOS0.c **** **     Description :
 302:../Generated_Code/FreeRTOS0.c **** **         Macro to mark the end of a critical code region. Preemptive
 303:../Generated_Code/FreeRTOS0.c **** **         context switches cannot occur when in a critical region.
 304:../Generated_Code/FreeRTOS0.c **** **         NOTE: This may alter the stack (depending on the portable
 305:../Generated_Code/FreeRTOS0.c **** **         implementation) so must be used with care!
 306:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 307:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 308:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 309:../Generated_Code/FreeRTOS0.c **** */
 310:../Generated_Code/FreeRTOS0.c **** /*
 311:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskEXIT_CRITICAL(void)
 312:../Generated_Code/FreeRTOS0.c **** {
 313:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 314:../Generated_Code/FreeRTOS0.c **** }
 315:../Generated_Code/FreeRTOS0.c **** */
 316:../Generated_Code/FreeRTOS0.c **** 
 317:../Generated_Code/FreeRTOS0.c **** /*
 318:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 319:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskDISABLE_INTERRUPTS (component FreeRTOS)
 320:../Generated_Code/FreeRTOS0.c **** **     Description :
 321:../Generated_Code/FreeRTOS0.c **** **         Macro to disable all maskable interrupts.
 322:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 323:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 324:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 325:../Generated_Code/FreeRTOS0.c **** */
 326:../Generated_Code/FreeRTOS0.c **** /*
 327:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskDISABLE_INTERRUPTS(void)
 328:../Generated_Code/FreeRTOS0.c **** {
 329:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 330:../Generated_Code/FreeRTOS0.c **** }
 331:../Generated_Code/FreeRTOS0.c **** */
 332:../Generated_Code/FreeRTOS0.c **** 
 333:../Generated_Code/FreeRTOS0.c **** /*
 334:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 335:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_taskENABLE_INTERRUPTS (component FreeRTOS)
 336:../Generated_Code/FreeRTOS0.c **** **     Description :
 337:../Generated_Code/FreeRTOS0.c **** **         Macro to enable microcontroller interrupts.
 338:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 339:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 340:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 341:../Generated_Code/FreeRTOS0.c **** */
 342:../Generated_Code/FreeRTOS0.c **** /*
 343:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_taskENABLE_INTERRUPTS(void)
 344:../Generated_Code/FreeRTOS0.c **** {
 345:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 346:../Generated_Code/FreeRTOS0.c **** }
 347:../Generated_Code/FreeRTOS0.c **** */
 348:../Generated_Code/FreeRTOS0.c **** 
 349:../Generated_Code/FreeRTOS0.c **** /*
 350:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 351:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskSuspendAll (component FreeRTOS)
 352:../Generated_Code/FreeRTOS0.c **** **     Description :
 353:../Generated_Code/FreeRTOS0.c **** **         Suspends all real time kernel activity while keeping
 354:../Generated_Code/FreeRTOS0.c **** **         interrupts (including the kernel tick) enabled.
 355:../Generated_Code/FreeRTOS0.c **** **         After calling vTaskSuspendAll () the calling task will
 356:../Generated_Code/FreeRTOS0.c **** **         continue to execute without risk of being swapped out until
 357:../Generated_Code/FreeRTOS0.c **** **         a call to xTaskResumeAll () has been made.
 358:../Generated_Code/FreeRTOS0.c **** **         API functions that have the potential to cause a context
 359:../Generated_Code/FreeRTOS0.c **** **         switch (for example, vTaskDelayUntil(), xQueueSend(), etc.)
 360:../Generated_Code/FreeRTOS0.c **** **         must not be called while the scheduler is suspended.
 361:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 362:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 363:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 364:../Generated_Code/FreeRTOS0.c **** */
 365:../Generated_Code/FreeRTOS0.c **** /*
 366:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskSuspendAll(void)
 367:../Generated_Code/FreeRTOS0.c **** {
 368:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 369:../Generated_Code/FreeRTOS0.c **** }
 370:../Generated_Code/FreeRTOS0.c **** */
 371:../Generated_Code/FreeRTOS0.c **** 
 372:../Generated_Code/FreeRTOS0.c **** /*
 373:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 374:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskResumeAll (component FreeRTOS)
 375:../Generated_Code/FreeRTOS0.c **** **     Description :
 376:../Generated_Code/FreeRTOS0.c **** **         Resumes real time kernel activity following a call to
 377:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspendAll (). After a call to xTaskSuspendAll () the
 378:../Generated_Code/FreeRTOS0.c **** **         kernel will take control of which task is executing at any
 379:../Generated_Code/FreeRTOS0.c **** **         time.
 380:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 381:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 382:../Generated_Code/FreeRTOS0.c **** **         ---             - If resuming the scheduler caused a context
 383:../Generated_Code/FreeRTOS0.c **** **                           switch then pdTRUE is returned, otherwise
 384:../Generated_Code/FreeRTOS0.c **** **                           pdFALSE is returned.
 385:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 386:../Generated_Code/FreeRTOS0.c **** */
 387:../Generated_Code/FreeRTOS0.c **** /*
 388:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskResumeAll(void)
 389:../Generated_Code/FreeRTOS0.c **** {
 390:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 391:../Generated_Code/FreeRTOS0.c **** }
 392:../Generated_Code/FreeRTOS0.c **** */
 393:../Generated_Code/FreeRTOS0.c **** 
 394:../Generated_Code/FreeRTOS0.c **** /*
 395:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 396:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskResumeFromISR (component FreeRTOS)
 397:../Generated_Code/FreeRTOS0.c **** **     Description :
 398:../Generated_Code/FreeRTOS0.c **** **         An implementation of vTaskResume() that can be called from
 399:../Generated_Code/FreeRTOS0.c **** **         within an ISR. A task that has been suspended by one of more
 400:../Generated_Code/FreeRTOS0.c **** **         calls to vTaskSuspend() will be made available for running
 401:../Generated_Code/FreeRTOS0.c **** **         again by a single call to xTaskResumeFromISR().
 402:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 403:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 404:../Generated_Code/FreeRTOS0.c **** **         pxTaskToResume  - Handle to the task
 405:../Generated_Code/FreeRTOS0.c **** **                           being readied.
 406:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 407:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
 408:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 409:../Generated_Code/FreeRTOS0.c **** */
 410:../Generated_Code/FreeRTOS0.c **** /*
 411:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskResumeFromISR(xTaskHandle pxTaskToResume)
 412:../Generated_Code/FreeRTOS0.c **** {
 413:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 414:../Generated_Code/FreeRTOS0.c **** }
 415:../Generated_Code/FreeRTOS0.c **** */
 416:../Generated_Code/FreeRTOS0.c **** 
 417:../Generated_Code/FreeRTOS0.c **** /*
 418:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 419:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskDelay (component FreeRTOS)
 420:../Generated_Code/FreeRTOS0.c **** **     Description :
 421:../Generated_Code/FreeRTOS0.c **** **         Delay a task for a given number of ticks. The actual time
 422:../Generated_Code/FreeRTOS0.c **** **         that the task remains blocked depends on the tick rate. The
 423:../Generated_Code/FreeRTOS0.c **** **         constant portTICK_RATE_MS can be used to calculate real time
 424:../Generated_Code/FreeRTOS0.c **** **         from the tick rate - with the resolution of one tick period.
 425:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() specifies a time at which the task wishes to
 426:../Generated_Code/FreeRTOS0.c **** **         unblock relative to the time at which vTaskDelay() is called.
 427:../Generated_Code/FreeRTOS0.c **** **         For example, specifying a block period of 100 ticks will
 428:../Generated_Code/FreeRTOS0.c **** **         cause the task to unblock 100 ticks after vTaskDelay() is
 429:../Generated_Code/FreeRTOS0.c **** **         called. vTaskDelay() does not therefore provide a good
 430:../Generated_Code/FreeRTOS0.c **** **         method of controlling the frequency of a cyclical task as
 431:../Generated_Code/FreeRTOS0.c **** **         the path taken through the code, as well as other task and
 432:../Generated_Code/FreeRTOS0.c **** **         interrupt activity, will effect the frequency at which
 433:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() gets called and therefore the time at which the
 434:../Generated_Code/FreeRTOS0.c **** **         task next executes. See vTaskDelayUntil() for an alternative
 435:../Generated_Code/FreeRTOS0.c **** **         API function designed to facilitate fixed frequency
 436:../Generated_Code/FreeRTOS0.c **** **         execution. It does this by specifying an absolute time
 437:../Generated_Code/FreeRTOS0.c **** **         (rather than a relative time) at which the calling task
 438:../Generated_Code/FreeRTOS0.c **** **         should unblock. 
 439:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 440:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 441:../Generated_Code/FreeRTOS0.c **** **         xTicksToDelay   - The amount of time, in
 442:../Generated_Code/FreeRTOS0.c **** **                           tick periods, that the calling task should
 443:../Generated_Code/FreeRTOS0.c **** **                           block.
 444:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 445:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 446:../Generated_Code/FreeRTOS0.c **** */
 447:../Generated_Code/FreeRTOS0.c **** /*
 448:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskDelay(portTickType xTicksToDelay)
 449:../Generated_Code/FreeRTOS0.c **** {
 450:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 451:../Generated_Code/FreeRTOS0.c **** }
 452:../Generated_Code/FreeRTOS0.c **** */
 453:../Generated_Code/FreeRTOS0.c **** 
 454:../Generated_Code/FreeRTOS0.c **** /*
 455:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 456:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskDelayUntil (component FreeRTOS)
 457:../Generated_Code/FreeRTOS0.c **** **     Description :
 458:../Generated_Code/FreeRTOS0.c **** **         Delay a task until a specified time. This function can be
 459:../Generated_Code/FreeRTOS0.c **** **         used by cyclical tasks to ensure a constant execution
 460:../Generated_Code/FreeRTOS0.c **** **         frequency.
 461:../Generated_Code/FreeRTOS0.c **** **         This function differs from vTaskDelay() in one important
 462:../Generated_Code/FreeRTOS0.c **** **         aspect: vTaskDelay() specifies a time at which the task
 463:../Generated_Code/FreeRTOS0.c **** **         wishes to unblock relative to the time at which vTaskDelay()
 464:../Generated_Code/FreeRTOS0.c **** **         is called, whereas vTaskDelayUntil() specifies an absolute
 465:../Generated_Code/FreeRTOS0.c **** **         time at which the task wishes to unblock.
 466:../Generated_Code/FreeRTOS0.c **** **         vTaskDelay() will cause a task to block for the specified
 467:../Generated_Code/FreeRTOS0.c **** **         number of ticks from the time vTaskDelay() is called. It is
 468:../Generated_Code/FreeRTOS0.c **** **         therefore difficult to use vTaskDelay() by itself to
 469:../Generated_Code/FreeRTOS0.c **** **         generate a fixed execution frequency as the time between a
 470:../Generated_Code/FreeRTOS0.c **** **         task unblocking following a call to vTaskDelay() and that
 471:../Generated_Code/FreeRTOS0.c **** **         task next calling vTaskDelay() may not be fixed [the task
 472:../Generated_Code/FreeRTOS0.c **** **         may take a different path though the code between calls, or
 473:../Generated_Code/FreeRTOS0.c **** **         may get interrupted or preempted a different number of times
 474:../Generated_Code/FreeRTOS0.c **** **         each time it executes].
 475:../Generated_Code/FreeRTOS0.c **** **         Whereas vTaskDelay() specifies a wake time relative to the
 476:../Generated_Code/FreeRTOS0.c **** **         time at which the function is called, vTaskDelayUntil()
 477:../Generated_Code/FreeRTOS0.c **** **         specifies the absolute (exact) time at which it wishes to
 478:../Generated_Code/FreeRTOS0.c **** **         unblock.
 479:../Generated_Code/FreeRTOS0.c **** **         It should be noted that vTaskDelayUntil() will return
 480:../Generated_Code/FreeRTOS0.c **** **         immediately (without blocking) if it is used to specify a
 481:../Generated_Code/FreeRTOS0.c **** **         wake time that is already in the past. Therefore a task
 482:../Generated_Code/FreeRTOS0.c **** **         using vTaskDelayUntil() to execute periodically will have to
 483:../Generated_Code/FreeRTOS0.c **** **         re-calculate its required wake time if the periodic
 484:../Generated_Code/FreeRTOS0.c **** **         execution is halted for any reason (for example, the task is
 485:../Generated_Code/FreeRTOS0.c **** **         temporarily placed into the Suspended state) causing the
 486:../Generated_Code/FreeRTOS0.c **** **         task to miss one or more periodic executions. This can be
 487:../Generated_Code/FreeRTOS0.c **** **         detected by checking the variable passed by reference as the
 488:../Generated_Code/FreeRTOS0.c **** **         pxPreviousWakeTime parameter against the current tick count.
 489:../Generated_Code/FreeRTOS0.c **** **         This is however not necessary under most usage scenarios.
 490:../Generated_Code/FreeRTOS0.c **** **         The constant portTICK_RATE_MS can be used to calculate real
 491:../Generated_Code/FreeRTOS0.c **** **         time from the tick rate - with the resolution of one tick
 492:../Generated_Code/FreeRTOS0.c **** **         period.
 493:../Generated_Code/FreeRTOS0.c **** **         This function must not be called while the scheduler has
 494:../Generated_Code/FreeRTOS0.c **** **         been suspended by a call to vTaskSuspendAll(). 
 495:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 496:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 497:../Generated_Code/FreeRTOS0.c **** **         pxPreviousWakeTime - Pointer to a
 498:../Generated_Code/FreeRTOS0.c **** **                           variable that holds the time at which the
 499:../Generated_Code/FreeRTOS0.c **** **                           task was last unblocked. The variable must
 500:../Generated_Code/FreeRTOS0.c **** **                           be initialised with the current time prior
 501:../Generated_Code/FreeRTOS0.c **** **                           to its first use (see the example below).
 502:../Generated_Code/FreeRTOS0.c **** **                           Following this the variable is
 503:../Generated_Code/FreeRTOS0.c **** **                           automatically updated within
 504:../Generated_Code/FreeRTOS0.c **** **                           vTaskDelayUntil(). 
 505:../Generated_Code/FreeRTOS0.c **** **         xTimeIncrement  - The cycle time
 506:../Generated_Code/FreeRTOS0.c **** **                           period. The task will be unblocked at time
 507:../Generated_Code/FreeRTOS0.c **** **                           (*pxPreviousWakeTime + xTimeIncrement).
 508:../Generated_Code/FreeRTOS0.c **** **                           Calling vTaskDelayUntil with the same
 509:../Generated_Code/FreeRTOS0.c **** **                           xTimeIncrement parameter value will cause
 510:../Generated_Code/FreeRTOS0.c **** **                           the task to execute with a fixed interval
 511:../Generated_Code/FreeRTOS0.c **** **                           period. 
 512:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 513:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 514:../Generated_Code/FreeRTOS0.c **** */
 515:../Generated_Code/FreeRTOS0.c **** /*
 516:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
 517:../Generated_Code/FreeRTOS0.c **** {
 518:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 519:../Generated_Code/FreeRTOS0.c **** }
 520:../Generated_Code/FreeRTOS0.c **** */
 521:../Generated_Code/FreeRTOS0.c **** 
 522:../Generated_Code/FreeRTOS0.c **** /*
 523:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 524:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskPriorityGet (component FreeRTOS)
 525:../Generated_Code/FreeRTOS0.c **** **     Description :
 526:../Generated_Code/FreeRTOS0.c **** **         Obtain the priority of any task.
 527:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 528:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 529:../Generated_Code/FreeRTOS0.c **** **         pxTask          - Handle of the task to be queried.
 530:../Generated_Code/FreeRTOS0.c **** **                           Passing a NULL handle results in the
 531:../Generated_Code/FreeRTOS0.c **** **                           priority of the calling task being returned.
 532:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 533:../Generated_Code/FreeRTOS0.c **** **         ---             - The priority of pxTask.
 534:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 535:../Generated_Code/FreeRTOS0.c **** */
 536:../Generated_Code/FreeRTOS0.c **** /*
 537:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskPriorityGet(xTaskHandle pxTask)
 538:../Generated_Code/FreeRTOS0.c **** {
 539:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 540:../Generated_Code/FreeRTOS0.c **** }
 541:../Generated_Code/FreeRTOS0.c **** */
 542:../Generated_Code/FreeRTOS0.c **** 
 543:../Generated_Code/FreeRTOS0.c **** /*
 544:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 545:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskPrioritySet (component FreeRTOS)
 546:../Generated_Code/FreeRTOS0.c **** **     Description :
 547:../Generated_Code/FreeRTOS0.c **** **         Set the priority of any task.
 548:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 549:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 550:../Generated_Code/FreeRTOS0.c **** **         pxTask          - Handle to the task for which the
 551:../Generated_Code/FreeRTOS0.c **** **                           priority is being set. Passing a NULL
 552:../Generated_Code/FreeRTOS0.c **** **                           handle results in the priority of the
 553:../Generated_Code/FreeRTOS0.c **** **                           calling task being set.
 554:../Generated_Code/FreeRTOS0.c **** **         uxNewPriority   - The priority to which
 555:../Generated_Code/FreeRTOS0.c **** **                           the task will be set.
 556:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 557:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 558:../Generated_Code/FreeRTOS0.c **** */
 559:../Generated_Code/FreeRTOS0.c **** /*
 560:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
 561:../Generated_Code/FreeRTOS0.c **** {
 562:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 563:../Generated_Code/FreeRTOS0.c **** }
 564:../Generated_Code/FreeRTOS0.c **** */
 565:../Generated_Code/FreeRTOS0.c **** 
 566:../Generated_Code/FreeRTOS0.c **** /*
 567:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 568:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTakeRecursive (component FreeRTOS)
 569:../Generated_Code/FreeRTOS0.c **** **     Description :
 570:../Generated_Code/FreeRTOS0.c **** **         Macro to recursively obtain, or 'take', a mutex type
 571:../Generated_Code/FreeRTOS0.c **** **         semaphore. The mutex must have previously been created using
 572:../Generated_Code/FreeRTOS0.c **** **         a call to xSemaphoreCreateRecursiveMutex();
 573:../Generated_Code/FreeRTOS0.c **** **         This macro must not be used on mutexes created using
 574:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex(). A mutex used recursively can be
 575:../Generated_Code/FreeRTOS0.c **** **         'taken' repeatedly by the owner. The mutex doesn't become
 576:../Generated_Code/FreeRTOS0.c **** **         available again until the owner has called
 577:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive() for each successful 'take' request.
 578:../Generated_Code/FreeRTOS0.c **** **         For example, if a task successfully 'takes' the same mutex 5
 579:../Generated_Code/FreeRTOS0.c **** **         times then the mutex will not be available to any other task
 580:../Generated_Code/FreeRTOS0.c **** **         until it has also  'given' the mutex back exactly five times.
 581:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 582:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 583:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being obtained.
 584:../Generated_Code/FreeRTOS0.c **** **                           This is the handle returned by
 585:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateRecursiveMutex();
 586:../Generated_Code/FreeRTOS0.c **** **         xBlockTime      - The time in ticks to wait
 587:../Generated_Code/FreeRTOS0.c **** **                           for the semaphore to become available.  The
 588:../Generated_Code/FreeRTOS0.c **** **                           macro portTICK_RATE_MS can be used to
 589:../Generated_Code/FreeRTOS0.c **** **                           convert this to a real time.  A block time
 590:../Generated_Code/FreeRTOS0.c **** **                           of zero can be used to poll the semaphore.
 591:../Generated_Code/FreeRTOS0.c **** **                           If the task already owns the semaphore then
 592:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreTakeRecursive() will return
 593:../Generated_Code/FreeRTOS0.c **** **                           immediately no matter what the value of
 594:../Generated_Code/FreeRTOS0.c **** **                           xBlockTime.
 595:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 596:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was
 597:../Generated_Code/FreeRTOS0.c **** **                           obtained.  pdFALSE if xBlockTime expired
 598:../Generated_Code/FreeRTOS0.c **** **                           without the semaphore becoming available.
 599:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 600:../Generated_Code/FreeRTOS0.c **** */
 601:../Generated_Code/FreeRTOS0.c **** /*
 602:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
 603:../Generated_Code/FreeRTOS0.c **** {
 604:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 605:../Generated_Code/FreeRTOS0.c **** }
 606:../Generated_Code/FreeRTOS0.c **** */
 607:../Generated_Code/FreeRTOS0.c **** 
 608:../Generated_Code/FreeRTOS0.c **** /*
 609:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 610:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGiveRecursive (component FreeRTOS)
 611:../Generated_Code/FreeRTOS0.c **** **     Description :
 612:../Generated_Code/FreeRTOS0.c **** **         Macro to recursively release, or 'give', a mutex type
 613:../Generated_Code/FreeRTOS0.c **** **         semaphore. The mutex must have previously been created using
 614:../Generated_Code/FreeRTOS0.c **** **         a call to xSemaphoreCreateRecursiveMutex();
 615:../Generated_Code/FreeRTOS0.c **** **         This macro must not be used on mutexes created using
 616:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex(). A mutex used recursively can be
 617:../Generated_Code/FreeRTOS0.c **** **         'taken' repeatedly by the owner. The mutex doesn't become
 618:../Generated_Code/FreeRTOS0.c **** **         available again until the owner has called
 619:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveRecursive() for each successful 'take' request.
 620:../Generated_Code/FreeRTOS0.c **** **         For example, if a task successfully 'takes' the same mutex 5
 621:../Generated_Code/FreeRTOS0.c **** **         times then the mutex will not be available to any other task
 622:../Generated_Code/FreeRTOS0.c **** **         until it has also  'given' the mutex back exactly five times.
 623:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 624:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 625:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being released,
 626:../Generated_Code/FreeRTOS0.c **** **                           or 'given'.  This is the handle returned by
 627:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 628:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 629:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 630:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 631:../Generated_Code/FreeRTOS0.c **** */
 632:../Generated_Code/FreeRTOS0.c **** /*
 633:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
 634:../Generated_Code/FreeRTOS0.c **** {
 635:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 636:../Generated_Code/FreeRTOS0.c **** }
 637:../Generated_Code/FreeRTOS0.c **** */
 638:../Generated_Code/FreeRTOS0.c **** 
 639:../Generated_Code/FreeRTOS0.c **** /*
 640:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 641:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateRecursiveMutex (component FreeRTOS)
 642:../Generated_Code/FreeRTOS0.c **** **     Description :
 643:../Generated_Code/FreeRTOS0.c **** **         Macro that implements a recursive mutex by using the
 644:../Generated_Code/FreeRTOS0.c **** **         existing queue mechanism.
 645:../Generated_Code/FreeRTOS0.c **** **         Mutexes created using this macro can be accessed using the
 646:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
 647:../Generated_Code/FreeRTOS0.c **** **         macros.  The  xSemaphoreTake() and xSemaphoreGive() macros
 648:../Generated_Code/FreeRTOS0.c **** **         should not be used.
 649:../Generated_Code/FreeRTOS0.c **** **         A mutex used recursively can be 'taken' repeatedly by the
 650:../Generated_Code/FreeRTOS0.c **** **         owner. The mutex doesn't become available again until the
 651:../Generated_Code/FreeRTOS0.c **** **         owner has called xSemaphoreGiveRecursive() for each
 652:../Generated_Code/FreeRTOS0.c **** **         successful 'take' request.  For example, if a task
 653:../Generated_Code/FreeRTOS0.c **** **         successfully 'takes' the same mutex 5 times then the mutex
 654:../Generated_Code/FreeRTOS0.c **** **         will not be available to any other task until it has also
 655:../Generated_Code/FreeRTOS0.c **** **         'given' the mutex back exactly five times.
 656:../Generated_Code/FreeRTOS0.c **** **         This type of semaphore uses a priority inheritance mechanism
 657:../Generated_Code/FreeRTOS0.c **** **         so a task 'taking' a semaphore MUST ALWAYS 'give' the
 658:../Generated_Code/FreeRTOS0.c **** **         semaphore back once the semaphore it is no longer required.
 659:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores cannot be used from within interrupt
 660:../Generated_Code/FreeRTOS0.c **** **         service routines.
 661:../Generated_Code/FreeRTOS0.c **** **         See vSemaphoreCreateBinary() for an alternative
 662:../Generated_Code/FreeRTOS0.c **** **         implementation that can be used for pure synchronisation
 663:../Generated_Code/FreeRTOS0.c **** **         (where one task or interrupt always 'gives' the semaphore
 664:../Generated_Code/FreeRTOS0.c **** **         and another always 'takes' the semaphore) and from within
 665:../Generated_Code/FreeRTOS0.c **** **         interrupt service routines.
 666:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 667:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 668:../Generated_Code/FreeRTOS0.c **** **         ---             - Handle to the created mutex semaphore.
 669:../Generated_Code/FreeRTOS0.c **** **                           Should be of type  xSemaphoreHandle.
 670:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 671:../Generated_Code/FreeRTOS0.c **** */
 672:../Generated_Code/FreeRTOS0.c **** /*
 673:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateRecursiveMutex(void)
 674:../Generated_Code/FreeRTOS0.c **** {
 675:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 676:../Generated_Code/FreeRTOS0.c **** }
 677:../Generated_Code/FreeRTOS0.c **** */
 678:../Generated_Code/FreeRTOS0.c **** 
 679:../Generated_Code/FreeRTOS0.c **** /*
 680:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 681:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vSemaphoreDelete (component FreeRTOS)
 682:../Generated_Code/FreeRTOS0.c **** **     Description :
 683:../Generated_Code/FreeRTOS0.c **** **         Delete a semaphore.  This function must be used with care.
 684:../Generated_Code/FreeRTOS0.c **** **         For example, do not delete a mutex type semaphore if the
 685:../Generated_Code/FreeRTOS0.c **** **         mutex is held by a task.
 686:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 687:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 688:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore to
 689:../Generated_Code/FreeRTOS0.c **** **                           be deleted.
 690:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 691:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 692:../Generated_Code/FreeRTOS0.c **** */
 693:../Generated_Code/FreeRTOS0.c **** /*
 694:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vSemaphoreDelete(xSemaphoreHandle xSemaphore)
 695:../Generated_Code/FreeRTOS0.c **** {
 696:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 697:../Generated_Code/FreeRTOS0.c **** }
 698:../Generated_Code/FreeRTOS0.c **** */
 699:../Generated_Code/FreeRTOS0.c **** 
 700:../Generated_Code/FreeRTOS0.c **** /*
 701:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 702:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskSuspend (component FreeRTOS)
 703:../Generated_Code/FreeRTOS0.c **** **     Description :
 704:../Generated_Code/FreeRTOS0.c **** **         Suspend any task. When suspended a task will never get any
 705:../Generated_Code/FreeRTOS0.c **** **         microcontroller processing time, no matter what its priority.
 706:../Generated_Code/FreeRTOS0.c **** **         Calls to vTaskSuspend are not accumulative - i.e. calling
 707:../Generated_Code/FreeRTOS0.c **** **         vTaskSuspend() twice on the same task still only requires
 708:../Generated_Code/FreeRTOS0.c **** **         one call to vTaskResume() to ready the suspended task.
 709:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 710:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 711:../Generated_Code/FreeRTOS0.c **** **         pxTaskToSuspend - Handle to the task
 712:../Generated_Code/FreeRTOS0.c **** **                           being suspended. Passing a NULL handle will
 713:../Generated_Code/FreeRTOS0.c **** **                           cause the calling task to be suspended.
 714:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 715:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 716:../Generated_Code/FreeRTOS0.c **** */
 717:../Generated_Code/FreeRTOS0.c **** /*
 718:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskSuspend(xTaskHandle pxTaskToSuspend)
 719:../Generated_Code/FreeRTOS0.c **** {
 720:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 721:../Generated_Code/FreeRTOS0.c **** }
 722:../Generated_Code/FreeRTOS0.c **** */
 723:../Generated_Code/FreeRTOS0.c **** 
 724:../Generated_Code/FreeRTOS0.c **** /*
 725:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 726:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vTaskResume (component FreeRTOS)
 727:../Generated_Code/FreeRTOS0.c **** **     Description :
 728:../Generated_Code/FreeRTOS0.c **** **         Resumes a suspended task. A task that has been suspended by
 729:../Generated_Code/FreeRTOS0.c **** **         one of more calls to vTaskSuspend() will be made available
 730:../Generated_Code/FreeRTOS0.c **** **         for running again by a single call to vTaskResume().
 731:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 732:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 733:../Generated_Code/FreeRTOS0.c **** **         pxTaskToResume  - Handle to the task
 734:../Generated_Code/FreeRTOS0.c **** **                           being readied.
 735:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 736:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 737:../Generated_Code/FreeRTOS0.c **** */
 738:../Generated_Code/FreeRTOS0.c **** /*
 739:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vTaskResume(xTaskHandle pxTaskToResume)
 740:../Generated_Code/FreeRTOS0.c **** {
 741:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 742:../Generated_Code/FreeRTOS0.c **** }
 743:../Generated_Code/FreeRTOS0.c **** */
 744:../Generated_Code/FreeRTOS0.c **** 
 745:../Generated_Code/FreeRTOS0.c **** /*
 746:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 747:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateMutex (component FreeRTOS)
 748:../Generated_Code/FreeRTOS0.c **** **     Description :
 749:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a mutex semaphore by using the existing
 750:../Generated_Code/FreeRTOS0.c **** **         queue mechanism.
 751:../Generated_Code/FreeRTOS0.c **** **         Mutexes created using this macro can be accessed using the
 752:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() and xSemaphoreGive() macros. The
 753:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
 754:../Generated_Code/FreeRTOS0.c **** **         macros should not be used.
 755:../Generated_Code/FreeRTOS0.c **** **         Mutexes and binary semaphores are very similar but have some
 756:../Generated_Code/FreeRTOS0.c **** **         subtle differences: Mutexes include a priority inheritance
 757:../Generated_Code/FreeRTOS0.c **** **         mechanism, binary semaphores do not. This makes binary
 758:../Generated_Code/FreeRTOS0.c **** **         semaphores the better choice for implementing
 759:../Generated_Code/FreeRTOS0.c **** **         synchronisation (between tasks or between tasks and an
 760:../Generated_Code/FreeRTOS0.c **** **         interrupt), and mutexes the better choice for implementing
 761:../Generated_Code/FreeRTOS0.c **** **         simple mutual exclusion.
 762:../Generated_Code/FreeRTOS0.c **** **         The priority of a task that 'takes' a mutex can potentially
 763:../Generated_Code/FreeRTOS0.c **** **         be raised if another task of higher priority attempts to
 764:../Generated_Code/FreeRTOS0.c **** **         obtain the same mutex. The task that owns the mutex
 765:../Generated_Code/FreeRTOS0.c **** **         'inherits' the priority of the task attempting to 'take' the
 766:../Generated_Code/FreeRTOS0.c **** **         same mutex. This means the mutex must always be 'given' back
 767:../Generated_Code/FreeRTOS0.c **** **         - otherwise the higher priority task will never be able to
 768:../Generated_Code/FreeRTOS0.c **** **         obtain the mutex, and the lower priority task will never
 769:../Generated_Code/FreeRTOS0.c **** **         'disinherit' the priority. An example of a mutex being used
 770:../Generated_Code/FreeRTOS0.c **** **         to implement mutual exclusion is provided on the
 771:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() documentation page.
 772:../Generated_Code/FreeRTOS0.c **** **         A binary semaphore need not be given back once obtained, so
 773:../Generated_Code/FreeRTOS0.c **** **         task synchronisation can be implemented by one
 774:../Generated_Code/FreeRTOS0.c **** **         task/interrupt continuously 'giving' the semaphore while
 775:../Generated_Code/FreeRTOS0.c **** **         another continuously 'takes' the semaphore. This is
 776:../Generated_Code/FreeRTOS0.c **** **         demonstrated by the sample code on the
 777:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() documentation page.
 778:../Generated_Code/FreeRTOS0.c **** **         Both mutex and binary semaphores are assigned to variables
 779:../Generated_Code/FreeRTOS0.c **** **         of type xSemaphoreHandle and can be used in any API function
 780:../Generated_Code/FreeRTOS0.c **** **         that takes a parameter of this type. 
 781:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
 782:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 783:../Generated_Code/FreeRTOS0.c **** **         ---             - Handle to the created mutex semaphore.
 784:../Generated_Code/FreeRTOS0.c **** **                           Should be of type  xSemaphoreHandle.
 785:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 786:../Generated_Code/FreeRTOS0.c **** */
 787:../Generated_Code/FreeRTOS0.c **** /*
 788:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateMutex(void)
 789:../Generated_Code/FreeRTOS0.c **** {
 790:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 791:../Generated_Code/FreeRTOS0.c **** }
 792:../Generated_Code/FreeRTOS0.c **** */
 793:../Generated_Code/FreeRTOS0.c **** 
 794:../Generated_Code/FreeRTOS0.c **** /*
 795:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 796:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTake (component FreeRTOS)
 797:../Generated_Code/FreeRTOS0.c **** **     Description :
 798:../Generated_Code/FreeRTOS0.c **** **         Macro to obtain a semaphore. The semaphore must have
 799:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 800:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
 801:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting().
 802:../Generated_Code/FreeRTOS0.c **** **         This macro must not be called from an ISR.
 803:../Generated_Code/FreeRTOS0.c **** **         xQueueReceiveFromISR() can be used to take a semaphore from
 804:../Generated_Code/FreeRTOS0.c **** **         within an interrupt if required, although this would not be
 805:../Generated_Code/FreeRTOS0.c **** **         a normal operation. Semaphores use queues as their
 806:../Generated_Code/FreeRTOS0.c **** **         underlying mechanism, so functions are to some extent
 807:../Generated_Code/FreeRTOS0.c **** **         interoperable.
 808:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() is part of the fully featured intertask
 809:../Generated_Code/FreeRTOS0.c **** **         communications API. xSemaphoreAltTake() is the alternative
 810:../Generated_Code/FreeRTOS0.c **** **         API equivalent. Both versions require the same parameters
 811:../Generated_Code/FreeRTOS0.c **** **         and return the same values.
 812:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 813:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 814:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being obtained.
 815:../Generated_Code/FreeRTOS0.c **** **                           This is the handle returned by
 816:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 817:../Generated_Code/FreeRTOS0.c **** **         xBlockTime      - The time in ticks to wait
 818:../Generated_Code/FreeRTOS0.c **** **                           for the semaphore to become available.  The
 819:../Generated_Code/FreeRTOS0.c **** **                           macro portTICK_RATE_MS can be used to
 820:../Generated_Code/FreeRTOS0.c **** **                           convert this to a real time.  A block time
 821:../Generated_Code/FreeRTOS0.c **** **                           of zero can be used to poll the semaphore.
 822:../Generated_Code/FreeRTOS0.c **** **                           If the task already owns the semaphore then
 823:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreTakeRecursive() will return
 824:../Generated_Code/FreeRTOS0.c **** **                           immediately no matter what the value of
 825:../Generated_Code/FreeRTOS0.c **** **                           xBlockTime. Specifying the block time as
 826:../Generated_Code/FreeRTOS0.c **** **                           portMAX_DELAY will cause the task to block
 827:../Generated_Code/FreeRTOS0.c **** **                           indefinitely (without a timeout).
 828:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 829:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was
 830:../Generated_Code/FreeRTOS0.c **** **                           obtained.  pdFALSE if xBlockTime expired
 831:../Generated_Code/FreeRTOS0.c **** **                           without the semaphore becoming available.
 832:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 833:../Generated_Code/FreeRTOS0.c **** */
 834:../Generated_Code/FreeRTOS0.c **** /*
 835:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
 836:../Generated_Code/FreeRTOS0.c **** {
 837:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 838:../Generated_Code/FreeRTOS0.c **** }
 839:../Generated_Code/FreeRTOS0.c **** */
 840:../Generated_Code/FreeRTOS0.c **** 
 841:../Generated_Code/FreeRTOS0.c **** /*
 842:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 843:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGive (component FreeRTOS)
 844:../Generated_Code/FreeRTOS0.c **** **     Description :
 845:../Generated_Code/FreeRTOS0.c **** **         Macro to release a semaphore. The semaphore must have
 846:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 847:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
 848:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateCounting(), and obtained using
 849:../Generated_Code/FreeRTOS0.c **** **         sSemaphoreTake().
 850:../Generated_Code/FreeRTOS0.c **** **         This must not be used from an ISR. See
 851:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() for an alternative which can be used
 852:../Generated_Code/FreeRTOS0.c **** **         from an ISR.
 853:../Generated_Code/FreeRTOS0.c **** **         This macro must also not be used on semaphores created using
 854:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateRecursiveMutex().
 855:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGive() is part of the fully featured intertask
 856:../Generated_Code/FreeRTOS0.c **** **         communications API. xSemaphoreAltGive() is the alternative
 857:../Generated_Code/FreeRTOS0.c **** **         API equivalent. Both versions require the same parameters
 858:../Generated_Code/FreeRTOS0.c **** **         and return the same values. 
 859:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 860:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 861:../Generated_Code/FreeRTOS0.c **** **         xMutex          - A handle to the mutex being released,
 862:../Generated_Code/FreeRTOS0.c **** **                           or 'given'.  This is the handle returned by
 863:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreCreateMutex();
 864:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 865:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 866:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 867:../Generated_Code/FreeRTOS0.c **** */
 868:../Generated_Code/FreeRTOS0.c **** /*
 869:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGive(xSemaphoreHandle xMutex)
 870:../Generated_Code/FreeRTOS0.c **** {
 871:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 872:../Generated_Code/FreeRTOS0.c **** }
 873:../Generated_Code/FreeRTOS0.c **** */
 874:../Generated_Code/FreeRTOS0.c **** 
 875:../Generated_Code/FreeRTOS0.c **** /*
 876:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 877:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vSemaphoreCreateBinary (component FreeRTOS)
 878:../Generated_Code/FreeRTOS0.c **** **     Description :
 879:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a semaphore by using the existing queue
 880:../Generated_Code/FreeRTOS0.c **** **         mechanism. The queue length is 1 as this is a binary
 881:../Generated_Code/FreeRTOS0.c **** **         semaphore. The data size is 0 as we don't want to actually
 882:../Generated_Code/FreeRTOS0.c **** **         store any data - we just want to know if the queue is empty
 883:../Generated_Code/FreeRTOS0.c **** **         or full.
 884:../Generated_Code/FreeRTOS0.c **** **         Binary semaphores and mutexes are very similar but have some
 885:../Generated_Code/FreeRTOS0.c **** **         subtle differences: Mutexes include a priority inheritance
 886:../Generated_Code/FreeRTOS0.c **** **         mechanism, binary semaphores do not. This makes binary
 887:../Generated_Code/FreeRTOS0.c **** **         semaphores the better choice for implementing
 888:../Generated_Code/FreeRTOS0.c **** **         synchronisation (between tasks or between tasks and an
 889:../Generated_Code/FreeRTOS0.c **** **         interrupt), and mutexes the better choice for implementing
 890:../Generated_Code/FreeRTOS0.c **** **         simple mutual exclusion.
 891:../Generated_Code/FreeRTOS0.c **** **         A binary semaphore need not be given back once obtained, so
 892:../Generated_Code/FreeRTOS0.c **** **         task synchronisation can be implemented by one
 893:../Generated_Code/FreeRTOS0.c **** **         task/interrupt continuously 'giving' the semaphore while
 894:../Generated_Code/FreeRTOS0.c **** **         another continuously 'takes' the semaphore. This is
 895:../Generated_Code/FreeRTOS0.c **** **         demonstrated by the sample code on the
 896:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreGiveFromISR() documentation page.
 897:../Generated_Code/FreeRTOS0.c **** **         The priority of a task that 'takes' a mutex can potentially
 898:../Generated_Code/FreeRTOS0.c **** **         be raised if another task of higher priority attempts to
 899:../Generated_Code/FreeRTOS0.c **** **         obtain the same mutex. The task that owns the mutex
 900:../Generated_Code/FreeRTOS0.c **** **         'inherits' the priority of the task attempting to 'take' the
 901:../Generated_Code/FreeRTOS0.c **** **         same mutex. This means the mutex must always be 'given' back
 902:../Generated_Code/FreeRTOS0.c **** **         - otherwise the higher priority task will never be able to
 903:../Generated_Code/FreeRTOS0.c **** **         obtain the mutex, and the lower priority task will never
 904:../Generated_Code/FreeRTOS0.c **** **         'disinherit' the priority. An example of a mutex being used
 905:../Generated_Code/FreeRTOS0.c **** **         to implement mutual exclusion is provided on the
 906:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreTake() documentation page.
 907:../Generated_Code/FreeRTOS0.c **** **         Both mutex and binary semaphores are assigned to variables
 908:../Generated_Code/FreeRTOS0.c **** **         of type xSemaphoreHandle and can be used in any API function
 909:../Generated_Code/FreeRTOS0.c **** **         that takes a parameter of this type. 
 910:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 911:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 912:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - Handle to the created
 913:../Generated_Code/FreeRTOS0.c **** **                           semaphore. Should be of type
 914:../Generated_Code/FreeRTOS0.c **** **                           xSemaphoreHandle.
 915:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
 916:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 917:../Generated_Code/FreeRTOS0.c **** */
 918:../Generated_Code/FreeRTOS0.c **** /*
 919:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
 920:../Generated_Code/FreeRTOS0.c **** {
 921:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 922:../Generated_Code/FreeRTOS0.c **** }
 923:../Generated_Code/FreeRTOS0.c **** */
 924:../Generated_Code/FreeRTOS0.c **** 
 925:../Generated_Code/FreeRTOS0.c **** /*
 926:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 927:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreCreateCounting (component FreeRTOS)
 928:../Generated_Code/FreeRTOS0.c **** **     Description :
 929:../Generated_Code/FreeRTOS0.c **** **         Macro that creates a counting semaphore by using the
 930:../Generated_Code/FreeRTOS0.c **** **         existing queue mechanism.
 931:../Generated_Code/FreeRTOS0.c **** **         Counting semaphores are typically used for two things:
 932:../Generated_Code/FreeRTOS0.c **** **         1. Counting events.
 933:../Generated_Code/FreeRTOS0.c **** **         In this usage scenario an event handler will 'give' a
 934:../Generated_Code/FreeRTOS0.c **** **         semaphore each time an event occurs (incrementing the
 935:../Generated_Code/FreeRTOS0.c **** **         semaphore count value), and a handler task will 'take' a
 936:../Generated_Code/FreeRTOS0.c **** **         semaphore each time it processes an event (decrementing the
 937:../Generated_Code/FreeRTOS0.c **** **         semaphore count value). The count value is therefore the
 938:../Generated_Code/FreeRTOS0.c **** **         difference between the number of events that have occurred
 939:../Generated_Code/FreeRTOS0.c **** **         and the number that have been processed. In this case it is
 940:../Generated_Code/FreeRTOS0.c **** **         desirable for the initial count value to be zero.
 941:../Generated_Code/FreeRTOS0.c **** **         2. Resource management.
 942:../Generated_Code/FreeRTOS0.c **** **         In this usage scenario the count value indicates the number
 943:../Generated_Code/FreeRTOS0.c **** **         of resources available. To obtain control of a resource a
 944:../Generated_Code/FreeRTOS0.c **** **         task must first obtain a semaphore - decrementing the
 945:../Generated_Code/FreeRTOS0.c **** **         semaphore count value. When the count value reaches zero
 946:../Generated_Code/FreeRTOS0.c **** **         there are no free resources. When a task finishes with the
 947:../Generated_Code/FreeRTOS0.c **** **         resource it 'gives' the semaphore back - incrementing the
 948:../Generated_Code/FreeRTOS0.c **** **         semaphore count value. In this case it is desirable for the
 949:../Generated_Code/FreeRTOS0.c **** **         initial count value to be equal to the maximum count value,
 950:../Generated_Code/FreeRTOS0.c **** **         indicating that all resources are free.
 951:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 952:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 953:../Generated_Code/FreeRTOS0.c **** **         uxMaxCount      - The maximum count value that
 954:../Generated_Code/FreeRTOS0.c **** **                           can be reached. When the semaphore reaches
 955:../Generated_Code/FreeRTOS0.c **** **                           this value it can no longer be 'given'.
 956:../Generated_Code/FreeRTOS0.c **** **         uxInitialCount  - The count value
 957:../Generated_Code/FreeRTOS0.c **** **                           assigned to the semaphore when it is
 958:../Generated_Code/FreeRTOS0.c **** **                           created.
 959:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 960:../Generated_Code/FreeRTOS0.c **** **         ---             - xSemaphoreHandle handle
 961:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 962:../Generated_Code/FreeRTOS0.c **** */
 963:../Generated_Code/FreeRTOS0.c **** /*
 964:../Generated_Code/FreeRTOS0.c **** xSemaphoreHandle FreeRTOS0_xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_por
 965:../Generated_Code/FreeRTOS0.c **** {
 966:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
 967:../Generated_Code/FreeRTOS0.c **** }
 968:../Generated_Code/FreeRTOS0.c **** */
 969:../Generated_Code/FreeRTOS0.c **** 
 970:../Generated_Code/FreeRTOS0.c **** /*
 971:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 972:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGiveFromISR (component FreeRTOS)
 973:../Generated_Code/FreeRTOS0.c **** **     Description :
 974:../Generated_Code/FreeRTOS0.c **** **         Macro to release a semaphore. The semaphore must have
 975:../Generated_Code/FreeRTOS0.c **** **         previously been created with a call to
 976:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
 977:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores (those created using a call to
 978:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex()) must not be used with this macro.
 979:../Generated_Code/FreeRTOS0.c **** **         This macro can be used from an ISR.
 980:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
 981:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
 982:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore
 983:../Generated_Code/FreeRTOS0.c **** **                           being released. This is the handle returned
 984:../Generated_Code/FreeRTOS0.c **** **                           when the semaphore was created.
 985:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
 986:../Generated_Code/FreeRTOS0.c **** **                           - xSemaphoreGiveFromISR() will set
 987:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
 988:../Generated_Code/FreeRTOS0.c **** **                           giving the semaphoree caused a task to
 989:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
 990:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
 991:../Generated_Code/FreeRTOS0.c **** **                           task. If xSemaphoreGiveFromISR() sets this
 992:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
 993:../Generated_Code/FreeRTOS0.c **** **                           should be requested before the interrupt is
 994:../Generated_Code/FreeRTOS0.c **** **                           exited.
 995:../Generated_Code/FreeRTOS0.c **** **     Returns     :
 996:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
 997:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
 998:../Generated_Code/FreeRTOS0.c **** */
 999:../Generated_Code/FreeRTOS0.c **** /*
1000:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPri
1001:../Generated_Code/FreeRTOS0.c **** {
1002:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1003:../Generated_Code/FreeRTOS0.c **** }
1004:../Generated_Code/FreeRTOS0.c **** */
1005:../Generated_Code/FreeRTOS0.c **** 
1006:../Generated_Code/FreeRTOS0.c **** /*
1007:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1008:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_pvPortMalloc (component FreeRTOS)
1009:../Generated_Code/FreeRTOS0.c **** **     Description :
1010:../Generated_Code/FreeRTOS0.c **** **         Allocates a memory block using the port pvPortMalloc()
1011:../Generated_Code/FreeRTOS0.c **** **         function
1012:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1013:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1014:../Generated_Code/FreeRTOS0.c **** **         xWantedSize     - size of memory block
1015:../Generated_Code/FreeRTOS0.c **** **                           requested
1016:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1017:../Generated_Code/FreeRTOS0.c **** **         ---             - memory block or NULL if failed
1018:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1019:../Generated_Code/FreeRTOS0.c **** */
1020:../Generated_Code/FreeRTOS0.c **** /*
1021:../Generated_Code/FreeRTOS0.c **** pVoid FreeRTOS0_pvPortMalloc(size_t xWantedSize)
1022:../Generated_Code/FreeRTOS0.c **** {
1023:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1024:../Generated_Code/FreeRTOS0.c **** }
1025:../Generated_Code/FreeRTOS0.c **** */
1026:../Generated_Code/FreeRTOS0.c **** 
1027:../Generated_Code/FreeRTOS0.c **** /*
1028:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1029:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vPortFree (component FreeRTOS)
1030:../Generated_Code/FreeRTOS0.c **** **     Description :
1031:../Generated_Code/FreeRTOS0.c **** **         Frees a memory block previously allocated with pvPortMalloc()
1032:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1033:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1034:../Generated_Code/FreeRTOS0.c **** **       * pv              - Pointer to data
1035:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1036:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1037:../Generated_Code/FreeRTOS0.c **** */
1038:../Generated_Code/FreeRTOS0.c **** /*
1039:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vPortFree(void *pv)
1040:../Generated_Code/FreeRTOS0.c **** {
1041:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1042:../Generated_Code/FreeRTOS0.c **** }
1043:../Generated_Code/FreeRTOS0.c **** */
1044:../Generated_Code/FreeRTOS0.c **** 
1045:../Generated_Code/FreeRTOS0.c **** /*
1046:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1047:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskGetTickCount (component FreeRTOS)
1048:../Generated_Code/FreeRTOS0.c **** **     Description :
1049:../Generated_Code/FreeRTOS0.c **** **         Return the count of ticks since vTaskStartScheduler was
1050:../Generated_Code/FreeRTOS0.c **** **         called.
1051:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1052:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1053:../Generated_Code/FreeRTOS0.c **** **         ---             - tick count
1054:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1055:../Generated_Code/FreeRTOS0.c **** */
1056:../Generated_Code/FreeRTOS0.c **** /*
1057:../Generated_Code/FreeRTOS0.c **** portTickType FreeRTOS0_xTaskGetTickCount(void)
1058:../Generated_Code/FreeRTOS0.c **** {
1059:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1060:../Generated_Code/FreeRTOS0.c **** }
1061:../Generated_Code/FreeRTOS0.c **** */
1062:../Generated_Code/FreeRTOS0.c **** 
1063:../Generated_Code/FreeRTOS0.c **** /*
1064:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1065:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xTaskGetSchedulerState (component FreeRTOS)
1066:../Generated_Code/FreeRTOS0.c **** **     Description :
1067:../Generated_Code/FreeRTOS0.c **** **         Returns the state of the scheduler
1068:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1069:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1070:../Generated_Code/FreeRTOS0.c **** **         ---             - One of the following constants (defined
1071:../Generated_Code/FreeRTOS0.c **** **                           within task.h): taskSCHEDULER_NOT_STARTED,
1072:../Generated_Code/FreeRTOS0.c **** **                           taskSCHEDULER_RUNNING,
1073:../Generated_Code/FreeRTOS0.c **** **                           taskSCHEDULER_SUSPENDED.
1074:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1075:../Generated_Code/FreeRTOS0.c **** */
1076:../Generated_Code/FreeRTOS0.c **** /*
1077:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xTaskGetSchedulerState(void)
1078:../Generated_Code/FreeRTOS0.c **** {
1079:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1080:../Generated_Code/FreeRTOS0.c **** }
1081:../Generated_Code/FreeRTOS0.c **** */
1082:../Generated_Code/FreeRTOS0.c **** 
1083:../Generated_Code/FreeRTOS0.c **** /*
1084:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1085:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskGetStackHighWaterMark (component FreeRTOS)
1086:../Generated_Code/FreeRTOS0.c **** **     Description :
1087:../Generated_Code/FreeRTOS0.c **** **         The stack used by a task will grow and shrink as the task
1088:../Generated_Code/FreeRTOS0.c **** **         executes and interrupts are processed.
1089:../Generated_Code/FreeRTOS0.c **** **         uxTaskGetStackHighWaterMark() returns the minimum amount of
1090:../Generated_Code/FreeRTOS0.c **** **         remaining stack space that was available to the task since
1091:../Generated_Code/FreeRTOS0.c **** **         the task started executing - that is the amount of stack
1092:../Generated_Code/FreeRTOS0.c **** **         that remained unused when the task stack was at its greatest
1093:../Generated_Code/FreeRTOS0.c **** **         (deepest) value. This is what is referred to as the stack
1094:../Generated_Code/FreeRTOS0.c **** **         'high water mark'.
1095:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1096:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1097:../Generated_Code/FreeRTOS0.c **** **         xTask           - The handle of the task being queried.
1098:../Generated_Code/FreeRTOS0.c **** **                           A task may query its own high water mark by
1099:../Generated_Code/FreeRTOS0.c **** **                           passing NULL as the xTask parameter.
1100:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1101:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
1102:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1103:../Generated_Code/FreeRTOS0.c **** */
1104:../Generated_Code/FreeRTOS0.c **** /*
1105:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetStackHighWaterMark(xTaskHandle xTask)
1106:../Generated_Code/FreeRTOS0.c **** {
1107:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1108:../Generated_Code/FreeRTOS0.c **** }
1109:../Generated_Code/FreeRTOS0.c **** */
1110:../Generated_Code/FreeRTOS0.c **** 
1111:../Generated_Code/FreeRTOS0.c **** /*
1112:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1113:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxTaskGetNumberOfTasks (component FreeRTOS)
1114:../Generated_Code/FreeRTOS0.c **** **     Description :
1115:../Generated_Code/FreeRTOS0.c **** **         Returns the number of tasks
1116:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1117:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1118:../Generated_Code/FreeRTOS0.c **** **         ---             - number of tasks
1119:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1120:../Generated_Code/FreeRTOS0.c **** */
1121:../Generated_Code/FreeRTOS0.c **** /*
1122:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxTaskGetNumberOfTasks(void)
1123:../Generated_Code/FreeRTOS0.c **** {
1124:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1125:../Generated_Code/FreeRTOS0.c **** }
1126:../Generated_Code/FreeRTOS0.c **** */
1127:../Generated_Code/FreeRTOS0.c **** 
1128:../Generated_Code/FreeRTOS0.c **** /*
1129:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1130:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xPortGetFreeHeapSize (component FreeRTOS)
1131:../Generated_Code/FreeRTOS0.c **** **     Description :
1132:../Generated_Code/FreeRTOS0.c **** **         Returns the actual free size of the heap
1133:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1134:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1135:../Generated_Code/FreeRTOS0.c **** **         ---             - Error code
1136:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1137:../Generated_Code/FreeRTOS0.c **** */
1138:../Generated_Code/FreeRTOS0.c **** /*
1139:../Generated_Code/FreeRTOS0.c **** Tsize_t FreeRTOS0_xPortGetFreeHeapSize(void)
1140:../Generated_Code/FreeRTOS0.c **** {
1141:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1142:../Generated_Code/FreeRTOS0.c **** }
1143:../Generated_Code/FreeRTOS0.c **** */
1144:../Generated_Code/FreeRTOS0.c **** 
1145:../Generated_Code/FreeRTOS0.c **** /*
1146:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1147:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueCreate (component FreeRTOS)
1148:../Generated_Code/FreeRTOS0.c **** **     Description :
1149:../Generated_Code/FreeRTOS0.c **** **         Creates a queue.
1150:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1151:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1152:../Generated_Code/FreeRTOS0.c **** **         uxQueueLength   - The maximum number of
1153:../Generated_Code/FreeRTOS0.c **** **                           items the queue can hold at any time.
1154:../Generated_Code/FreeRTOS0.c **** **         uxItemSize      - The size in bytes of each
1155:../Generated_Code/FreeRTOS0.c **** **                           item the queue will hold.
1156:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1157:../Generated_Code/FreeRTOS0.c **** **         ---             - A handle to the created queue is returned
1158:../Generated_Code/FreeRTOS0.c **** **                           provided the queue was created successfully.
1159:../Generated_Code/FreeRTOS0.c **** **                           NULL is returned if the queue cannot be
1160:../Generated_Code/FreeRTOS0.c **** **                           created because there is too little heap
1161:../Generated_Code/FreeRTOS0.c **** **                           RAM available.
1162:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1163:../Generated_Code/FreeRTOS0.c **** */
1164:../Generated_Code/FreeRTOS0.c **** /*
1165:../Generated_Code/FreeRTOS0.c **** xQueueHandle FreeRTOS0_xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE ux
1166:../Generated_Code/FreeRTOS0.c **** {
1167:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1168:../Generated_Code/FreeRTOS0.c **** }
1169:../Generated_Code/FreeRTOS0.c **** */
1170:../Generated_Code/FreeRTOS0.c **** 
1171:../Generated_Code/FreeRTOS0.c **** /*
1172:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1173:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToFront (component FreeRTOS)
1174:../Generated_Code/FreeRTOS0.c **** **     Description :
1175:../Generated_Code/FreeRTOS0.c **** **         Sends an item to the front of a queue.
1176:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1177:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1178:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1179:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1180:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1181:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1182:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1183:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1184:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1185:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1186:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1187:../Generated_Code/FreeRTOS0.c **** **                           become available on the queue should the
1188:../Generated_Code/FreeRTOS0.c **** **                           queue already be full.
1189:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1190:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1191:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1192:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1193:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1194:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1195:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1196:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully sent to the
1197:../Generated_Code/FreeRTOS0.c **** **                           queue. If a block time was specified then
1198:../Generated_Code/FreeRTOS0.c **** **                           the calling task may have been temporarily
1199:../Generated_Code/FreeRTOS0.c **** **                           placed into the Blocked state to wait for
1200:../Generated_Code/FreeRTOS0.c **** **                           space to become available and space did
1201:../Generated_Code/FreeRTOS0.c **** **                           become available before the block time
1202:../Generated_Code/FreeRTOS0.c **** **                           expired.
1203:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL: The queue is already full so
1204:../Generated_Code/FreeRTOS0.c **** **                           no data could be sent to the queue. If a
1205:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1206:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1207:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1208:../Generated_Code/FreeRTOS0.c **** **                           become available, but no space became
1209:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1210:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1211:../Generated_Code/FreeRTOS0.c **** */
1212:../Generated_Code/FreeRTOS0.c **** /*
1213:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickT
1214:../Generated_Code/FreeRTOS0.c **** {
1215:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1216:../Generated_Code/FreeRTOS0.c **** }
1217:../Generated_Code/FreeRTOS0.c **** */
1218:../Generated_Code/FreeRTOS0.c **** 
1219:../Generated_Code/FreeRTOS0.c **** /*
1220:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1221:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToBack (component FreeRTOS)
1222:../Generated_Code/FreeRTOS0.c **** **     Description :
1223:../Generated_Code/FreeRTOS0.c **** **         Sends an item to the back of a queue.
1224:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1225:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1226:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1227:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1228:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1229:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1230:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1231:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1232:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1233:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1234:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1235:../Generated_Code/FreeRTOS0.c **** **                           become available on the queue should the
1236:../Generated_Code/FreeRTOS0.c **** **                           queue already be full.
1237:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1238:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1239:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1240:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1241:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1242:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1243:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1244:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully sent to the
1245:../Generated_Code/FreeRTOS0.c **** **                           queue. If a block time was specified then
1246:../Generated_Code/FreeRTOS0.c **** **                           the calling task may have been temporarily
1247:../Generated_Code/FreeRTOS0.c **** **                           placed into the Blocked state to wait for
1248:../Generated_Code/FreeRTOS0.c **** **                           space to become available and space did
1249:../Generated_Code/FreeRTOS0.c **** **                           become available before the block time
1250:../Generated_Code/FreeRTOS0.c **** **                           expired.
1251:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL: The queue is already full so
1252:../Generated_Code/FreeRTOS0.c **** **                           no data could be sent to the queue. If a
1253:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1254:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1255:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for space to
1256:../Generated_Code/FreeRTOS0.c **** **                           become available, but no space became
1257:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1258:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1259:../Generated_Code/FreeRTOS0.c **** */
1260:../Generated_Code/FreeRTOS0.c **** /*
1261:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickTy
1262:../Generated_Code/FreeRTOS0.c **** {
1263:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1264:../Generated_Code/FreeRTOS0.c **** }
1265:../Generated_Code/FreeRTOS0.c **** */
1266:../Generated_Code/FreeRTOS0.c **** 
1267:../Generated_Code/FreeRTOS0.c **** /*
1268:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1269:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReceive (component FreeRTOS)
1270:../Generated_Code/FreeRTOS0.c **** **     Description :
1271:../Generated_Code/FreeRTOS0.c **** **         Receives an item from a queue.
1272:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1273:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1274:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1275:../Generated_Code/FreeRTOS0.c **** **                           the data is to be received.
1276:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1277:../Generated_Code/FreeRTOS0.c **** **                           which the data received from the queue will
1278:../Generated_Code/FreeRTOS0.c **** **                           be copied.
1279:../Generated_Code/FreeRTOS0.c **** **                           The length of the buffer must be at least
1280:../Generated_Code/FreeRTOS0.c **** **                           equal to the queue item size (set when the
1281:../Generated_Code/FreeRTOS0.c **** **                           queue was created).
1282:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1283:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1284:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1285:../Generated_Code/FreeRTOS0.c **** **                           become available from the queue should the
1286:../Generated_Code/FreeRTOS0.c **** **                           queue already be empty.
1287:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1288:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1289:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1290:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1291:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1292:../Generated_Code/FreeRTOS0.c **** **                           for data.
1293:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1294:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1295:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1296:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1297:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1298:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1299:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1300:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1301:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1302:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1303:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1304:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1305:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1306:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1307:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1308:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1309:../Generated_Code/FreeRTOS0.c **** */
1310:../Generated_Code/FreeRTOS0.c **** /*
1311:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWai
1312:../Generated_Code/FreeRTOS0.c **** {
1313:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1314:../Generated_Code/FreeRTOS0.c **** }
1315:../Generated_Code/FreeRTOS0.c **** */
1316:../Generated_Code/FreeRTOS0.c **** 
1317:../Generated_Code/FreeRTOS0.c **** /*
1318:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1319:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueuePeek (component FreeRTOS)
1320:../Generated_Code/FreeRTOS0.c **** **     Description :
1321:../Generated_Code/FreeRTOS0.c **** **         Reads an item from a queue, but does not remove the item
1322:../Generated_Code/FreeRTOS0.c **** **         from the queue. Therefore the same item would be returned
1323:../Generated_Code/FreeRTOS0.c **** **         the next time xQueueReceive() or xQueuePeek() was called on
1324:../Generated_Code/FreeRTOS0.c **** **         the same queue.
1325:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1326:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1327:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1328:../Generated_Code/FreeRTOS0.c **** **                           the data is to be read.
1329:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1330:../Generated_Code/FreeRTOS0.c **** **                           which the data read from the queue will be
1331:../Generated_Code/FreeRTOS0.c **** **                           copied. The length of the buffer must be at
1332:../Generated_Code/FreeRTOS0.c **** **                           least equal to the queue item size (set
1333:../Generated_Code/FreeRTOS0.c **** **                           when the queue was created).
1334:../Generated_Code/FreeRTOS0.c **** **         xTicksToWait    - The number of ticks for
1335:../Generated_Code/FreeRTOS0.c **** **                           which the calling task should be held in
1336:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1337:../Generated_Code/FreeRTOS0.c **** **                           become available from the queue should the
1338:../Generated_Code/FreeRTOS0.c **** **                           queue already be empty.
1339:../Generated_Code/FreeRTOS0.c **** **                           A value of zero will prevent the calling
1340:../Generated_Code/FreeRTOS0.c **** **                           task from entering the Blocked state.
1341:../Generated_Code/FreeRTOS0.c **** **                           If INCLUDE_vTaskSuspend is set to 1 then a
1342:../Generated_Code/FreeRTOS0.c **** **                           value of portMAX_DELAY will hold the task
1343:../Generated_Code/FreeRTOS0.c **** **                           in the Blocked state indefinitely to wait
1344:../Generated_Code/FreeRTOS0.c **** **                           for data.
1345:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1346:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1347:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1348:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1349:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1350:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1351:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1352:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1353:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1354:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1355:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1356:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1357:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1358:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1359:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1360:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1361:../Generated_Code/FreeRTOS0.c **** */
1362:../Generated_Code/FreeRTOS0.c **** /*
1363:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
1364:../Generated_Code/FreeRTOS0.c **** {
1365:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1366:../Generated_Code/FreeRTOS0.c **** }
1367:../Generated_Code/FreeRTOS0.c **** */
1368:../Generated_Code/FreeRTOS0.c **** 
1369:../Generated_Code/FreeRTOS0.c **** /*
1370:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1371:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_vQueueDelete (component FreeRTOS)
1372:../Generated_Code/FreeRTOS0.c **** **     Description :
1373:../Generated_Code/FreeRTOS0.c **** **         Deletes a queue that was previously created using a call to
1374:../Generated_Code/FreeRTOS0.c **** **         xQueueCreate(). vQueueDelete() can also be used to delete a
1375:../Generated_Code/FreeRTOS0.c **** **         semaphore.
1376:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1377:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1378:../Generated_Code/FreeRTOS0.c **** **         pxQueueToDelete - The handle of the
1379:../Generated_Code/FreeRTOS0.c **** **                           queue being deleted. Semaphore handles can
1380:../Generated_Code/FreeRTOS0.c **** **                           also be used. Queues are used to pass data
1381:../Generated_Code/FreeRTOS0.c **** **                           between tasks and between tasks and
1382:../Generated_Code/FreeRTOS0.c **** **                           interrupts. A queue/semaphore must not be
1383:../Generated_Code/FreeRTOS0.c **** **                           deleted if there are any tasks that are
1384:../Generated_Code/FreeRTOS0.c **** **                           blocked on the queue/semaphore waiting for
1385:../Generated_Code/FreeRTOS0.c **** **                           events (sends or receives).
1386:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1387:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1388:../Generated_Code/FreeRTOS0.c **** */
1389:../Generated_Code/FreeRTOS0.c **** /*
1390:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_vQueueDelete(xQueueHandle pxQueueToDelete)
1391:../Generated_Code/FreeRTOS0.c **** {
1392:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1393:../Generated_Code/FreeRTOS0.c **** }
1394:../Generated_Code/FreeRTOS0.c **** */
1395:../Generated_Code/FreeRTOS0.c **** 
1396:../Generated_Code/FreeRTOS0.c **** /*
1397:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1398:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxQueueMessagesWaiting (component FreeRTOS)
1399:../Generated_Code/FreeRTOS0.c **** **     Description :
1400:../Generated_Code/FreeRTOS0.c **** **         Queries the number of items that are currently held within a
1401:../Generated_Code/FreeRTOS0.c **** **         queue.
1402:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1403:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1404:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue being
1405:../Generated_Code/FreeRTOS0.c **** **                           queried.
1406:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1407:../Generated_Code/FreeRTOS0.c **** **         ---             - The number of items that are held within
1408:../Generated_Code/FreeRTOS0.c **** **                           the queue being queried.
1409:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1410:../Generated_Code/FreeRTOS0.c **** */
1411:../Generated_Code/FreeRTOS0.c **** /*
1412:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaiting(xQueueHandle xQueue)
1413:../Generated_Code/FreeRTOS0.c **** {
1414:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1415:../Generated_Code/FreeRTOS0.c **** }
1416:../Generated_Code/FreeRTOS0.c **** */
1417:../Generated_Code/FreeRTOS0.c **** 
1418:../Generated_Code/FreeRTOS0.c **** /*
1419:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1420:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_uxQueueMessagesWaitingfromISR (component FreeRTOS)
1421:../Generated_Code/FreeRTOS0.c **** **     Description :
1422:../Generated_Code/FreeRTOS0.c **** **         A version of uxQueueMessagesWaiting() that can be used from
1423:../Generated_Code/FreeRTOS0.c **** **         inside an interrupt service routine.
1424:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1425:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1426:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue being
1427:../Generated_Code/FreeRTOS0.c **** **                           queried.
1428:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1429:../Generated_Code/FreeRTOS0.c **** **         ---             - The number of items that are held within
1430:../Generated_Code/FreeRTOS0.c **** **                           the queue being queried.
1431:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1432:../Generated_Code/FreeRTOS0.c **** */
1433:../Generated_Code/FreeRTOS0.c **** /*
1434:../Generated_Code/FreeRTOS0.c **** unsigned_portBASE_TYPE FreeRTOS0_uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
1435:../Generated_Code/FreeRTOS0.c **** {
1436:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1437:../Generated_Code/FreeRTOS0.c **** }
1438:../Generated_Code/FreeRTOS0.c **** */
1439:../Generated_Code/FreeRTOS0.c **** 
1440:../Generated_Code/FreeRTOS0.c **** /*
1441:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1442:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReceiveFromISR (component FreeRTOS)
1443:../Generated_Code/FreeRTOS0.c **** **     Description :
1444:../Generated_Code/FreeRTOS0.c **** **         A version of xQueueReceive() that can be called from an ISR.
1445:../Generated_Code/FreeRTOS0.c **** **         Unlike xQueueReceive(), xQueueReceiveFromISR() does not
1446:../Generated_Code/FreeRTOS0.c **** **         permit a block time to be specified.
1447:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1448:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1449:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue from which
1450:../Generated_Code/FreeRTOS0.c **** **                           the data is to be received.
1451:../Generated_Code/FreeRTOS0.c **** **         pvBuffer        - A pointer to the memory into
1452:../Generated_Code/FreeRTOS0.c **** **                           which the data received from the queue will
1453:../Generated_Code/FreeRTOS0.c **** **                           be copied.The length of the buffer must be
1454:../Generated_Code/FreeRTOS0.c **** **                           at least equal to the queue item size (set
1455:../Generated_Code/FreeRTOS0.c **** **                           when the queue was created).
1456:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1457:../Generated_Code/FreeRTOS0.c **** **                           - Pointer to A task may be blocked waiting
1458:../Generated_Code/FreeRTOS0.c **** **                           for space to become available on the queue.
1459:../Generated_Code/FreeRTOS0.c **** **                           If xQueueReceiveFromISR() causes such a
1460:../Generated_Code/FreeRTOS0.c **** **                           task to unblock then
1461:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken will get set to
1462:../Generated_Code/FreeRTOS0.c **** **                           pdTRUE, otherwise
1463:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken will remain
1464:../Generated_Code/FreeRTOS0.c **** **                           unchanged.
1465:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1466:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS: Data was successfully read from
1467:../Generated_Code/FreeRTOS0.c **** **                           the queue. If a block time was specified
1468:../Generated_Code/FreeRTOS0.c **** **                           then the calling task may have been
1469:../Generated_Code/FreeRTOS0.c **** **                           temporarily placed into the Blocked state
1470:../Generated_Code/FreeRTOS0.c **** **                           to wait for data to become available and
1471:../Generated_Code/FreeRTOS0.c **** **                           data did become available before the block
1472:../Generated_Code/FreeRTOS0.c **** **                           time expired.
1473:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_EMPTY: The queue was empty so no
1474:../Generated_Code/FreeRTOS0.c **** **                           date could be read form the queue. If a
1475:../Generated_Code/FreeRTOS0.c **** **                           block time was specified then the calling
1476:../Generated_Code/FreeRTOS0.c **** **                           task may have been temporarily placed into
1477:../Generated_Code/FreeRTOS0.c **** **                           the Blocked state to wait for data to
1478:../Generated_Code/FreeRTOS0.c **** **                           become available, but no data became
1479:../Generated_Code/FreeRTOS0.c **** **                           available before the block time expired.
1480:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1481:../Generated_Code/FreeRTOS0.c **** */
1482:../Generated_Code/FreeRTOS0.c **** /*
1483:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *px
1484:../Generated_Code/FreeRTOS0.c **** {
1485:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1486:../Generated_Code/FreeRTOS0.c **** }
1487:../Generated_Code/FreeRTOS0.c **** */
1488:../Generated_Code/FreeRTOS0.c **** 
1489:../Generated_Code/FreeRTOS0.c **** /*
1490:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1491:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToFrontFromISR (component FreeRTOS)
1492:../Generated_Code/FreeRTOS0.c **** **     Description :
1493:../Generated_Code/FreeRTOS0.c **** **         Versions of xQueueSendToFront() API functions that can be
1494:../Generated_Code/FreeRTOS0.c **** **         called from an ISR. Unlike xQueueSendToFront() these
1495:../Generated_Code/FreeRTOS0.c **** **         functions do not permit a block time to be specified.
1496:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1497:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1498:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1499:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1500:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1501:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1502:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1503:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1504:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1505:../Generated_Code/FreeRTOS0.c **** **                           - xQueueSendFromISR() will set
1506:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1507:../Generated_Code/FreeRTOS0.c **** **                           sending to the queue caused a task to
1508:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1509:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1510:../Generated_Code/FreeRTOS0.c **** **                           task. If xQueueSendFromISR() sets this
1511:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1512:../Generated_Code/FreeRTOS0.c **** **                           should be performed before the interrupt is
1513:../Generated_Code/FreeRTOS0.c **** **                           exited.
1514:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1515:../Generated_Code/FreeRTOS0.c **** **         ---             - pdTRUE Data was successfully sent to the
1516:../Generated_Code/FreeRTOS0.c **** **                           queue.
1517:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL Data could not be sent to the
1518:../Generated_Code/FreeRTOS0.c **** **                           queue because the queue was already full.
1519:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1520:../Generated_Code/FreeRTOS0.c **** */
1521:../Generated_Code/FreeRTOS0.c **** /*
1522:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, po
1523:../Generated_Code/FreeRTOS0.c **** {
1524:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1525:../Generated_Code/FreeRTOS0.c **** }
1526:../Generated_Code/FreeRTOS0.c **** */
1527:../Generated_Code/FreeRTOS0.c **** 
1528:../Generated_Code/FreeRTOS0.c **** /*
1529:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1530:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueSendToBackFromISR (component FreeRTOS)
1531:../Generated_Code/FreeRTOS0.c **** **     Description :
1532:../Generated_Code/FreeRTOS0.c **** **         Versions of xQueueSendToBack() API functions that can be
1533:../Generated_Code/FreeRTOS0.c **** **         called from an ISR. Unlike xQueueSendToBack() these
1534:../Generated_Code/FreeRTOS0.c **** **         functions do not permit a block time to be specified.
1535:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1536:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1537:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to which the
1538:../Generated_Code/FreeRTOS0.c **** **                           data is to be sent.
1539:../Generated_Code/FreeRTOS0.c **** **         pvItemToQueue   - A pointer to the data
1540:../Generated_Code/FreeRTOS0.c **** **                           to be sent to the queue. The size of the
1541:../Generated_Code/FreeRTOS0.c **** **                           data that can be sent to a queue was
1542:../Generated_Code/FreeRTOS0.c **** **                           defined when the queue was created.
1543:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1544:../Generated_Code/FreeRTOS0.c **** **                           - xQueueSendFromISR() will set
1545:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1546:../Generated_Code/FreeRTOS0.c **** **                           sending to the queue caused a task to
1547:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1548:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1549:../Generated_Code/FreeRTOS0.c **** **                           task. If xQueueSendFromISR() sets this
1550:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1551:../Generated_Code/FreeRTOS0.c **** **                           should be performed before the interrupt is
1552:../Generated_Code/FreeRTOS0.c **** **                           exited.
1553:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1554:../Generated_Code/FreeRTOS0.c **** **         ---             - pdTRUE Data was successfully sent to the
1555:../Generated_Code/FreeRTOS0.c **** **                           queue.
1556:../Generated_Code/FreeRTOS0.c **** **                           errQUEUE_FULL Data could not be sent to the
1557:../Generated_Code/FreeRTOS0.c **** **                           queue because the queue was already full.
1558:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1559:../Generated_Code/FreeRTOS0.c **** */
1560:../Generated_Code/FreeRTOS0.c **** /*
1561:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, por
1562:../Generated_Code/FreeRTOS0.c **** {
1563:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1564:../Generated_Code/FreeRTOS0.c **** }
1565:../Generated_Code/FreeRTOS0.c **** */
1566:../Generated_Code/FreeRTOS0.c **** /*
1567:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1568:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xQueueReset (component FreeRTOS)
1569:../Generated_Code/FreeRTOS0.c **** **     Description :
1570:../Generated_Code/FreeRTOS0.c **** **         Reset a queue back to its original empty state.  pdPASS is
1571:../Generated_Code/FreeRTOS0.c **** **         returned if the queue is successfully reset.  pdFAIL is
1572:../Generated_Code/FreeRTOS0.c **** **         returned if the queue could not be reset because there are
1573:../Generated_Code/FreeRTOS0.c **** **         tasks blocked on the queue waiting to either receive from
1574:../Generated_Code/FreeRTOS0.c **** **         the queue or send to the queue.
1575:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1576:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1577:../Generated_Code/FreeRTOS0.c **** **         xQueue          - The handle of the queue to reset.
1578:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1579:../Generated_Code/FreeRTOS0.c **** **         ---             - pdPASS is returned if the queue is
1580:../Generated_Code/FreeRTOS0.c **** **                           successfully reset. pdFAIL is returned if
1581:../Generated_Code/FreeRTOS0.c **** **                           the queue could not be reset because there
1582:../Generated_Code/FreeRTOS0.c **** **                           are tasks blocked on the queue waiting to
1583:../Generated_Code/FreeRTOS0.c **** **                           either receive from the queue or send to
1584:../Generated_Code/FreeRTOS0.c **** **                           the queue.
1585:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1586:../Generated_Code/FreeRTOS0.c **** */
1587:../Generated_Code/FreeRTOS0.c **** /*
1588:../Generated_Code/FreeRTOS0.c **** portBASE_TYPE FreeRTOS0_xQueueReset(xQueueHandle xQueue)
1589:../Generated_Code/FreeRTOS0.c **** {
1590:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1591:../Generated_Code/FreeRTOS0.c **** }
1592:../Generated_Code/FreeRTOS0.c **** */
1593:../Generated_Code/FreeRTOS0.c **** 
1594:../Generated_Code/FreeRTOS0.c **** /*
1595:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1596:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreGetMutexHolder (component FreeRTOS)
1597:../Generated_Code/FreeRTOS0.c **** **     Description :
1598:../Generated_Code/FreeRTOS0.c **** **         Returns the holder of a mutex or semaphore. If xMutex is
1599:../Generated_Code/FreeRTOS0.c **** **         indeed a mutex type semaphore, return the current mutex
1600:../Generated_Code/FreeRTOS0.c **** **         holder. If xMutex is not a mutex type semaphore, or the
1601:../Generated_Code/FreeRTOS0.c **** **         mutex is available (not held by a task), return NULL. Note:
1602:../Generated_Code/FreeRTOS0.c **** **         This Is is a good way of determining if the calling task is
1603:../Generated_Code/FreeRTOS0.c **** **         the mutex holder, but not a good way of determining the
1604:../Generated_Code/FreeRTOS0.c **** **         identity of the mutex holder as the holder may change
1605:../Generated_Code/FreeRTOS0.c **** **         between the function exiting and the returned value being
1606:../Generated_Code/FreeRTOS0.c **** **         tested.
1607:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1608:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1609:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore.
1610:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1611:../Generated_Code/FreeRTOS0.c **** **         ---             - Not NULL if the calling task is the holder
1612:../Generated_Code/FreeRTOS0.c **** **                           of the mutex, NULL otherwise.
1613:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1614:../Generated_Code/FreeRTOS0.c **** */
1615:../Generated_Code/FreeRTOS0.c **** /*
1616:../Generated_Code/FreeRTOS0.c **** void* FreeRTOS0_xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
1617:../Generated_Code/FreeRTOS0.c **** {
1618:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1619:../Generated_Code/FreeRTOS0.c **** }
1620:../Generated_Code/FreeRTOS0.c **** */
1621:../Generated_Code/FreeRTOS0.c **** 
1622:../Generated_Code/FreeRTOS0.c **** /*
1623:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1624:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_xSemaphoreTakeFromISR (component FreeRTOS)
1625:../Generated_Code/FreeRTOS0.c **** **     Description :
1626:../Generated_Code/FreeRTOS0.c **** **         Macro to take a semaphore from an ISR. The semaphore must
1627:../Generated_Code/FreeRTOS0.c **** **         have previously been created with a call to
1628:../Generated_Code/FreeRTOS0.c **** **         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
1629:../Generated_Code/FreeRTOS0.c **** **         Mutex type semaphores (those created using a call to
1630:../Generated_Code/FreeRTOS0.c **** **         xSemaphoreCreateMutex()) must not be used with this macro.
1631:../Generated_Code/FreeRTOS0.c **** **         This macro can be used from an ISR, however taking a
1632:../Generated_Code/FreeRTOS0.c **** **         semaphore from an ISR is not a common operation.  It is
1633:../Generated_Code/FreeRTOS0.c **** **         likely to only be useful when taking a counting semaphore
1634:../Generated_Code/FreeRTOS0.c **** **         when an interrupt is obtaining an object from a resource
1635:../Generated_Code/FreeRTOS0.c **** **         pool (when the semaphore count indicates the number of
1636:../Generated_Code/FreeRTOS0.c **** **         resources available).
1637:../Generated_Code/FreeRTOS0.c **** **     Parameters  :
1638:../Generated_Code/FreeRTOS0.c **** **         NAME            - DESCRIPTION
1639:../Generated_Code/FreeRTOS0.c **** **         xSemaphore      - A handle to the semaphore
1640:../Generated_Code/FreeRTOS0.c **** **                           being taken. This is the handle returned
1641:../Generated_Code/FreeRTOS0.c **** **                           when the semaphore was created.
1642:../Generated_Code/FreeRTOS0.c **** **       * pxHigherPriorityTaskWoken 
1643:../Generated_Code/FreeRTOS0.c **** **                           - xSemaphoreTakeFromISR() will set
1644:../Generated_Code/FreeRTOS0.c **** **                           *pxHigherPriorityTaskWoken to pdTRUE if
1645:../Generated_Code/FreeRTOS0.c **** **                           taking the semaphore caused a task to
1646:../Generated_Code/FreeRTOS0.c **** **                           unblock, and the unblocked task has a
1647:../Generated_Code/FreeRTOS0.c **** **                           priority higher than the currently running
1648:../Generated_Code/FreeRTOS0.c **** **                           task.  If xSemaphoreTakeFromISR() sets this
1649:../Generated_Code/FreeRTOS0.c **** **                           value to pdTRUE then a context switch
1650:../Generated_Code/FreeRTOS0.c **** **                           should be requested before the interrupt is
1651:../Generated_Code/FreeRTOS0.c **** **                           exited.
1652:../Generated_Code/FreeRTOS0.c **** **     Returns     :
1653:../Generated_Code/FreeRTOS0.c **** **         ---             - Returns pdTRUE if the semaphore was given.
1654:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1655:../Generated_Code/FreeRTOS0.c **** */
1656:../Generated_Code/FreeRTOS0.c **** /*
1657:../Generated_Code/FreeRTOS0.c **** bool FreeRTOS0_xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPri
1658:../Generated_Code/FreeRTOS0.c **** {
1659:../Generated_Code/FreeRTOS0.c ****   *** Implemented as macro in the header file FreeRTOS0.h
1660:../Generated_Code/FreeRTOS0.c **** }
1661:../Generated_Code/FreeRTOS0.c **** */
1662:../Generated_Code/FreeRTOS0.c **** 
1663:../Generated_Code/FreeRTOS0.c **** /*
1664:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1665:../Generated_Code/FreeRTOS0.c **** **     Method      :  FreeRTOS0_Init (component FreeRTOS)
1666:../Generated_Code/FreeRTOS0.c **** **     Description :
1667:../Generated_Code/FreeRTOS0.c **** **         Low level initialization routine called from startup code.
1668:../Generated_Code/FreeRTOS0.c **** **         This method ensures that the tick timer is  not enabled.
1669:../Generated_Code/FreeRTOS0.c **** **     Parameters  : None
1670:../Generated_Code/FreeRTOS0.c **** **     Returns     : Nothing
1671:../Generated_Code/FreeRTOS0.c **** ** ===================================================================
1672:../Generated_Code/FreeRTOS0.c **** */
1673:../Generated_Code/FreeRTOS0.c **** void FreeRTOS0_Init(void)
1674:../Generated_Code/FreeRTOS0.c **** {
  26              		.loc 1 1674 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 00AF     		add	r7, sp, #0
  34              	.LCFI1:
  35              		.cfi_def_cfa_register 7
1675:../Generated_Code/FreeRTOS0.c ****   vPortInitTickTimer();
  36              		.loc 1 1675 0
  37 0004 FFF7FEFF 		bl	vPortInitTickTimer
1676:../Generated_Code/FreeRTOS0.c ****   vPortStopTickTimer();
  38              		.loc 1 1676 0
  39 0008 FFF7FEFF 		bl	vPortStopTickTimer
1677:../Generated_Code/FreeRTOS0.c **** }
  40              		.loc 1 1677 0
  41 000c BD46     		mov	sp, r7
  42              		@ sp needed for prologue
  43 000e 80BD     		pop	{r7, pc}
  44              		.cfi_endproc
  45              	.LFE5:
  47              		.text
  48              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 FreeRTOS0.c
C:\Users\Judah\AppData\Local\Temp\ccGlb3JX.s:18     .text._Z14FreeRTOS0_Initv:00000000 $t
C:\Users\Judah\AppData\Local\Temp\ccGlb3JX.s:23     .text._Z14FreeRTOS0_Initv:00000000 _Z14FreeRTOS0_Initv
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortInitTickTimer
vPortStopTickTimer
