   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss._ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	_ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	88
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss._ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	_ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.I2C0_Interrupt,"ax",%progbits
  30              		.align	2
  31              		.global	I2C0_Interrupt
  32              		.code	16
  33              		.thumb_func
  35              	I2C0_Interrupt:
  36              	.LFB5:
  37              		.file 1 "../Generated_Code/I2C0.c"
   1:../Generated_Code/I2C0.c **** /* ###################################################################
   2:../Generated_Code/I2C0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/I2C0.c **** **     Filename    : I2C0.c
   4:../Generated_Code/I2C0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/I2C0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/I2C0.c **** **     Component   : I2C_LDD
   7:../Generated_Code/I2C0.c **** **     Version     : Component 01.016, Driver 01.07, CPU db: 3.00.000
   8:../Generated_Code/I2C0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/I2C0.c **** **     Date/Time   : 2014-04-05, 15:34, # CodeGen: 6
  10:../Generated_Code/I2C0.c **** **     Abstract    :
  11:../Generated_Code/I2C0.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/I2C0.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/I2C0.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/I2C0.c **** **          Interface features:
  15:../Generated_Code/I2C0.c **** **          MASTER mode
  16:../Generated_Code/I2C0.c **** **            - Multi master communication
  17:../Generated_Code/I2C0.c **** **            - The combined format of communication possible
  18:../Generated_Code/I2C0.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/I2C0.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/I2C0.c **** **            - Acknowledge polling provided
  21:../Generated_Code/I2C0.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/I2C0.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/I2C0.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/I2C0.c **** **          SLAVE mode
  25:../Generated_Code/I2C0.c **** **            - 7-bit slave addressing
  26:../Generated_Code/I2C0.c **** **            - General call address detection provided
  27:../Generated_Code/I2C0.c **** **     Settings    :
  28:../Generated_Code/I2C0.c **** **          Component name                                 : I2C0
  29:../Generated_Code/I2C0.c **** **          I2C channel                                    : I2C0
  30:../Generated_Code/I2C0.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/I2C0.c **** **            Interrupt                                    : INT_I2C0
  32:../Generated_Code/I2C0.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/I2C0.c **** **          Settings                                       : 
  34:../Generated_Code/I2C0.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/I2C0.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/I2C0.c **** **              Initialization                             : 
  37:../Generated_Code/I2C0.c **** **                Address mode                             : 10-bit addressing
  38:../Generated_Code/I2C0.c **** **                Target slave address init                : 1D
  39:../Generated_Code/I2C0.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/I2C0.c **** **            Pins                                         : 
  41:../Generated_Code/I2C0.c **** **              SDA pin                                    : 
  42:../Generated_Code/I2C0.c **** **                SDA pin                                  : PTE25/TPM0_CH1/I2C0_SDA
  43:../Generated_Code/I2C0.c **** **                SDA pin signal                           : 
  44:../Generated_Code/I2C0.c **** **              SCL pin                                    : 
  45:../Generated_Code/I2C0.c **** **                SCL pin                                  : PTE24/TPM0_CH0/I2C0_SCL
  46:../Generated_Code/I2C0.c **** **                SCL pin signal                           : 
  47:../Generated_Code/I2C0.c **** **              High drive select                          : Disabled
  48:../Generated_Code/I2C0.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/I2C0.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/I2C0.c **** **            Bits 0-2 of Frequency divider register       : 111
  51:../Generated_Code/I2C0.c **** **            Bits 3-5 of Frequency divider register       : 011
  52:../Generated_Code/I2C0.c **** **            SCL frequency                                : 100 kHz
  53:../Generated_Code/I2C0.c **** **            SDA Hold                                     : 1.375 us
  54:../Generated_Code/I2C0.c **** **            SCL start Hold                               : 4.917 us
  55:../Generated_Code/I2C0.c **** **            SCL stop Hold                                : 5.042 us
  56:../Generated_Code/I2C0.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/I2C0.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/I2C0.c **** **          Initialization                                 : 
  59:../Generated_Code/I2C0.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/I2C0.c **** **            Auto initialization                          : yes
  61:../Generated_Code/I2C0.c **** **            Event mask                                   : 
  62:../Generated_Code/I2C0.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/I2C0.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/I2C0.c **** **              OnMasterByteReceived                       : Enabled
  65:../Generated_Code/I2C0.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/I2C0.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/I2C0.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/I2C0.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/I2C0.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/I2C0.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/I2C0.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/I2C0.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/I2C0.c **** **              OnError                                    : Enabled
  74:../Generated_Code/I2C0.c **** **              OnBusStopDetected                          : Enabled
  75:../Generated_Code/I2C0.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/I2C0.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/I2C0.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/I2C0.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/I2C0.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/I2C0.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/I2C0.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/I2C0.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/I2C0.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/I2C0.c **** **     Contents    :
  85:../Generated_Code/I2C0.c **** **         Init                         - LDD_TDeviceData* I2C0_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/I2C0.c **** **         Deinit                       - void I2C0_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/I2C0.c **** **         Enable                       - LDD_TError I2C0_Enable(LDD_TDeviceData *DeviceDataPtr);
  88:../Generated_Code/I2C0.c **** **         Disable                      - LDD_TError I2C0_Disable(LDD_TDeviceData *DeviceDataPtr);
  89:../Generated_Code/I2C0.c **** **         SetEventMask                 - LDD_TError I2C0_SetEventMask(LDD_TDeviceData *DeviceDataP
  90:../Generated_Code/I2C0.c **** **         GetEventMask                 - LDD_TEventMask I2C0_GetEventMask(LDD_TDeviceData *DeviceD
  91:../Generated_Code/I2C0.c **** **         MasterSendBlock              - LDD_TError I2C0_MasterSendBlock(LDD_TDeviceData *DeviceDa
  92:../Generated_Code/I2C0.c **** **         MasterGetBlockSentStatus     - bool I2C0_MasterGetBlockSentStatus(LDD_TDeviceData *Devic
  93:../Generated_Code/I2C0.c **** **         MasterGetSentDataNum         - LDD_I2C_TSize I2C0_MasterGetSentDataNum(LDD_TDeviceData *
  94:../Generated_Code/I2C0.c **** **         MasterReceiveBlock           - LDD_TError I2C0_MasterReceiveBlock(LDD_TDeviceData *Devic
  95:../Generated_Code/I2C0.c **** **         MasterGetBlockReceivedStatus - bool I2C0_MasterGetBlockReceivedStatus(LDD_TDeviceData *D
  96:../Generated_Code/I2C0.c **** **         MasterGetReceivedDataNum     - LDD_I2C_TSize I2C0_MasterGetReceivedDataNum(LDD_TDeviceDa
  97:../Generated_Code/I2C0.c **** **         MasterUpdateReceiveBlockSize - LDD_TError I2C0_MasterUpdateReceiveBlockSize(LDD_TDeviceD
  98:../Generated_Code/I2C0.c **** **         SelectSlaveDevice            - LDD_TError I2C0_SelectSlaveDevice(LDD_TDeviceData *Device
  99:../Generated_Code/I2C0.c **** **         GetError                     - LDD_TError I2C0_GetError(LDD_TDeviceData *DeviceDataPtr, 
 100:../Generated_Code/I2C0.c **** **         CheckBus                     - LDD_TError I2C0_CheckBus(LDD_TDeviceData *DeviceDataPtr, 
 101:../Generated_Code/I2C0.c **** **         GetStats                     - LDD_I2C_TStats I2C0_GetStats(LDD_TDeviceData *DeviceDataP
 102:../Generated_Code/I2C0.c **** **         ConnectPin                   - LDD_TError I2C0_ConnectPin(LDD_TDeviceData *DeviceDataPtr
 103:../Generated_Code/I2C0.c **** **         SetOperationMode             - LDD_TError I2C0_SetOperationMode(LDD_TDeviceData *DeviceD
 104:../Generated_Code/I2C0.c **** **         GetDriverState               - LDD_TDriverState I2C0_GetDriverState(LDD_TDeviceData *Dev
 105:../Generated_Code/I2C0.c **** **
 106:../Generated_Code/I2C0.c **** **     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
 107:../Generated_Code/I2C0.c **** **     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
 108:../Generated_Code/I2C0.c **** **     
 109:../Generated_Code/I2C0.c **** **     http      : www.freescale.com
 110:../Generated_Code/I2C0.c **** **     mail      : support@freescale.com
 111:../Generated_Code/I2C0.c **** ** ###################################################################*/
 112:../Generated_Code/I2C0.c **** /*!
 113:../Generated_Code/I2C0.c **** ** @file I2C0.c
 114:../Generated_Code/I2C0.c **** ** @version 01.07
 115:../Generated_Code/I2C0.c **** ** @brief
 116:../Generated_Code/I2C0.c **** **          This component encapsulates the internal I2C communication
 117:../Generated_Code/I2C0.c **** **          interface. The implementation of the interface is based
 118:../Generated_Code/I2C0.c **** **          on the Philips I2C-bus specification version 2.0.
 119:../Generated_Code/I2C0.c **** **          Interface features:
 120:../Generated_Code/I2C0.c **** **          MASTER mode
 121:../Generated_Code/I2C0.c **** **            - Multi master communication
 122:../Generated_Code/I2C0.c **** **            - The combined format of communication possible
 123:../Generated_Code/I2C0.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
 124:../Generated_Code/I2C0.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
 125:../Generated_Code/I2C0.c **** **            - Acknowledge polling provided
 126:../Generated_Code/I2C0.c **** **            - No wait state initiated when a slave device holds the SCL line low
 127:../Generated_Code/I2C0.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
 128:../Generated_Code/I2C0.c **** **            - Invalid start/stop condition detection provided
 129:../Generated_Code/I2C0.c **** **          SLAVE mode
 130:../Generated_Code/I2C0.c **** **            - 7-bit slave addressing
 131:../Generated_Code/I2C0.c **** **            - General call address detection provided
 132:../Generated_Code/I2C0.c **** */         
 133:../Generated_Code/I2C0.c **** /*!
 134:../Generated_Code/I2C0.c **** **  @addtogroup I2C0_module I2C0 module documentation
 135:../Generated_Code/I2C0.c **** **  @{
 136:../Generated_Code/I2C0.c **** */         
 137:../Generated_Code/I2C0.c **** 
 138:../Generated_Code/I2C0.c **** /* MODULE I2C0. */
 139:../Generated_Code/I2C0.c **** 
 140:../Generated_Code/I2C0.c **** #include "GI2C0.h"
 141:../Generated_Code/I2C0.c **** #include "Events.h"
 142:../Generated_Code/I2C0.c **** #include "I2C0.h"
 143:../Generated_Code/I2C0.c **** #include "PORT_PDD.h"
 144:../Generated_Code/I2C0.c **** #include "I2C_PDD.h"
 145:../Generated_Code/I2C0.c **** #include "FreeRTOS.h" /* FreeRTOS interface */
 146:../Generated_Code/I2C0.c **** #include "IO_Map.h"
 147:../Generated_Code/I2C0.c **** #include "SIM_PDD.h"
 148:../Generated_Code/I2C0.c **** 
 149:../Generated_Code/I2C0.c **** #ifdef __cplusplus
 150:../Generated_Code/I2C0.c **** extern "C" {
 151:../Generated_Code/I2C0.c **** #endif 
 152:../Generated_Code/I2C0.c **** 
 153:../Generated_Code/I2C0.c **** 
 154:../Generated_Code/I2C0.c **** /* SerFlag bits */
 155:../Generated_Code/I2C0.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 156:../Generated_Code/I2C0.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 157:../Generated_Code/I2C0.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 158:../Generated_Code/I2C0.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 159:../Generated_Code/I2C0.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 160:../Generated_Code/I2C0.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 161:../Generated_Code/I2C0.c **** 
 162:../Generated_Code/I2C0.c **** /* StatusFlag bits */
 163:../Generated_Code/I2C0.c **** #define MASTER_BLOCK_SENT       0x01U  /* Master data block sent flag */
 164:../Generated_Code/I2C0.c **** #define MASTER_BLOCK_RECEIVED   0x02U  /* Master data block received flag */
 165:../Generated_Code/I2C0.c **** 
 166:../Generated_Code/I2C0.c **** typedef struct {
 167:../Generated_Code/I2C0.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 168:../Generated_Code/I2C0.c ****                                        /* Bits: 0 - Running int from TX */
 169:../Generated_Code/I2C0.c ****                                        /*       1 - 10-bit address transmission complete   */
 170:../Generated_Code/I2C0.c ****                                        /*       2 - repeated address transmission complete */
 171:../Generated_Code/I2C0.c ****                                        /*       3 - General Call flag */
 172:../Generated_Code/I2C0.c ****                                        /*       4 - 10-bit addr flag */
 173:../Generated_Code/I2C0.c ****                                        /*       5 - 7-bit addr flag */
 174:../Generated_Code/I2C0.c ****   uint8_t StatusFlag;                  /* Flags for status of communication */
 175:../Generated_Code/I2C0.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 176:../Generated_Code/I2C0.c ****   bool EnUser;                         /* Enable/Disable device */
 177:../Generated_Code/I2C0.c ****   LDD_I2C_TErrorMask ErrorMask;        /* Variable for errors mask value */
 178:../Generated_Code/I2C0.c ****   LDD_TEventMask EventMask;            /* Enable/Disable events mask */
 179:../Generated_Code/I2C0.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 180:../Generated_Code/I2C0.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 181:../Generated_Code/I2C0.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 182:../Generated_Code/I2C0.c ****   LDD_I2C_TSize InpByteMNum;           /* Length of input bufer's content */
 183:../Generated_Code/I2C0.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 184:../Generated_Code/I2C0.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 185:../Generated_Code/I2C0.c ****   LDD_I2C_TSize OutByteMNum;           /* Byte number of output bufer's content */
 186:../Generated_Code/I2C0.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 187:../Generated_Code/I2C0.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 188:../Generated_Code/I2C0.c ****   LDD_I2C_TStats Stats;                /* Communication statistics */
 189:../Generated_Code/I2C0.c **** } I2C0_TDeviceData;
 190:../Generated_Code/I2C0.c **** 
 191:../Generated_Code/I2C0.c **** typedef I2C0_TDeviceData *I2C0_TDeviceDataPtr; /* Pointer to the device data structure. */
 192:../Generated_Code/I2C0.c **** 
 193:../Generated_Code/I2C0.c **** /* {FreeRTOS RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 194:../Generated_Code/I2C0.c **** static I2C0_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 195:../Generated_Code/I2C0.c **** /* {FreeRTOS RTOS Adapter} Global variable used for passing a parameter into ISR */
 196:../Generated_Code/I2C0.c **** static I2C0_TDeviceDataPtr INT_I2C0__BAREBOARD_RTOS_ISRPARAM;
 197:../Generated_Code/I2C0.c **** 
 198:../Generated_Code/I2C0.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 199:../Generated_Code/I2C0.c **** #define AVAILABLE_PIN_MASK (LDD_I2C_SDA_PIN | LDD_I2C_SCL_PIN)
 200:../Generated_Code/I2C0.c **** 
 201:../Generated_Code/I2C0.c **** /* Internal method prototypes */
 202:../Generated_Code/I2C0.c **** static void HWEnDi(LDD_TDeviceData *DeviceDataPtr);
 203:../Generated_Code/I2C0.c **** 
 204:../Generated_Code/I2C0.c **** /*
 205:../Generated_Code/I2C0.c **** ** ===================================================================
 206:../Generated_Code/I2C0.c **** **     Method      :  I2C0_Interrupt (component I2C_LDD)
 207:../Generated_Code/I2C0.c **** **
 208:../Generated_Code/I2C0.c **** **     Description :
 209:../Generated_Code/I2C0.c **** **         The method services the interrupt of the selected peripheral(s)
 210:../Generated_Code/I2C0.c **** **         and eventually invokes event(s) of the component.
 211:../Generated_Code/I2C0.c **** **         This method is internal. It is used by Processor Expert only.
 212:../Generated_Code/I2C0.c **** ** ===================================================================
 213:../Generated_Code/I2C0.c **** */
 214:../Generated_Code/I2C0.c **** 
 215:../Generated_Code/I2C0.c **** PE_ISR(I2C0_Interrupt)
 216:../Generated_Code/I2C0.c **** {
  38              		.loc 1 216 0
  39              		.cfi_startproc
  40 0000 90B5     		push	{r4, r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 83B0     		sub	sp, sp, #12
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 24
  49 0004 00AF     		add	r7, sp, #0
  50              	.LCFI2:
  51              		.cfi_def_cfa_register 7
  52              	.LBB2:
 217:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} ISR parameter is passed through the global variable */
 218:../Generated_Code/I2C0.c ****   I2C0_TDeviceDataPtr DeviceDataPrv = INT_I2C0__BAREBOARD_RTOS_ISRPARAM;
  53              		.loc 1 218 0
  54 0006 C34B     		ldr	r3, .L20
  55 0008 1B68     		ldr	r3, [r3]
  56 000a 3B60     		str	r3, [r7]
 219:../Generated_Code/I2C0.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  57              		.loc 1 219 0
  58 000c BB1D     		add	r3, r7, #6
  59 000e 0022     		mov	r2, #0
  60 0010 1A80     		strh	r2, [r3]
 220:../Generated_Code/I2C0.c ****   register uint8_t Status;             /* Temporary variable for status register */
 221:../Generated_Code/I2C0.c **** 
 222:../Generated_Code/I2C0.c ****   Status = I2C_PDD_ReadBusStatusFlags(I2C0_BASE_PTR); /* Get bus state flags */
  61              		.loc 1 222 0
  62 0012 C14B     		ldr	r3, .L20+4
  63 0014 9B79     		ldrb	r3, [r3, #6]
  64 0016 DCB2     		uxtb	r4, r3
 223:../Generated_Code/I2C0.c ****   I2C_PDD_ClearBusStatusInterruptFlags(I2C0_BASE_PTR, (Status)); /* */
  65              		.loc 1 223 0
  66 0018 BF4B     		ldr	r3, .L20+4
  67 001a BF4A     		ldr	r2, .L20+4
  68 001c 9279     		ldrb	r2, [r2, #6]
  69 001e D2B2     		uxtb	r2, r2
  70 0020 D2B2     		uxtb	r2, r2
  71 0022 4021     		mov	r1, #64
  72 0024 8A43     		bic	r2, r1
  73 0026 D1B2     		uxtb	r1, r2
  74 0028 E2B2     		uxtb	r2, r4
  75 002a 0A43     		orr	r2, r1
  76 002c D2B2     		uxtb	r2, r2
  77 002e D2B2     		uxtb	r2, r2
  78 0030 9A71     		strb	r2, [r3, #6]
 224:../Generated_Code/I2C0.c ****   if ((Status & I2C_PDD_BUS_STOP_FLAG) != 0x00U) { /* Is bus stop condition detected? */
  79              		.loc 1 224 0
  80 0032 221C     		mov	r2, r4
  81 0034 4023     		mov	r3, #64
  82 0036 1340     		and	r3, r2
  83 0038 0CD0     		beq	.L2
 225:../Generated_Code/I2C0.c ****     if ((DeviceDataPrv->EventMask & LDD_I2C_ON_BUS_STOP_DETECTED) != 0x00U) { /* Is enabled call On
  84              		.loc 1 225 0
  85 003a 3B68     		ldr	r3, [r7]
  86 003c 9A68     		ldr	r2, [r3, #8]
  87 003e 8023     		mov	r3, #128
  88 0040 9B01     		lsl	r3, r3, #6
  89 0042 1340     		and	r3, r2
  90 0044 00D1     		bne	.LCB50
  91 0046 A7E1     		b	.L19	@long jump
  92              	.LCB50:
 226:../Generated_Code/I2C0.c ****       I2C0_OnBusStopDetected(DeviceDataPrv->UserData); /* If yes then invoke user event */
  93              		.loc 1 226 0
  94 0048 3B68     		ldr	r3, [r7]
  95 004a 1B6A     		ldr	r3, [r3, #32]
  96 004c 181C     		mov	r0, r3
  97 004e FFF7FEFF 		bl	_Z22I2C0_OnBusStopDetectedPv
 227:../Generated_Code/I2C0.c ****     }
 228:../Generated_Code/I2C0.c ****     return;
  98              		.loc 1 228 0
  99 0052 A1E1     		b	.L19
 100              	.L2:
 229:../Generated_Code/I2C0.c ****   }
 230:../Generated_Code/I2C0.c ****   Status = I2C_PDD_ReadStatusReg(I2C0_BASE_PTR); /* Safe status register */
 101              		.loc 1 230 0
 102 0054 B04B     		ldr	r3, .L20+4
 103 0056 DB78     		ldrb	r3, [r3, #3]
 104 0058 DCB2     		uxtb	r4, r3
 231:../Generated_Code/I2C0.c ****   I2C_PDD_ClearInterruptFlags(I2C0_BASE_PTR, (Status)); /* Clear interrupt flag */
 105              		.loc 1 231 0
 106 005a AF4B     		ldr	r3, .L20+4
 107 005c AE4A     		ldr	r2, .L20+4
 108 005e D278     		ldrb	r2, [r2, #3]
 109 0060 D2B2     		uxtb	r2, r2
 110 0062 D2B2     		uxtb	r2, r2
 111 0064 1221     		mov	r1, #18
 112 0066 8A43     		bic	r2, r1
 113 0068 D1B2     		uxtb	r1, r2
 114 006a E2B2     		uxtb	r2, r4
 115 006c 0A43     		orr	r2, r1
 116 006e D2B2     		uxtb	r2, r2
 117 0070 D2B2     		uxtb	r2, r2
 118 0072 DA70     		strb	r2, [r3, #3]
 232:../Generated_Code/I2C0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 119              		.loc 1 232 0
 120 0074 A84B     		ldr	r3, .L20+4
 121 0076 9B78     		ldrb	r3, [r3, #2]
 122 0078 DBB2     		uxtb	r3, r3
 123 007a 1A1C     		mov	r2, r3
 124 007c 2023     		mov	r3, #32
 125 007e 1340     		and	r3, r2
 126 0080 5A1E     		sub	r2, r3, #1
 127 0082 9341     		sbc	r3, r3, r2
 128 0084 DBB2     		uxtb	r3, r3
 129 0086 002B     		cmp	r3, #0
 130 0088 00D1     		bne	.LCB84
 131 008a 47E1     		b	.L5	@long jump
 132              	.LCB84:
 233:../Generated_Code/I2C0.c ****     if (I2C_PDD_GetTransmitMode(I2C0_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
 133              		.loc 1 233 0
 134 008c A24B     		ldr	r3, .L20+4
 135 008e 9B78     		ldrb	r3, [r3, #2]
 136 0090 DBB2     		uxtb	r3, r3
 137 0092 1A1C     		mov	r2, r3
 138 0094 1023     		mov	r3, #16
 139 0096 1340     		and	r3, r2
 140 0098 5A1E     		sub	r2, r3, #1
 141 009a 9341     		sbc	r3, r3, r2
 142 009c DBB2     		uxtb	r3, r3
 143 009e 002B     		cmp	r3, #0
 144 00a0 00D1     		bne	.LCB94
 145 00a2 D3E0     		b	.L6	@long jump
 146              	.LCB94:
 234:../Generated_Code/I2C0.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
 147              		.loc 1 234 0
 148 00a4 221C     		mov	r2, r4
 149 00a6 0123     		mov	r3, #1
 150 00a8 1340     		and	r3, r2
 151 00aa 2FD0     		beq	.L7
 235:../Generated_Code/I2C0.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
 152              		.loc 1 235 0
 153 00ac 9A4B     		ldr	r3, .L20+4
 154 00ae 9A4A     		ldr	r2, .L20+4
 155 00b0 9278     		ldrb	r2, [r2, #2]
 156 00b2 D2B2     		uxtb	r2, r2
 157 00b4 2021     		mov	r1, #32
 158 00b6 8A43     		bic	r2, r1
 159 00b8 D2B2     		uxtb	r2, r2
 160 00ba 9A70     		strb	r2, [r3, #2]
 236:../Generated_Code/I2C0.c ****         I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 161              		.loc 1 236 0
 162 00bc 964B     		ldr	r3, .L20+4
 163 00be 964A     		ldr	r2, .L20+4
 164 00c0 9278     		ldrb	r2, [r2, #2]
 165 00c2 D2B2     		uxtb	r2, r2
 166 00c4 1021     		mov	r1, #16
 167 00c6 8A43     		bic	r2, r1
 168 00c8 D2B2     		uxtb	r2, r2
 169 00ca 9A70     		strb	r2, [r3, #2]
 237:../Generated_Code/I2C0.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 170              		.loc 1 237 0
 171 00cc 3B68     		ldr	r3, [r7]
 172 00ce 0022     		mov	r2, #0
 173 00d0 1A83     		strh	r2, [r3, #24]
 238:../Generated_Code/I2C0.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 174              		.loc 1 238 0
 175 00d2 3B68     		ldr	r3, [r7]
 176 00d4 0022     		mov	r2, #0
 177 00d6 DA81     		strh	r2, [r3, #14]
 239:../Generated_Code/I2C0.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 178              		.loc 1 239 0
 179 00d8 3B68     		ldr	r3, [r7]
 180 00da 1B78     		ldrb	r3, [r3]
 181 00dc 0122     		mov	r2, #1
 182 00de 9343     		bic	r3, r2
 183 00e0 DAB2     		uxtb	r2, r3
 184 00e2 3B68     		ldr	r3, [r7]
 185 00e4 1A70     		strb	r2, [r3]
 240:../Generated_Code/I2C0.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 186              		.loc 1 240 0
 187 00e6 3B68     		ldr	r3, [r7]
 188 00e8 1B78     		ldrb	r3, [r3]
 189 00ea 0622     		mov	r2, #6
 190 00ec 1343     		orr	r3, r2
 191 00ee DAB2     		uxtb	r2, r3
 192 00f0 3B68     		ldr	r3, [r7]
 193 00f2 1A70     		strb	r2, [r3]
 241:../Generated_Code/I2C0.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 194              		.loc 1 241 0
 195 00f4 BB1D     		add	r3, r7, #6
 196 00f6 BA1D     		add	r2, r7, #6
 197 00f8 1288     		ldrh	r2, [r2]
 198 00fa 0821     		mov	r1, #8
 199 00fc 0A43     		orr	r2, r1
 200 00fe 1A80     		strh	r2, [r3]
 242:../Generated_Code/I2C0.c ****         DeviceDataPrv->Stats.MasterNacks++; /* Increment MasterNacks counter */
 201              		.loc 1 242 0
 202 0100 3B68     		ldr	r3, [r7]
 203 0102 DB6A     		ldr	r3, [r3, #44]
 204 0104 5A1C     		add	r2, r3, #1
 205 0106 3B68     		ldr	r3, [r7]
 206 0108 DA62     		str	r2, [r3, #44]
 207 010a 2EE1     		b	.L8
 208              	.L7:
 243:../Generated_Code/I2C0.c ****       } else {
 244:../Generated_Code/I2C0.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 209              		.loc 1 244 0
 210 010c 3B68     		ldr	r3, [r7]
 211 010e 1B78     		ldrb	r3, [r3]
 212 0110 1A1C     		mov	r2, r3
 213 0112 0223     		mov	r3, #2
 214 0114 1340     		and	r3, r2
 215 0116 00D1     		bne	.LCB157
 216 0118 8CE0     		b	.L9	@long jump
 217              	.LCB157:
 245:../Generated_Code/I2C0.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 218              		.loc 1 245 0
 219 011a 3B68     		ldr	r3, [r7]
 220 011c 1B8B     		ldrh	r3, [r3, #24]
 221 011e 002B     		cmp	r3, #0
 222 0120 19D0     		beq	.L10
 246:../Generated_Code/I2C0.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 223              		.loc 1 246 0
 224 0122 3B68     		ldr	r3, [r7]
 225 0124 1B8B     		ldrh	r3, [r3, #24]
 226 0126 013B     		sub	r3, r3, #1
 227 0128 9AB2     		uxth	r2, r3
 228 012a 3B68     		ldr	r3, [r7]
 229 012c 1A83     		strh	r2, [r3, #24]
 247:../Generated_Code/I2C0.c ****             DeviceDataPrv->OutByteMNum++;
 230              		.loc 1 247 0
 231 012e 3B68     		ldr	r3, [r7]
 232 0130 5B8B     		ldrh	r3, [r3, #26]
 233 0132 0133     		add	r3, r3, #1
 234 0134 9AB2     		uxth	r2, r3
 235 0136 3B68     		ldr	r3, [r7]
 236 0138 5A83     		strh	r2, [r3, #26]
 248:../Generated_Code/I2C0.c ****             I2C_PDD_WriteDataReg(I2C0_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 237              		.loc 1 248 0
 238 013a 774A     		ldr	r2, .L20+4
 239 013c 3B68     		ldr	r3, [r7]
 240 013e DB69     		ldr	r3, [r3, #28]
 241 0140 1978     		ldrb	r1, [r3]
 242 0142 1171     		strb	r1, [r2, #4]
 243 0144 5A1C     		add	r2, r3, #1
 244 0146 3B68     		ldr	r3, [r7]
 245 0148 DA61     		str	r2, [r3, #28]
 249:../Generated_Code/I2C0.c ****             DeviceDataPrv->Stats.MasterSentChars++; /* Increment MasterSentChars counter */
 246              		.loc 1 249 0
 247 014a 3B68     		ldr	r3, [r7]
 248 014c 5B6A     		ldr	r3, [r3, #36]
 249 014e 5A1C     		add	r2, r3, #1
 250 0150 3B68     		ldr	r3, [r7]
 251 0152 5A62     		str	r2, [r3, #36]
 252 0154 09E1     		b	.L8
 253              	.L10:
 250:../Generated_Code/I2C0.c ****           } else {
 251:../Generated_Code/I2C0.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 254              		.loc 1 251 0
 255 0156 3B68     		ldr	r3, [r7]
 256 0158 DB89     		ldrh	r3, [r3, #14]
 257 015a 002B     		cmp	r3, #0
 258 015c 3CD0     		beq	.L11
 252:../Generated_Code/I2C0.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 259              		.loc 1 252 0
 260 015e 3B68     		ldr	r3, [r7]
 261 0160 1B78     		ldrb	r3, [r3]
 262 0162 1A1C     		mov	r2, r3
 263 0164 0423     		mov	r3, #4
 264 0166 1340     		and	r3, r2
 265 0168 1FD0     		beq	.L12
 253:../Generated_Code/I2C0.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 266              		.loc 1 253 0
 267 016a 3B68     		ldr	r3, [r7]
 268 016c DB89     		ldrh	r3, [r3, #14]
 269 016e 012B     		cmp	r3, #1
 270 0170 08D1     		bne	.L13
 254:../Generated_Code/I2C0.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* then transmit A
 271              		.loc 1 254 0
 272 0172 694B     		ldr	r3, .L20+4
 273 0174 684A     		ldr	r2, .L20+4
 274 0176 9278     		ldrb	r2, [r2, #2]
 275 0178 D2B2     		uxtb	r2, r2
 276 017a 0821     		mov	r1, #8
 277 017c 0A43     		orr	r2, r1
 278 017e D2B2     		uxtb	r2, r2
 279 0180 9A70     		strb	r2, [r3, #2]
 280 0182 07E0     		b	.L14
 281              	.L13:
 255:../Generated_Code/I2C0.c ****                 } else {
 256:../Generated_Code/I2C0.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* else transmit AC
 282              		.loc 1 256 0
 283 0184 644B     		ldr	r3, .L20+4
 284 0186 644A     		ldr	r2, .L20+4
 285 0188 9278     		ldrb	r2, [r2, #2]
 286 018a D2B2     		uxtb	r2, r2
 287 018c 0821     		mov	r1, #8
 288 018e 8A43     		bic	r2, r1
 289 0190 D2B2     		uxtb	r2, r2
 290 0192 9A70     		strb	r2, [r3, #2]
 291              	.L14:
 257:../Generated_Code/I2C0.c ****                 }
 258:../Generated_Code/I2C0.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 292              		.loc 1 258 0
 293 0194 604B     		ldr	r3, .L20+4
 294 0196 604A     		ldr	r2, .L20+4
 295 0198 9278     		ldrb	r2, [r2, #2]
 296 019a D2B2     		uxtb	r2, r2
 297 019c 1021     		mov	r1, #16
 298 019e 8A43     		bic	r2, r1
 299 01a0 D2B2     		uxtb	r2, r2
 300 01a2 9A70     		strb	r2, [r3, #2]
 259:../Generated_Code/I2C0.c ****                 (void)I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Dummy read character */
 301              		.loc 1 259 0
 302 01a4 5C4B     		ldr	r3, .L20+4
 303 01a6 1B79     		ldrb	r3, [r3, #4]
 304 01a8 DFE0     		b	.L8
 305              	.L12:
 260:../Generated_Code/I2C0.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 261:../Generated_Code/I2C0.c ****                 I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* Repeat start cycle generated */
 306              		.loc 1 261 0
 307 01aa 5B4B     		ldr	r3, .L20+4
 308 01ac 5A4A     		ldr	r2, .L20+4
 309 01ae 9278     		ldrb	r2, [r2, #2]
 310 01b0 D2B2     		uxtb	r2, r2
 311 01b2 0421     		mov	r1, #4
 312 01b4 0A43     		orr	r2, r1
 313 01b6 D2B2     		uxtb	r2, r2
 314 01b8 9A70     		strb	r2, [r3, #2]
 262:../Generated_Code/I2C0.c ****                 I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 315              		.loc 1 262 0
 316 01ba 574B     		ldr	r3, .L20+4
 317 01bc 3A68     		ldr	r2, [r7]
 318 01be 527B     		ldrb	r2, [r2, #13]
 319 01c0 0121     		mov	r1, #1
 320 01c2 0A43     		orr	r2, r1
 321 01c4 D2B2     		uxtb	r2, r2
 322 01c6 1A71     		strb	r2, [r3, #4]
 263:../Generated_Code/I2C0.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 323              		.loc 1 263 0
 324 01c8 3B68     		ldr	r3, [r7]
 325 01ca 1B78     		ldrb	r3, [r3]
 326 01cc 0422     		mov	r2, #4
 327 01ce 1343     		orr	r3, r2
 328 01d0 DAB2     		uxtb	r2, r3
 329 01d2 3B68     		ldr	r3, [r7]
 330 01d4 1A70     		strb	r2, [r3]
 331 01d6 C8E0     		b	.L8
 332              	.L11:
 264:../Generated_Code/I2C0.c ****               }
 265:../Generated_Code/I2C0.c ****             } else {
 266:../Generated_Code/I2C0.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 333              		.loc 1 266 0
 334 01d8 3B68     		ldr	r3, [r7]
 335 01da 1B78     		ldrb	r3, [r3]
 336 01dc 0122     		mov	r2, #1
 337 01de 9343     		bic	r3, r2
 338 01e0 DAB2     		uxtb	r2, r3
 339 01e2 3B68     		ldr	r3, [r7]
 340 01e4 1A70     		strb	r2, [r3]
 267:../Generated_Code/I2C0.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 341              		.loc 1 267 0
 342 01e6 3B68     		ldr	r3, [r7]
 343 01e8 9B78     		ldrb	r3, [r3, #2]
 344 01ea 012B     		cmp	r3, #1
 345 01ec 0FD1     		bne	.L15
 268:../Generated_Code/I2C0.c ****                 I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 346              		.loc 1 268 0
 347 01ee 4A4B     		ldr	r3, .L20+4
 348 01f0 494A     		ldr	r2, .L20+4
 349 01f2 9278     		ldrb	r2, [r2, #2]
 350 01f4 D2B2     		uxtb	r2, r2
 351 01f6 2021     		mov	r1, #32
 352 01f8 8A43     		bic	r2, r1
 353 01fa D2B2     		uxtb	r2, r2
 354 01fc 9A70     		strb	r2, [r3, #2]
 269:../Generated_Code/I2C0.c ****                 I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 355              		.loc 1 269 0
 356 01fe 464B     		ldr	r3, .L20+4
 357 0200 454A     		ldr	r2, .L20+4
 358 0202 9278     		ldrb	r2, [r2, #2]
 359 0204 D2B2     		uxtb	r2, r2
 360 0206 1021     		mov	r1, #16
 361 0208 8A43     		bic	r2, r1
 362 020a D2B2     		uxtb	r2, r2
 363 020c 9A70     		strb	r2, [r3, #2]
 364              	.L15:
 270:../Generated_Code/I2C0.c ****               }
 271:../Generated_Code/I2C0.c ****               DeviceDataPrv->StatusFlag |= MASTER_BLOCK_SENT; /* Set data block sent flag */
 365              		.loc 1 271 0
 366 020e 3B68     		ldr	r3, [r7]
 367 0210 5B78     		ldrb	r3, [r3, #1]
 368 0212 0122     		mov	r2, #1
 369 0214 1343     		orr	r3, r2
 370 0216 DAB2     		uxtb	r2, r3
 371 0218 3B68     		ldr	r3, [r7]
 372 021a 5A70     		strb	r2, [r3, #1]
 272:../Generated_Code/I2C0.c ****               if ((DeviceDataPrv->EventMask & LDD_I2C_ON_MASTER_BLOCK_SENT) != 0x00U) {
 373              		.loc 1 272 0
 374 021c 3B68     		ldr	r3, [r7]
 375 021e 9A68     		ldr	r2, [r3, #8]
 376 0220 0123     		mov	r3, #1
 377 0222 1340     		and	r3, r2
 378 0224 00D1     		bne	.LCB309
 379 0226 A0E0     		b	.L8	@long jump
 380              	.LCB309:
 273:../Generated_Code/I2C0.c ****                 I2C0_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event 
 381              		.loc 1 273 0
 382 0228 3B68     		ldr	r3, [r7]
 383 022a 1B6A     		ldr	r3, [r3, #32]
 384 022c 181C     		mov	r0, r3
 385 022e FFF7FEFF 		bl	_Z22I2C0_OnMasterBlockSentPv
 386 0232 9AE0     		b	.L8
 387              	.L9:
 274:../Generated_Code/I2C0.c ****               }
 275:../Generated_Code/I2C0.c ****             }
 276:../Generated_Code/I2C0.c ****           }
 277:../Generated_Code/I2C0.c ****         } else {
 278:../Generated_Code/I2C0.c ****           I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 388              		.loc 1 278 0
 389 0234 384B     		ldr	r3, .L20+4
 390 0236 3A68     		ldr	r2, [r7]
 391 0238 127B     		ldrb	r2, [r2, #12]
 392 023a 1A71     		strb	r2, [r3, #4]
 279:../Generated_Code/I2C0.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 393              		.loc 1 279 0
 394 023c 3B68     		ldr	r3, [r7]
 395 023e 1B78     		ldrb	r3, [r3]
 396 0240 0222     		mov	r2, #2
 397 0242 1343     		orr	r3, r2
 398 0244 DAB2     		uxtb	r2, r3
 399 0246 3B68     		ldr	r3, [r7]
 400 0248 1A70     		strb	r2, [r3]
 401 024a 8EE0     		b	.L8
 402              	.L6:
 280:../Generated_Code/I2C0.c ****         }
 281:../Generated_Code/I2C0.c ****       }
 282:../Generated_Code/I2C0.c ****     } else {
 283:../Generated_Code/I2C0.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 403              		.loc 1 283 0
 404 024c 3B68     		ldr	r3, [r7]
 405 024e DB89     		ldrh	r3, [r3, #14]
 406 0250 013B     		sub	r3, r3, #1
 407 0252 9AB2     		uxth	r2, r3
 408 0254 3B68     		ldr	r3, [r7]
 409 0256 DA81     		strh	r2, [r3, #14]
 284:../Generated_Code/I2C0.c ****       DeviceDataPrv->InpByteMNum++;
 410              		.loc 1 284 0
 411 0258 3B68     		ldr	r3, [r7]
 412 025a 1B8A     		ldrh	r3, [r3, #16]
 413 025c 0133     		add	r3, r3, #1
 414 025e 9AB2     		uxth	r2, r3
 415 0260 3B68     		ldr	r3, [r7]
 416 0262 1A82     		strh	r2, [r3, #16]
 285:../Generated_Code/I2C0.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 417              		.loc 1 285 0
 418 0264 3B68     		ldr	r3, [r7]
 419 0266 DB89     		ldrh	r3, [r3, #14]
 420 0268 002B     		cmp	r3, #0
 421 026a 0CD0     		beq	.L16
 286:../Generated_Code/I2C0.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 422              		.loc 1 286 0
 423 026c 3B68     		ldr	r3, [r7]
 424 026e DB89     		ldrh	r3, [r3, #14]
 425 0270 012B     		cmp	r3, #1
 426 0272 1FD1     		bne	.L17
 287:../Generated_Code/I2C0.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 427              		.loc 1 287 0
 428 0274 284B     		ldr	r3, .L20+4
 429 0276 284A     		ldr	r2, .L20+4
 430 0278 9278     		ldrb	r2, [r2, #2]
 431 027a D2B2     		uxtb	r2, r2
 432 027c 0821     		mov	r1, #8
 433 027e 0A43     		orr	r2, r1
 434 0280 D2B2     		uxtb	r2, r2
 435 0282 9A70     		strb	r2, [r3, #2]
 436 0284 16E0     		b	.L17
 437              	.L16:
 288:../Generated_Code/I2C0.c ****         }
 289:../Generated_Code/I2C0.c ****       } else {
 290:../Generated_Code/I2C0.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 438              		.loc 1 290 0
 439 0286 3B68     		ldr	r3, [r7]
 440 0288 1B78     		ldrb	r3, [r3]
 441 028a 0122     		mov	r2, #1
 442 028c 9343     		bic	r3, r2
 443 028e DAB2     		uxtb	r2, r3
 444 0290 3B68     		ldr	r3, [r7]
 445 0292 1A70     		strb	r2, [r3]
 291:../Generated_Code/I2C0.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 446              		.loc 1 291 0
 447 0294 204B     		ldr	r3, .L20+4
 448 0296 204A     		ldr	r2, .L20+4
 449 0298 9278     		ldrb	r2, [r2, #2]
 450 029a D2B2     		uxtb	r2, r2
 451 029c 2021     		mov	r1, #32
 452 029e 8A43     		bic	r2, r1
 453 02a0 D2B2     		uxtb	r2, r2
 454 02a2 9A70     		strb	r2, [r3, #2]
 292:../Generated_Code/I2C0.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 455              		.loc 1 292 0
 456 02a4 1C4B     		ldr	r3, .L20+4
 457 02a6 1C4A     		ldr	r2, .L20+4
 458 02a8 9278     		ldrb	r2, [r2, #2]
 459 02aa D2B2     		uxtb	r2, r2
 460 02ac 0821     		mov	r1, #8
 461 02ae 8A43     		bic	r2, r1
 462 02b0 D2B2     		uxtb	r2, r2
 463 02b2 9A70     		strb	r2, [r3, #2]
 464              	.L17:
 293:../Generated_Code/I2C0.c ****       }
 294:../Generated_Code/I2C0.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Receive character */
 465              		.loc 1 294 0
 466 02b4 3B68     		ldr	r3, [r7]
 467 02b6 5B69     		ldr	r3, [r3, #20]
 468 02b8 174A     		ldr	r2, .L20+4
 469 02ba 1279     		ldrb	r2, [r2, #4]
 470 02bc D2B2     		uxtb	r2, r2
 471 02be 1A70     		strb	r2, [r3]
 472 02c0 5A1C     		add	r2, r3, #1
 473 02c2 3B68     		ldr	r3, [r7]
 474 02c4 5A61     		str	r2, [r3, #20]
 295:../Generated_Code/I2C0.c ****       DeviceDataPrv->Stats.MasterReceivedChars++; /* Increment MasterReceivedChars counter */
 475              		.loc 1 295 0
 476 02c6 3B68     		ldr	r3, [r7]
 477 02c8 9B6A     		ldr	r3, [r3, #40]
 478 02ca 5A1C     		add	r2, r3, #1
 479 02cc 3B68     		ldr	r3, [r7]
 480 02ce 9A62     		str	r2, [r3, #40]
 296:../Generated_Code/I2C0.c ****       if ((DeviceDataPrv->EventMask & LDD_I2C_ON_MASTER_BYTE_RECEIVED) != 0x00U) {
 481              		.loc 1 296 0
 482 02d0 3B68     		ldr	r3, [r7]
 483 02d2 9A68     		ldr	r2, [r3, #8]
 484 02d4 8023     		mov	r3, #128
 485 02d6 DB00     		lsl	r3, r3, #3
 486 02d8 1340     		and	r3, r2
 487 02da 04D0     		beq	.L18
 297:../Generated_Code/I2C0.c ****         I2C0_OnMasterByteReceived(DeviceDataPrv->UserData); /* Invoke OnMasterByteReceived event */
 488              		.loc 1 297 0
 489 02dc 3B68     		ldr	r3, [r7]
 490 02de 1B6A     		ldr	r3, [r3, #32]
 491 02e0 181C     		mov	r0, r3
 492 02e2 FFF7FEFF 		bl	_Z25I2C0_OnMasterByteReceivedPv
 493              	.L18:
 298:../Generated_Code/I2C0.c ****       }
 299:../Generated_Code/I2C0.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 494              		.loc 1 299 0
 495 02e6 3B68     		ldr	r3, [r7]
 496 02e8 DB89     		ldrh	r3, [r3, #14]
 497 02ea 002B     		cmp	r3, #0
 498 02ec 3DD1     		bne	.L8
 300:../Generated_Code/I2C0.c ****         DeviceDataPrv->StatusFlag |= MASTER_BLOCK_RECEIVED; /* Set data block received flag */
 499              		.loc 1 300 0
 500 02ee 3B68     		ldr	r3, [r7]
 501 02f0 5B78     		ldrb	r3, [r3, #1]
 502 02f2 0222     		mov	r2, #2
 503 02f4 1343     		orr	r3, r2
 504 02f6 DAB2     		uxtb	r2, r3
 505 02f8 3B68     		ldr	r3, [r7]
 506 02fa 5A70     		strb	r2, [r3, #1]
 301:../Generated_Code/I2C0.c ****         if ((DeviceDataPrv->EventMask & LDD_I2C_ON_MASTER_BLOCK_RECEIVED) != 0x00U) {
 507              		.loc 1 301 0
 508 02fc 3B68     		ldr	r3, [r7]
 509 02fe 9A68     		ldr	r2, [r3, #8]
 510 0300 0223     		mov	r3, #2
 511 0302 1340     		and	r3, r2
 512 0304 31D0     		beq	.L8
 302:../Generated_Code/I2C0.c ****           I2C0_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived even
 513              		.loc 1 302 0
 514 0306 3B68     		ldr	r3, [r7]
 515 0308 1B6A     		ldr	r3, [r3, #32]
 516 030a 181C     		mov	r0, r3
 517 030c FFF7FEFF 		bl	_Z26I2C0_OnMasterBlockReceivedPv
 518 0310 2BE0     		b	.L8
 519              	.L21:
 520 0312 C046     		.align	2
 521              	.L20:
 522 0314 00000000 		.word	_ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM
 523 0318 00600640 		.word	1074159616
 524              	.L5:
 303:../Generated_Code/I2C0.c ****         }
 304:../Generated_Code/I2C0.c ****       }
 305:../Generated_Code/I2C0.c ****     }
 306:../Generated_Code/I2C0.c ****   } else {
 307:../Generated_Code/I2C0.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 525              		.loc 1 307 0
 526 031c 221C     		mov	r2, r4
 527 031e 1023     		mov	r3, #16
 528 0320 1340     		and	r3, r2
 529 0322 22D0     		beq	.L8
 308:../Generated_Code/I2C0.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 530              		.loc 1 308 0
 531 0324 3B68     		ldr	r3, [r7]
 532 0326 0022     		mov	r2, #0
 533 0328 1A83     		strh	r2, [r3, #24]
 309:../Generated_Code/I2C0.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 534              		.loc 1 309 0
 535 032a 3B68     		ldr	r3, [r7]
 536 032c 0022     		mov	r2, #0
 537 032e DA81     		strh	r2, [r3, #14]
 310:../Generated_Code/I2C0.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 538              		.loc 1 310 0
 539 0330 3B68     		ldr	r3, [r7]
 540 0332 0122     		mov	r2, #1
 541 0334 9A70     		strb	r2, [r3, #2]
 311:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 542              		.loc 1 311 0
 543 0336 3B68     		ldr	r3, [r7]
 544 0338 1B78     		ldrb	r3, [r3]
 545 033a 0122     		mov	r2, #1
 546 033c 9343     		bic	r3, r2
 547 033e DAB2     		uxtb	r2, r3
 548 0340 3B68     		ldr	r3, [r7]
 549 0342 1A70     		strb	r2, [r3]
 312:../Generated_Code/I2C0.c ****       I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 550              		.loc 1 312 0
 551 0344 164B     		ldr	r3, .L22
 552 0346 164A     		ldr	r2, .L22
 553 0348 9278     		ldrb	r2, [r2, #2]
 554 034a D2B2     		uxtb	r2, r2
 555 034c 1021     		mov	r1, #16
 556 034e 8A43     		bic	r2, r1
 557 0350 D2B2     		uxtb	r2, r2
 558 0352 9A70     		strb	r2, [r3, #2]
 313:../Generated_Code/I2C0.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 559              		.loc 1 313 0
 560 0354 BB1D     		add	r3, r7, #6
 561 0356 BA1D     		add	r2, r7, #6
 562 0358 1288     		ldrh	r2, [r2]
 563 035a 0421     		mov	r1, #4
 564 035c 0A43     		orr	r2, r1
 565 035e 1A80     		strh	r2, [r3]
 314:../Generated_Code/I2C0.c ****       DeviceDataPrv->Stats.ArbitLost++; /* Increment ArbitLost counter */
 566              		.loc 1 314 0
 567 0360 3B68     		ldr	r3, [r7]
 568 0362 1B6B     		ldr	r3, [r3, #48]
 569 0364 5A1C     		add	r2, r3, #1
 570 0366 3B68     		ldr	r3, [r7]
 571 0368 1A63     		str	r2, [r3, #48]
 572              	.L8:
 315:../Generated_Code/I2C0.c ****     }
 316:../Generated_Code/I2C0.c ****   }
 317:../Generated_Code/I2C0.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 573              		.loc 1 317 0
 574 036a BB1D     		add	r3, r7, #6
 575 036c 1B88     		ldrh	r3, [r3]
 576 036e 002B     		cmp	r3, #0
 577 0370 13D0     		beq	.L1
 318:../Generated_Code/I2C0.c ****     DeviceDataPrv->ErrorMask |= ErrorMask; /* Update list of error mask value */
 578              		.loc 1 318 0
 579 0372 3B68     		ldr	r3, [r7]
 580 0374 9A88     		ldrh	r2, [r3, #4]
 581 0376 BB1D     		add	r3, r7, #6
 582 0378 1B88     		ldrh	r3, [r3]
 583 037a 1343     		orr	r3, r2
 584 037c 9AB2     		uxth	r2, r3
 585 037e 3B68     		ldr	r3, [r7]
 586 0380 9A80     		strh	r2, [r3, #4]
 319:../Generated_Code/I2C0.c ****     if ((DeviceDataPrv->EventMask & LDD_I2C_ON_ERROR) != 0x00U) { /* Is enabled call OnError? */
 587              		.loc 1 319 0
 588 0382 3B68     		ldr	r3, [r7]
 589 0384 9A68     		ldr	r2, [r3, #8]
 590 0386 4023     		mov	r3, #64
 591 0388 1340     		and	r3, r2
 592 038a 06D0     		beq	.L1
 320:../Generated_Code/I2C0.c ****       I2C0_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 593              		.loc 1 320 0
 594 038c 3B68     		ldr	r3, [r7]
 595 038e 1B6A     		ldr	r3, [r3, #32]
 596 0390 181C     		mov	r0, r3
 597 0392 FFF7FEFF 		bl	_Z12I2C0_OnErrorPv
 598 0396 00E0     		b	.L1
 599              	.L19:
 228:../Generated_Code/I2C0.c ****     return;
 600              		.loc 1 228 0
 601 0398 C046     		mov	r8, r8
 602              	.L1:
 603              	.LBE2:
 321:../Generated_Code/I2C0.c ****     }
 322:../Generated_Code/I2C0.c ****   }
 323:../Generated_Code/I2C0.c **** }
 604              		.loc 1 323 0
 605 039a BD46     		mov	sp, r7
 606 039c 03B0     		add	sp, sp, #12
 607              		@ sp needed for prologue
 608 039e 90BD     		pop	{r4, r7, pc}
 609              	.L23:
 610              		.align	2
 611              	.L22:
 612 03a0 00600640 		.word	1074159616
 613              		.cfi_endproc
 614              	.LFE5:
 616              		.section	.text.I2C0_Init,"ax",%progbits
 617              		.align	2
 618              		.global	I2C0_Init
 619              		.code	16
 620              		.thumb_func
 622              	I2C0_Init:
 623              	.LFB6:
 324:../Generated_Code/I2C0.c **** 
 325:../Generated_Code/I2C0.c **** /*
 326:../Generated_Code/I2C0.c **** ** ===================================================================
 327:../Generated_Code/I2C0.c **** **     Method      :  I2C0_Init (component I2C_LDD)
 328:../Generated_Code/I2C0.c **** */
 329:../Generated_Code/I2C0.c **** /*!
 330:../Generated_Code/I2C0.c **** **     @brief
 331:../Generated_Code/I2C0.c **** **         Initializes the device. Allocates memory for the device data
 332:../Generated_Code/I2C0.c **** **         structure, allocates interrupt vectors and sets interrupt
 333:../Generated_Code/I2C0.c **** **         priority, sets pin routing, sets timing, etc.
 334:../Generated_Code/I2C0.c **** **         If the "Enable in init. code" is set to "yes" value then the
 335:../Generated_Code/I2C0.c **** **         device is also enabled(see the description of the Enable()
 336:../Generated_Code/I2C0.c **** **         method). In this case the Enable() method is not necessary
 337:../Generated_Code/I2C0.c **** **         and needn't to be generated. 
 338:../Generated_Code/I2C0.c **** **         This method can be called only once. Before the second call
 339:../Generated_Code/I2C0.c **** **         of Init() the Deinit() must be called first.
 340:../Generated_Code/I2C0.c **** **     @param
 341:../Generated_Code/I2C0.c **** **         UserDataPtr     - Pointer to the user or
 342:../Generated_Code/I2C0.c **** **                           RTOS specific data. This pointer will be
 343:../Generated_Code/I2C0.c **** **                           passed as an event or callback parameter.
 344:../Generated_Code/I2C0.c **** **     @return
 345:../Generated_Code/I2C0.c **** **                         - Pointer to the device data structure. 
 346:../Generated_Code/I2C0.c **** */
 347:../Generated_Code/I2C0.c **** /* ===================================================================*/
 348:../Generated_Code/I2C0.c **** LDD_TDeviceData* I2C0_Init(LDD_TUserData *UserDataPtr)
 349:../Generated_Code/I2C0.c **** {
 624              		.loc 1 349 0
 625              		.cfi_startproc
 626 0000 80B5     		push	{r7, lr}
 627              	.LCFI3:
 628              		.cfi_def_cfa_offset 8
 629              		.cfi_offset 7, -8
 630              		.cfi_offset 14, -4
 631 0002 84B0     		sub	sp, sp, #16
 632              	.LCFI4:
 633              		.cfi_def_cfa_offset 24
 634 0004 00AF     		add	r7, sp, #0
 635              	.LCFI5:
 636              		.cfi_def_cfa_register 7
 637 0006 7860     		str	r0, [r7, #4]
 638              	.LBB3:
 350:../Generated_Code/I2C0.c ****   /* Allocate HAL device structure */
 351:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv;
 352:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer
 353:../Generated_Code/I2C0.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 639              		.loc 1 353 0
 640 0008 504B     		ldr	r3, .L26
 641 000a FB60     		str	r3, [r7, #12]
 354:../Generated_Code/I2C0.c **** 
 355:../Generated_Code/I2C0.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 642              		.loc 1 355 0
 643 000c FB68     		ldr	r3, [r7, #12]
 644 000e 7A68     		ldr	r2, [r7, #4]
 645 0010 1A62     		str	r2, [r3, #32]
 356:../Generated_Code/I2C0.c **** 
 357:../Generated_Code/I2C0.c ****   /* Clear the statistics structure */
 358:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.MasterSentChars = 0x00U;
 646              		.loc 1 358 0
 647 0012 FB68     		ldr	r3, [r7, #12]
 648 0014 0022     		mov	r2, #0
 649 0016 5A62     		str	r2, [r3, #36]
 359:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.MasterReceivedChars = 0x00U;
 650              		.loc 1 359 0
 651 0018 FB68     		ldr	r3, [r7, #12]
 652 001a 0022     		mov	r2, #0
 653 001c 9A62     		str	r2, [r3, #40]
 360:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.MasterNacks = 0x00U;
 654              		.loc 1 360 0
 655 001e FB68     		ldr	r3, [r7, #12]
 656 0020 0022     		mov	r2, #0
 657 0022 DA62     		str	r2, [r3, #44]
 361:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.ArbitLost = 0x00U;
 658              		.loc 1 361 0
 659 0024 FB68     		ldr	r3, [r7, #12]
 660 0026 0022     		mov	r2, #0
 661 0028 1A63     		str	r2, [r3, #48]
 362:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveSentChars = 0x00U;
 662              		.loc 1 362 0
 663 002a FB68     		ldr	r3, [r7, #12]
 664 002c 0022     		mov	r2, #0
 665 002e 5A63     		str	r2, [r3, #52]
 363:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveReceivedChars = 0x00U;
 666              		.loc 1 363 0
 667 0030 FB68     		ldr	r3, [r7, #12]
 668 0032 0022     		mov	r2, #0
 669 0034 9A63     		str	r2, [r3, #56]
 364:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveTxUnderrun = 0x00U;
 670              		.loc 1 364 0
 671 0036 FB68     		ldr	r3, [r7, #12]
 672 0038 0022     		mov	r2, #0
 673 003a DA63     		str	r2, [r3, #60]
 365:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveRxOverrun = 0x00U;
 674              		.loc 1 365 0
 675 003c FB68     		ldr	r3, [r7, #12]
 676 003e 0022     		mov	r2, #0
 677 0040 1A64     		str	r2, [r3, #64]
 366:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveGeneralCallAddr = 0x00U;
 678              		.loc 1 366 0
 679 0042 FB68     		ldr	r3, [r7, #12]
 680 0044 0022     		mov	r2, #0
 681 0046 5A64     		str	r2, [r3, #68]
 367:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveSmBusCallAddr = 0x00U;
 682              		.loc 1 367 0
 683 0048 FB68     		ldr	r3, [r7, #12]
 684 004a 0022     		mov	r2, #0
 685 004c 9A64     		str	r2, [r3, #72]
 368:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SlaveSmBusAlertResponse = 0x00U;
 686              		.loc 1 368 0
 687 004e FB68     		ldr	r3, [r7, #12]
 688 0050 0022     		mov	r2, #0
 689 0052 DA64     		str	r2, [r3, #76]
 369:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SCLLowTimeout = 0x00U;
 690              		.loc 1 369 0
 691 0054 FB68     		ldr	r3, [r7, #12]
 692 0056 0022     		mov	r2, #0
 693 0058 1A65     		str	r2, [r3, #80]
 370:../Generated_Code/I2C0.c ****   DeviceDataPrv->Stats.SDALowTimeout = 0x00U;
 694              		.loc 1 370 0
 695 005a FB68     		ldr	r3, [r7, #12]
 696 005c 0022     		mov	r2, #0
 697 005e 5A65     		str	r2, [r3, #84]
 371:../Generated_Code/I2C0.c **** 
 372:../Generated_Code/I2C0.c ****   /* Allocate interrupt vector */
 373:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the gl
 374:../Generated_Code/I2C0.c ****   INT_I2C0__BAREBOARD_RTOS_ISRPARAM = DeviceDataPrv;
 698              		.loc 1 374 0
 699 0060 3B4B     		ldr	r3, .L26+4
 700 0062 FA68     		ldr	r2, [r7, #12]
 701 0064 1A60     		str	r2, [r3]
 375:../Generated_Code/I2C0.c ****   DeviceDataPrv->SerFlag = ADDR_10;    /* Reset all flags start with 10-bit address mode */
 702              		.loc 1 375 0
 703 0066 FB68     		ldr	r3, [r7, #12]
 704 0068 1022     		mov	r2, #16
 705 006a 1A70     		strb	r2, [r3]
 376:../Generated_Code/I2C0.c ****   DeviceDataPrv->EventMask = (LDD_TEventMask)(LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOC
 706              		.loc 1 376 0
 707 006c FB68     		ldr	r3, [r7, #12]
 708 006e 394A     		ldr	r2, .L26+8
 709 0070 9A60     		str	r2, [r3, #8]
 377:../Generated_Code/I2C0.c ****   DeviceDataPrv->EnUser = TRUE;        /* Enable device */
 710              		.loc 1 377 0
 711 0072 FB68     		ldr	r3, [r7, #12]
 712 0074 0122     		mov	r2, #1
 713 0076 DA70     		strb	r2, [r3, #3]
 378:../Generated_Code/I2C0.c ****   DeviceDataPrv->SlaveAddr = 0x1DU;    /* Set variable for slave address */
 714              		.loc 1 378 0
 715 0078 FB68     		ldr	r3, [r7, #12]
 716 007a 1D22     		mov	r2, #29
 717 007c 1A73     		strb	r2, [r3, #12]
 379:../Generated_Code/I2C0.c ****   DeviceDataPrv->SlaveAddrHigh = 0xF0U; /* Set variable for slave address - high byte */
 718              		.loc 1 379 0
 719 007e FB68     		ldr	r3, [r7, #12]
 720 0080 F022     		mov	r2, #240
 721 0082 5A73     		strb	r2, [r3, #13]
 380:../Generated_Code/I2C0.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 722              		.loc 1 380 0
 723 0084 FB68     		ldr	r3, [r7, #12]
 724 0086 0122     		mov	r2, #1
 725 0088 9A70     		strb	r2, [r3, #2]
 381:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpByteMNum = 0x00U;  /* Set zero number of input bufer's content */
 726              		.loc 1 381 0
 727 008a FB68     		ldr	r3, [r7, #12]
 728 008c 0022     		mov	r2, #0
 729 008e 1A82     		strh	r2, [r3, #16]
 382:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 730              		.loc 1 382 0
 731 0090 FB68     		ldr	r3, [r7, #12]
 732 0092 0022     		mov	r2, #0
 733 0094 DA81     		strh	r2, [r3, #14]
 383:../Generated_Code/I2C0.c ****   DeviceDataPrv->OutByteMNum = 0x00U;  /* Set zero length of output bufer's content */
 734              		.loc 1 383 0
 735 0096 FB68     		ldr	r3, [r7, #12]
 736 0098 0022     		mov	r2, #0
 737 009a 5A83     		strh	r2, [r3, #26]
 384:../Generated_Code/I2C0.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 738              		.loc 1 384 0
 739 009c FB68     		ldr	r3, [r7, #12]
 740 009e 0022     		mov	r2, #0
 741 00a0 1A83     		strh	r2, [r3, #24]
 385:../Generated_Code/I2C0.c ****   DeviceDataPrv->StatusFlag = 0x00U;   /* Clear data block transfer complete flags */
 742              		.loc 1 385 0
 743 00a2 FB68     		ldr	r3, [r7, #12]
 744 00a4 0022     		mov	r2, #0
 745 00a6 5A70     		strb	r2, [r3, #1]
 386:../Generated_Code/I2C0.c ****   DeviceDataPrv->ErrorMask = 0x00U;    /* Clear variable for errors mask value */
 746              		.loc 1 386 0
 747 00a8 FB68     		ldr	r3, [r7, #12]
 748 00aa 0022     		mov	r2, #0
 749 00ac 9A80     		strh	r2, [r3, #4]
 387:../Generated_Code/I2C0.c ****   /* SIM_SCGC4: I2C0=1 */
 388:../Generated_Code/I2C0.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;                                   
 750              		.loc 1 388 0
 751 00ae 2A4A     		ldr	r2, .L26+12
 752 00b0 2949     		ldr	r1, .L26+12
 753 00b2 2A4B     		ldr	r3, .L26+16
 754 00b4 CB58     		ldr	r3, [r1, r3]
 755 00b6 4021     		mov	r1, #64
 756 00b8 1943     		orr	r1, r3
 757 00ba 284B     		ldr	r3, .L26+16
 758 00bc D150     		str	r1, [r2, r3]
 389:../Generated_Code/I2C0.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 390:../Generated_Code/I2C0.c ****   I2C0_C1 = 0x00U;                     /* Clear control register */
 759              		.loc 1 390 0
 760 00be 284B     		ldr	r3, .L26+20
 761 00c0 0022     		mov	r2, #0
 762 00c2 9A70     		strb	r2, [r3, #2]
 391:../Generated_Code/I2C0.c ****   /* I2C0_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 392:../Generated_Code/I2C0.c ****   I2C0_FLT = (I2C_FLT_STOPF_MASK | I2C_FLT_FLT(0x00)); /* Clear bus status interrupt flags */
 763              		.loc 1 392 0
 764 00c4 264B     		ldr	r3, .L26+20
 765 00c6 4022     		mov	r2, #64
 766 00c8 9A71     		strb	r2, [r3, #6]
 393:../Generated_Code/I2C0.c ****   /* I2C0_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 394:../Generated_Code/I2C0.c ****   I2C0_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 767              		.loc 1 394 0
 768 00ca 254B     		ldr	r3, .L26+20
 769 00cc 0222     		mov	r2, #2
 770 00ce DA70     		strb	r2, [r3, #3]
 395:../Generated_Code/I2C0.c ****   /* PORTE_PCR25: ISF=0,MUX=5 */
 396:../Generated_Code/I2C0.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 771              		.loc 1 396 0
 772 00d0 244B     		ldr	r3, .L26+24
 397:../Generated_Code/I2C0.c ****                  PORT_PCR_ISF_MASK |
 398:../Generated_Code/I2C0.c ****                  PORT_PCR_MUX(0x02)
 399:../Generated_Code/I2C0.c ****                 )) | (uint32_t)(
 400:../Generated_Code/I2C0.c ****                  PORT_PCR_MUX(0x05)
 401:../Generated_Code/I2C0.c ****                 ));                                  
 773              		.loc 1 401 0
 774 00d2 244A     		ldr	r2, .L26+24
 396:../Generated_Code/I2C0.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 775              		.loc 1 396 0
 776 00d4 516E     		ldr	r1, [r2, #100]
 777              		.loc 1 401 0
 778 00d6 244A     		ldr	r2, .L26+28
 779 00d8 0A40     		and	r2, r1
 780 00da A021     		mov	r1, #160
 781 00dc C900     		lsl	r1, r1, #3
 782 00de 0A43     		orr	r2, r1
 783 00e0 5A66     		str	r2, [r3, #100]
 402:../Generated_Code/I2C0.c ****   /* PORTE_PCR24: ISF=0,MUX=5 */
 403:../Generated_Code/I2C0.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 784              		.loc 1 403 0
 785 00e2 204B     		ldr	r3, .L26+24
 404:../Generated_Code/I2C0.c ****                  PORT_PCR_ISF_MASK |
 405:../Generated_Code/I2C0.c ****                  PORT_PCR_MUX(0x02)
 406:../Generated_Code/I2C0.c ****                 )) | (uint32_t)(
 407:../Generated_Code/I2C0.c ****                  PORT_PCR_MUX(0x05)
 408:../Generated_Code/I2C0.c ****                 ));                                  
 786              		.loc 1 408 0
 787 00e4 1F4A     		ldr	r2, .L26+24
 403:../Generated_Code/I2C0.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 788              		.loc 1 403 0
 789 00e6 116E     		ldr	r1, [r2, #96]
 790              		.loc 1 408 0
 791 00e8 1F4A     		ldr	r2, .L26+28
 792 00ea 0A40     		and	r2, r1
 793 00ec A021     		mov	r1, #160
 794 00ee C900     		lsl	r1, r1, #3
 795 00f0 0A43     		orr	r2, r1
 796 00f2 1A66     		str	r2, [r3, #96]
 409:../Generated_Code/I2C0.c ****   /* NVIC_IPR2: PRI_8=0x80 */
 410:../Generated_Code/I2C0.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 797              		.loc 1 410 0
 798 00f4 1D4A     		ldr	r2, .L26+32
 411:../Generated_Code/I2C0.c ****                NVIC_IP_PRI_8(0x7F)
 412:../Generated_Code/I2C0.c ****               )) | (uint32_t)(
 413:../Generated_Code/I2C0.c ****                NVIC_IP_PRI_8(0x80)
 414:../Generated_Code/I2C0.c ****               ));                                  
 799              		.loc 1 414 0
 800 00f6 1D49     		ldr	r1, .L26+32
 410:../Generated_Code/I2C0.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 801              		.loc 1 410 0
 802 00f8 C223     		mov	r3, #194
 803 00fa 9B00     		lsl	r3, r3, #2
 804 00fc CB58     		ldr	r3, [r1, r3]
 805              		.loc 1 414 0
 806 00fe FF21     		mov	r1, #255
 807 0100 8B43     		bic	r3, r1
 808 0102 8021     		mov	r1, #128
 809 0104 1943     		orr	r1, r3
 810 0106 C223     		mov	r3, #194
 811 0108 9B00     		lsl	r3, r3, #2
 812 010a D150     		str	r1, [r2, r3]
 415:../Generated_Code/I2C0.c ****   /* NVIC_ISER: SETENA|=0x0100 */
 416:../Generated_Code/I2C0.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0100);                                   
 813              		.loc 1 416 0
 814 010c 174B     		ldr	r3, .L26+32
 815 010e 174A     		ldr	r2, .L26+32
 816 0110 1268     		ldr	r2, [r2]
 817 0112 8021     		mov	r1, #128
 818 0114 4900     		lsl	r1, r1, #1
 819 0116 0A43     		orr	r2, r1
 820 0118 1A60     		str	r2, [r3]
 417:../Generated_Code/I2C0.c ****   /* I2C0_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 418:../Generated_Code/I2C0.c ****   I2C0_C2 = I2C_C2_AD(0x00);                                   
 821              		.loc 1 418 0
 822 011a 114B     		ldr	r3, .L26+20
 823 011c 0022     		mov	r2, #0
 824 011e 5A71     		strb	r2, [r3, #5]
 419:../Generated_Code/I2C0.c ****   /* I2C0_FLT: SHEN=0,STOPF=0,STOPIE=1,FLT=0 */
 420:../Generated_Code/I2C0.c ****   I2C0_FLT = (I2C_FLT_STOPIE_MASK | I2C_FLT_FLT(0x00)); /* Set glitch filter register */
 825              		.loc 1 420 0
 826 0120 0F4B     		ldr	r3, .L26+20
 827 0122 2022     		mov	r2, #32
 828 0124 9A71     		strb	r2, [r3, #6]
 421:../Generated_Code/I2C0.c ****   /* I2C0_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 422:../Generated_Code/I2C0.c ****   I2C0_SMB = I2C_SMB_SLTF_MASK;                                   
 829              		.loc 1 422 0
 830 0126 0E4B     		ldr	r3, .L26+20
 831 0128 0822     		mov	r2, #8
 832 012a 1A72     		strb	r2, [r3, #8]
 423:../Generated_Code/I2C0.c ****   /* I2C0_F: MULT=0,ICR=0x1F */
 424:../Generated_Code/I2C0.c ****   I2C0_F = (I2C_F_MULT(0x00) | I2C_F_ICR(0x1F)); /* Set prescaler bits */
 833              		.loc 1 424 0
 834 012c 0C4B     		ldr	r3, .L26+20
 835 012e 1F22     		mov	r2, #31
 836 0130 5A70     		strb	r2, [r3, #1]
 425:../Generated_Code/I2C0.c ****   HWEnDi(DeviceDataPrv);               /* Enable/disable device according to status flags */
 837              		.loc 1 425 0
 838 0132 FB68     		ldr	r3, [r7, #12]
 839 0134 181C     		mov	r0, r3
 840 0136 FFF7FEFF 		bl	HWEnDi
 426:../Generated_Code/I2C0.c ****   /* Registration of the device structure */
 427:../Generated_Code/I2C0.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_I2C0_ID,DeviceDataPrv);
 841              		.loc 1 427 0
 842 013a 0D4B     		ldr	r3, .L26+36
 843 013c FA68     		ldr	r2, [r7, #12]
 844 013e 1A60     		str	r2, [r3]
 428:../Generated_Code/I2C0.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 845              		.loc 1 428 0
 846 0140 FB68     		ldr	r3, [r7, #12]
 847              	.LBE3:
 429:../Generated_Code/I2C0.c **** }
 848              		.loc 1 429 0
 849 0142 181C     		mov	r0, r3
 850 0144 BD46     		mov	sp, r7
 851 0146 04B0     		add	sp, sp, #16
 852              		@ sp needed for prologue
 853 0148 80BD     		pop	{r7, pc}
 854              	.L27:
 855 014a C046     		.align	2
 856              	.L26:
 857 014c 00000000 		.word	_ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC
 858 0150 00000000 		.word	_ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM
 859 0154 43240000 		.word	9283
 860 0158 00700440 		.word	1074032640
 861 015c 34100000 		.word	4148
 862 0160 00600640 		.word	1074159616
 863 0164 00D00440 		.word	1074057216
 864 0168 FFF8FFFE 		.word	-16779009
 865 016c 00E100E0 		.word	-536813312
 866 0170 00000000 		.word	PE_LDD_DeviceDataList
 867              		.cfi_endproc
 868              	.LFE6:
 870              		.section	.text.I2C0_Deinit,"ax",%progbits
 871              		.align	2
 872              		.global	I2C0_Deinit
 873              		.code	16
 874              		.thumb_func
 876              	I2C0_Deinit:
 877              	.LFB7:
 430:../Generated_Code/I2C0.c **** 
 431:../Generated_Code/I2C0.c **** /*
 432:../Generated_Code/I2C0.c **** ** ===================================================================
 433:../Generated_Code/I2C0.c **** **     Method      :  I2C0_Deinit (component I2C_LDD)
 434:../Generated_Code/I2C0.c **** */
 435:../Generated_Code/I2C0.c **** /*!
 436:../Generated_Code/I2C0.c **** **     @brief
 437:../Generated_Code/I2C0.c **** **         Deinitializes the device. Switches off the device, frees the
 438:../Generated_Code/I2C0.c **** **         device data structure memory, interrupts vectors, etc.
 439:../Generated_Code/I2C0.c **** **     @param
 440:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 441:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 442:../Generated_Code/I2C0.c **** */
 443:../Generated_Code/I2C0.c **** /* ===================================================================*/
 444:../Generated_Code/I2C0.c **** void I2C0_Deinit(LDD_TDeviceData *DeviceDataPtr)
 445:../Generated_Code/I2C0.c **** {
 878              		.loc 1 445 0
 879              		.cfi_startproc
 880 0000 80B5     		push	{r7, lr}
 881              	.LCFI6:
 882              		.cfi_def_cfa_offset 8
 883              		.cfi_offset 7, -8
 884              		.cfi_offset 14, -4
 885 0002 82B0     		sub	sp, sp, #8
 886              	.LCFI7:
 887              		.cfi_def_cfa_offset 16
 888 0004 00AF     		add	r7, sp, #0
 889              	.LCFI8:
 890              		.cfi_def_cfa_register 7
 891 0006 7860     		str	r0, [r7, #4]
 446:../Generated_Code/I2C0.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 447:../Generated_Code/I2C0.c **** 
 448:../Generated_Code/I2C0.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 449:../Generated_Code/I2C0.c ****   I2C0_C1 = 0x00U;                     /* Reset I2C Control register */
 892              		.loc 1 449 0
 893 0008 094B     		ldr	r3, .L29
 894 000a 0022     		mov	r2, #0
 895 000c 9A70     		strb	r2, [r3, #2]
 450:../Generated_Code/I2C0.c ****   /* Restoring the interrupt vector */
 451:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 452:../Generated_Code/I2C0.c ****   /* Unregistration of the device structure */
 453:../Generated_Code/I2C0.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_I2C0_ID);
 896              		.loc 1 453 0
 897 000e 094B     		ldr	r3, .L29+4
 898 0010 0022     		mov	r2, #0
 899 0012 1A60     		str	r2, [r3]
 454:../Generated_Code/I2C0.c ****   /* Deallocation of the device structure */
 455:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallo
 456:../Generated_Code/I2C0.c ****   /* SIM_SCGC4: I2C0=0 */
 457:../Generated_Code/I2C0.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C0_MASK);                                   
 900              		.loc 1 457 0
 901 0014 084A     		ldr	r2, .L29+8
 902 0016 0849     		ldr	r1, .L29+8
 903 0018 084B     		ldr	r3, .L29+12
 904 001a CB58     		ldr	r3, [r1, r3]
 905 001c 4021     		mov	r1, #64
 906 001e 181C     		mov	r0, r3
 907 0020 8843     		bic	r0, r1
 908 0022 011C     		mov	r1, r0
 909 0024 054B     		ldr	r3, .L29+12
 910 0026 D150     		str	r1, [r2, r3]
 458:../Generated_Code/I2C0.c **** }
 911              		.loc 1 458 0
 912 0028 BD46     		mov	sp, r7
 913 002a 02B0     		add	sp, sp, #8
 914              		@ sp needed for prologue
 915 002c 80BD     		pop	{r7, pc}
 916              	.L30:
 917 002e C046     		.align	2
 918              	.L29:
 919 0030 00600640 		.word	1074159616
 920 0034 00000000 		.word	PE_LDD_DeviceDataList
 921 0038 00700440 		.word	1074032640
 922 003c 34100000 		.word	4148
 923              		.cfi_endproc
 924              	.LFE7:
 926              		.section	.text.I2C0_Enable,"ax",%progbits
 927              		.align	2
 928              		.global	I2C0_Enable
 929              		.code	16
 930              		.thumb_func
 932              	I2C0_Enable:
 933              	.LFB8:
 459:../Generated_Code/I2C0.c **** 
 460:../Generated_Code/I2C0.c **** /*
 461:../Generated_Code/I2C0.c **** ** ===================================================================
 462:../Generated_Code/I2C0.c **** **     Method      :  I2C0_Enable (component I2C_LDD)
 463:../Generated_Code/I2C0.c **** */
 464:../Generated_Code/I2C0.c **** /*!
 465:../Generated_Code/I2C0.c **** **     @brief
 466:../Generated_Code/I2C0.c **** **         Enables I2C component. Events may be generated
 467:../Generated_Code/I2C0.c **** **         ("DisableEvent"/"EnableEvent").
 468:../Generated_Code/I2C0.c **** **     @param
 469:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 470:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 471:../Generated_Code/I2C0.c **** **     @return
 472:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 473:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 474:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 475:../Generated_Code/I2C0.c **** **                           the active clock configuration
 476:../Generated_Code/I2C0.c **** */
 477:../Generated_Code/I2C0.c **** /* ===================================================================*/
 478:../Generated_Code/I2C0.c **** LDD_TError I2C0_Enable(LDD_TDeviceData *DeviceDataPtr)
 479:../Generated_Code/I2C0.c **** {
 934              		.loc 1 479 0
 935              		.cfi_startproc
 936 0000 80B5     		push	{r7, lr}
 937              	.LCFI9:
 938              		.cfi_def_cfa_offset 8
 939              		.cfi_offset 7, -8
 940              		.cfi_offset 14, -4
 941 0002 84B0     		sub	sp, sp, #16
 942              	.LCFI10:
 943              		.cfi_def_cfa_offset 24
 944 0004 00AF     		add	r7, sp, #0
 945              	.LCFI11:
 946              		.cfi_def_cfa_register 7
 947 0006 7860     		str	r0, [r7, #4]
 948              	.LBB4:
 480:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 949              		.loc 1 480 0
 950 0008 7B68     		ldr	r3, [r7, #4]
 951 000a FB60     		str	r3, [r7, #12]
 481:../Generated_Code/I2C0.c **** 
 482:../Generated_Code/I2C0.c ****   if (!DeviceDataPrv->EnUser) {        /* Is the device disabled by user? */
 952              		.loc 1 482 0
 953 000c FB68     		ldr	r3, [r7, #12]
 954 000e DB78     		ldrb	r3, [r3, #3]
 955 0010 0122     		mov	r2, #1
 956 0012 5340     		eor	r3, r2
 957 0014 DBB2     		uxtb	r3, r3
 958 0016 002B     		cmp	r3, #0
 959 0018 0DD0     		beq	.L32
 483:../Generated_Code/I2C0.c ****     DeviceDataPrv->EnUser = TRUE;      /* If yes then set the flag "device enabled" */
 960              		.loc 1 483 0
 961 001a FB68     		ldr	r3, [r7, #12]
 962 001c 0122     		mov	r2, #1
 963 001e DA70     		strb	r2, [r3, #3]
 484:../Generated_Code/I2C0.c ****     DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear the status variable */
 964              		.loc 1 484 0
 965 0020 FB68     		ldr	r3, [r7, #12]
 966 0022 1B78     		ldrb	r3, [r3]
 967 0024 0122     		mov	r2, #1
 968 0026 9343     		bic	r3, r2
 969 0028 DAB2     		uxtb	r2, r3
 970 002a FB68     		ldr	r3, [r7, #12]
 971 002c 1A70     		strb	r2, [r3]
 485:../Generated_Code/I2C0.c ****     HWEnDi(DeviceDataPrv);             /* Enable the device */
 972              		.loc 1 485 0
 973 002e FB68     		ldr	r3, [r7, #12]
 974 0030 181C     		mov	r0, r3
 975 0032 FFF7FEFF 		bl	HWEnDi
 976              	.L32:
 486:../Generated_Code/I2C0.c ****   }
 487:../Generated_Code/I2C0.c ****   return ERR_OK;
 977              		.loc 1 487 0
 978 0036 0023     		mov	r3, #0
 979              	.LBE4:
 488:../Generated_Code/I2C0.c **** }
 980              		.loc 1 488 0
 981 0038 181C     		mov	r0, r3
 982 003a BD46     		mov	sp, r7
 983 003c 04B0     		add	sp, sp, #16
 984              		@ sp needed for prologue
 985 003e 80BD     		pop	{r7, pc}
 986              		.cfi_endproc
 987              	.LFE8:
 989              		.section	.text.I2C0_Disable,"ax",%progbits
 990              		.align	2
 991              		.global	I2C0_Disable
 992              		.code	16
 993              		.thumb_func
 995              	I2C0_Disable:
 996              	.LFB9:
 489:../Generated_Code/I2C0.c **** 
 490:../Generated_Code/I2C0.c **** /*
 491:../Generated_Code/I2C0.c **** ** ===================================================================
 492:../Generated_Code/I2C0.c **** **     Method      :  I2C0_Disable (component I2C_LDD)
 493:../Generated_Code/I2C0.c **** */
 494:../Generated_Code/I2C0.c **** /*!
 495:../Generated_Code/I2C0.c **** **     @brief
 496:../Generated_Code/I2C0.c **** **         Disables I2C component. No events will be generated.
 497:../Generated_Code/I2C0.c **** **     @param
 498:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 499:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 500:../Generated_Code/I2C0.c **** **     @return
 501:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 502:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 503:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 504:../Generated_Code/I2C0.c **** **                           the active clock configuration
 505:../Generated_Code/I2C0.c **** */
 506:../Generated_Code/I2C0.c **** /* ===================================================================*/
 507:../Generated_Code/I2C0.c **** LDD_TError I2C0_Disable(LDD_TDeviceData *DeviceDataPtr)
 508:../Generated_Code/I2C0.c **** {
 997              		.loc 1 508 0
 998              		.cfi_startproc
 999 0000 80B5     		push	{r7, lr}
 1000              	.LCFI12:
 1001              		.cfi_def_cfa_offset 8
 1002              		.cfi_offset 7, -8
 1003              		.cfi_offset 14, -4
 1004 0002 84B0     		sub	sp, sp, #16
 1005              	.LCFI13:
 1006              		.cfi_def_cfa_offset 24
 1007 0004 00AF     		add	r7, sp, #0
 1008              	.LCFI14:
 1009              		.cfi_def_cfa_register 7
 1010 0006 7860     		str	r0, [r7, #4]
 1011              	.LBB5:
 509:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1012              		.loc 1 509 0
 1013 0008 7B68     		ldr	r3, [r7, #4]
 1014 000a FB60     		str	r3, [r7, #12]
 510:../Generated_Code/I2C0.c **** 
 511:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->EnUser) {         /* Is the device enabled by user? */
 1015              		.loc 1 511 0
 1016 000c FB68     		ldr	r3, [r7, #12]
 1017 000e DB78     		ldrb	r3, [r3, #3]
 1018 0010 002B     		cmp	r3, #0
 1019 0012 06D0     		beq	.L35
 512:../Generated_Code/I2C0.c ****     DeviceDataPrv->EnUser = FALSE;     /* If yes then set the flag "device disabled" */
 1020              		.loc 1 512 0
 1021 0014 FB68     		ldr	r3, [r7, #12]
 1022 0016 0022     		mov	r2, #0
 1023 0018 DA70     		strb	r2, [r3, #3]
 513:../Generated_Code/I2C0.c ****     HWEnDi(DeviceDataPrv);             /* Disable the device */
 1024              		.loc 1 513 0
 1025 001a FB68     		ldr	r3, [r7, #12]
 1026 001c 181C     		mov	r0, r3
 1027 001e FFF7FEFF 		bl	HWEnDi
 1028              	.L35:
 514:../Generated_Code/I2C0.c ****   }
 515:../Generated_Code/I2C0.c ****   return ERR_OK;                       /* OK */
 1029              		.loc 1 515 0
 1030 0022 0023     		mov	r3, #0
 1031              	.LBE5:
 516:../Generated_Code/I2C0.c **** }
 1032              		.loc 1 516 0
 1033 0024 181C     		mov	r0, r3
 1034 0026 BD46     		mov	sp, r7
 1035 0028 04B0     		add	sp, sp, #16
 1036              		@ sp needed for prologue
 1037 002a 80BD     		pop	{r7, pc}
 1038              		.cfi_endproc
 1039              	.LFE9:
 1041              		.section	.text.I2C0_SetEventMask,"ax",%progbits
 1042              		.align	2
 1043              		.global	I2C0_SetEventMask
 1044              		.code	16
 1045              		.thumb_func
 1047              	I2C0_SetEventMask:
 1048              	.LFB10:
 517:../Generated_Code/I2C0.c **** 
 518:../Generated_Code/I2C0.c **** /*
 519:../Generated_Code/I2C0.c **** ** ===================================================================
 520:../Generated_Code/I2C0.c **** **     Method      :  I2C0_SetEventMask (component I2C_LDD)
 521:../Generated_Code/I2C0.c **** */
 522:../Generated_Code/I2C0.c **** /*!
 523:../Generated_Code/I2C0.c **** **     @brief
 524:../Generated_Code/I2C0.c **** **         Enables/Disables events. This method is available if at
 525:../Generated_Code/I2C0.c **** **         least one event is enabled. Pair method to GetEventMask().
 526:../Generated_Code/I2C0.c **** **     @param
 527:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 528:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 529:../Generated_Code/I2C0.c **** **     @param
 530:../Generated_Code/I2C0.c **** **         EventMask       - Event mask, e.g.
 531:../Generated_Code/I2C0.c **** **                           LDD_I2C_ON_MASTER_BLOCK_SENT.
 532:../Generated_Code/I2C0.c **** **     @return
 533:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 534:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 535:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
 536:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 537:../Generated_Code/I2C0.c **** **                           the active clock configuration
 538:../Generated_Code/I2C0.c **** **                           ERR_PARAM_MASK - Event mask not valid
 539:../Generated_Code/I2C0.c **** */
 540:../Generated_Code/I2C0.c **** /* ===================================================================*/
 541:../Generated_Code/I2C0.c **** LDD_TError I2C0_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)
 542:../Generated_Code/I2C0.c **** {
 1049              		.loc 1 542 0
 1050              		.cfi_startproc
 1051 0000 80B5     		push	{r7, lr}
 1052              	.LCFI15:
 1053              		.cfi_def_cfa_offset 8
 1054              		.cfi_offset 7, -8
 1055              		.cfi_offset 14, -4
 1056 0002 84B0     		sub	sp, sp, #16
 1057              	.LCFI16:
 1058              		.cfi_def_cfa_offset 24
 1059 0004 00AF     		add	r7, sp, #0
 1060              	.LCFI17:
 1061              		.cfi_def_cfa_register 7
 1062 0006 7860     		str	r0, [r7, #4]
 1063 0008 3960     		str	r1, [r7]
 1064              	.LBB6:
 543:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1065              		.loc 1 543 0
 1066 000a 7B68     		ldr	r3, [r7, #4]
 1067 000c FB60     		str	r3, [r7, #12]
 544:../Generated_Code/I2C0.c **** 
 545:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 546:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
 547:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 1068              		.loc 1 547 0
 1069 000e FB68     		ldr	r3, [r7, #12]
 1070 0010 DB78     		ldrb	r3, [r3, #3]
 1071 0012 0122     		mov	r2, #1
 1072 0014 5340     		eor	r3, r2
 1073 0016 DBB2     		uxtb	r3, r3
 1074 0018 002B     		cmp	r3, #0
 1075 001a 01D0     		beq	.L38
 548:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 1076              		.loc 1 548 0
 1077 001c 0723     		mov	r3, #7
 1078 001e 09E0     		b	.L39
 1079              	.L38:
 549:../Generated_Code/I2C0.c ****   }
 550:../Generated_Code/I2C0.c ****   if ((EventMask & (LDD_TEventMask)~((LDD_TEventMask)AVAILABLE_EVENTS_MASK)) != 0x00U) { /* Is the 
 1080              		.loc 1 550 0
 1081 0020 3A68     		ldr	r2, [r7]
 1082 0022 064B     		ldr	r3, .L41
 1083 0024 1340     		and	r3, r2
 1084 0026 01D0     		beq	.L40
 551:../Generated_Code/I2C0.c ****     return ERR_PARAM_MASK;             /* If no then error. */
 1085              		.loc 1 551 0
 1086 0028 8023     		mov	r3, #128
 1087 002a 03E0     		b	.L39
 1088              	.L40:
 552:../Generated_Code/I2C0.c ****   }
 553:../Generated_Code/I2C0.c ****   DeviceDataPrv->EventMask = EventMask;
 1089              		.loc 1 553 0
 1090 002c FB68     		ldr	r3, [r7, #12]
 1091 002e 3A68     		ldr	r2, [r7]
 1092 0030 9A60     		str	r2, [r3, #8]
 554:../Generated_Code/I2C0.c ****   return ERR_OK;
 1093              		.loc 1 554 0
 1094 0032 0023     		mov	r3, #0
 1095              	.L39:
 1096              	.LBE6:
 555:../Generated_Code/I2C0.c **** }
 1097              		.loc 1 555 0
 1098 0034 181C     		mov	r0, r3
 1099 0036 BD46     		mov	sp, r7
 1100 0038 04B0     		add	sp, sp, #16
 1101              		@ sp needed for prologue
 1102 003a 80BD     		pop	{r7, pc}
 1103              	.L42:
 1104              		.align	2
 1105              	.L41:
 1106 003c BCDBFFFF 		.word	-9284
 1107              		.cfi_endproc
 1108              	.LFE10:
 1110              		.section	.text.I2C0_GetEventMask,"ax",%progbits
 1111              		.align	2
 1112              		.global	I2C0_GetEventMask
 1113              		.code	16
 1114              		.thumb_func
 1116              	I2C0_GetEventMask:
 1117              	.LFB11:
 556:../Generated_Code/I2C0.c **** 
 557:../Generated_Code/I2C0.c **** /*
 558:../Generated_Code/I2C0.c **** ** ===================================================================
 559:../Generated_Code/I2C0.c **** **     Method      :  I2C0_GetEventMask (component I2C_LDD)
 560:../Generated_Code/I2C0.c **** */
 561:../Generated_Code/I2C0.c **** /*!
 562:../Generated_Code/I2C0.c **** **     @brief
 563:../Generated_Code/I2C0.c **** **         Returns current event mask, e.g.
 564:../Generated_Code/I2C0.c **** **         LDD_I2C_ON_MASTER_BLOCK_SENT. This method is available if at
 565:../Generated_Code/I2C0.c **** **         least one event is enabled.
 566:../Generated_Code/I2C0.c **** **     @param
 567:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 568:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 569:../Generated_Code/I2C0.c **** **     @return
 570:../Generated_Code/I2C0.c **** **                         - Current event mask.
 571:../Generated_Code/I2C0.c **** */
 572:../Generated_Code/I2C0.c **** /* ===================================================================*/
 573:../Generated_Code/I2C0.c **** LDD_TEventMask I2C0_GetEventMask(LDD_TDeviceData *DeviceDataPtr)
 574:../Generated_Code/I2C0.c **** {
 1118              		.loc 1 574 0
 1119              		.cfi_startproc
 1120 0000 80B5     		push	{r7, lr}
 1121              	.LCFI18:
 1122              		.cfi_def_cfa_offset 8
 1123              		.cfi_offset 7, -8
 1124              		.cfi_offset 14, -4
 1125 0002 84B0     		sub	sp, sp, #16
 1126              	.LCFI19:
 1127              		.cfi_def_cfa_offset 24
 1128 0004 00AF     		add	r7, sp, #0
 1129              	.LCFI20:
 1130              		.cfi_def_cfa_register 7
 1131 0006 7860     		str	r0, [r7, #4]
 1132              	.LBB7:
 575:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1133              		.loc 1 575 0
 1134 0008 7B68     		ldr	r3, [r7, #4]
 1135 000a FB60     		str	r3, [r7, #12]
 576:../Generated_Code/I2C0.c **** 
 577:../Generated_Code/I2C0.c ****   return ((LDD_TEventMask)(DeviceDataPrv->EventMask & AVAILABLE_EVENTS_MASK));
 1136              		.loc 1 577 0
 1137 000c FB68     		ldr	r3, [r7, #12]
 1138 000e 9A68     		ldr	r2, [r3, #8]
 1139 0010 024B     		ldr	r3, .L45
 1140 0012 1340     		and	r3, r2
 1141              	.LBE7:
 578:../Generated_Code/I2C0.c **** }
 1142              		.loc 1 578 0
 1143 0014 181C     		mov	r0, r3
 1144 0016 BD46     		mov	sp, r7
 1145 0018 04B0     		add	sp, sp, #16
 1146              		@ sp needed for prologue
 1147 001a 80BD     		pop	{r7, pc}
 1148              	.L46:
 1149              		.align	2
 1150              	.L45:
 1151 001c 43240000 		.word	9283
 1152              		.cfi_endproc
 1153              	.LFE11:
 1155              		.section	.text.I2C0_MasterSendBlock,"ax",%progbits
 1156              		.align	2
 1157              		.global	I2C0_MasterSendBlock
 1158              		.code	16
 1159              		.thumb_func
 1161              	I2C0_MasterSendBlock:
 1162              	.LFB12:
 579:../Generated_Code/I2C0.c **** 
 580:../Generated_Code/I2C0.c **** /*
 581:../Generated_Code/I2C0.c **** ** ===================================================================
 582:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterSendBlock (component I2C_LDD)
 583:../Generated_Code/I2C0.c **** */
 584:../Generated_Code/I2C0.c **** /*!
 585:../Generated_Code/I2C0.c **** **     @brief
 586:../Generated_Code/I2C0.c **** **         This method writes one (7-bit addressing) or two (10-bit
 587:../Generated_Code/I2C0.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 588:../Generated_Code/I2C0.c **** **         the I2C bus and then writes the block of characters to the
 589:../Generated_Code/I2C0.c **** **         bus. The slave address must be specified before, by the
 590:../Generated_Code/I2C0.c **** **         "SelectSlaveDevice" method or in component initialization
 591:../Generated_Code/I2C0.c **** **         section, "Target slave address init" property. If the method
 592:../Generated_Code/I2C0.c **** **         returns ERR_OK, it doesn't mean that transmission was
 593:../Generated_Code/I2C0.c **** **         successful. The state of transmission is detectable by means
 594:../Generated_Code/I2C0.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 595:../Generated_Code/I2C0.c **** **         are not copied to an internal buffer and remains in the
 596:../Generated_Code/I2C0.c **** **         original location. Therefore the content of the buffer
 597:../Generated_Code/I2C0.c **** **         should not be changed until the transmission is complete.
 598:../Generated_Code/I2C0.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 599:../Generated_Code/I2C0.c **** **         the transmission. This method is available only for the
 600:../Generated_Code/I2C0.c **** **         MASTER or MASTER - SLAVE mode.
 601:../Generated_Code/I2C0.c **** **     @param
 602:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 603:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 604:../Generated_Code/I2C0.c **** **     @param
 605:../Generated_Code/I2C0.c **** **         BufferPtr       - Pointer to the block of data
 606:../Generated_Code/I2C0.c **** **                           to send.
 607:../Generated_Code/I2C0.c **** **     @param
 608:../Generated_Code/I2C0.c **** **         Size            - Size of the data block.
 609:../Generated_Code/I2C0.c **** **     @param
 610:../Generated_Code/I2C0.c **** **         SendStop        - Parameter for generating I2C
 611:../Generated_Code/I2C0.c **** **                           Stop condition
 612:../Generated_Code/I2C0.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 613:../Generated_Code/I2C0.c **** **                           generated on end transmission.
 614:../Generated_Code/I2C0.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 615:../Generated_Code/I2C0.c **** **                           generated on end transmission.
 616:../Generated_Code/I2C0.c **** **     @return
 617:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 618:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 619:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
 620:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 621:../Generated_Code/I2C0.c **** **                           the active clock configuration
 622:../Generated_Code/I2C0.c **** **                           ERR_BUSY - The I2C device is now running
 623:../Generated_Code/I2C0.c **** */
 624:../Generated_Code/I2C0.c **** /* ===================================================================*/
 625:../Generated_Code/I2C0.c **** LDD_TError I2C0_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize
 626:../Generated_Code/I2C0.c **** {
 1163              		.loc 1 626 0
 1164              		.cfi_startproc
 1165 0000 80B5     		push	{r7, lr}
 1166              	.LCFI21:
 1167              		.cfi_def_cfa_offset 8
 1168              		.cfi_offset 7, -8
 1169              		.cfi_offset 14, -4
 1170 0002 86B0     		sub	sp, sp, #24
 1171              	.LCFI22:
 1172              		.cfi_def_cfa_offset 32
 1173 0004 00AF     		add	r7, sp, #0
 1174              	.LCFI23:
 1175              		.cfi_def_cfa_register 7
 1176 0006 F860     		str	r0, [r7, #12]
 1177 0008 B960     		str	r1, [r7, #8]
 1178 000a 111C     		mov	r1, r2
 1179 000c 1A1C     		mov	r2, r3
 1180 000e BB1D     		add	r3, r7, #6
 1181 0010 1980     		strh	r1, [r3]
 1182 0012 7B1D     		add	r3, r7, #5
 1183 0014 1A70     		strb	r2, [r3]
 1184              	.LBB8:
 627:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1185              		.loc 1 627 0
 1186 0016 FB68     		ldr	r3, [r7, #12]
 1187 0018 7B61     		str	r3, [r7, #20]
 628:../Generated_Code/I2C0.c **** 
 629:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 630:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
 631:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 1188              		.loc 1 631 0
 1189 001a 7B69     		ldr	r3, [r7, #20]
 1190 001c DB78     		ldrb	r3, [r3, #3]
 1191 001e 0122     		mov	r2, #1
 1192 0020 5340     		eor	r3, r2
 1193 0022 DBB2     		uxtb	r3, r3
 1194 0024 002B     		cmp	r3, #0
 1195 0026 01D0     		beq	.L48
 632:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 1196              		.loc 1 632 0
 1197 0028 0723     		mov	r3, #7
 1198 002a 9FE0     		b	.L49
 1199              	.L48:
 633:../Generated_Code/I2C0.c ****   }
 634:../Generated_Code/I2C0.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1200              		.loc 1 634 0
 1201 002c BB1D     		add	r3, r7, #6
 1202 002e 1B88     		ldrh	r3, [r3]
 1203 0030 002B     		cmp	r3, #0
 1204 0032 01D1     		bne	.L50
 635:../Generated_Code/I2C0.c ****     return ERR_OK;                     /* If zero then OK */
 1205              		.loc 1 635 0
 1206 0034 0023     		mov	r3, #0
 1207 0036 99E0     		b	.L49
 1208              	.L50:
 636:../Generated_Code/I2C0.c ****   }
 637:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1209              		.loc 1 637 0
 1210 0038 7B69     		ldr	r3, [r7, #20]
 1211 003a 9B78     		ldrb	r3, [r3, #2]
 1212 003c 012B     		cmp	r3, #1
 1213 003e 17D1     		bne	.L51
 638:../Generated_Code/I2C0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1214              		.loc 1 638 0
 1215 0040 4C4B     		ldr	r3, .L62
 1216 0042 DB78     		ldrb	r3, [r3, #3]
 1217 0044 DBB2     		uxtb	r3, r3
 1218 0046 1A1C     		mov	r2, r3
 1219 0048 2023     		mov	r3, #32
 1220 004a 1340     		and	r3, r2
 1221 004c 09D1     		bne	.L52
 1222              		.loc 1 638 0 is_stmt 0
 1223 004e 7B69     		ldr	r3, [r7, #20]
 1224 0050 1B78     		ldrb	r3, [r3]
 1225 0052 1A1C     		mov	r2, r3
 1226 0054 0123     		mov	r3, #1
 1227 0056 1340     		and	r3, r2
 1228 0058 03D1     		bne	.L52
 1229              		.loc 1 638 0
 1230 005a 7B69     		ldr	r3, [r7, #20]
 1231 005c 1B8B     		ldrh	r3, [r3, #24]
 1232 005e 002B     		cmp	r3, #0
 1233 0060 01D0     		beq	.L53
 1234              	.L52:
 1235              		.loc 1 638 0
 1236 0062 0123     		mov	r3, #1
 1237 0064 00E0     		b	.L54
 1238              	.L53:
 1239              		.loc 1 638 0
 1240 0066 0023     		mov	r3, #0
 1241              	.L54:
 1242              		.loc 1 638 0
 1243 0068 002B     		cmp	r3, #0
 1244 006a 0DD0     		beq	.L55
 639:../Generated_Code/I2C0.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 640:../Generated_Code/I2C0.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 641:../Generated_Code/I2C0.c ****       return ERR_BUSY;                 /* If yes then error */
 1245              		.loc 1 641 0 is_stmt 1
 1246 006c 0823     		mov	r3, #8
 1247 006e 7DE0     		b	.L49
 1248              	.L51:
 642:../Generated_Code/I2C0.c ****     }
 643:../Generated_Code/I2C0.c ****   } else {
 644:../Generated_Code/I2C0.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1249              		.loc 1 644 0
 1250 0070 7B69     		ldr	r3, [r7, #20]
 1251 0072 1B78     		ldrb	r3, [r3]
 1252 0074 1A1C     		mov	r2, r3
 1253 0076 0123     		mov	r3, #1
 1254 0078 1340     		and	r3, r2
 1255 007a 03D1     		bne	.L56
 1256              		.loc 1 644 0 is_stmt 0
 1257 007c 7B69     		ldr	r3, [r7, #20]
 1258 007e 1B8B     		ldrh	r3, [r3, #24]
 1259 0080 002B     		cmp	r3, #0
 1260 0082 01D0     		beq	.L55
 1261              	.L56:
 645:../Generated_Code/I2C0.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 646:../Generated_Code/I2C0.c ****       return ERR_BUSY;                 /* If yes then error */
 1262              		.loc 1 646 0 is_stmt 1
 1263 0084 0823     		mov	r3, #8
 1264 0086 71E0     		b	.L49
 1265              	.L55:
 647:../Generated_Code/I2C0.c ****     }
 648:../Generated_Code/I2C0.c ****   }
 649:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
 650:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 1266              		.loc 1 650 0
 1267 0088 FFF7FEFF 		bl	vPortEnterCritical
 651:../Generated_Code/I2C0.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1268              		.loc 1 651 0
 1269 008c 7B69     		ldr	r3, [r7, #20]
 1270 008e 1B78     		ldrb	r3, [r3]
 1271 0090 0122     		mov	r2, #1
 1272 0092 1343     		orr	r3, r2
 1273 0094 DAB2     		uxtb	r2, r3
 1274 0096 7B69     		ldr	r3, [r7, #20]
 1275 0098 1A70     		strb	r2, [r3]
 652:../Generated_Code/I2C0.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 1276              		.loc 1 652 0
 1277 009a 7B69     		ldr	r3, [r7, #20]
 1278 009c BA68     		ldr	r2, [r7, #8]
 1279 009e DA61     		str	r2, [r3, #28]
 653:../Generated_Code/I2C0.c ****   DeviceDataPrv->OutByteMNum = 0x00U;  /* Set data counter */
 1280              		.loc 1 653 0
 1281 00a0 7B69     		ldr	r3, [r7, #20]
 1282 00a2 0022     		mov	r2, #0
 1283 00a4 5A83     		strh	r2, [r3, #26]
 654:../Generated_Code/I2C0.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 1284              		.loc 1 654 0
 1285 00a6 7B69     		ldr	r3, [r7, #20]
 1286 00a8 BA1D     		add	r2, r7, #6
 1287 00aa 1288     		ldrh	r2, [r2]
 1288 00ac 1A83     		strh	r2, [r3, #24]
 655:../Generated_Code/I2C0.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1289              		.loc 1 655 0
 1290 00ae 7B69     		ldr	r3, [r7, #20]
 1291 00b0 7A1D     		add	r2, r7, #5
 1292 00b2 1278     		ldrb	r2, [r2]
 1293 00b4 9A70     		strb	r2, [r3, #2]
 656:../Generated_Code/I2C0.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1294              		.loc 1 656 0
 1295 00b6 2F4B     		ldr	r3, .L62
 1296 00b8 2E4A     		ldr	r2, .L62
 1297 00ba 9278     		ldrb	r2, [r2, #2]
 1298 00bc D2B2     		uxtb	r2, r2
 1299 00be 1021     		mov	r1, #16
 1300 00c0 0A43     		orr	r2, r1
 1301 00c2 D2B2     		uxtb	r2, r2
 1302 00c4 9A70     		strb	r2, [r3, #2]
 657:../Generated_Code/I2C0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1303              		.loc 1 657 0
 1304 00c6 2B4B     		ldr	r3, .L62
 1305 00c8 9B78     		ldrb	r3, [r3, #2]
 1306 00ca DBB2     		uxtb	r3, r3
 1307 00cc 1A1C     		mov	r2, r3
 1308 00ce 2023     		mov	r3, #32
 1309 00d0 1340     		and	r3, r2
 1310 00d2 5A1E     		sub	r2, r3, #1
 1311 00d4 9341     		sbc	r3, r3, r2
 1312 00d6 DBB2     		uxtb	r3, r3
 1313 00d8 002B     		cmp	r3, #0
 1314 00da 08D0     		beq	.L57
 658:../Generated_Code/I2C0.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 1315              		.loc 1 658 0
 1316 00dc 254B     		ldr	r3, .L62
 1317 00de 254A     		ldr	r2, .L62
 1318 00e0 9278     		ldrb	r2, [r2, #2]
 1319 00e2 D2B2     		uxtb	r2, r2
 1320 00e4 0421     		mov	r1, #4
 1321 00e6 0A43     		orr	r2, r1
 1322 00e8 D2B2     		uxtb	r2, r2
 1323 00ea 9A70     		strb	r2, [r3, #2]
 1324 00ec 07E0     		b	.L58
 1325              	.L57:
 659:../Generated_Code/I2C0.c ****   } else {
 660:../Generated_Code/I2C0.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1326              		.loc 1 660 0
 1327 00ee 214B     		ldr	r3, .L62
 1328 00f0 204A     		ldr	r2, .L62
 1329 00f2 9278     		ldrb	r2, [r2, #2]
 1330 00f4 D2B2     		uxtb	r2, r2
 1331 00f6 2021     		mov	r1, #32
 1332 00f8 0A43     		orr	r2, r1
 1333 00fa D2B2     		uxtb	r2, r2
 1334 00fc 9A70     		strb	r2, [r3, #2]
 1335              	.L58:
 661:../Generated_Code/I2C0.c ****   }
 662:../Generated_Code/I2C0.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1336              		.loc 1 662 0
 1337 00fe 7B69     		ldr	r3, [r7, #20]
 1338 0100 1B78     		ldrb	r3, [r3]
 1339 0102 1A1C     		mov	r2, r3
 1340 0104 2023     		mov	r3, #32
 1341 0106 1340     		and	r3, r2
 1342 0108 0BD0     		beq	.L59
 663:../Generated_Code/I2C0.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 1343              		.loc 1 663 0
 1344 010a 7B69     		ldr	r3, [r7, #20]
 1345 010c 1B78     		ldrb	r3, [r3]
 1346 010e 0622     		mov	r2, #6
 1347 0110 1343     		orr	r3, r2
 1348 0112 DAB2     		uxtb	r2, r3
 1349 0114 7B69     		ldr	r3, [r7, #20]
 1350 0116 1A70     		strb	r2, [r3]
 664:../Generated_Code/I2C0.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 1351              		.loc 1 664 0
 1352 0118 164B     		ldr	r3, .L62
 1353 011a 7A69     		ldr	r2, [r7, #20]
 1354 011c 127B     		ldrb	r2, [r2, #12]
 1355 011e 1A71     		strb	r2, [r3, #4]
 1356 0120 21E0     		b	.L60
 1357              	.L59:
 665:../Generated_Code/I2C0.c ****   } else {
 666:../Generated_Code/I2C0.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1358              		.loc 1 666 0
 1359 0122 7B69     		ldr	r3, [r7, #20]
 1360 0124 1B78     		ldrb	r3, [r3]
 1361 0126 1A1C     		mov	r2, r3
 1362 0128 1023     		mov	r3, #16
 1363 012a 1340     		and	r3, r2
 1364 012c 0BD0     		beq	.L61
 667:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1365              		.loc 1 667 0
 1366 012e 7B69     		ldr	r3, [r7, #20]
 1367 0130 1B78     		ldrb	r3, [r3]
 1368 0132 0622     		mov	r2, #6
 1369 0134 9343     		bic	r3, r2
 1370 0136 DAB2     		uxtb	r2, r3
 1371 0138 7B69     		ldr	r3, [r7, #20]
 1372 013a 1A70     		strb	r2, [r3]
 668:../Generated_Code/I2C0.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1373              		.loc 1 668 0
 1374 013c 0D4B     		ldr	r3, .L62
 1375 013e 7A69     		ldr	r2, [r7, #20]
 1376 0140 527B     		ldrb	r2, [r2, #13]
 1377 0142 1A71     		strb	r2, [r3, #4]
 1378 0144 0FE0     		b	.L60
 1379              	.L61:
 669:../Generated_Code/I2C0.c ****     } else {
 670:../Generated_Code/I2C0.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 1380              		.loc 1 670 0
 1381 0146 7B69     		ldr	r3, [r7, #20]
 1382 0148 1B78     		ldrb	r3, [r3]
 1383 014a 1A1C     		mov	r2, r3
 1384 014c 0823     		mov	r3, #8
 1385 014e 1340     		and	r3, r2
 1386 0150 09D0     		beq	.L60
 671:../Generated_Code/I2C0.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 1387              		.loc 1 671 0
 1388 0152 7B69     		ldr	r3, [r7, #20]
 1389 0154 1B78     		ldrb	r3, [r3]
 1390 0156 0222     		mov	r2, #2
 1391 0158 1343     		orr	r3, r2
 1392 015a DAB2     		uxtb	r2, r3
 1393 015c 7B69     		ldr	r3, [r7, #20]
 1394 015e 1A70     		strb	r2, [r3]
 672:../Generated_Code/I2C0.c ****         I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x00U); /* Send general call address */
 1395              		.loc 1 672 0
 1396 0160 044B     		ldr	r3, .L62
 1397 0162 0022     		mov	r2, #0
 1398 0164 1A71     		strb	r2, [r3, #4]
 1399              	.L60:
 673:../Generated_Code/I2C0.c ****       }
 674:../Generated_Code/I2C0.c ****     }
 675:../Generated_Code/I2C0.c ****   }
 676:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
 677:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 1400              		.loc 1 677 0
 1401 0166 FFF7FEFF 		bl	vPortExitCritical
 678:../Generated_Code/I2C0.c ****   return ERR_OK;                       /* OK */
 1402              		.loc 1 678 0
 1403 016a 0023     		mov	r3, #0
 1404              	.L49:
 1405              	.LBE8:
 679:../Generated_Code/I2C0.c **** }
 1406              		.loc 1 679 0
 1407 016c 181C     		mov	r0, r3
 1408 016e BD46     		mov	sp, r7
 1409 0170 06B0     		add	sp, sp, #24
 1410              		@ sp needed for prologue
 1411 0172 80BD     		pop	{r7, pc}
 1412              	.L63:
 1413              		.align	2
 1414              	.L62:
 1415 0174 00600640 		.word	1074159616
 1416              		.cfi_endproc
 1417              	.LFE12:
 1419              		.section	.text.I2C0_MasterGetBlockSentStatus,"ax",%progbits
 1420              		.align	2
 1421              		.global	I2C0_MasterGetBlockSentStatus
 1422              		.code	16
 1423              		.thumb_func
 1425              	I2C0_MasterGetBlockSentStatus:
 1426              	.LFB13:
 680:../Generated_Code/I2C0.c **** 
 681:../Generated_Code/I2C0.c **** /*
 682:../Generated_Code/I2C0.c **** ** ===================================================================
 683:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterGetBlockSentStatus (component I2C_LDD)
 684:../Generated_Code/I2C0.c **** */
 685:../Generated_Code/I2C0.c **** /*!
 686:../Generated_Code/I2C0.c **** **     @brief
 687:../Generated_Code/I2C0.c **** **         This method returns current state of MasterSendBlock method.
 688:../Generated_Code/I2C0.c **** **         This method is available only for the MASTER mode and if
 689:../Generated_Code/I2C0.c **** **         method MasterSendBlock is enabled.
 690:../Generated_Code/I2C0.c **** **     @param
 691:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 692:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 693:../Generated_Code/I2C0.c **** **     @return
 694:../Generated_Code/I2C0.c **** **                         - Return value:
 695:../Generated_Code/I2C0.c **** **                           <true> - data block is completely
 696:../Generated_Code/I2C0.c **** **                           transmitted.
 697:../Generated_Code/I2C0.c **** **                           <false> - data block isn't completely
 698:../Generated_Code/I2C0.c **** **                           transmitted.
 699:../Generated_Code/I2C0.c **** */
 700:../Generated_Code/I2C0.c **** /* ===================================================================*/
 701:../Generated_Code/I2C0.c **** bool I2C0_MasterGetBlockSentStatus(LDD_TDeviceData *DeviceDataPtr)
 702:../Generated_Code/I2C0.c **** {
 1427              		.loc 1 702 0
 1428              		.cfi_startproc
 1429 0000 80B5     		push	{r7, lr}
 1430              	.LCFI24:
 1431              		.cfi_def_cfa_offset 8
 1432              		.cfi_offset 7, -8
 1433              		.cfi_offset 14, -4
 1434 0002 84B0     		sub	sp, sp, #16
 1435              	.LCFI25:
 1436              		.cfi_def_cfa_offset 24
 1437 0004 00AF     		add	r7, sp, #0
 1438              	.LCFI26:
 1439              		.cfi_def_cfa_register 7
 1440 0006 7860     		str	r0, [r7, #4]
 1441              	.LBB9:
 703:../Generated_Code/I2C0.c ****   uint8_t Status;                      /* Temporary variable for flag saving */
 704:../Generated_Code/I2C0.c **** 
 705:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
 706:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 1442              		.loc 1 706 0
 1443 0008 FFF7FEFF 		bl	vPortEnterCritical
 707:../Generated_Code/I2C0.c ****   Status = ((I2C0_TDeviceDataPtr)DeviceDataPtr)->StatusFlag; /* Save flag for return */
 1444              		.loc 1 707 0
 1445 000c 3B1C     		mov	r3, r7
 1446 000e 0F33     		add	r3, r3, #15
 1447 0010 7A68     		ldr	r2, [r7, #4]
 1448 0012 5278     		ldrb	r2, [r2, #1]
 1449 0014 1A70     		strb	r2, [r3]
 708:../Generated_Code/I2C0.c ****   ((I2C0_TDeviceDataPtr)DeviceDataPtr)->StatusFlag &= (uint8_t)(~(uint8_t)MASTER_BLOCK_SENT); /* Cl
 1450              		.loc 1 708 0
 1451 0016 7B68     		ldr	r3, [r7, #4]
 1452 0018 5B78     		ldrb	r3, [r3, #1]
 1453 001a 0122     		mov	r2, #1
 1454 001c 9343     		bic	r3, r2
 1455 001e DAB2     		uxtb	r2, r3
 1456 0020 7B68     		ldr	r3, [r7, #4]
 1457 0022 5A70     		strb	r2, [r3, #1]
 709:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
 710:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 1458              		.loc 1 710 0
 1459 0024 FFF7FEFF 		bl	vPortExitCritical
 711:../Generated_Code/I2C0.c ****   return (bool)(((Status & MASTER_BLOCK_SENT) != 0x00U)? TRUE : FALSE); /* Return saved status */
 1460              		.loc 1 711 0
 1461 0028 3B1C     		mov	r3, r7
 1462 002a 0F33     		add	r3, r3, #15
 1463 002c 1A78     		ldrb	r2, [r3]
 1464 002e 0123     		mov	r3, #1
 1465 0030 1340     		and	r3, r2
 1466 0032 5A1E     		sub	r2, r3, #1
 1467 0034 9341     		sbc	r3, r3, r2
 1468 0036 DBB2     		uxtb	r3, r3
 1469              	.LBE9:
 712:../Generated_Code/I2C0.c **** }
 1470              		.loc 1 712 0
 1471 0038 181C     		mov	r0, r3
 1472 003a BD46     		mov	sp, r7
 1473 003c 04B0     		add	sp, sp, #16
 1474              		@ sp needed for prologue
 1475 003e 80BD     		pop	{r7, pc}
 1476              		.cfi_endproc
 1477              	.LFE13:
 1479              		.section	.text.I2C0_MasterGetSentDataNum,"ax",%progbits
 1480              		.align	2
 1481              		.global	I2C0_MasterGetSentDataNum
 1482              		.code	16
 1483              		.thumb_func
 1485              	I2C0_MasterGetSentDataNum:
 1486              	.LFB14:
 713:../Generated_Code/I2C0.c **** 
 714:../Generated_Code/I2C0.c **** /*
 715:../Generated_Code/I2C0.c **** ** ===================================================================
 716:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterGetSentDataNum (component I2C_LDD)
 717:../Generated_Code/I2C0.c **** */
 718:../Generated_Code/I2C0.c **** /*!
 719:../Generated_Code/I2C0.c **** **     @brief
 720:../Generated_Code/I2C0.c **** **         This method returns the number of transmitted characters
 721:../Generated_Code/I2C0.c **** **         from the transmit buffer. This method is available only for
 722:../Generated_Code/I2C0.c **** **         the MASTER mode and if method MasterSendBlock is enabled.
 723:../Generated_Code/I2C0.c **** **     @param
 724:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 725:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 726:../Generated_Code/I2C0.c **** **     @return
 727:../Generated_Code/I2C0.c **** **                         - The number of sent characters.
 728:../Generated_Code/I2C0.c **** */
 729:../Generated_Code/I2C0.c **** /* ===================================================================*/
 730:../Generated_Code/I2C0.c **** LDD_I2C_TSize I2C0_MasterGetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
 731:../Generated_Code/I2C0.c **** {
 1487              		.loc 1 731 0
 1488              		.cfi_startproc
 1489 0000 80B5     		push	{r7, lr}
 1490              	.LCFI27:
 1491              		.cfi_def_cfa_offset 8
 1492              		.cfi_offset 7, -8
 1493              		.cfi_offset 14, -4
 1494 0002 82B0     		sub	sp, sp, #8
 1495              	.LCFI28:
 1496              		.cfi_def_cfa_offset 16
 1497 0004 00AF     		add	r7, sp, #0
 1498              	.LCFI29:
 1499              		.cfi_def_cfa_register 7
 1500 0006 7860     		str	r0, [r7, #4]
 732:../Generated_Code/I2C0.c ****   return (LDD_I2C_TSize)(((I2C0_TDeviceData *)DeviceDataPtr)->OutByteMNum);
 1501              		.loc 1 732 0
 1502 0008 7B68     		ldr	r3, [r7, #4]
 1503 000a 5B8B     		ldrh	r3, [r3, #26]
 733:../Generated_Code/I2C0.c **** }
 1504              		.loc 1 733 0
 1505 000c 181C     		mov	r0, r3
 1506 000e BD46     		mov	sp, r7
 1507 0010 02B0     		add	sp, sp, #8
 1508              		@ sp needed for prologue
 1509 0012 80BD     		pop	{r7, pc}
 1510              		.cfi_endproc
 1511              	.LFE14:
 1513              		.section	.text.I2C0_MasterReceiveBlock,"ax",%progbits
 1514              		.align	2
 1515              		.global	I2C0_MasterReceiveBlock
 1516              		.code	16
 1517              		.thumb_func
 1519              	I2C0_MasterReceiveBlock:
 1520              	.LFB15:
 734:../Generated_Code/I2C0.c **** 
 735:../Generated_Code/I2C0.c **** /*
 736:../Generated_Code/I2C0.c **** ** ===================================================================
 737:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterReceiveBlock (component I2C_LDD)
 738:../Generated_Code/I2C0.c **** */
 739:../Generated_Code/I2C0.c **** /*!
 740:../Generated_Code/I2C0.c **** **     @brief
 741:../Generated_Code/I2C0.c **** **         This method writes one (7-bit addressing) or two (10-bit
 742:../Generated_Code/I2C0.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 743:../Generated_Code/I2C0.c **** **         the I2C bus and then receives the block of characters from
 744:../Generated_Code/I2C0.c **** **         the bus. The slave address must be specified before, by the
 745:../Generated_Code/I2C0.c **** **         "SelectSlaveDevice" method or in component initialization
 746:../Generated_Code/I2C0.c **** **         section, "Target slave address init" property. If the method
 747:../Generated_Code/I2C0.c **** **         returns ERR_OK, it doesn't mean that reception was
 748:../Generated_Code/I2C0.c **** **         successful. The state of reception is detectable by means of
 749:../Generated_Code/I2C0.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 750:../Generated_Code/I2C0.c **** **         received are not copied to an internal buffer and remains in
 751:../Generated_Code/I2C0.c **** **         the original location. Therefore the content of the buffer
 752:../Generated_Code/I2C0.c **** **         should not be changed until the transmission is complete.
 753:../Generated_Code/I2C0.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 754:../Generated_Code/I2C0.c **** **         of the reception. This method is available only for the
 755:../Generated_Code/I2C0.c **** **         MASTER or MASTER - SLAVE mode.
 756:../Generated_Code/I2C0.c **** **     @param
 757:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 758:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 759:../Generated_Code/I2C0.c **** **     @param
 760:../Generated_Code/I2C0.c **** **         BufferPtr       - Pointer to a buffer where
 761:../Generated_Code/I2C0.c **** **                           received characters will be stored.
 762:../Generated_Code/I2C0.c **** **     @param
 763:../Generated_Code/I2C0.c **** **         Size            - The size of the block.
 764:../Generated_Code/I2C0.c **** **     @param
 765:../Generated_Code/I2C0.c **** **         SendStop        - Parameter for generating I2C
 766:../Generated_Code/I2C0.c **** **                           Stop condition
 767:../Generated_Code/I2C0.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 768:../Generated_Code/I2C0.c **** **                           generated on end transmission.
 769:../Generated_Code/I2C0.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 770:../Generated_Code/I2C0.c **** **                           generated on end transmission.
 771:../Generated_Code/I2C0.c **** **     @return
 772:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 773:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 774:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
 775:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 776:../Generated_Code/I2C0.c **** **                           the active clock configuration
 777:../Generated_Code/I2C0.c **** **                           ERR_BUSY - The master device is busy
 778:../Generated_Code/I2C0.c **** **                           ERR_NOTAVAIL - It is not possible to
 779:../Generated_Code/I2C0.c **** **                           receive data if general call address is set.
 780:../Generated_Code/I2C0.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 781:../Generated_Code/I2C0.c **** **                           possible generated on end transmission.
 782:../Generated_Code/I2C0.c **** */
 783:../Generated_Code/I2C0.c **** /* ===================================================================*/
 784:../Generated_Code/I2C0.c **** LDD_TError I2C0_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 785:../Generated_Code/I2C0.c **** {
 1521              		.loc 1 785 0
 1522              		.cfi_startproc
 1523 0000 80B5     		push	{r7, lr}
 1524              	.LCFI30:
 1525              		.cfi_def_cfa_offset 8
 1526              		.cfi_offset 7, -8
 1527              		.cfi_offset 14, -4
 1528 0002 86B0     		sub	sp, sp, #24
 1529              	.LCFI31:
 1530              		.cfi_def_cfa_offset 32
 1531 0004 00AF     		add	r7, sp, #0
 1532              	.LCFI32:
 1533              		.cfi_def_cfa_register 7
 1534 0006 F860     		str	r0, [r7, #12]
 1535 0008 B960     		str	r1, [r7, #8]
 1536 000a 111C     		mov	r1, r2
 1537 000c 1A1C     		mov	r2, r3
 1538 000e BB1D     		add	r3, r7, #6
 1539 0010 1980     		strh	r1, [r3]
 1540 0012 7B1D     		add	r3, r7, #5
 1541 0014 1A70     		strb	r2, [r3]
 1542              	.LBB10:
 786:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1543              		.loc 1 786 0
 1544 0016 FB68     		ldr	r3, [r7, #12]
 1545 0018 7B61     		str	r3, [r7, #20]
 787:../Generated_Code/I2C0.c **** 
 788:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 789:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
 790:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 1546              		.loc 1 790 0
 1547 001a 7B69     		ldr	r3, [r7, #20]
 1548 001c DB78     		ldrb	r3, [r3, #3]
 1549 001e 0122     		mov	r2, #1
 1550 0020 5340     		eor	r3, r2
 1551 0022 DBB2     		uxtb	r3, r3
 1552 0024 002B     		cmp	r3, #0
 1553 0026 01D0     		beq	.L69
 791:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 1554              		.loc 1 791 0
 1555 0028 0723     		mov	r3, #7
 1556 002a 9FE0     		b	.L70
 1557              	.L69:
 792:../Generated_Code/I2C0.c ****   }
 793:../Generated_Code/I2C0.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1558              		.loc 1 793 0
 1559 002c BB1D     		add	r3, r7, #6
 1560 002e 1B88     		ldrh	r3, [r3]
 1561 0030 002B     		cmp	r3, #0
 1562 0032 01D1     		bne	.L71
 794:../Generated_Code/I2C0.c ****     return ERR_OK;                     /* If zero then OK */
 1563              		.loc 1 794 0
 1564 0034 0023     		mov	r3, #0
 1565 0036 99E0     		b	.L70
 1566              	.L71:
 795:../Generated_Code/I2C0.c ****   }
 796:../Generated_Code/I2C0.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 1567              		.loc 1 796 0
 1568 0038 7B1D     		add	r3, r7, #5
 1569 003a 1B78     		ldrb	r3, [r3]
 1570 003c 002B     		cmp	r3, #0
 1571 003e 01D1     		bne	.L72
 797:../Generated_Code/I2C0.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1572              		.loc 1 797 0
 1573 0040 8123     		mov	r3, #129
 1574 0042 93E0     		b	.L70
 1575              	.L72:
 798:../Generated_Code/I2C0.c ****   }
 799:../Generated_Code/I2C0.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1576              		.loc 1 799 0
 1577 0044 7B69     		ldr	r3, [r7, #20]
 1578 0046 1B78     		ldrb	r3, [r3]
 1579 0048 1A1C     		mov	r2, r3
 1580 004a 0823     		mov	r3, #8
 1581 004c 1340     		and	r3, r2
 1582 004e 01D0     		beq	.L73
 800:../Generated_Code/I2C0.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1583              		.loc 1 800 0
 1584 0050 0923     		mov	r3, #9
 1585 0052 8BE0     		b	.L70
 1586              	.L73:
 801:../Generated_Code/I2C0.c ****   }
 802:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1587              		.loc 1 802 0
 1588 0054 7B69     		ldr	r3, [r7, #20]
 1589 0056 9B78     		ldrb	r3, [r3, #2]
 1590 0058 012B     		cmp	r3, #1
 1591 005a 17D1     		bne	.L74
 803:../Generated_Code/I2C0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1592              		.loc 1 803 0
 1593 005c 454B     		ldr	r3, .L84
 1594 005e DB78     		ldrb	r3, [r3, #3]
 1595 0060 DBB2     		uxtb	r3, r3
 1596 0062 1A1C     		mov	r2, r3
 1597 0064 2023     		mov	r3, #32
 1598 0066 1340     		and	r3, r2
 1599 0068 09D1     		bne	.L75
 1600              		.loc 1 803 0 is_stmt 0
 1601 006a 7B69     		ldr	r3, [r7, #20]
 1602 006c 1B78     		ldrb	r3, [r3]
 1603 006e 1A1C     		mov	r2, r3
 1604 0070 0123     		mov	r3, #1
 1605 0072 1340     		and	r3, r2
 1606 0074 03D1     		bne	.L75
 1607              		.loc 1 803 0
 1608 0076 7B69     		ldr	r3, [r7, #20]
 1609 0078 DB89     		ldrh	r3, [r3, #14]
 1610 007a 002B     		cmp	r3, #0
 1611 007c 01D0     		beq	.L76
 1612              	.L75:
 1613              		.loc 1 803 0
 1614 007e 0123     		mov	r3, #1
 1615 0080 00E0     		b	.L77
 1616              	.L76:
 1617              		.loc 1 803 0
 1618 0082 0023     		mov	r3, #0
 1619              	.L77:
 1620              		.loc 1 803 0
 1621 0084 002B     		cmp	r3, #0
 1622 0086 0DD0     		beq	.L78
 804:../Generated_Code/I2C0.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 805:../Generated_Code/I2C0.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 806:../Generated_Code/I2C0.c ****       return ERR_BUSY;                 /* If yes then error */
 1623              		.loc 1 806 0 is_stmt 1
 1624 0088 0823     		mov	r3, #8
 1625 008a 6FE0     		b	.L70
 1626              	.L74:
 807:../Generated_Code/I2C0.c ****     }
 808:../Generated_Code/I2C0.c ****   } else {
 809:../Generated_Code/I2C0.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1627              		.loc 1 809 0
 1628 008c 7B69     		ldr	r3, [r7, #20]
 1629 008e 1B78     		ldrb	r3, [r3]
 1630 0090 1A1C     		mov	r2, r3
 1631 0092 0123     		mov	r3, #1
 1632 0094 1340     		and	r3, r2
 1633 0096 03D1     		bne	.L79
 1634              		.loc 1 809 0 is_stmt 0
 1635 0098 7B69     		ldr	r3, [r7, #20]
 1636 009a DB89     		ldrh	r3, [r3, #14]
 1637 009c 002B     		cmp	r3, #0
 1638 009e 01D0     		beq	.L78
 1639              	.L79:
 810:../Generated_Code/I2C0.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 811:../Generated_Code/I2C0.c ****       return ERR_BUSY;               /* If yes then error */
 1640              		.loc 1 811 0 is_stmt 1
 1641 00a0 0823     		mov	r3, #8
 1642 00a2 63E0     		b	.L70
 1643              	.L78:
 812:../Generated_Code/I2C0.c ****     }
 813:../Generated_Code/I2C0.c ****   }
 814:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
 815:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 1644              		.loc 1 815 0
 1645 00a4 FFF7FEFF 		bl	vPortEnterCritical
 816:../Generated_Code/I2C0.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1646              		.loc 1 816 0
 1647 00a8 7B69     		ldr	r3, [r7, #20]
 1648 00aa 1B78     		ldrb	r3, [r3]
 1649 00ac 0122     		mov	r2, #1
 1650 00ae 1343     		orr	r3, r2
 1651 00b0 DAB2     		uxtb	r2, r3
 1652 00b2 7B69     		ldr	r3, [r7, #20]
 1653 00b4 1A70     		strb	r2, [r3]
 817:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1654              		.loc 1 817 0
 1655 00b6 7B69     		ldr	r3, [r7, #20]
 1656 00b8 BA68     		ldr	r2, [r7, #8]
 1657 00ba 5A61     		str	r2, [r3, #20]
 818:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpByteMNum = 0x00U;  /* Clear data number */
 1658              		.loc 1 818 0
 1659 00bc 7B69     		ldr	r3, [r7, #20]
 1660 00be 0022     		mov	r2, #0
 1661 00c0 1A82     		strh	r2, [r3, #16]
 819:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1662              		.loc 1 819 0
 1663 00c2 7B69     		ldr	r3, [r7, #20]
 1664 00c4 BA1D     		add	r2, r7, #6
 1665 00c6 1288     		ldrh	r2, [r2]
 1666 00c8 DA81     		strh	r2, [r3, #14]
 820:../Generated_Code/I2C0.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1667              		.loc 1 820 0
 1668 00ca 7B69     		ldr	r3, [r7, #20]
 1669 00cc 7A1D     		add	r2, r7, #5
 1670 00ce 1278     		ldrb	r2, [r2]
 1671 00d0 9A70     		strb	r2, [r3, #2]
 821:../Generated_Code/I2C0.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1672              		.loc 1 821 0
 1673 00d2 284B     		ldr	r3, .L84
 1674 00d4 274A     		ldr	r2, .L84
 1675 00d6 9278     		ldrb	r2, [r2, #2]
 1676 00d8 D2B2     		uxtb	r2, r2
 1677 00da 1021     		mov	r1, #16
 1678 00dc 0A43     		orr	r2, r1
 1679 00de D2B2     		uxtb	r2, r2
 1680 00e0 9A70     		strb	r2, [r3, #2]
 822:../Generated_Code/I2C0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1681              		.loc 1 822 0
 1682 00e2 244B     		ldr	r3, .L84
 1683 00e4 9B78     		ldrb	r3, [r3, #2]
 1684 00e6 DBB2     		uxtb	r3, r3
 1685 00e8 1A1C     		mov	r2, r3
 1686 00ea 2023     		mov	r3, #32
 1687 00ec 1340     		and	r3, r2
 1688 00ee 5A1E     		sub	r2, r3, #1
 1689 00f0 9341     		sbc	r3, r3, r2
 1690 00f2 DBB2     		uxtb	r3, r3
 1691 00f4 002B     		cmp	r3, #0
 1692 00f6 08D0     		beq	.L80
 823:../Generated_Code/I2C0.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 1693              		.loc 1 823 0
 1694 00f8 1E4B     		ldr	r3, .L84
 1695 00fa 1E4A     		ldr	r2, .L84
 1696 00fc 9278     		ldrb	r2, [r2, #2]
 1697 00fe D2B2     		uxtb	r2, r2
 1698 0100 0421     		mov	r1, #4
 1699 0102 0A43     		orr	r2, r1
 1700 0104 D2B2     		uxtb	r2, r2
 1701 0106 9A70     		strb	r2, [r3, #2]
 1702 0108 07E0     		b	.L81
 1703              	.L80:
 824:../Generated_Code/I2C0.c ****   } else {
 825:../Generated_Code/I2C0.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1704              		.loc 1 825 0
 1705 010a 1A4B     		ldr	r3, .L84
 1706 010c 194A     		ldr	r2, .L84
 1707 010e 9278     		ldrb	r2, [r2, #2]
 1708 0110 D2B2     		uxtb	r2, r2
 1709 0112 2021     		mov	r1, #32
 1710 0114 0A43     		orr	r2, r1
 1711 0116 D2B2     		uxtb	r2, r2
 1712 0118 9A70     		strb	r2, [r3, #2]
 1713              	.L81:
 826:../Generated_Code/I2C0.c ****   }
 827:../Generated_Code/I2C0.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1714              		.loc 1 827 0
 1715 011a 7B69     		ldr	r3, [r7, #20]
 1716 011c 1B78     		ldrb	r3, [r3]
 1717 011e 1A1C     		mov	r2, r3
 1718 0120 2023     		mov	r3, #32
 1719 0122 1340     		and	r3, r2
 1720 0124 0ED0     		beq	.L82
 828:../Generated_Code/I2C0.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1721              		.loc 1 828 0
 1722 0126 7B69     		ldr	r3, [r7, #20]
 1723 0128 1B78     		ldrb	r3, [r3]
 1724 012a 0622     		mov	r2, #6
 1725 012c 1343     		orr	r3, r2
 1726 012e DAB2     		uxtb	r2, r3
 1727 0130 7B69     		ldr	r3, [r7, #20]
 1728 0132 1A70     		strb	r2, [r3]
 829:../Generated_Code/I2C0.c ****     I2C_PDD_WriteDataReg(I2C0_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1729              		.loc 1 829 0
 1730 0134 0F4B     		ldr	r3, .L84
 1731 0136 7A69     		ldr	r2, [r7, #20]
 1732 0138 127B     		ldrb	r2, [r2, #12]
 1733 013a 0121     		mov	r1, #1
 1734 013c 0A43     		orr	r2, r1
 1735 013e D2B2     		uxtb	r2, r2
 1736 0140 1A71     		strb	r2, [r3, #4]
 1737 0142 10E0     		b	.L83
 1738              	.L82:
 830:../Generated_Code/I2C0.c ****   } else {
 831:../Generated_Code/I2C0.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1739              		.loc 1 831 0
 1740 0144 7B69     		ldr	r3, [r7, #20]
 1741 0146 1B78     		ldrb	r3, [r3]
 1742 0148 1A1C     		mov	r2, r3
 1743 014a 1023     		mov	r3, #16
 1744 014c 1340     		and	r3, r2
 1745 014e 0AD0     		beq	.L83
 832:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1746              		.loc 1 832 0
 1747 0150 7B69     		ldr	r3, [r7, #20]
 1748 0152 1B78     		ldrb	r3, [r3]
 1749 0154 0622     		mov	r2, #6
 1750 0156 9343     		bic	r3, r2
 1751 0158 DAB2     		uxtb	r2, r3
 1752 015a 7B69     		ldr	r3, [r7, #20]
 1753 015c 1A70     		strb	r2, [r3]
 833:../Generated_Code/I2C0.c ****       I2C_PDD_WriteDataReg(I2C0_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1754              		.loc 1 833 0
 1755 015e 054B     		ldr	r3, .L84
 1756 0160 7A69     		ldr	r2, [r7, #20]
 1757 0162 527B     		ldrb	r2, [r2, #13]
 1758 0164 1A71     		strb	r2, [r3, #4]
 1759              	.L83:
 834:../Generated_Code/I2C0.c ****     }
 835:../Generated_Code/I2C0.c ****   }
 836:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
 837:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 1760              		.loc 1 837 0
 1761 0166 FFF7FEFF 		bl	vPortExitCritical
 838:../Generated_Code/I2C0.c ****   return ERR_OK;                       /* OK */
 1762              		.loc 1 838 0
 1763 016a 0023     		mov	r3, #0
 1764              	.L70:
 1765              	.LBE10:
 839:../Generated_Code/I2C0.c **** }
 1766              		.loc 1 839 0
 1767 016c 181C     		mov	r0, r3
 1768 016e BD46     		mov	sp, r7
 1769 0170 06B0     		add	sp, sp, #24
 1770              		@ sp needed for prologue
 1771 0172 80BD     		pop	{r7, pc}
 1772              	.L85:
 1773              		.align	2
 1774              	.L84:
 1775 0174 00600640 		.word	1074159616
 1776              		.cfi_endproc
 1777              	.LFE15:
 1779              		.section	.text.I2C0_MasterUpdateReceiveBlockSize,"ax",%progbits
 1780              		.align	2
 1781              		.global	I2C0_MasterUpdateReceiveBlockSize
 1782              		.code	16
 1783              		.thumb_func
 1785              	I2C0_MasterUpdateReceiveBlockSize:
 1786              	.LFB16:
 840:../Generated_Code/I2C0.c **** 
 841:../Generated_Code/I2C0.c **** /*
 842:../Generated_Code/I2C0.c **** ** ===================================================================
 843:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterUpdateReceiveBlockSize (component I2C_LDD)
 844:../Generated_Code/I2C0.c **** */
 845:../Generated_Code/I2C0.c **** /*!
 846:../Generated_Code/I2C0.c **** **     @brief
 847:../Generated_Code/I2C0.c **** **         This method updates received block size in master mode. For
 848:../Generated_Code/I2C0.c **** **         correct function must this method called in
 849:../Generated_Code/I2C0.c **** **         OnMasterByteReceived. This method is available only for the
 850:../Generated_Code/I2C0.c **** **         MASTER or MASTER - SLAVE mode.
 851:../Generated_Code/I2C0.c **** **     @param
 852:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 853:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 854:../Generated_Code/I2C0.c **** **     @param
 855:../Generated_Code/I2C0.c **** **         Size            - The size of the block.
 856:../Generated_Code/I2C0.c **** **     @return
 857:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 858:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 859:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
 860:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 861:../Generated_Code/I2C0.c **** **                           the active clock configuration
 862:../Generated_Code/I2C0.c **** **                           ERR_NOTAVAIL - It is not possible set new
 863:../Generated_Code/I2C0.c **** **                           value receive block size, master is not
 864:../Generated_Code/I2C0.c **** **                           receive block.
 865:../Generated_Code/I2C0.c **** **                           ERR_PARAM_SIZE -  Value of block size is
 866:../Generated_Code/I2C0.c **** **                           out of range.
 867:../Generated_Code/I2C0.c **** */
 868:../Generated_Code/I2C0.c **** /* ===================================================================*/
 869:../Generated_Code/I2C0.c **** LDD_TError I2C0_MasterUpdateReceiveBlockSize(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TSize Size)
 870:../Generated_Code/I2C0.c **** {
 1787              		.loc 1 870 0
 1788              		.cfi_startproc
 1789 0000 80B5     		push	{r7, lr}
 1790              	.LCFI33:
 1791              		.cfi_def_cfa_offset 8
 1792              		.cfi_offset 7, -8
 1793              		.cfi_offset 14, -4
 1794 0002 84B0     		sub	sp, sp, #16
 1795              	.LCFI34:
 1796              		.cfi_def_cfa_offset 24
 1797 0004 00AF     		add	r7, sp, #0
 1798              	.LCFI35:
 1799              		.cfi_def_cfa_register 7
 1800 0006 7860     		str	r0, [r7, #4]
 1801 0008 0A1C     		mov	r2, r1
 1802 000a BB1C     		add	r3, r7, #2
 1803 000c 1A80     		strh	r2, [r3]
 1804              	.LBB11:
 871:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 1805              		.loc 1 871 0
 1806 000e 7B68     		ldr	r3, [r7, #4]
 1807 0010 FB60     		str	r3, [r7, #12]
 872:../Generated_Code/I2C0.c ****   LDD_I2C_TSize ByteReceived;
 873:../Generated_Code/I2C0.c **** 
 874:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 875:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
 876:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 1808              		.loc 1 876 0
 1809 0012 FB68     		ldr	r3, [r7, #12]
 1810 0014 DB78     		ldrb	r3, [r3, #3]
 1811 0016 0122     		mov	r2, #1
 1812 0018 5340     		eor	r3, r2
 1813 001a DBB2     		uxtb	r3, r3
 1814 001c 002B     		cmp	r3, #0
 1815 001e 01D0     		beq	.L87
 877:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 1816              		.loc 1 877 0
 1817 0020 0723     		mov	r3, #7
 1818 0022 29E0     		b	.L88
 1819              	.L87:
 878:../Generated_Code/I2C0.c ****   }
 879:../Generated_Code/I2C0.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) == 0U) { /* Is the Master receive data? */
 1820              		.loc 1 879 0
 1821 0024 FB68     		ldr	r3, [r7, #12]
 1822 0026 1B78     		ldrb	r3, [r3]
 1823 0028 1A1C     		mov	r2, r3
 1824 002a 0123     		mov	r3, #1
 1825 002c 1340     		and	r3, r2
 1826 002e 01D1     		bne	.L89
 880:../Generated_Code/I2C0.c ****     return ERR_NOTAVAIL;               /* If no, return error */
 1827              		.loc 1 880 0
 1828 0030 0923     		mov	r3, #9
 1829 0032 21E0     		b	.L88
 1830              	.L89:
 881:../Generated_Code/I2C0.c ****   }
 882:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
 883:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 1831              		.loc 1 883 0
 1832 0034 FFF7FEFF 		bl	vPortEnterCritical
 884:../Generated_Code/I2C0.c ****   ByteReceived = DeviceDataPrv->InpByteMNum;
 1833              		.loc 1 884 0
 1834 0038 3B1C     		mov	r3, r7
 1835 003a 0A33     		add	r3, r3, #10
 1836 003c FA68     		ldr	r2, [r7, #12]
 1837 003e 128A     		ldrh	r2, [r2, #16]
 1838 0040 1A80     		strh	r2, [r3]
 885:../Generated_Code/I2C0.c ****   if ((Size < ByteReceived)||(DeviceDataPrv->InpLenM == 0x01U)) { /* Is possible set a new size? */
 1839              		.loc 1 885 0
 1840 0042 BA1C     		add	r2, r7, #2
 1841 0044 3B1C     		mov	r3, r7
 1842 0046 0A33     		add	r3, r3, #10
 1843 0048 1288     		ldrh	r2, [r2]
 1844 004a 1B88     		ldrh	r3, [r3]
 1845 004c 9A42     		cmp	r2, r3
 1846 004e 03D3     		bcc	.L90
 1847              		.loc 1 885 0 is_stmt 0
 1848 0050 FB68     		ldr	r3, [r7, #12]
 1849 0052 DB89     		ldrh	r3, [r3, #14]
 1850 0054 012B     		cmp	r3, #1
 1851 0056 03D1     		bne	.L91
 1852              	.L90:
 886:../Generated_Code/I2C0.c ****     /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTO
 887:../Generated_Code/I2C0.c ****     taskEXIT_CRITICAL();
 1853              		.loc 1 887 0 is_stmt 1
 1854 0058 FFF7FEFF 		bl	vPortExitCritical
 888:../Generated_Code/I2C0.c ****     return ERR_PARAM_SIZE;             /* If yes, return error */
 1855              		.loc 1 888 0
 1856 005c 8423     		mov	r3, #132
 1857 005e 0BE0     		b	.L88
 1858              	.L91:
 889:../Generated_Code/I2C0.c ****   }
 890:../Generated_Code/I2C0.c ****   DeviceDataPrv->InpLenM = Size - ByteReceived; /* Update receive data block size */
 1859              		.loc 1 890 0
 1860 0060 BA1C     		add	r2, r7, #2
 1861 0062 3B1C     		mov	r3, r7
 1862 0064 0A33     		add	r3, r3, #10
 1863 0066 1288     		ldrh	r2, [r2]
 1864 0068 1B88     		ldrh	r3, [r3]
 1865 006a D31A     		sub	r3, r2, r3
 1866 006c 9AB2     		uxth	r2, r3
 1867 006e FB68     		ldr	r3, [r7, #12]
 1868 0070 DA81     		strh	r2, [r3, #14]
 891:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
 892:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 1869              		.loc 1 892 0
 1870 0072 FFF7FEFF 		bl	vPortExitCritical
 893:../Generated_Code/I2C0.c ****   return ERR_OK;
 1871              		.loc 1 893 0
 1872 0076 0023     		mov	r3, #0
 1873              	.L88:
 1874              	.LBE11:
 894:../Generated_Code/I2C0.c **** }
 1875              		.loc 1 894 0
 1876 0078 181C     		mov	r0, r3
 1877 007a BD46     		mov	sp, r7
 1878 007c 04B0     		add	sp, sp, #16
 1879              		@ sp needed for prologue
 1880 007e 80BD     		pop	{r7, pc}
 1881              		.cfi_endproc
 1882              	.LFE16:
 1884              		.section	.text.I2C0_MasterGetBlockReceivedStatus,"ax",%progbits
 1885              		.align	2
 1886              		.global	I2C0_MasterGetBlockReceivedStatus
 1887              		.code	16
 1888              		.thumb_func
 1890              	I2C0_MasterGetBlockReceivedStatus:
 1891              	.LFB17:
 895:../Generated_Code/I2C0.c **** 
 896:../Generated_Code/I2C0.c **** /*
 897:../Generated_Code/I2C0.c **** ** ===================================================================
 898:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterGetBlockReceivedStatus (component I2C_LDD)
 899:../Generated_Code/I2C0.c **** */
 900:../Generated_Code/I2C0.c **** /*!
 901:../Generated_Code/I2C0.c **** **     @brief
 902:../Generated_Code/I2C0.c **** **         This method returns current state of MasterReceiveBlock
 903:../Generated_Code/I2C0.c **** **         method. This method is available only for the MASTER mode
 904:../Generated_Code/I2C0.c **** **         and if method MasterReceiveBlock is enabled.
 905:../Generated_Code/I2C0.c **** **     @param
 906:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 907:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 908:../Generated_Code/I2C0.c **** **     @return
 909:../Generated_Code/I2C0.c **** **                         - Return value:
 910:../Generated_Code/I2C0.c **** **                           <true> - data block is completely received.
 911:../Generated_Code/I2C0.c **** **                           <false> - data block isn't completely
 912:../Generated_Code/I2C0.c **** **                           received.
 913:../Generated_Code/I2C0.c **** */
 914:../Generated_Code/I2C0.c **** /* ===================================================================*/
 915:../Generated_Code/I2C0.c **** bool I2C0_MasterGetBlockReceivedStatus(LDD_TDeviceData *DeviceDataPtr)
 916:../Generated_Code/I2C0.c **** {
 1892              		.loc 1 916 0
 1893              		.cfi_startproc
 1894 0000 80B5     		push	{r7, lr}
 1895              	.LCFI36:
 1896              		.cfi_def_cfa_offset 8
 1897              		.cfi_offset 7, -8
 1898              		.cfi_offset 14, -4
 1899 0002 84B0     		sub	sp, sp, #16
 1900              	.LCFI37:
 1901              		.cfi_def_cfa_offset 24
 1902 0004 00AF     		add	r7, sp, #0
 1903              	.LCFI38:
 1904              		.cfi_def_cfa_register 7
 1905 0006 7860     		str	r0, [r7, #4]
 1906              	.LBB12:
 917:../Generated_Code/I2C0.c ****   uint8_t Status;                      /* Temporary variable for flag saving */
 918:../Generated_Code/I2C0.c **** 
 919:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
 920:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 1907              		.loc 1 920 0
 1908 0008 FFF7FEFF 		bl	vPortEnterCritical
 921:../Generated_Code/I2C0.c ****   Status = ((I2C0_TDeviceDataPtr)DeviceDataPtr)->StatusFlag; /* Save flag for return */
 1909              		.loc 1 921 0
 1910 000c 3B1C     		mov	r3, r7
 1911 000e 0F33     		add	r3, r3, #15
 1912 0010 7A68     		ldr	r2, [r7, #4]
 1913 0012 5278     		ldrb	r2, [r2, #1]
 1914 0014 1A70     		strb	r2, [r3]
 922:../Generated_Code/I2C0.c ****   ((I2C0_TDeviceDataPtr)DeviceDataPtr)->StatusFlag &= (uint8_t)(~(uint8_t)MASTER_BLOCK_RECEIVED); /
 1915              		.loc 1 922 0
 1916 0016 7B68     		ldr	r3, [r7, #4]
 1917 0018 5B78     		ldrb	r3, [r3, #1]
 1918 001a 0222     		mov	r2, #2
 1919 001c 9343     		bic	r3, r2
 1920 001e DAB2     		uxtb	r2, r3
 1921 0020 7B68     		ldr	r3, [r7, #4]
 1922 0022 5A70     		strb	r2, [r3, #1]
 923:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
 924:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 1923              		.loc 1 924 0
 1924 0024 FFF7FEFF 		bl	vPortExitCritical
 925:../Generated_Code/I2C0.c ****   return (bool)(((Status & MASTER_BLOCK_RECEIVED) != 0x00U)? TRUE : FALSE); /* Return saved status 
 1925              		.loc 1 925 0
 1926 0028 3B1C     		mov	r3, r7
 1927 002a 0F33     		add	r3, r3, #15
 1928 002c 1A78     		ldrb	r2, [r3]
 1929 002e 0223     		mov	r3, #2
 1930 0030 1340     		and	r3, r2
 1931 0032 5A1E     		sub	r2, r3, #1
 1932 0034 9341     		sbc	r3, r3, r2
 1933 0036 DBB2     		uxtb	r3, r3
 1934              	.LBE12:
 926:../Generated_Code/I2C0.c **** }
 1935              		.loc 1 926 0
 1936 0038 181C     		mov	r0, r3
 1937 003a BD46     		mov	sp, r7
 1938 003c 04B0     		add	sp, sp, #16
 1939              		@ sp needed for prologue
 1940 003e 80BD     		pop	{r7, pc}
 1941              		.cfi_endproc
 1942              	.LFE17:
 1944              		.section	.text.I2C0_MasterGetReceivedDataNum,"ax",%progbits
 1945              		.align	2
 1946              		.global	I2C0_MasterGetReceivedDataNum
 1947              		.code	16
 1948              		.thumb_func
 1950              	I2C0_MasterGetReceivedDataNum:
 1951              	.LFB18:
 927:../Generated_Code/I2C0.c **** 
 928:../Generated_Code/I2C0.c **** /*
 929:../Generated_Code/I2C0.c **** ** ===================================================================
 930:../Generated_Code/I2C0.c **** **     Method      :  I2C0_MasterGetReceivedDataNum (component I2C_LDD)
 931:../Generated_Code/I2C0.c **** */
 932:../Generated_Code/I2C0.c **** /*!
 933:../Generated_Code/I2C0.c **** **     @brief
 934:../Generated_Code/I2C0.c **** **         This method returns the number of received characters in the
 935:../Generated_Code/I2C0.c **** **         receive buffer. This method is available only for the MASTER
 936:../Generated_Code/I2C0.c **** **         mode and if method MasterReceiveBlock is enabled.
 937:../Generated_Code/I2C0.c **** **     @param
 938:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 939:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 940:../Generated_Code/I2C0.c **** **     @return
 941:../Generated_Code/I2C0.c **** **                         - The number of characters in the input
 942:../Generated_Code/I2C0.c **** **                           buffer.
 943:../Generated_Code/I2C0.c **** */
 944:../Generated_Code/I2C0.c **** /* ===================================================================*/
 945:../Generated_Code/I2C0.c **** LDD_I2C_TSize I2C0_MasterGetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
 946:../Generated_Code/I2C0.c **** {
 1952              		.loc 1 946 0
 1953              		.cfi_startproc
 1954 0000 80B5     		push	{r7, lr}
 1955              	.LCFI39:
 1956              		.cfi_def_cfa_offset 8
 1957              		.cfi_offset 7, -8
 1958              		.cfi_offset 14, -4
 1959 0002 82B0     		sub	sp, sp, #8
 1960              	.LCFI40:
 1961              		.cfi_def_cfa_offset 16
 1962 0004 00AF     		add	r7, sp, #0
 1963              	.LCFI41:
 1964              		.cfi_def_cfa_register 7
 1965 0006 7860     		str	r0, [r7, #4]
 947:../Generated_Code/I2C0.c ****   return (LDD_I2C_TSize)(((I2C0_TDeviceData *)DeviceDataPtr)->InpByteMNum);
 1966              		.loc 1 947 0
 1967 0008 7B68     		ldr	r3, [r7, #4]
 1968 000a 1B8A     		ldrh	r3, [r3, #16]
 948:../Generated_Code/I2C0.c **** }
 1969              		.loc 1 948 0
 1970 000c 181C     		mov	r0, r3
 1971 000e BD46     		mov	sp, r7
 1972 0010 02B0     		add	sp, sp, #8
 1973              		@ sp needed for prologue
 1974 0012 80BD     		pop	{r7, pc}
 1975              		.cfi_endproc
 1976              	.LFE18:
 1978              		.section	.text.I2C0_SelectSlaveDevice,"ax",%progbits
 1979              		.align	2
 1980              		.global	I2C0_SelectSlaveDevice
 1981              		.code	16
 1982              		.thumb_func
 1984              	I2C0_SelectSlaveDevice:
 1985              	.LFB19:
 949:../Generated_Code/I2C0.c **** 
 950:../Generated_Code/I2C0.c **** /*
 951:../Generated_Code/I2C0.c **** ** ===================================================================
 952:../Generated_Code/I2C0.c **** **     Method      :  I2C0_SelectSlaveDevice (component I2C_LDD)
 953:../Generated_Code/I2C0.c **** */
 954:../Generated_Code/I2C0.c **** /*!
 955:../Generated_Code/I2C0.c **** **     @brief
 956:../Generated_Code/I2C0.c **** **         This method selects a new slave for communication by its
 957:../Generated_Code/I2C0.c **** **         7-bit slave, 10-bit address or general call value. Any send
 958:../Generated_Code/I2C0.c **** **         or receive method directs to or from selected device, until
 959:../Generated_Code/I2C0.c **** **         a new slave device is selected by this method. This method
 960:../Generated_Code/I2C0.c **** **         is available for the MASTER mode.
 961:../Generated_Code/I2C0.c **** **     @param
 962:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
 963:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
 964:../Generated_Code/I2C0.c **** **     @param
 965:../Generated_Code/I2C0.c **** **         AddrType        - Specify type of slave address
 966:../Generated_Code/I2C0.c **** **                           (7bit, 10bit or general call address), e.g.
 967:../Generated_Code/I2C0.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 968:../Generated_Code/I2C0.c **** **     @param
 969:../Generated_Code/I2C0.c **** **         Addr            - 7bit or 10bit slave address value.
 970:../Generated_Code/I2C0.c **** **     @return
 971:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
 972:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
 973:../Generated_Code/I2C0.c **** **                           ERR_BUSY - The device is busy, wait until
 974:../Generated_Code/I2C0.c **** **                           the current operation is finished.
 975:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  The device is disabled.
 976:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
 977:../Generated_Code/I2C0.c **** **                           the active clock configuration
 978:../Generated_Code/I2C0.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 979:../Generated_Code/I2C0.c **** **                           type.
 980:../Generated_Code/I2C0.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 981:../Generated_Code/I2C0.c **** */
 982:../Generated_Code/I2C0.c **** /* ===================================================================*/
 983:../Generated_Code/I2C0.c **** LDD_TError I2C0_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I
 984:../Generated_Code/I2C0.c **** {
 1986              		.loc 1 984 0
 1987              		.cfi_startproc
 1988 0000 80B5     		push	{r7, lr}
 1989              	.LCFI42:
 1990              		.cfi_def_cfa_offset 8
 1991              		.cfi_offset 7, -8
 1992              		.cfi_offset 14, -4
 1993 0002 84B0     		sub	sp, sp, #16
 1994              	.LCFI43:
 1995              		.cfi_def_cfa_offset 24
 1996 0004 00AF     		add	r7, sp, #0
 1997              	.LCFI44:
 1998              		.cfi_def_cfa_register 7
 1999 0006 7860     		str	r0, [r7, #4]
 2000 0008 FB1C     		add	r3, r7, #3
 2001 000a 1970     		strb	r1, [r3]
 2002 000c 3B1C     		mov	r3, r7
 2003 000e 1A80     		strh	r2, [r3]
 2004              	.LBB13:
 985:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 2005              		.loc 1 985 0
 2006 0010 7B68     		ldr	r3, [r7, #4]
 2007 0012 FB60     		str	r3, [r7, #12]
 986:../Generated_Code/I2C0.c **** 
 987:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 988:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
 989:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 2008              		.loc 1 989 0
 2009 0014 FB68     		ldr	r3, [r7, #12]
 2010 0016 DB78     		ldrb	r3, [r3, #3]
 2011 0018 0122     		mov	r2, #1
 2012 001a 5340     		eor	r3, r2
 2013 001c DBB2     		uxtb	r3, r3
 2014 001e 002B     		cmp	r3, #0
 2015 0020 01D0     		beq	.L97
 990:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 2016              		.loc 1 990 0
 2017 0022 0723     		mov	r3, #7
 2018 0024 6DE0     		b	.L98
 2019              	.L97:
 991:../Generated_Code/I2C0.c ****   }
 992:../Generated_Code/I2C0.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 2020              		.loc 1 992 0
 2021 0026 FB68     		ldr	r3, [r7, #12]
 2022 0028 1B78     		ldrb	r3, [r3]
 2023 002a 1A1C     		mov	r2, r3
 2024 002c 0123     		mov	r3, #1
 2025 002e 1340     		and	r3, r2
 2026 0030 01D0     		beq	.L99
 993:../Generated_Code/I2C0.c ****     return ERR_BUSY;                   /* If yes then error */
 2027              		.loc 1 993 0
 2028 0032 0823     		mov	r3, #8
 2029 0034 65E0     		b	.L98
 2030              	.L99:
 994:../Generated_Code/I2C0.c ****   }
 995:../Generated_Code/I2C0.c ****   switch (AddrType) {
 2031              		.loc 1 995 0
 2032 0036 FB1C     		add	r3, r7, #3
 2033 0038 1B78     		ldrb	r3, [r3]
 2034 003a 012B     		cmp	r3, #1
 2035 003c 1FD0     		beq	.L102
 2036 003e 022B     		cmp	r3, #2
 2037 0040 4DD0     		beq	.L103
 2038 0042 002B     		cmp	r3, #0
 2039 0044 5AD1     		bne	.L107
 2040              	.L101:
 996:../Generated_Code/I2C0.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 997:../Generated_Code/I2C0.c ****       if (Addr > 0x7FU) {              /* Test address value */
 2041              		.loc 1 997 0
 2042 0046 3B1C     		mov	r3, r7
 2043 0048 1B88     		ldrh	r3, [r3]
 2044 004a 7F2B     		cmp	r3, #127
 2045 004c 01D9     		bls	.L104
 998:../Generated_Code/I2C0.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 2046              		.loc 1 998 0
 2047 004e 8923     		mov	r3, #137
 2048 0050 57E0     		b	.L98
 2049              	.L104:
 999:../Generated_Code/I2C0.c ****       }
1000:../Generated_Code/I2C0.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 2050              		.loc 1 1000 0
 2051 0052 3B1C     		mov	r3, r7
 2052 0054 1B88     		ldrh	r3, [r3]
 2053 0056 DBB2     		uxtb	r3, r3
 2054 0058 5B00     		lsl	r3, r3, #1
 2055 005a DAB2     		uxtb	r2, r3
 2056 005c FB68     		ldr	r3, [r7, #12]
 2057 005e 1A73     		strb	r2, [r3, #12]
1001:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 2058              		.loc 1 1001 0
 2059 0060 FB68     		ldr	r3, [r7, #12]
 2060 0062 1B78     		ldrb	r3, [r3]
 2061 0064 1822     		mov	r2, #24
 2062 0066 9343     		bic	r3, r2
 2063 0068 DAB2     		uxtb	r2, r3
 2064 006a FB68     		ldr	r3, [r7, #12]
 2065 006c 1A70     		strb	r2, [r3]
1002:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 2066              		.loc 1 1002 0
 2067 006e FB68     		ldr	r3, [r7, #12]
 2068 0070 1B78     		ldrb	r3, [r3]
 2069 0072 2022     		mov	r2, #32
 2070 0074 1343     		orr	r3, r2
 2071 0076 DAB2     		uxtb	r2, r3
 2072 0078 FB68     		ldr	r3, [r7, #12]
 2073 007a 1A70     		strb	r2, [r3]
1003:../Generated_Code/I2C0.c ****     break;
 2074              		.loc 1 1003 0
 2075 007c 40E0     		b	.L105
 2076              	.L102:
1004:../Generated_Code/I2C0.c ****     case LDD_I2C_ADDRTYPE_10BITS:
1005:../Generated_Code/I2C0.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 2077              		.loc 1 1005 0
 2078 007e 3B1C     		mov	r3, r7
 2079 0080 1A88     		ldrh	r2, [r3]
 2080 0082 224B     		ldr	r3, .L108
 2081 0084 9A42     		cmp	r2, r3
 2082 0086 01D9     		bls	.L106
1006:../Generated_Code/I2C0.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 2083              		.loc 1 1006 0
 2084 0088 8923     		mov	r3, #137
 2085 008a 3AE0     		b	.L98
 2086              	.L106:
1007:../Generated_Code/I2C0.c ****       }
1008:../Generated_Code/I2C0.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 2087              		.loc 1 1008 0
 2088 008c 3B1C     		mov	r3, r7
 2089 008e 1B88     		ldrh	r3, [r3]
 2090 0090 DAB2     		uxtb	r2, r3
 2091 0092 FB68     		ldr	r3, [r7, #12]
 2092 0094 1A73     		strb	r2, [r3, #12]
1009:../Generated_Code/I2C0.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 2093              		.loc 1 1009 0
 2094 0096 3B1C     		mov	r3, r7
 2095 0098 1B88     		ldrh	r3, [r3]
 2096 009a DB11     		asr	r3, r3, #7
 2097 009c DAB2     		uxtb	r2, r3
 2098 009e FB68     		ldr	r3, [r7, #12]
 2099 00a0 5A73     		strb	r2, [r3, #13]
1010:../Generated_Code/I2C0.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 2100              		.loc 1 1010 0
 2101 00a2 FB68     		ldr	r3, [r7, #12]
 2102 00a4 5A7B     		ldrb	r2, [r3, #13]
 2103 00a6 0623     		mov	r3, #6
 2104 00a8 1340     		and	r3, r2
 2105 00aa DAB2     		uxtb	r2, r3
 2106 00ac FB68     		ldr	r3, [r7, #12]
 2107 00ae 5A73     		strb	r2, [r3, #13]
1011:../Generated_Code/I2C0.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 2108              		.loc 1 1011 0
 2109 00b0 FB68     		ldr	r3, [r7, #12]
 2110 00b2 5B7B     		ldrb	r3, [r3, #13]
 2111 00b4 1022     		mov	r2, #16
 2112 00b6 5242     		neg	r2, r2
 2113 00b8 1343     		orr	r3, r2
 2114 00ba DAB2     		uxtb	r2, r3
 2115 00bc FB68     		ldr	r3, [r7, #12]
 2116 00be 5A73     		strb	r2, [r3, #13]
1012:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 2117              		.loc 1 1012 0
 2118 00c0 FB68     		ldr	r3, [r7, #12]
 2119 00c2 1B78     		ldrb	r3, [r3]
 2120 00c4 2822     		mov	r2, #40
 2121 00c6 9343     		bic	r3, r2
 2122 00c8 DAB2     		uxtb	r2, r3
 2123 00ca FB68     		ldr	r3, [r7, #12]
 2124 00cc 1A70     		strb	r2, [r3]
1013:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 2125              		.loc 1 1013 0
 2126 00ce FB68     		ldr	r3, [r7, #12]
 2127 00d0 1B78     		ldrb	r3, [r3]
 2128 00d2 1022     		mov	r2, #16
 2129 00d4 1343     		orr	r3, r2
 2130 00d6 DAB2     		uxtb	r2, r3
 2131 00d8 FB68     		ldr	r3, [r7, #12]
 2132 00da 1A70     		strb	r2, [r3]
1014:../Generated_Code/I2C0.c ****     break;
 2133              		.loc 1 1014 0
 2134 00dc 10E0     		b	.L105
 2135              	.L103:
1015:../Generated_Code/I2C0.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
1016:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 2136              		.loc 1 1016 0
 2137 00de FB68     		ldr	r3, [r7, #12]
 2138 00e0 1B78     		ldrb	r3, [r3]
 2139 00e2 3022     		mov	r2, #48
 2140 00e4 9343     		bic	r3, r2
 2141 00e6 DAB2     		uxtb	r2, r3
 2142 00e8 FB68     		ldr	r3, [r7, #12]
 2143 00ea 1A70     		strb	r2, [r3]
1017:../Generated_Code/I2C0.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 2144              		.loc 1 1017 0
 2145 00ec FB68     		ldr	r3, [r7, #12]
 2146 00ee 1B78     		ldrb	r3, [r3]
 2147 00f0 0822     		mov	r2, #8
 2148 00f2 1343     		orr	r3, r2
 2149 00f4 DAB2     		uxtb	r2, r3
 2150 00f6 FB68     		ldr	r3, [r7, #12]
 2151 00f8 1A70     		strb	r2, [r3]
1018:../Generated_Code/I2C0.c ****     break;
 2152              		.loc 1 1018 0
 2153 00fa 01E0     		b	.L105
 2154              	.L107:
1019:../Generated_Code/I2C0.c ****     default:
1020:../Generated_Code/I2C0.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 2155              		.loc 1 1020 0
 2156 00fc 8D23     		mov	r3, #141
 2157 00fe 00E0     		b	.L98
 2158              	.L105:
1021:../Generated_Code/I2C0.c ****   }
1022:../Generated_Code/I2C0.c ****   return ERR_OK;                       /* OK */
 2159              		.loc 1 1022 0
 2160 0100 0023     		mov	r3, #0
 2161              	.L98:
 2162              	.LBE13:
1023:../Generated_Code/I2C0.c **** }
 2163              		.loc 1 1023 0
 2164 0102 181C     		mov	r0, r3
 2165 0104 BD46     		mov	sp, r7
 2166 0106 04B0     		add	sp, sp, #16
 2167              		@ sp needed for prologue
 2168 0108 80BD     		pop	{r7, pc}
 2169              	.L109:
 2170 010a C046     		.align	2
 2171              	.L108:
 2172 010c FF030000 		.word	1023
 2173              		.cfi_endproc
 2174              	.LFE19:
 2176              		.section	.text.I2C0_GetError,"ax",%progbits
 2177              		.align	2
 2178              		.global	I2C0_GetError
 2179              		.code	16
 2180              		.thumb_func
 2182              	I2C0_GetError:
 2183              	.LFB20:
1024:../Generated_Code/I2C0.c **** 
1025:../Generated_Code/I2C0.c **** /*
1026:../Generated_Code/I2C0.c **** ** ===================================================================
1027:../Generated_Code/I2C0.c **** **     Method      :  I2C0_GetError (component I2C_LDD)
1028:../Generated_Code/I2C0.c **** */
1029:../Generated_Code/I2C0.c **** /*!
1030:../Generated_Code/I2C0.c **** **     @brief
1031:../Generated_Code/I2C0.c **** **         Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
1032:../Generated_Code/I2C0.c **** **     @param
1033:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1034:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1035:../Generated_Code/I2C0.c **** **     @param
1036:../Generated_Code/I2C0.c **** **         ErrorMaskPtr    - Pointer to a variable
1037:../Generated_Code/I2C0.c **** **                           where errors value mask will be stored.
1038:../Generated_Code/I2C0.c **** **     @return
1039:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
1040:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
1041:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
1042:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
1043:../Generated_Code/I2C0.c **** **                           the active clock configuration
1044:../Generated_Code/I2C0.c **** */
1045:../Generated_Code/I2C0.c **** /* ===================================================================*/
1046:../Generated_Code/I2C0.c **** LDD_TError I2C0_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TErrorMask *ErrorMaskPtr)
1047:../Generated_Code/I2C0.c **** {
 2184              		.loc 1 1047 0
 2185              		.cfi_startproc
 2186 0000 80B5     		push	{r7, lr}
 2187              	.LCFI45:
 2188              		.cfi_def_cfa_offset 8
 2189              		.cfi_offset 7, -8
 2190              		.cfi_offset 14, -4
 2191 0002 84B0     		sub	sp, sp, #16
 2192              	.LCFI46:
 2193              		.cfi_def_cfa_offset 24
 2194 0004 00AF     		add	r7, sp, #0
 2195              	.LCFI47:
 2196              		.cfi_def_cfa_register 7
 2197 0006 7860     		str	r0, [r7, #4]
 2198 0008 3960     		str	r1, [r7]
 2199              	.LBB14:
1048:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 2200              		.loc 1 1048 0
 2201 000a 7B68     		ldr	r3, [r7, #4]
 2202 000c FB60     		str	r3, [r7, #12]
1049:../Generated_Code/I2C0.c **** 
1050:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
1051:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
1052:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 2203              		.loc 1 1052 0
 2204 000e FB68     		ldr	r3, [r7, #12]
 2205 0010 DB78     		ldrb	r3, [r3, #3]
 2206 0012 0122     		mov	r2, #1
 2207 0014 5340     		eor	r3, r2
 2208 0016 DBB2     		uxtb	r3, r3
 2209 0018 002B     		cmp	r3, #0
 2210 001a 01D0     		beq	.L111
1053:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 2211              		.loc 1 1053 0
 2212 001c 0723     		mov	r3, #7
 2213 001e 0BE0     		b	.L112
 2214              	.L111:
1054:../Generated_Code/I2C0.c ****   }
1055:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS
1056:../Generated_Code/I2C0.c ****   taskENTER_CRITICAL();
 2215              		.loc 1 1056 0
 2216 0020 FFF7FEFF 		bl	vPortEnterCritical
1057:../Generated_Code/I2C0.c ****   *ErrorMaskPtr = DeviceDataPrv->ErrorMask; /* Return last value of error mask */
 2217              		.loc 1 1057 0
 2218 0024 FB68     		ldr	r3, [r7, #12]
 2219 0026 9A88     		ldrh	r2, [r3, #4]
 2220 0028 3B68     		ldr	r3, [r7]
 2221 002a 1A80     		strh	r2, [r3]
1058:../Generated_Code/I2C0.c ****   DeviceDataPrv->ErrorMask = 0x00U;
 2222              		.loc 1 1058 0
 2223 002c FB68     		ldr	r3, [r7, #12]
 2224 002e 0022     		mov	r2, #0
 2225 0030 9A80     		strh	r2, [r3, #4]
1059:../Generated_Code/I2C0.c ****   /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS 
1060:../Generated_Code/I2C0.c ****   taskEXIT_CRITICAL();
 2226              		.loc 1 1060 0
 2227 0032 FFF7FEFF 		bl	vPortExitCritical
1061:../Generated_Code/I2C0.c ****   return ERR_OK;
 2228              		.loc 1 1061 0
 2229 0036 0023     		mov	r3, #0
 2230              	.L112:
 2231              	.LBE14:
1062:../Generated_Code/I2C0.c **** }
 2232              		.loc 1 1062 0
 2233 0038 181C     		mov	r0, r3
 2234 003a BD46     		mov	sp, r7
 2235 003c 04B0     		add	sp, sp, #16
 2236              		@ sp needed for prologue
 2237 003e 80BD     		pop	{r7, pc}
 2238              		.cfi_endproc
 2239              	.LFE20:
 2241              		.section	.text.I2C0_CheckBus,"ax",%progbits
 2242              		.align	2
 2243              		.global	I2C0_CheckBus
 2244              		.code	16
 2245              		.thumb_func
 2247              	I2C0_CheckBus:
 2248              	.LFB21:
1063:../Generated_Code/I2C0.c **** 
1064:../Generated_Code/I2C0.c **** /*
1065:../Generated_Code/I2C0.c **** ** ===================================================================
1066:../Generated_Code/I2C0.c **** **     Method      :  I2C0_CheckBus (component I2C_LDD)
1067:../Generated_Code/I2C0.c **** */
1068:../Generated_Code/I2C0.c **** /*!
1069:../Generated_Code/I2C0.c **** **     @brief
1070:../Generated_Code/I2C0.c **** **         This method returns the status of the bus. If the START
1071:../Generated_Code/I2C0.c **** **         condition has been detected, the method returns LDD_I2C_BUSY.
1072:../Generated_Code/I2C0.c **** **         If the STOP condition has been detected, the method returns
1073:../Generated_Code/I2C0.c **** **         LDD_I2C_IDLE.
1074:../Generated_Code/I2C0.c **** **     @param
1075:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1076:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1077:../Generated_Code/I2C0.c **** **     @param
1078:../Generated_Code/I2C0.c **** **         BusStatePtr     - Pointer to a variable,
1079:../Generated_Code/I2C0.c **** **                           where value of status is stored.
1080:../Generated_Code/I2C0.c **** **     @return
1081:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
1082:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
1083:../Generated_Code/I2C0.c **** **                           ERR_DISABLED -  Device is disabled
1084:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
1085:../Generated_Code/I2C0.c **** **                           the active clock configuration
1086:../Generated_Code/I2C0.c **** */
1087:../Generated_Code/I2C0.c **** /* ===================================================================*/
1088:../Generated_Code/I2C0.c **** LDD_TError I2C0_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TBusState *BusStatePtr)
1089:../Generated_Code/I2C0.c **** {
 2249              		.loc 1 1089 0
 2250              		.cfi_startproc
 2251 0000 80B5     		push	{r7, lr}
 2252              	.LCFI48:
 2253              		.cfi_def_cfa_offset 8
 2254              		.cfi_offset 7, -8
 2255              		.cfi_offset 14, -4
 2256 0002 84B0     		sub	sp, sp, #16
 2257              	.LCFI49:
 2258              		.cfi_def_cfa_offset 24
 2259 0004 00AF     		add	r7, sp, #0
 2260              	.LCFI50:
 2261              		.cfi_def_cfa_register 7
 2262 0006 7860     		str	r0, [r7, #4]
 2263 0008 3960     		str	r1, [r7]
 2264              	.LBB15:
1090:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 2265              		.loc 1 1090 0
 2266 000a 7B68     		ldr	r3, [r7, #4]
 2267 000c FB60     		str	r3, [r7, #12]
1091:../Generated_Code/I2C0.c **** 
1092:../Generated_Code/I2C0.c ****   (void)DeviceDataPrv;                 /* Suppress unused variable warning if needed */
1093:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
1094:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
1095:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 2268              		.loc 1 1095 0
 2269 000e FB68     		ldr	r3, [r7, #12]
 2270 0010 DB78     		ldrb	r3, [r3, #3]
 2271 0012 0122     		mov	r2, #1
 2272 0014 5340     		eor	r3, r2
 2273 0016 DBB2     		uxtb	r3, r3
 2274 0018 002B     		cmp	r3, #0
 2275 001a 01D0     		beq	.L114
1096:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 2276              		.loc 1 1096 0
 2277 001c 0723     		mov	r3, #7
 2278 001e 0CE0     		b	.L115
 2279              	.L114:
1097:../Generated_Code/I2C0.c ****   }
1098:../Generated_Code/I2C0.c ****   *BusStatePtr = (LDD_I2C_TBusState)((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY)?LDD_
 2280              		.loc 1 1098 0
 2281 0020 084B     		ldr	r3, .L116
 2282 0022 DB78     		ldrb	r3, [r3, #3]
 2283 0024 DBB2     		uxtb	r3, r3
 2284 0026 1A1C     		mov	r2, r3
 2285 0028 2023     		mov	r3, #32
 2286 002a 1340     		and	r3, r2
 2287 002c 5A42     		neg	r2, r3
 2288 002e 5341     		adc	r3, r3, r2
 2289 0030 DBB2     		uxtb	r3, r3
 2290 0032 1A1C     		mov	r2, r3
 2291 0034 3B68     		ldr	r3, [r7]
 2292 0036 1A70     		strb	r2, [r3]
1099:../Generated_Code/I2C0.c ****   return ERR_OK;
 2293              		.loc 1 1099 0
 2294 0038 0023     		mov	r3, #0
 2295              	.L115:
 2296              	.LBE15:
1100:../Generated_Code/I2C0.c **** }
 2297              		.loc 1 1100 0
 2298 003a 181C     		mov	r0, r3
 2299 003c BD46     		mov	sp, r7
 2300 003e 04B0     		add	sp, sp, #16
 2301              		@ sp needed for prologue
 2302 0040 80BD     		pop	{r7, pc}
 2303              	.L117:
 2304 0042 C046     		.align	2
 2305              	.L116:
 2306 0044 00600640 		.word	1074159616
 2307              		.cfi_endproc
 2308              	.LFE21:
 2310              		.section	.text.I2C0_GetStats,"ax",%progbits
 2311              		.align	2
 2312              		.global	I2C0_GetStats
 2313              		.code	16
 2314              		.thumb_func
 2316              	I2C0_GetStats:
 2317              	.LFB22:
1101:../Generated_Code/I2C0.c **** 
1102:../Generated_Code/I2C0.c **** /*
1103:../Generated_Code/I2C0.c **** ** ===================================================================
1104:../Generated_Code/I2C0.c **** **     Method      :  I2C0_GetStats (component I2C_LDD)
1105:../Generated_Code/I2C0.c **** */
1106:../Generated_Code/I2C0.c **** /*!
1107:../Generated_Code/I2C0.c **** **     @brief
1108:../Generated_Code/I2C0.c **** **         Returns receive/transmit statistics.
1109:../Generated_Code/I2C0.c **** **     @param
1110:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1111:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1112:../Generated_Code/I2C0.c **** **     @return
1113:../Generated_Code/I2C0.c **** **                         - Device receive/transmit statistics since the
1114:../Generated_Code/I2C0.c **** **                           device initialization or since the
1115:../Generated_Code/I2C0.c **** **                           statistical information has been cleared.
1116:../Generated_Code/I2C0.c **** */
1117:../Generated_Code/I2C0.c **** /* ===================================================================*/
1118:../Generated_Code/I2C0.c **** LDD_I2C_TStats I2C0_GetStats(LDD_TDeviceData *DeviceDataPtr)
1119:../Generated_Code/I2C0.c **** {
 2318              		.loc 1 1119 0
 2319              		.cfi_startproc
 2320 0000 80B5     		push	{r7, lr}
 2321              	.LCFI51:
 2322              		.cfi_def_cfa_offset 8
 2323              		.cfi_offset 7, -8
 2324              		.cfi_offset 14, -4
 2325 0002 84B0     		sub	sp, sp, #16
 2326              	.LCFI52:
 2327              		.cfi_def_cfa_offset 24
 2328 0004 00AF     		add	r7, sp, #0
 2329              	.LCFI53:
 2330              		.cfi_def_cfa_register 7
 2331 0006 7860     		str	r0, [r7, #4]
 2332 0008 3960     		str	r1, [r7]
 2333              	.LBB16:
1120:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 2334              		.loc 1 1120 0
 2335 000a 3B68     		ldr	r3, [r7]
 2336 000c FB60     		str	r3, [r7, #12]
1121:../Generated_Code/I2C0.c **** 
1122:../Generated_Code/I2C0.c ****   return (DeviceDataPrv->Stats);
 2337              		.loc 1 1122 0
 2338 000e 7A68     		ldr	r2, [r7, #4]
 2339 0010 FB68     		ldr	r3, [r7, #12]
 2340 0012 111C     		mov	r1, r2
 2341 0014 1A1C     		mov	r2, r3
 2342 0016 2432     		add	r2, r2, #36
 2343 0018 3423     		mov	r3, #52
 2344 001a 081C     		mov	r0, r1
 2345 001c 111C     		mov	r1, r2
 2346 001e 1A1C     		mov	r2, r3
 2347 0020 FFF7FEFF 		bl	memcpy
 2348              	.LBE16:
1123:../Generated_Code/I2C0.c **** }
 2349              		.loc 1 1123 0
 2350 0024 7868     		ldr	r0, [r7, #4]
 2351 0026 BD46     		mov	sp, r7
 2352 0028 04B0     		add	sp, sp, #16
 2353              		@ sp needed for prologue
 2354 002a 80BD     		pop	{r7, pc}
 2355              		.cfi_endproc
 2356              	.LFE22:
 2358              		.section	.text.HWEnDi,"ax",%progbits
 2359              		.align	2
 2360              		.code	16
 2361              		.thumb_func
 2363              	HWEnDi:
 2364              	.LFB23:
1124:../Generated_Code/I2C0.c **** 
1125:../Generated_Code/I2C0.c **** /*
1126:../Generated_Code/I2C0.c **** ** ===================================================================
1127:../Generated_Code/I2C0.c **** **     Method      :  HWEnDi (component I2C_LDD)
1128:../Generated_Code/I2C0.c **** **
1129:../Generated_Code/I2C0.c **** **     Description :
1130:../Generated_Code/I2C0.c **** **         Enables or disables the peripheral(s) associated with the 
1131:../Generated_Code/I2C0.c **** **         component. The method is called automatically as a part of the 
1132:../Generated_Code/I2C0.c **** **         Enable and Disable methods and several internal methods.
1133:../Generated_Code/I2C0.c **** **         This method is internal. It is used by Processor Expert only.
1134:../Generated_Code/I2C0.c **** ** ===================================================================
1135:../Generated_Code/I2C0.c **** */
1136:../Generated_Code/I2C0.c **** static void HWEnDi(LDD_TDeviceData *DeviceDataPtr)
1137:../Generated_Code/I2C0.c **** {
 2365              		.loc 1 1137 0
 2366              		.cfi_startproc
 2367 0000 80B5     		push	{r7, lr}
 2368              	.LCFI54:
 2369              		.cfi_def_cfa_offset 8
 2370              		.cfi_offset 7, -8
 2371              		.cfi_offset 14, -4
 2372 0002 84B0     		sub	sp, sp, #16
 2373              	.LCFI55:
 2374              		.cfi_def_cfa_offset 24
 2375 0004 00AF     		add	r7, sp, #0
 2376              	.LCFI56:
 2377              		.cfi_def_cfa_register 7
 2378 0006 7860     		str	r0, [r7, #4]
 2379              	.LBB17:
1138:../Generated_Code/I2C0.c ****   I2C0_TDeviceData *DeviceDataPrv = (I2C0_TDeviceData *)DeviceDataPtr;
 2380              		.loc 1 1138 0
 2381 0008 7B68     		ldr	r3, [r7, #4]
 2382 000a FB60     		str	r3, [r7, #12]
1139:../Generated_Code/I2C0.c **** 
1140:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->EnUser) {         /* Enable device? */
 2383              		.loc 1 1140 0
 2384 000c FB68     		ldr	r3, [r7, #12]
 2385 000e DB78     		ldrb	r3, [r3, #3]
 2386 0010 002B     		cmp	r3, #0
 2387 0012 1CD0     		beq	.L121
1141:../Generated_Code/I2C0.c ****     I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 2388              		.loc 1 1141 0
 2389 0014 1F4B     		ldr	r3, .L123
 2390 0016 1F4A     		ldr	r2, .L123
 2391 0018 9278     		ldrb	r2, [r2, #2]
 2392 001a D2B2     		uxtb	r2, r2
 2393 001c 8021     		mov	r1, #128
 2394 001e 4942     		neg	r1, r1
 2395 0020 0A43     		orr	r2, r1
 2396 0022 D2B2     		uxtb	r2, r2
 2397 0024 9A70     		strb	r2, [r3, #2]
1142:../Generated_Code/I2C0.c ****     I2C_PDD_EnableBusStopInterrupt(I2C0_BASE_PTR); /* Enable bus status detect interrupt */
 2398              		.loc 1 1142 0
 2399 0026 1B4B     		ldr	r3, .L123
 2400 0028 1A4A     		ldr	r2, .L123
 2401 002a 9279     		ldrb	r2, [r2, #6]
 2402 002c D2B2     		uxtb	r2, r2
 2403 002e 6021     		mov	r1, #96
 2404 0030 8A43     		bic	r2, r1
 2405 0032 D2B2     		uxtb	r2, r2
 2406 0034 2021     		mov	r1, #32
 2407 0036 0A43     		orr	r2, r1
 2408 0038 D2B2     		uxtb	r2, r2
 2409 003a 9A71     		strb	r2, [r3, #6]
1143:../Generated_Code/I2C0.c ****     I2C_PDD_EnableInterrupt(I2C0_BASE_PTR); /* Enable interrupt */
 2410              		.loc 1 1143 0
 2411 003c 154B     		ldr	r3, .L123
 2412 003e 154A     		ldr	r2, .L123
 2413 0040 9278     		ldrb	r2, [r2, #2]
 2414 0042 D2B2     		uxtb	r2, r2
 2415 0044 4021     		mov	r1, #64
 2416 0046 0A43     		orr	r2, r1
 2417 0048 D2B2     		uxtb	r2, r2
 2418 004a 9A70     		strb	r2, [r3, #2]
 2419 004c 1FE0     		b	.L120
 2420              	.L121:
1144:../Generated_Code/I2C0.c ****   } else {
1145:../Generated_Code/I2C0.c ****     I2C_PDD_DisableInterrupt(I2C0_BASE_PTR); /* Disable interrupt */
 2421              		.loc 1 1145 0
 2422 004e 114B     		ldr	r3, .L123
 2423 0050 104A     		ldr	r2, .L123
 2424 0052 9278     		ldrb	r2, [r2, #2]
 2425 0054 D2B2     		uxtb	r2, r2
 2426 0056 4021     		mov	r1, #64
 2427 0058 8A43     		bic	r2, r1
 2428 005a D2B2     		uxtb	r2, r2
 2429 005c 9A70     		strb	r2, [r3, #2]
1146:../Generated_Code/I2C0.c ****     I2C_PDD_DisableBusStopInterrupt(I2C0_BASE_PTR); /* Disable bus status detect interrupt */
 2430              		.loc 1 1146 0
 2431 005e 0D4B     		ldr	r3, .L123
 2432 0060 0C4A     		ldr	r2, .L123
 2433 0062 9279     		ldrb	r2, [r2, #6]
 2434 0064 D2B2     		uxtb	r2, r2
 2435 0066 6021     		mov	r1, #96
 2436 0068 8A43     		bic	r2, r1
 2437 006a D2B2     		uxtb	r2, r2
 2438 006c 9A71     		strb	r2, [r3, #6]
1147:../Generated_Code/I2C0.c ****     I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_DISABLE); /* Disable device */
 2439              		.loc 1 1147 0
 2440 006e 094B     		ldr	r3, .L123
 2441 0070 084A     		ldr	r2, .L123
 2442 0072 9278     		ldrb	r2, [r2, #2]
 2443 0074 D1B2     		uxtb	r1, r2
 2444 0076 7F22     		mov	r2, #127
 2445 0078 0A40     		and	r2, r1
 2446 007a D2B2     		uxtb	r2, r2
 2447 007c 9A70     		strb	r2, [r3, #2]
1148:../Generated_Code/I2C0.c ****     I2C_PDD_ClearBusStatusInterruptFlags(I2C0_BASE_PTR, (I2C_PDD_BUS_STOP_FLAG)); /* Clear bus stat
 2448              		.loc 1 1148 0
 2449 007e 054B     		ldr	r3, .L123
 2450 0080 044A     		ldr	r2, .L123
 2451 0082 9279     		ldrb	r2, [r2, #6]
 2452 0084 D2B2     		uxtb	r2, r2
 2453 0086 4021     		mov	r1, #64
 2454 0088 0A43     		orr	r2, r1
 2455 008a D2B2     		uxtb	r2, r2
 2456 008c 9A71     		strb	r2, [r3, #6]
 2457              	.L120:
 2458              	.LBE17:
1149:../Generated_Code/I2C0.c ****   }
1150:../Generated_Code/I2C0.c **** }
 2459              		.loc 1 1150 0
 2460 008e BD46     		mov	sp, r7
 2461 0090 04B0     		add	sp, sp, #16
 2462              		@ sp needed for prologue
 2463 0092 80BD     		pop	{r7, pc}
 2464              	.L124:
 2465              		.align	2
 2466              	.L123:
 2467 0094 00600640 		.word	1074159616
 2468              		.cfi_endproc
 2469              	.LFE23:
 2471              		.section	.text.I2C0_ConnectPin,"ax",%progbits
 2472              		.align	2
 2473              		.global	I2C0_ConnectPin
 2474              		.code	16
 2475              		.thumb_func
 2477              	I2C0_ConnectPin:
 2478              	.LFB24:
1151:../Generated_Code/I2C0.c **** 
1152:../Generated_Code/I2C0.c **** /*
1153:../Generated_Code/I2C0.c **** ** ===================================================================
1154:../Generated_Code/I2C0.c **** **     Method      :  I2C0_ConnectPin (component I2C_LDD)
1155:../Generated_Code/I2C0.c **** */
1156:../Generated_Code/I2C0.c **** /*!
1157:../Generated_Code/I2C0.c **** **     @brief
1158:../Generated_Code/I2C0.c **** **         This method reconnects the requested pin associated with the
1159:../Generated_Code/I2C0.c **** **         selected peripheral in this component. This method is only
1160:../Generated_Code/I2C0.c **** **         available for CPU derivatives and peripherals that support
1161:../Generated_Code/I2C0.c **** **         the runtime pin sharing with other internal on-chip
1162:../Generated_Code/I2C0.c **** **         peripherals.
1163:../Generated_Code/I2C0.c **** **     @param
1164:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1165:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1166:../Generated_Code/I2C0.c **** **     @param
1167:../Generated_Code/I2C0.c **** **         PinMask         - Mask for the requested pins. The
1168:../Generated_Code/I2C0.c **** **                           peripheral pins are reconnected according
1169:../Generated_Code/I2C0.c **** **                           to this mask.
1170:../Generated_Code/I2C0.c **** **                           Possible parameters:
1171:../Generated_Code/I2C0.c **** **                           LDD_I2C_SDA_PIN - Data pin
1172:../Generated_Code/I2C0.c **** **                           LDD_I2C_SCL_PIN - Clock pin
1173:../Generated_Code/I2C0.c **** **     @return
1174:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
1175:../Generated_Code/I2C0.c **** **                           ERR_OK - OK
1176:../Generated_Code/I2C0.c **** **                           ERR_SPEED - This device does not work in
1177:../Generated_Code/I2C0.c **** **                           the active clock configuration
1178:../Generated_Code/I2C0.c **** **                           ERR_PARAM_MASK - Invalid PinMask value.
1179:../Generated_Code/I2C0.c **** */
1180:../Generated_Code/I2C0.c **** /* ===================================================================*/
1181:../Generated_Code/I2C0.c **** LDD_TError I2C0_ConnectPin(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask PinMask)
1182:../Generated_Code/I2C0.c **** {
 2479              		.loc 1 1182 0
 2480              		.cfi_startproc
 2481 0000 80B5     		push	{r7, lr}
 2482              	.LCFI57:
 2483              		.cfi_def_cfa_offset 8
 2484              		.cfi_offset 7, -8
 2485              		.cfi_offset 14, -4
 2486 0002 82B0     		sub	sp, sp, #8
 2487              	.LCFI58:
 2488              		.cfi_def_cfa_offset 16
 2489 0004 00AF     		add	r7, sp, #0
 2490              	.LCFI59:
 2491              		.cfi_def_cfa_register 7
 2492 0006 7860     		str	r0, [r7, #4]
 2493 0008 3960     		str	r1, [r7]
1183:../Generated_Code/I2C0.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
1184:../Generated_Code/I2C0.c **** 
1185:../Generated_Code/I2C0.c ****   /* Pin mask test - this test can be disabled by setting the "Ignore range checking"
1186:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
1187:../Generated_Code/I2C0.c ****   if ((PinMask & (LDD_TPinMask)~((LDD_TPinMask)AVAILABLE_PIN_MASK)) != 0x00U) { /* Is the parameter
 2494              		.loc 1 1187 0
 2495 000a 3B68     		ldr	r3, [r7]
 2496 000c 0322     		mov	r2, #3
 2497 000e 9343     		bic	r3, r2
 2498 0010 01D0     		beq	.L126
1188:../Generated_Code/I2C0.c ****     return ERR_PARAM_MASK;             /* If no then error. */
 2499              		.loc 1 1188 0
 2500 0012 8023     		mov	r3, #128
 2501 0014 1AE0     		b	.L127
 2502              	.L126:
1189:../Generated_Code/I2C0.c ****   }
1190:../Generated_Code/I2C0.c ****   if (PinMask & LDD_I2C_SDA_PIN) {
 2503              		.loc 1 1190 0
 2504 0016 3A68     		ldr	r2, [r7]
 2505 0018 0123     		mov	r3, #1
 2506 001a 1340     		and	r3, r2
 2507 001c 08D0     		beq	.L128
1191:../Generated_Code/I2C0.c ****     clrSetReg32Bits(PORTE_PCR25, 0x01000200U, 0x0500U); /* MUX=0x05U */
 2508              		.loc 1 1191 0
 2509 001e 0D4B     		ldr	r3, .L130
 2510 0020 0C4A     		ldr	r2, .L130
 2511 0022 516E     		ldr	r1, [r2, #100]
 2512 0024 0C4A     		ldr	r2, .L130+4
 2513 0026 0A40     		and	r2, r1
 2514 0028 A021     		mov	r1, #160
 2515 002a C900     		lsl	r1, r1, #3
 2516 002c 0A43     		orr	r2, r1
 2517 002e 5A66     		str	r2, [r3, #100]
 2518              	.L128:
1192:../Generated_Code/I2C0.c ****   }
1193:../Generated_Code/I2C0.c ****   if (PinMask & LDD_I2C_SCL_PIN) {
 2519              		.loc 1 1193 0
 2520 0030 3A68     		ldr	r2, [r7]
 2521 0032 0223     		mov	r3, #2
 2522 0034 1340     		and	r3, r2
 2523 0036 08D0     		beq	.L129
1194:../Generated_Code/I2C0.c ****     clrSetReg32Bits(PORTE_PCR24, 0x01000200U, 0x0500U); /* MUX=0x05U */
 2524              		.loc 1 1194 0
 2525 0038 064B     		ldr	r3, .L130
 2526 003a 064A     		ldr	r2, .L130
 2527 003c 116E     		ldr	r1, [r2, #96]
 2528 003e 064A     		ldr	r2, .L130+4
 2529 0040 0A40     		and	r2, r1
 2530 0042 A021     		mov	r1, #160
 2531 0044 C900     		lsl	r1, r1, #3
 2532 0046 0A43     		orr	r2, r1
 2533 0048 1A66     		str	r2, [r3, #96]
 2534              	.L129:
1195:../Generated_Code/I2C0.c ****   }
1196:../Generated_Code/I2C0.c ****   return ERR_OK;
 2535              		.loc 1 1196 0
 2536 004a 0023     		mov	r3, #0
 2537              	.L127:
1197:../Generated_Code/I2C0.c **** }
 2538              		.loc 1 1197 0
 2539 004c 181C     		mov	r0, r3
 2540 004e BD46     		mov	sp, r7
 2541 0050 02B0     		add	sp, sp, #8
 2542              		@ sp needed for prologue
 2543 0052 80BD     		pop	{r7, pc}
 2544              	.L131:
 2545              		.align	2
 2546              	.L130:
 2547 0054 00D00440 		.word	1074057216
 2548 0058 FFF8FFFE 		.word	-16779009
 2549              		.cfi_endproc
 2550              	.LFE24:
 2552              		.section	.text.I2C0_SetOperationMode,"ax",%progbits
 2553              		.align	2
 2554              		.global	I2C0_SetOperationMode
 2555              		.code	16
 2556              		.thumb_func
 2558              	I2C0_SetOperationMode:
 2559              	.LFB25:
1198:../Generated_Code/I2C0.c **** 
1199:../Generated_Code/I2C0.c **** /*
1200:../Generated_Code/I2C0.c **** ** ===================================================================
1201:../Generated_Code/I2C0.c **** **     Method      :  I2C0_SetOperationMode (component I2C_LDD)
1202:../Generated_Code/I2C0.c **** */
1203:../Generated_Code/I2C0.c **** /*!
1204:../Generated_Code/I2C0.c **** **     @brief
1205:../Generated_Code/I2C0.c **** **         This method requests to change the component's operation
1206:../Generated_Code/I2C0.c **** **         mode. Upon a request to change the operation mode, the
1207:../Generated_Code/I2C0.c **** **         component will finish a pending job first and then notify a
1208:../Generated_Code/I2C0.c **** **         caller that an operation mode has been changed. When no job
1209:../Generated_Code/I2C0.c **** **         is pending (ERR_OK), the component changes an operation mode
1210:../Generated_Code/I2C0.c **** **         immediately and notify a caller about this change. 
1211:../Generated_Code/I2C0.c **** **     @param
1212:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1213:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1214:../Generated_Code/I2C0.c **** **     @param
1215:../Generated_Code/I2C0.c **** **         OperationMode   - Requested driver
1216:../Generated_Code/I2C0.c **** **                           operation mode.
1217:../Generated_Code/I2C0.c **** **     @param
1218:../Generated_Code/I2C0.c **** **         ModeChangeCallback - Callback to
1219:../Generated_Code/I2C0.c **** **                           notify the upper layer once a mode has been
1220:../Generated_Code/I2C0.c **** **                           changed.
1221:../Generated_Code/I2C0.c **** **     @param
1222:../Generated_Code/I2C0.c **** **         ModeChangeCallbackParamPtr 
1223:../Generated_Code/I2C0.c **** **                           - Pointer to callback parameter to notify
1224:../Generated_Code/I2C0.c **** **                           the upper layer once a mode has been
1225:../Generated_Code/I2C0.c **** **                           changed.
1226:../Generated_Code/I2C0.c **** **     @return
1227:../Generated_Code/I2C0.c **** **                         - Error code, possible codes:
1228:../Generated_Code/I2C0.c **** **                           ERR_OK - The change operation mode request
1229:../Generated_Code/I2C0.c **** **                           has been accepted, callback will notify an
1230:../Generated_Code/I2C0.c **** **                           application as soon as the mode is changed.
1231:../Generated_Code/I2C0.c **** **                           ERR_SPEED - The component does not work in
1232:../Generated_Code/I2C0.c **** **                           the active clock configuration.
1233:../Generated_Code/I2C0.c **** **                           ERR_DISABLED - This component is disabled
1234:../Generated_Code/I2C0.c **** **                           by user.
1235:../Generated_Code/I2C0.c **** **                           ERR_PARAM_MODE - Invalid operation mode.
1236:../Generated_Code/I2C0.c **** **                           ERR_BUSY - Job is running and the driver
1237:../Generated_Code/I2C0.c **** **                           can't detect job end by itself. The
1238:../Generated_Code/I2C0.c **** **                           approximate end of the job can be detected
1239:../Generated_Code/I2C0.c **** **                           by method GetDriverState. The real
1240:../Generated_Code/I2C0.c **** **                           transmission/reception finishes later. It
1241:../Generated_Code/I2C0.c **** **                           depends on component settings (data width,
1242:../Generated_Code/I2C0.c **** **                           timing, size of buffer, etc.).
1243:../Generated_Code/I2C0.c **** */
1244:../Generated_Code/I2C0.c **** /* ===================================================================*/
1245:../Generated_Code/I2C0.c **** LDD_TError I2C0_SetOperationMode(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode Operation
1246:../Generated_Code/I2C0.c **** {
 2560              		.loc 1 1246 0
 2561              		.cfi_startproc
 2562 0000 80B5     		push	{r7, lr}
 2563              	.LCFI60:
 2564              		.cfi_def_cfa_offset 8
 2565              		.cfi_offset 7, -8
 2566              		.cfi_offset 14, -4
 2567 0002 86B0     		sub	sp, sp, #24
 2568              	.LCFI61:
 2569              		.cfi_def_cfa_offset 32
 2570 0004 00AF     		add	r7, sp, #0
 2571              	.LCFI62:
 2572              		.cfi_def_cfa_register 7
 2573 0006 F860     		str	r0, [r7, #12]
 2574 0008 7A60     		str	r2, [r7, #4]
 2575 000a 3B60     		str	r3, [r7]
 2576 000c 3B1C     		mov	r3, r7
 2577 000e 0B33     		add	r3, r3, #11
 2578 0010 0A1C     		add	r2, r1, #0
 2579 0012 1A70     		strb	r2, [r3]
 2580              	.LBB18:
1247:../Generated_Code/I2C0.c ****   I2C0_TDeviceDataPtr DeviceDataPrv = (I2C0_TDeviceDataPtr)DeviceDataPtr;
 2581              		.loc 1 1247 0
 2582 0014 FB68     		ldr	r3, [r7, #12]
 2583 0016 7B61     		str	r3, [r7, #20]
1248:../Generated_Code/I2C0.c **** 
1249:../Generated_Code/I2C0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
1250:../Generated_Code/I2C0.c ****      property to the "yes" value in the "Configuration inspector" */
1251:../Generated_Code/I2C0.c ****   if(!DeviceDataPrv->EnUser) {         /* Is the device disabled by user? */
 2584              		.loc 1 1251 0
 2585 0018 7B69     		ldr	r3, [r7, #20]
 2586 001a DB78     		ldrb	r3, [r3, #3]
 2587 001c 0122     		mov	r2, #1
 2588 001e 5340     		eor	r3, r2
 2589 0020 DBB2     		uxtb	r3, r3
 2590 0022 002B     		cmp	r3, #0
 2591 0024 01D0     		beq	.L133
1252:../Generated_Code/I2C0.c ****     return ERR_DISABLED;               /* If yes then error */
 2592              		.loc 1 1252 0
 2593 0026 0723     		mov	r3, #7
 2594 0028 48E0     		b	.L134
 2595              	.L133:
1253:../Generated_Code/I2C0.c ****   }
1254:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->InpLenM != 0x00U) {
 2596              		.loc 1 1254 0
 2597 002a 7B69     		ldr	r3, [r7, #20]
 2598 002c DB89     		ldrh	r3, [r3, #14]
 2599 002e 002B     		cmp	r3, #0
 2600 0030 01D0     		beq	.L135
1255:../Generated_Code/I2C0.c ****     return ERR_BUSY;
 2601              		.loc 1 1255 0
 2602 0032 0823     		mov	r3, #8
 2603 0034 42E0     		b	.L134
 2604              	.L135:
1256:../Generated_Code/I2C0.c ****   }
1257:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->OutLenM != 0x00U) {
 2605              		.loc 1 1257 0
 2606 0036 7B69     		ldr	r3, [r7, #20]
 2607 0038 1B8B     		ldrh	r3, [r3, #24]
 2608 003a 002B     		cmp	r3, #0
 2609 003c 01D0     		beq	.L136
1258:../Generated_Code/I2C0.c ****     return ERR_BUSY;
 2610              		.loc 1 1258 0
 2611 003e 0823     		mov	r3, #8
 2612 0040 3CE0     		b	.L134
 2613              	.L136:
1259:../Generated_Code/I2C0.c ****   }
1260:../Generated_Code/I2C0.c ****   switch (OperationMode) {
 2614              		.loc 1 1260 0
 2615 0042 3B1C     		mov	r3, r7
 2616 0044 0B33     		add	r3, r3, #11
 2617 0046 1B78     		ldrb	r3, [r3]
 2618 0048 032B     		cmp	r3, #3
 2619 004a 04DC     		bgt	.L141
 2620 004c 022B     		cmp	r3, #2
 2621 004e 2CDA     		bge	.L144
 2622 0050 012B     		cmp	r3, #1
 2623 0052 03D0     		beq	.L138
 2624 0054 27E0     		b	.L137
 2625              	.L141:
 2626 0056 042B     		cmp	r3, #4
 2627 0058 12D0     		beq	.L140
 2628 005a 24E0     		b	.L137
 2629              	.L138:
1261:../Generated_Code/I2C0.c ****     case DOM_RUN:
1262:../Generated_Code/I2C0.c ****       #if defined(SIM_PDD_CLOCK_GATE_I2C0)
1263:../Generated_Code/I2C0.c ****       SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_I2C0, PDD_ENABLE);
 2630              		.loc 1 1263 0
 2631 005c 194A     		ldr	r2, .L145
 2632 005e 1949     		ldr	r1, .L145
 2633 0060 194B     		ldr	r3, .L145+4
 2634 0062 CB58     		ldr	r3, [r1, r3]
 2635 0064 4021     		mov	r1, #64
 2636 0066 1943     		orr	r1, r3
 2637 0068 174B     		ldr	r3, .L145+4
 2638 006a D150     		str	r1, [r2, r3]
1264:../Generated_Code/I2C0.c ****       #endif
1265:../Generated_Code/I2C0.c ****       I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 2639              		.loc 1 1265 0
 2640 006c 174B     		ldr	r3, .L145+8
 2641 006e 174A     		ldr	r2, .L145+8
 2642 0070 9278     		ldrb	r2, [r2, #2]
 2643 0072 D2B2     		uxtb	r2, r2
 2644 0074 8021     		mov	r1, #128
 2645 0076 4942     		neg	r1, r1
 2646 0078 0A43     		orr	r2, r1
 2647 007a D2B2     		uxtb	r2, r2
 2648 007c 9A70     		strb	r2, [r3, #2]
1266:../Generated_Code/I2C0.c ****       break;
 2649              		.loc 1 1266 0
 2650 007e 15E0     		b	.L142
 2651              	.L140:
1267:../Generated_Code/I2C0.c ****     case DOM_WAIT:
1268:../Generated_Code/I2C0.c ****     case DOM_SLEEP:
1269:../Generated_Code/I2C0.c ****       break;
1270:../Generated_Code/I2C0.c ****     case DOM_STOP:
1271:../Generated_Code/I2C0.c ****       I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_DISABLE); /* Disable device */
 2652              		.loc 1 1271 0
 2653 0080 124B     		ldr	r3, .L145+8
 2654 0082 124A     		ldr	r2, .L145+8
 2655 0084 9278     		ldrb	r2, [r2, #2]
 2656 0086 D1B2     		uxtb	r1, r2
 2657 0088 7F22     		mov	r2, #127
 2658 008a 0A40     		and	r2, r1
 2659 008c D2B2     		uxtb	r2, r2
 2660 008e 9A70     		strb	r2, [r3, #2]
1272:../Generated_Code/I2C0.c ****       #if defined(SIM_PDD_CLOCK_GATE_I2C0)
1273:../Generated_Code/I2C0.c ****       SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_I2C0, PDD_DISABLE);
 2661              		.loc 1 1273 0
 2662 0090 0C4A     		ldr	r2, .L145
 2663 0092 0C49     		ldr	r1, .L145
 2664 0094 0C4B     		ldr	r3, .L145+4
 2665 0096 CB58     		ldr	r3, [r1, r3]
 2666 0098 4021     		mov	r1, #64
 2667 009a 181C     		mov	r0, r3
 2668 009c 8843     		bic	r0, r1
 2669 009e 011C     		mov	r1, r0
 2670 00a0 094B     		ldr	r3, .L145+4
 2671 00a2 D150     		str	r1, [r2, r3]
1274:../Generated_Code/I2C0.c ****       #endif
1275:../Generated_Code/I2C0.c ****       break;
 2672              		.loc 1 1275 0
 2673 00a4 02E0     		b	.L142
 2674              	.L137:
1276:../Generated_Code/I2C0.c ****     default:
1277:../Generated_Code/I2C0.c ****       return ERR_PARAM_MODE;           /* Invalid Operationmode parameter */
 2675              		.loc 1 1277 0
 2676 00a6 8123     		mov	r3, #129
 2677 00a8 08E0     		b	.L134
 2678              	.L144:
1269:../Generated_Code/I2C0.c ****       break;
 2679              		.loc 1 1269 0
 2680 00aa C046     		mov	r8, r8
 2681              	.L142:
1278:../Generated_Code/I2C0.c ****   }
1279:../Generated_Code/I2C0.c ****   if (ModeChangeCallback != NULL) {
 2682              		.loc 1 1279 0
 2683 00ac 7B68     		ldr	r3, [r7, #4]
 2684 00ae 002B     		cmp	r3, #0
 2685 00b0 03D0     		beq	.L143
1280:../Generated_Code/I2C0.c ****     ModeChangeCallback(ModeChangeCallbackParamPtr); /* Invoke a callback */
 2686              		.loc 1 1280 0
 2687 00b2 3A68     		ldr	r2, [r7]
 2688 00b4 7B68     		ldr	r3, [r7, #4]
 2689 00b6 101C     		mov	r0, r2
 2690 00b8 9847     		blx	r3
 2691              	.L143:
1281:../Generated_Code/I2C0.c ****   }
1282:../Generated_Code/I2C0.c ****   return ERR_OK;
 2692              		.loc 1 1282 0
 2693 00ba 0023     		mov	r3, #0
 2694              	.L134:
 2695              	.LBE18:
1283:../Generated_Code/I2C0.c **** }
 2696              		.loc 1 1283 0
 2697 00bc 181C     		mov	r0, r3
 2698 00be BD46     		mov	sp, r7
 2699 00c0 06B0     		add	sp, sp, #24
 2700              		@ sp needed for prologue
 2701 00c2 80BD     		pop	{r7, pc}
 2702              	.L146:
 2703              		.align	2
 2704              	.L145:
 2705 00c4 00700440 		.word	1074032640
 2706 00c8 34100000 		.word	4148
 2707 00cc 00600640 		.word	1074159616
 2708              		.cfi_endproc
 2709              	.LFE25:
 2711              		.section	.text.I2C0_GetDriverState,"ax",%progbits
 2712              		.align	2
 2713              		.global	I2C0_GetDriverState
 2714              		.code	16
 2715              		.thumb_func
 2717              	I2C0_GetDriverState:
 2718              	.LFB26:
1284:../Generated_Code/I2C0.c **** 
1285:../Generated_Code/I2C0.c **** /*
1286:../Generated_Code/I2C0.c **** ** ===================================================================
1287:../Generated_Code/I2C0.c **** **     Method      :  I2C0_GetDriverState (component I2C_LDD)
1288:../Generated_Code/I2C0.c **** */
1289:../Generated_Code/I2C0.c **** /*!
1290:../Generated_Code/I2C0.c **** **     @brief
1291:../Generated_Code/I2C0.c **** **         This method returns the current driver status.
1292:../Generated_Code/I2C0.c **** **     @param
1293:../Generated_Code/I2C0.c **** **         DeviceDataPtr   - Device data structure
1294:../Generated_Code/I2C0.c **** **                           pointer returned by <Init> method.
1295:../Generated_Code/I2C0.c **** **     @return
1296:../Generated_Code/I2C0.c **** **                         - The current driver status mask.
1297:../Generated_Code/I2C0.c **** **                           Following status masks defined in PE_Types.h
1298:../Generated_Code/I2C0.c **** **                           can be used to check the current driver
1299:../Generated_Code/I2C0.c **** **                           status.
1300:../Generated_Code/I2C0.c **** **                           PE_LDD_DRIVER_DISABLED_IN_CLOCK_CONFIGURATIO
1301:../Generated_Code/I2C0.c **** **                           N - 1 - Driver is disabled in the current
1302:../Generated_Code/I2C0.c **** **                           mode; 0 - Driver is enabled in the current
1303:../Generated_Code/I2C0.c **** **                           mode.  
1304:../Generated_Code/I2C0.c **** **                           PE_LDD_DRIVER_DISABLED_BY_USER - 1 - Driver
1305:../Generated_Code/I2C0.c **** **                           is disabled by the user; 0 - Driver is
1306:../Generated_Code/I2C0.c **** **                           enabled by the user.        
1307:../Generated_Code/I2C0.c **** **                           PE_LDD_DRIVER_BUSY - 1 - Driver is the BUSY
1308:../Generated_Code/I2C0.c **** **                           state; 0 - Driver is in the IDLE state.
1309:../Generated_Code/I2C0.c **** */
1310:../Generated_Code/I2C0.c **** /* ===================================================================*/
1311:../Generated_Code/I2C0.c **** LDD_TDriverState I2C0_GetDriverState(LDD_TDeviceData *DeviceDataPtr)
1312:../Generated_Code/I2C0.c **** {
 2719              		.loc 1 1312 0
 2720              		.cfi_startproc
 2721 0000 80B5     		push	{r7, lr}
 2722              	.LCFI63:
 2723              		.cfi_def_cfa_offset 8
 2724              		.cfi_offset 7, -8
 2725              		.cfi_offset 14, -4
 2726 0002 84B0     		sub	sp, sp, #16
 2727              	.LCFI64:
 2728              		.cfi_def_cfa_offset 24
 2729 0004 00AF     		add	r7, sp, #0
 2730              	.LCFI65:
 2731              		.cfi_def_cfa_register 7
 2732 0006 7860     		str	r0, [r7, #4]
 2733              	.LBB19:
1313:../Generated_Code/I2C0.c ****   LDD_TDriverState DriverState = 0x00U;
 2734              		.loc 1 1313 0
 2735 0008 3B1C     		mov	r3, r7
 2736 000a 0E33     		add	r3, r3, #14
 2737 000c 0022     		mov	r2, #0
 2738 000e 1A80     		strh	r2, [r3]
1314:../Generated_Code/I2C0.c ****   I2C0_TDeviceDataPtr DeviceDataPrv = (I2C0_TDeviceDataPtr)DeviceDataPtr;
 2739              		.loc 1 1314 0
 2740 0010 7B68     		ldr	r3, [r7, #4]
 2741 0012 BB60     		str	r3, [r7, #8]
1315:../Generated_Code/I2C0.c **** 
1316:../Generated_Code/I2C0.c ****   DriverState |= (DeviceDataPrv->EnUser)? 0x00U : PE_LDD_DRIVER_DISABLED_BY_USER; /* Driver disable
 2742              		.loc 1 1316 0
 2743 0014 BB68     		ldr	r3, [r7, #8]
 2744 0016 DB78     		ldrb	r3, [r3, #3]
 2745 0018 002B     		cmp	r3, #0
 2746 001a 01D0     		beq	.L148
 2747              		.loc 1 1316 0 is_stmt 0
 2748 001c 0023     		mov	r3, #0
 2749 001e 00E0     		b	.L149
 2750              	.L148:
 2751              		.loc 1 1316 0
 2752 0020 0223     		mov	r3, #2
 2753              	.L149:
 2754              		.loc 1 1316 0
 2755 0022 3A1C     		mov	r2, r7
 2756 0024 0E32     		add	r2, r2, #14
 2757 0026 391C     		mov	r1, r7
 2758 0028 0E31     		add	r1, r1, #14
 2759 002a 0988     		ldrh	r1, [r1]
 2760 002c 0B43     		orr	r3, r1
 2761 002e 1380     		strh	r3, [r2]
1317:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->InpLenM != 0x00U) {
 2762              		.loc 1 1317 0 is_stmt 1
 2763 0030 BB68     		ldr	r3, [r7, #8]
 2764 0032 DB89     		ldrh	r3, [r3, #14]
 2765 0034 002B     		cmp	r3, #0
 2766 0036 0BD0     		beq	.L150
1318:../Generated_Code/I2C0.c ****     DriverState |= PE_LDD_DRIVER_BUSY;
 2767              		.loc 1 1318 0
 2768 0038 3B1C     		mov	r3, r7
 2769 003a 0E33     		add	r3, r3, #14
 2770 003c 3A1C     		mov	r2, r7
 2771 003e 0E32     		add	r2, r2, #14
 2772 0040 1288     		ldrh	r2, [r2]
 2773 0042 0421     		mov	r1, #4
 2774 0044 0A43     		orr	r2, r1
 2775 0046 1A80     		strh	r2, [r3]
1319:../Generated_Code/I2C0.c ****     return DriverState;
 2776              		.loc 1 1319 0
 2777 0048 3B1C     		mov	r3, r7
 2778 004a 0E33     		add	r3, r3, #14
 2779 004c 1B88     		ldrh	r3, [r3]
 2780 004e 12E0     		b	.L151
 2781              	.L150:
1320:../Generated_Code/I2C0.c ****   }
1321:../Generated_Code/I2C0.c ****   if (DeviceDataPrv->OutLenM != 0x00U) {
 2782              		.loc 1 1321 0
 2783 0050 BB68     		ldr	r3, [r7, #8]
 2784 0052 1B8B     		ldrh	r3, [r3, #24]
 2785 0054 002B     		cmp	r3, #0
 2786 0056 0BD0     		beq	.L152
1322:../Generated_Code/I2C0.c ****     DriverState |= PE_LDD_DRIVER_BUSY;
 2787              		.loc 1 1322 0
 2788 0058 3B1C     		mov	r3, r7
 2789 005a 0E33     		add	r3, r3, #14
 2790 005c 3A1C     		mov	r2, r7
 2791 005e 0E32     		add	r2, r2, #14
 2792 0060 1288     		ldrh	r2, [r2]
 2793 0062 0421     		mov	r1, #4
 2794 0064 0A43     		orr	r2, r1
 2795 0066 1A80     		strh	r2, [r3]
1323:../Generated_Code/I2C0.c ****     return DriverState;
 2796              		.loc 1 1323 0
 2797 0068 3B1C     		mov	r3, r7
 2798 006a 0E33     		add	r3, r3, #14
 2799 006c 1B88     		ldrh	r3, [r3]
 2800 006e 02E0     		b	.L151
 2801              	.L152:
1324:../Generated_Code/I2C0.c ****   }
1325:../Generated_Code/I2C0.c ****   return DriverState;
 2802              		.loc 1 1325 0
 2803 0070 3B1C     		mov	r3, r7
 2804 0072 0E33     		add	r3, r3, #14
 2805 0074 1B88     		ldrh	r3, [r3]
 2806              	.L151:
 2807              	.LBE19:
1326:../Generated_Code/I2C0.c **** }
 2808              		.loc 1 1326 0
 2809 0076 181C     		mov	r0, r3
 2810 0078 BD46     		mov	sp, r7
 2811 007a 04B0     		add	sp, sp, #16
 2812              		@ sp needed for prologue
 2813 007c 80BD     		pop	{r7, pc}
 2814              		.cfi_endproc
 2815              	.LFE26:
 2817 007e C046     		.text
 2818              	.Letext0:
 2819              		.file 2 "../Generated_Code/PE_Types.h"
 2820              		.file 3 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 2821              		.file 4 "../Generated_Code/IO_Map.h"
DEFINED SYMBOLS
                            *ABS*:00000000 I2C0.c
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:18     .bss._ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:21     .bss._ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 _ZL33DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:24     .bss._ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM:00000000 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:27     .bss._ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM:00000000 _ZL33INT_I2C0__BAREBOARD_RTOS_ISRPARAM
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:30     .text.I2C0_Interrupt:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:35     .text.I2C0_Interrupt:00000000 I2C0_Interrupt
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:522    .text.I2C0_Interrupt:00000314 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:526    .text.I2C0_Interrupt:0000031c $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:612    .text.I2C0_Interrupt:000003a0 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:617    .text.I2C0_Init:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:622    .text.I2C0_Init:00000000 I2C0_Init
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2363   .text.HWEnDi:00000000 HWEnDi
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:857    .text.I2C0_Init:0000014c $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:871    .text.I2C0_Deinit:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:876    .text.I2C0_Deinit:00000000 I2C0_Deinit
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:919    .text.I2C0_Deinit:00000030 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:927    .text.I2C0_Enable:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:932    .text.I2C0_Enable:00000000 I2C0_Enable
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:990    .text.I2C0_Disable:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:995    .text.I2C0_Disable:00000000 I2C0_Disable
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1042   .text.I2C0_SetEventMask:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1047   .text.I2C0_SetEventMask:00000000 I2C0_SetEventMask
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1106   .text.I2C0_SetEventMask:0000003c $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1111   .text.I2C0_GetEventMask:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1116   .text.I2C0_GetEventMask:00000000 I2C0_GetEventMask
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1151   .text.I2C0_GetEventMask:0000001c $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1156   .text.I2C0_MasterSendBlock:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1161   .text.I2C0_MasterSendBlock:00000000 I2C0_MasterSendBlock
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1415   .text.I2C0_MasterSendBlock:00000174 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1420   .text.I2C0_MasterGetBlockSentStatus:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1425   .text.I2C0_MasterGetBlockSentStatus:00000000 I2C0_MasterGetBlockSentStatus
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1480   .text.I2C0_MasterGetSentDataNum:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1485   .text.I2C0_MasterGetSentDataNum:00000000 I2C0_MasterGetSentDataNum
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1514   .text.I2C0_MasterReceiveBlock:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1519   .text.I2C0_MasterReceiveBlock:00000000 I2C0_MasterReceiveBlock
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1775   .text.I2C0_MasterReceiveBlock:00000174 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1780   .text.I2C0_MasterUpdateReceiveBlockSize:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1785   .text.I2C0_MasterUpdateReceiveBlockSize:00000000 I2C0_MasterUpdateReceiveBlockSize
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1885   .text.I2C0_MasterGetBlockReceivedStatus:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1890   .text.I2C0_MasterGetBlockReceivedStatus:00000000 I2C0_MasterGetBlockReceivedStatus
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1945   .text.I2C0_MasterGetReceivedDataNum:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1950   .text.I2C0_MasterGetReceivedDataNum:00000000 I2C0_MasterGetReceivedDataNum
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1979   .text.I2C0_SelectSlaveDevice:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:1984   .text.I2C0_SelectSlaveDevice:00000000 I2C0_SelectSlaveDevice
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2172   .text.I2C0_SelectSlaveDevice:0000010c $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2177   .text.I2C0_GetError:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2182   .text.I2C0_GetError:00000000 I2C0_GetError
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2242   .text.I2C0_CheckBus:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2247   .text.I2C0_CheckBus:00000000 I2C0_CheckBus
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2306   .text.I2C0_CheckBus:00000044 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2311   .text.I2C0_GetStats:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2316   .text.I2C0_GetStats:00000000 I2C0_GetStats
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2359   .text.HWEnDi:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2467   .text.HWEnDi:00000094 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2472   .text.I2C0_ConnectPin:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2477   .text.I2C0_ConnectPin:00000000 I2C0_ConnectPin
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2547   .text.I2C0_ConnectPin:00000054 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2553   .text.I2C0_SetOperationMode:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2558   .text.I2C0_SetOperationMode:00000000 I2C0_SetOperationMode
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2705   .text.I2C0_SetOperationMode:000000c4 $d
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2712   .text.I2C0_GetDriverState:00000000 $t
C:\Users\JH\AppData\Local\Temp\ccxlU8e8.s:2717   .text.I2C0_GetDriverState:00000000 I2C0_GetDriverState
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_Z22I2C0_OnBusStopDetectedPv
_Z22I2C0_OnMasterBlockSentPv
_Z25I2C0_OnMasterByteReceivedPv
_Z26I2C0_OnMasterBlockReceivedPv
_Z12I2C0_OnErrorPv
PE_LDD_DeviceDataList
vPortEnterCritical
vPortExitCritical
memcpy
